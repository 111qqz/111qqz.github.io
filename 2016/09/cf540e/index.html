<!doctype html><html lang=zh-cn><head><meta charset=xutf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="8z1CE8DAp_7fjPec1DyAAL6oIfnRJSKeoaEoESnHfmU"><meta property="og:site_name" content="111qqz的小窝"><meta property="og:type" content="article"><meta property="og:image" content="https://111qqz.github.io/img/2.png"><meta property="twitter:image" content="https://111qqz.github.io/img/2.png"><meta name=title content="codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)"><meta property="og:title" content="codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)"><meta property="twitter:title" content="codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)"><meta name=description content><meta property="og:description" content><meta property="twitter:description" content><meta property="twitter:card" content="summary"><meta name=keyword content="ICPC, 111qqz,HUST,Sensetime,Tencent"><link rel="shortcut icon" href=/img/favicon.ico><title>codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)-111qqz的小窝</title><link rel=canonical href=/2016/09/cf540e/><link rel=stylesheet href=/css/iDisqus.min.css><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/zanshang.css><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/docco.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/hux-blog.min-custom.css><script data-ad-client=ca-pub-2010211964550865 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=/>111qqz的小窝</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>Home</a></li><li><a href=/categories/acm/>ACM-ICPC</a></li><li><a href=/categories/deep-learning/>深度学习</a></li><li><a href=/categories/mooc/>公开课</a></li><li><a href=/categories/%e5%85%b6%e4%bb%96/>其他</a></li><li><a href=/top/about/>ABOUT</a></li><li><a href=/search>SEARCH <img src=/img/search.png height=15 style=cursor:pointer alt=Search></a></li></ul></div></div></div></nav><script>var $body=document.body;var $toggle=document.querySelector('.navbar-toggle');var $navbar=document.querySelector('#huxblog_navbar');var $collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic)
function handleMagic(e){if($navbar.className.indexOf('in')>0){$navbar.className=" ";setTimeout(function(){if($navbar.className.indexOf('in')<0){$collapse.style.height="0px"}},400)}else{$collapse.style.height="auto"
$navbar.className+=" in";}}</script><style type=text/css>header.intro-header{background-image:url(/img/2.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91 title=线段树>线段树</a>
<a class=tag href=/tags/%E9%80%86%E5%BA%8F%E5%AF%B9 title=逆序对>逆序对</a></div><h1>codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)</h1><h2 class=subheading></h2><span class=meta>Posted by
111qqz
on
Tuesday, September 20, 2016
<span id=/2016/09/cf540e/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span><i class="fa fa-eye"></i><span class=old-visitors-count style=display:none></span><span class=leancloud-visitors-count></span></span><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("UzhnsgbPvx1RFb2kNXUHpPtf-gzGzoHsz","OXOvoYGuwMv70Os5GOgaGEWT");</script><script type=text/javascript>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");console.log("aaa")
$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';var OLD_COUNT_CONTAINER_REF='.old-visitors-count';for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){var oldCountSpan=$(element).find(OLD_COUNT_CONTAINER_REF).text();if(oldCountSpan!=''){countSpan.text(0+parseInt(oldCountSpan));}else{countSpan.text(0);}}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);con
query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);var OLD_COUNT_CONTAINER_REF='.old-visitors-count';var $element=$(document.getElementById(url));var oldCountSpan=$element.find(OLD_COUNT_CONTAINER_REF).text();if(oldCountSpan!=''){newcounter.set("time",parseInt(oldCountSpan)+1);}else{newcounter.set("time",1);}
newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");console.log("miao miao miao")
if($('.leancloud_visitors').length==1){addCount(Counter);}else{showTime(Counter);}});</script></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><header><h2>TOC</h2></header><nav id=TableOfContents></nav><p><a href=http://codeforces.com/problemset/problem/540/E>题目链接</a></p><p>题意：一个无穷数列，从1开始，初始第i个位置上为i，给出n个swap，每次交换两个位置的数。问交换n次以后得到的数列中，逆序对的数。</p><p>思路：</p><p>官方题解：</p><blockquote>At first find the position of each element which is used in swap (using map). Now let's find the answer. It consists of the two parts. First part is the number of inversions formed by only whose elements which took part in the swaps. They can be counted by one of the standard ways: mergesort or Fenwick tree. The second part is the number of inversions formed by pairs of elements where one element has been swapped even once, and the other element stayed at his position. Let's consider the following test:<p>2</p><p>2 6</p><p>4 8</p><p>The global sequence will look as follows: [1 6 3 8 5 2 7 4 9 &mldr;], and here is the array of swapped elements: [6 8 2 4].</p><p>Let's understand with which numbers the number 8 forms the inversions. The only elements that could do that are the elements between the initial position of the number 8 (where the number 4 is now) and its current position: [5 2 7]. There are two numbers on this segment which didn't take part in swaps: 5 and 7. The number 2 should not be counted as it took part in the swaps and we have already counted it in the first part of the solution.</p><p>So we should take the count of numbers between 8's indices in the global sequence (8 - 4 - 1 = 3) and subtract the count of numbers between its indices in the swaps array <strong>(4 - 2 - 1 = 1)(在交换序列中【6,8,2,4】4的位置在4,8的位置在2).</strong> We'll get the number of inversions formed by the element 8 and the elements which haven't moved at all, it's 2. Counting this value for all elements which have been swapped at least once, we get the second part of the answer. All operations in the second part of the solution can be performed using sorts and binary searches.</blockquote></p><p>讲真。。。题解写的真是不友好。。。。很多概念从天而降。。。公式中magic number不加说明。。。。差评。</p><p>我来说一下这道题的做法：</p><p>首先，由于交换的位置最大1E9，但是最多1E5个交换。。所以自然而然想到离散化。</p><p><strong>需要注意的是，离散化后最多有2E5个，而不是1E5 （<del>因此re #7</del>）</strong></p><p>对于统计最后的逆序对数，我们分为两部分。</p><p>首先我们知道，对于两个没有被交换过的数，肯定不是一对逆序对。</p><p>因此答案分为，<strong>两个数都是被交换过的数产生的逆序对数 和 交换过的数和没被交换过的数之间产生的逆序对数。</strong></p><blockquote>First part is the number of inversions formed by only whose elements which took part in the swaps. They can be counted by one of the standard ways: mergesort or Fenwick tree. The second part is the number of inversions formed by pairs of elements where one element has been swapped even once, and the other element stayed at his position. Let's consider the following test:</blockquote><p>对于前者。。。。</p><p>就是普通的逆序对。。。直接BIT处理（<del>故意写成线段树真是不美丽）</del></p><p>对于后者。。。我们的做法是。。。</p><p>处理两个数组。。。f[i]和p[i]</p><p><strong>f[i]表示交换序列中，离散化后，处于第i个位置上面的值（也是离散化之前的位置）</strong></p><p><strong>p[i]表示现在在i位置上的数初始是在p[i]位置(位置是离散化后的从小到大的顺序，因此是对于交换序列的（因为只有交换序列才离散化了））</strong></p><p>对于处于交换序列中的某个数，其初始位置和最终位置之间有多少个数，答案为：<strong>abs(f[p[i]]-f[i])-1</strong></p><p>但是这两个位置之间，处于交换序列中的数在之前的第一部分已经算过了（也就是两个数都是被交换过的数）</p><p>所以我们需要减去 两个位置之间，已经处于交换序列的个数（不包含两个位置）</p><p>结果为<strong>abs(i-p[i])-1</strong> (交换序列中 i和p[i]位置之间，有<strong>abs(i-p[i])-1</strong>个数)</p><p>两部分相间，答案为res = abs(f[p[i]-f[i]]-1 - (ans(i-p[i])-1) = abs(f[p[i]]-f[i]) - abs(i-p[i])</p><p>把每个处于交换序列中的数的res累加，就是最后的结果。</p><p>注意要开LL.</p><pre><code>/* ***********************************************
Author :111qqz
Created Time :Tue 20 Sep 2016 02:14:23 PM CST
File Name :code/cf/problem/540E.cpp
 ************************************************ */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#define fst first
#define sec second
#define lson l,m,rt&lt;&lt;1
#define rson m+1,r,rt&lt;&lt;1|1
#define ms(a,x) memset(a,x,sizeof(a))
typedef long long LL;
#define pi pair &lt; int ,int &gt;
#define MP make_pair
using namespace std;
const double eps = 1E-8;
const int dx4[4]={1,0,0,-1};
const int dy4[4]={0,-1,1,0};
const int inf = 0x3f3f3f3f;
const int N=2E5+7;
int n;
struct node
{
    int l,r;
}q[N];
int f[N],p[N];
map&lt;int,int&gt;mp;
LL tree[N&lt;&lt;2];
void PushUp( int rt)
{
    tree[rt] = tree[rt&lt;&lt;1] + tree[rt&lt;&lt;1|1];
}
void update( int p,LL sc,int l,int r,int rt)
{
    if (l==r)
    {
    tree[rt] += sc;
    return ;
    }
    int m = (l+r)&gt;&gt;1;
    if (p&lt;=m) update(p,sc,lson);
    else update(p,sc,rson);
    PushUp(rt);
}
LL query(int L,int R,int l,int r,int rt)
{
    if (L&lt;=l&amp;&amp;r&lt;=R) return tree[rt];
    int m = (l+r)&gt;&gt;1;
    LL ret = 0LL;
    if (L&lt;=m) ret+=query(L,R,lson);
    if (R&gt;=m+1) ret+=query(L,R,rson);
    return ret;
}
int main()
{
#ifndef  ONLINE_JUDGE 
    //freopen(&quot;code/in.txt&quot;,&quot;r&quot;,stdin);
#endif
    scanf(&quot;%d&quot;,&amp;n);
    mp.clear();
    ms(p,0);
    for ( int i = 1 ;i &lt;= n ; i++)
    {
    scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);
    mp[q[i].l] = 0 ;
    mp[q[i].r] = 0;
    }
    int cnt = 0 ;
    for ( auto it = mp.begin() ; it!=mp.end() ; it++)
    {
    it-&gt;sec = ++cnt;
    f[cnt] = it-&gt;fst;
    p[cnt] = cnt;
    }
    for ( int i = 1 ; i &lt;= n ; i++) q[i].l = mp[q[i].l],q[i].r = mp[q[i].r];
    for ( int i = 1 ; i &lt;= n ; i++) swap(p[q[i].l],p[q[i].r]);
    LL ans = 0LL;
    for ( LL i = 1; i &lt;= cnt ; i++)
    {
    update(p[i],1,1,cnt,1);
    ans += i-query(1,p[i],1,cnt,1);
    ans += abs(f[i]-f[p[i]])-abs(i-p[i]);
    }
    printf(&quot;%lld\n&quot;,ans);
#ifndef ONLINE_JUDGE  
    fclose(stdin);
#endif
    return 0;
}
</code></pre><hr><ul class=pager><li class=previous><a href=/2016/09/poj-3579/ data-toggle=tooltip data-placement=top title="poj 3579 Median (尺取法+二分)">&larr;
Previous Post</a></li><li class=next><a href=/2016/09/codeforces-609-f-frogs-and-mosquitoes-/ data-toggle=tooltip data-placement=top title="codeforces #609 F. Frogs and mosquitoes (线段树+二分)">Next
Post &rarr;</a></li></ul><div class=post-comment><span id=/2016/09/cf540e/ class=leancloud_visitors data-flag-title="codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)"><span class=post-meta-item-text>访问量 "/2016/09/cf540e/"</span>
<span class=leancloud-visitors-count></span><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'UzhnsgbPvx1RFb2kNXUHpPtf-gzGzoHsz',appKey:'OXOvoYGuwMv70Os5GOgaGEWT',notify:true,verify:false,avatar:'retro',placeholder:'说点什么吧...',visitor:true});</script></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/bfs title=bfs>bfs</a>
<a href=/tags/binary-search title=binary-search>binary-search</a>
<a href=/tags/brute-force title=brute-force>brute-force</a>
<a href=/tags/dfs title=dfs>dfs</a>
<a href=/tags/dp title=dp>dp</a>
<a href=/tags/greedy title=greedy>greedy</a>
<a href=/tags/kmp title=kmp>kmp</a>
<a href=/tags/leetcode title=leetcode>leetcode</a>
<a href=/tags/math title=math>math</a>
<a href=/tags/number-theory title=number-theory>number-theory</a>
<a href=/tags/rmq title=rmq>rmq</a>
<a href=/tags/stl title=stl>stl</a>
<a href=/tags/%E5%89%8D%E7%BC%80%E5%92%8C title=前缀和>前缀和</a>
<a href=/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA title=博弈论>博弈论</a>
<a href=/tags/%E5%9B%BE%E8%AE%BA title=图论>图论</a>
<a href=/tags/%E5%BF%AB%E9%80%9F%E5%B9%82 title=快速幂>快速幂</a>
<a href=/tags/%E6%95%B0%E4%BD%8Ddp title=数位dp>数位dp</a>
<a href=/tags/%E6%9E%84%E9%80%A0 title=构造>构造</a>
<a href=/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84 title=树状数组>树状数组</a>
<a href=/tags/%E6%A8%A1%E6%8B%9F title=模拟>模拟</a>
<a href=/tags/%E6%AF%8D%E5%87%BD%E6%95%B0 title=母函数>母函数</a>
<a href=/tags/%E7%9F%A9%E9%98%B5 title=矩阵>矩阵</a>
<a href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91 title=线段树>线段树</a>
<a href=/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95 title=计算几何>计算几何</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://111qqz.com>111qqz的wordpress博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href rel=alternate type=application/rss+xml title=111qqz的小窝><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=mailto:hust.111qqz@gmail.com><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-wechat fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/111qqz/><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 111qqz的小窝 2022<br><a href=https://beian.miit.gov.cn/>粤ICP备18103363号</a><br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function async(u,c){var d=document,t='script',o=d.createElement(t),s=d.getElementsByTagName(t)[0];o.src=u;if(c){o.addEventListener('load',function(e){c(null,e);},false);}
s.parentNode.insertBefore(o,s);}</script><script>if($('#tag_cloud').length!==0){async("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'},};$('#tag_cloud a').tagcloud();})}</script><script>async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var $nav=document.querySelector("nav");if($nav)FastClick.attach($nav);})</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-219255388-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>