<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 111qqz的小窝</title><link>https://111qqz.com/post/</link><description>Recent content in Posts on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 26 Feb 2022 19:10:30 +0800</lastBuildDate><atom:link href="https://111qqz.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>caffe 源码阅读笔记</title><link>https://111qqz.com/2020/06/caffe-notes/</link><pubDate>Tue, 30 Jun 2020 19:47:02 +0800</pubDate><guid>https://111qqz.com/2020/06/caffe-notes/</guid><description>
blob
layer
net
激活函数
卷积
reshape
slice
loss function
reduce
eltwise
argmax</description></item><item><title>The Programming Language Course</title><link>https://111qqz.com/2019/10/The-Programming-Language-Course/</link><pubDate>Sat, 19 Oct 2019 19:04:01 +0800</pubDate><guid>https://111qqz.com/2019/10/The-Programming-Language-Course/</guid><description>
花了三个月的时间,终于跟完了这门编程语言课. 课程内容非常赞,而且也充分发挥了coursera平台的作用. 非要说缺点的话,就是这门课时间有点短,以及peers' assignments总是找不到人...
这么课是什么 这门课并不是在讲一门特定的编程语言,而是在讲一些通用的编程语言概念.
课程本身大体上上分为三部分,分别结合sml,racket,ruby三门语言来讲. 每部分大体先是视频内容(有同样内容的文字pdf,便于查询),然后要完成一项作业(10节中有8节是编程作业,2节是多选题的笔试) 作业过后,是备受好评的(?) peers' assignments的环节. 不过由于每个人的作业只能被其他三个人评分...所以如果没有对3个同学做过code review的话,需要经常上来看看有没有新的人提交作业了...
我的体会 作业难度不算高,每门作业最开始的题目感觉稍微有点难度,不过大体是因为还不太熟悉一门新的语言,热身之后,后面的题目都比较容易了.
按照Grossman的说法,最难的是第二部分课程中用racket写一个简单的语言解释器.不过实际写起来其实还好,就是一个代码量不到200行的大模拟,难度感觉并不比其他部分的作业更难.
比较有意思的作业感觉反而是第三部分那个,用OOP和functional的方法实现同样的计算几何...用函数式写几何题好舒服啊...
这么课应该没有什么必须的前置技能点,因为课程中涉及的语言反正也没什么人学过(?),所以有过编程经验应该就可以跟? 以及,感觉这应该算是CS中比较核心的课程了,可是国内的高校似乎很少有开相关的课程? 有点可惜.
总之安利一波~ 最后附上我的代码链接: github CSE341</description></item><item><title>2022 TO DO list</title><link>https://111qqz.com/2022/02/2022-to-do-list/</link><pubDate>Sat, 26 Feb 2022 18:12:20 +0800</pubDate><guid>https://111qqz.com/2022/02/2022-to-do-list/</guid><description>
竟然一下子就2022年了，时间过得真快。 还是简单列一下TODO list吧。
源码 levelDB workflow 书籍 课程 目前买了一年的极客时间，可以学6门课... 还没想好学哪些...</description></item><item><title>levelDB 代码阅读笔记 01</title><link>https://111qqz.com/2022/02/leveldb-notes-01/</link><pubDate>Sat, 26 Feb 2022 19:10:30 +0800</pubDate><guid>https://111qqz.com/2022/02/leveldb-notes-01/</guid><description>
背景 最近在做一个智能算力相关的项目，类似美团外卖广告智能算力的探索与实践 其中实现控制系统需要与数据库交互。 虽然最后技术选型并没有使用到levelDB,但是想趁机把代码读了吧。
很惊讶的发现我大三的时候声称自己度过部分levelDB代码，甚至还写了几篇相关的博客，比如
murmurhash源码分析 Lock-free vs wait-free concurrency 内存屏障（Memory Barriers） levelDB 学习笔记 但是我却一点都没印象了.... 仔细看来很多概念在当时可能都是没有充分理解的，而且从数目上来看，应该并没有完整看完levelDB代码。
所以重新开个坑，看看自己比起毕业前有没有长进【没有
先从入口 include/leveldb/db.h 开始
LEVELDB_EXPORT 看到LEVELDB_EXPORT这个macro
1 2class LEVELDB_EXPORT Snapshot { 3 protected: 4 virtual ~Snapshot(); 5}; 6 是在 include/leveldb/export.h 中定义的
1 2// 符号可见性问题，使用macro来控制在编译成动态库时暴露，在Link时不暴露符号是一种common 的做法 3// 4#if !defined(LEVELDB_EXPORT) 5 6#if defined(LEVELDB_SHARED_LIBRARY) 7#if defined(_WIN32) 8 9#if defined(LEVELDB_COMPILE_LIBRARY) 10#define LEVELDB_EXPORT __declspec(dllexport) 11#else 12#define LEVELDB_EXPORT __declspec(dllimport) 13#endif // defined(LEVELDB_COMPILE_LIBRARY) 14 15#else // defined(_WIN32) 16#if defined(LEVELDB_COMPILE_LIBRARY) 17#define LEVELDB_EXPORT __attribute__((visibility(&amp;#34;default&amp;#34;))) 18#else 19#define LEVELDB_EXPORT 20#endif 21#endif // defined(_WIN32) 22 23#else // defined(LEVELDB_SHARED_LIBRARY) 24#define LEVELDB_EXPORT 25#endif 26 27#endif // !</description></item><item><title>博客除草</title><link>https://111qqz.com/2022/02/better-blog/</link><pubDate>Wed, 02 Feb 2022 19:56:49 +0800</pubDate><guid>https://111qqz.com/2022/02/better-blog/</guid><description>
博客要长草了。。趁着过年时间多，打理一下。。
添加google analytics hugo本身已经集成了这个功能 要点是集成的是旧版本的universal analytics (对应的是UA-ID) 而目前google主推得其实是新版本google analytics 4(对应的是GA4-ID)
更换主题 更换主题为 hugo-clarity
最主要的原因是之前的博客主题语法高亮有些问题...
cpp中代码添加了注释后，会将代码显示在注释的同一行 proto文件不能正确换行 所以换了个可以正确解析语法的主题...
问题1 github actions执行正常，访问渲染好的页面提示
1 2This page contains the following errors: 3error on line 50 at column 394: PCDATA invalid Char value 8 4 最终发现原因是没有清除掉旧theme的 git submodule 清除后问题解决
同时更新了一下github actions中 hugo的版本为extented版本
问题2 algolia 更新报错，似乎是json文件没生成。 由于搜索功能使用频率也不太高，暂时禁止掉
1- name:upload algolia data2uses:actions/setup-node@v23with:4node-version:&amp;#39;12&amp;#39;5- run:npm run algolia问题3 图片无法显示，提示&amp;quot;error not found&amp;quot;
目测是blog的一个bug,已经提了issue
暂时fork了一份，修改了代码绕过去
故障修复</description></item><item><title>Goodbye 2021</title><link>https://111qqz.com/2022/01/goodbye-2021/</link><pubDate>Mon, 03 Jan 2022 16:27:20 +0800</pubDate><guid>https://111qqz.com/2022/01/goodbye-2021/</guid><description>
在公司做ppt做到吐血，恰好想起2021年终总结还没有写
过去的一年 总的来说,2021年真的是无比辛苦的一年。 转行互联网的阵痛期这句话其实完全不是开玩笑。从CV转来做推荐，技术栈看起来接近，但是问题的重点变得很不一样。
推荐场景存在大量稀疏特征，而CV下大部分特征都是稠密的 推荐模型更新频繁，几分钟就要做一次更新，而CV模型的迭代速度是以天或者周来计算的 离线请求和在线serving. 当然这点其实并不是CV/推荐 带来的不同 以至于对于行业内一些人尽皆知的概念，我第一次听到也一头雾水。比如&amp;quot;看一下服务的流量分布&amp;quot;，比如“统计下p99”最初这一个个简单的概念都让工作比较吃力
说起&amp;quot;阵痛期&amp;quot;，前两个月组里本来来了个商汤的前同事，做PPL(商汤自研的推理框架)的。然后也是感到了极大的不适应，于是在被折磨了两个月之后跑路到其他组了233
再加上腾讯内部的基础设施非常的烂，不仅仅是PCG内部的，导致最初的几个月过得无比煎熬。
基础设置有多烂呢，拿内部CI/CD平台蓝盾举例，我们每次提交代码会触发5条流水线(有不同tensorflow版本，以及gpu/cpu的区别)，所有流水线都通过代码才能被合入。 在有一段时间里，5条流水线同时通过的概率接近为0,原因就是蓝盾上的各种组件非常不稳定。 不是这个挂，就是那个挂。 挂了之后的解决办法就是拉群，然后helper让你这样试试，那样试试，解决不了就再拉人进群。通常一个小问题的三天以上才能解决，有的甚至要一周以上。在解决的过程中是不是做自己的工作就好了呢？ 想的太美好了。蓝盾常常会让你进行一个尝试，并声称“这样改一下就可以了”。本来的一个问题在改过会变成新的三个问题，并拉更多的人进群解决。那么平台出问题的频率是怎么样的呢？ 大概每周一次吧，非常频繁。 以至于甚至总监在开会的时候都会安慰大家&amp;quot;(腾讯)内部的工具就是这样，大家不要太因为这些工具的不稳定而感到气馁&amp;quot;233
总的来说，转行可真苦
展望 腾讯也要过冬了
&amp;quot;留给PCG的时间也不多了“
2022预计会比2021艰难许多
苟住，我们2023年见</description></item><item><title>ska::flat_hash_map 源码分析</title><link>https://111qqz.com/2021/08/ska_flat_hash_map_notes/</link><pubDate>Sat, 21 Aug 2021 17:43:02 +0800</pubDate><guid>https://111qqz.com/2021/08/ska_flat_hash_map_notes/</guid><description>
背景 最近在调研各种hashmap.. 发现ska::flat hash map性能优秀。。于是来看看代码。。 发现最大的特点是,ska::flat_hash_map使用了带probe count上限的robin hood hashing
相关概念 Distance_from_desired 对于采用了open addressing的hash实现，当插入发生冲突时，会以一定方式(如线性探测、平方探测等)来探测下一个可以插入的slot. 因而实际插入的slot位置与理想的slot位置通常不相同，这段距离定义为distance_from_desired 在没有冲突的理想情况下，所有distance_from_desired的值应该都为0 distance_from_desired的一种更常见的说法叫做probe sequence lengths(PSL)
robin hood hashing robin hood hashing的核心思想是&amp;quot;劫富济贫&amp;quot; distance_from_desired小的slot被认为更&amp;quot;富有&amp;quot;，distance_from_desired大的slot被认为更&amp;quot;贫穷&amp;quot; 具体来说，当去插入一个新的元素时，如果当前位置的元素的distance_from_desired要比待插入元素的distance_from_desired要小，那么就将待插入元素放入当前位置，将当前位置的元素取出，寻找一个新的位置。
这样做使得所有元素的distance_from_desired的分布更为平均，variance更小。 这样的分布对cache更友好（几乎全部元素distance_from_desired都小于一个cache line的长度，因此在find的时候只需要fetch一次cache line），从而拥有更好的性能。
一般的robin hashing 在find时，一般用一个全局的最大distance_from_desired作为没有找到该元素终止条件。 一种常见的改进是,不维护全局最大distance_from_desired,而是在看到当前位置元素的distance_from_desired比要插入的元素的distance_from_desired小时终止。
1 2 iterator find(const FindKey&amp;amp; key) { 3 size_t index = 4 hash_policy.index_for_hash(hash_object(key), num_slots_minus_one); 5 EntryPointer it = entries + ptrdiff_t(index); 6 for (int8_t distance = 0; it-&amp;gt;distance_from_desired &amp;gt;= distance; 7 ++distance, ++it) { 8 if (compares_equal(key, it-&amp;gt;value)) return {it}; 9 } 10 return end(); 11 } 12 带上限的robin hashing 一般的robin hashing在insert时，会不断进行寻找(包括了可能的swap过程)，直到找到一个空的slot为止。该过程在hash table较满时可能接近线性的时间复杂度。 ska::flat_hash_map对这一点的改进是，限制了insert时尝试的上限次数，作者给出的经验值为log(N),其中N为slots的个数。 这样保证每个slot的最大distance_from_desired不会超过log(N)</description></item><item><title>一次avx2在gcc上core dump的排查经历</title><link>https://111qqz.com/2021/07/core-dump-on-gcc-4-with-avx2/</link><pubDate>Thu, 22 Jul 2021 20:01:50 +0800</pubDate><guid>https://111qqz.com/2021/07/core-dump-on-gcc-4-with-avx2/</guid><description>
背景 起因是同事在实现int4的功能，结果流水线有一条死活过不了(gcc版本为4.8.5),一直core dump 经过初步排查，找出了如下最小可以复现的代码:
1 2#include &amp;lt;immintrin.h&amp;gt;3 4class Test{ 5 public: 6 Test(){ 7 tmp = _mm256_set_epi32(0,0,0,0,0,0,0,0); 8 } 9 private: 10 __m256i tmp; 11}; 12int main(){ 13 auto *tmp = new Test(); 14 return 0; 15} gcc版本为4.8.5 其中编译选项为
1g++ -std=c++11 -mavx2 a.cpp 2 现象为会core在 tmp = _mm256_set_epi32(0,0,0,0,0,0,0,0);
但是同样的代码，同样的编译选项，在gcc7.3上就不会发生core的问题。
初步排查 查看汇编代码,gcc4.8.5生成的如下:
1 2main: 3 push rbp 4 mov rbp, rsp 5 mov edi, 32 6 call operator new(unsigned long) 7 vpxor xmm0, xmm0, xmm0 8 vmovdqa YMMWORD PTR [rax], ymm0 9 mov eax, 0 10 pop rbp 11 ret 12 链接在这里</description></item><item><title>[施工完成] CSAPP shell lab</title><link>https://111qqz.com/2021/06/csapp-shelllab/</link><pubDate>Sat, 26 Jun 2021 18:18:52 +0800</pubDate><guid>https://111qqz.com/2021/06/csapp-shelllab/</guid><description>
背景 动手实现一个简单的Lab，主要依赖于课本第八章的内容 感觉主要是05比较难。。发现执行的顺序不太对。。原因是SIGCHLD里面waitpid参数没写对。。 后面的就相对简单了 累计大概花了10个小时的样子
实现细节 built-in comamnd built-in command 指的是shell自身的命令，因此只有少数几个，比如pwd.在上使用which pwd的时候，会提示&amp;quot;pwd: shell built-in command&amp;quot;
测试文件的构成 以trace04.txt举例
1# 2# trace04.txt - Run a background job. 3# 4/bin/echo -e tsh&amp;gt; ./myspin 1 \046 5./myspin 1 &amp;amp; 这是两条测试命令。。第一条是调用了 &amp;quot;/bin/echo -e&amp;quot;来执行，而且这条命令是一个fg job, \046 是'&amp;amp;'的ascii，这是输出字符串的一部分。
子进程中的log打印不正确 有些执行路径的log没有打印出来 可以调用flush(stdout) 确保打印
在执行fg job的时候，会等待上一个未结束的bg job执行 这是因为waitpid中的option写了默认的0，没有传入正确的option导致的
SIGCHLD的实现 感觉这个函数是整个Lab的难点
注意这里除了要对正常结束的process处理以外，也要处理因为其他原因导致的进程退出 可以根据下图的内容来判断是因为哪种原因进程结束的 这段调了好久。。虽然书上已经讲了比较多的情况。。。不过还是觉得略难
1void sigchld_handler(int sig) { 2 int olderrno = errno; 3 sigset_t mask_all, prev_all; 4 pid_t pid; 5 int status; 6 Sigfillset(&amp;amp;mask_all); 7 8 while ((pid = waitpid(-1, &amp;amp;status, WNOHANG | WUNTRACED)) &amp;gt; 0) { 9 if (WIFEXITED(status)) { 10 Sigprocmask(SIG_BLOCK, &amp;amp;mask_all, &amp;amp;prev_all); 11 deletejob(jobs, pid); 12 Sigprocmask(SIG_SETMASK, &amp;amp;prev_all, NULL); 13 } else if (WIFSIGNALED(status)) { 14 printf(&amp;#34;Job (%d) [%d] terminated by signal %d\n&amp;#34;, 15 pid2jid(pid), pid, WTERMSIG(status)); 16 Sigprocmask(SIG_BLOCK, &amp;amp;mask_all, &amp;amp;prev_all); 17 18 deletejob(jobs, pid); 19 Sigprocmask(SIG_SETMASK, &amp;amp;prev_all, NULL); 20 } else if (WIFSTOPPED(status)) { 21 printf(&amp;#34;Job (%d) [%d] stopped by signal %d\n&amp;#34;, 22 pid2jid(pid), pid, WSTOPSIG(status)); 23 struct job_t* job = getjobpid(jobs, pid); 24 if (job !</description></item><item><title>(CSE 599W)Reverse Mode Autodiff</title><link>https://111qqz.com/2021/04/reverse-mode-autodiff/</link><pubDate>Mon, 05 Apr 2021 14:44:25 +0800</pubDate><guid>https://111qqz.com/2021/04/reverse-mode-autodiff/</guid><description>
背景 怎么算微分。。通常有三种方法。
Symbolic Differentiation Numerical Differentiation Automatic Differentiation (auto diff)
auto diff中两种主流的方式分别是forward-mode和reverse-mode 由于forward-mode的方法中，计算的时间复杂度是O(n),n是输入的参数个数。而reverse-mode中，计算的时间复杂度是O(m),m是输出节点的个数。在dnn中，n往往很大，远大于m，因此这里主要介绍reverse-mode auto diff方法。
backprop和reverse mode auto diff的区别 看了reverse mode auto diff的过程，感觉和backprop是一回事呀。。。 实际上，backprop指的是训练神经网络根据loss的gradient来更新weight的过程，而auto diff是backprop使用的一个用来计算gradient的 technique.
Bakpropagation refers to the whole process of training an artificial neural network using multiple backpropagation steps, each of which computes gradients and uses them to perform a Gradient Descent step. In contrast, reverse-mode auto diff is simply a technique used to compute gradients efficiently and it happens to be used by backpropagation.</description></item><item><title>[施工完成] CSAPP Malloc lab</title><link>https://111qqz.com/2021/04/csapp-malloclab/</link><pubDate>Sun, 14 Mar 2021 16:05:42 +0800</pubDate><guid>https://111qqz.com/2021/04/csapp-malloclab/</guid><description>
背景 动手实现一个memory allocator,体会core到爆炸的乐趣(不是
trace file 结构分析 trace file 是对allocator的输入的描述，可以从mdriver.c中的
1static trace_t *read_trace(char *tracedir, char *filename); 看到Parse的逻辑，从而得到trace file的结构。
1 fscanf(tracefile, &amp;#34;%d&amp;#34;, &amp;amp;(trace-&amp;gt;sugg_heapsize)); /* not used */ 2 fscanf(tracefile, &amp;#34;%d&amp;#34;, &amp;amp;(trace-&amp;gt;num_ids)); 3 // 似乎只有num_ops用到了。。 4 fscanf(tracefile, &amp;#34;%d&amp;#34;, &amp;amp;(trace-&amp;gt;num_ops)); 5 fscanf(tracefile, &amp;#34;%d&amp;#34;, &amp;amp;(trace-&amp;gt;weight)); /* not used */ trace file起始位置的4个数的含义，其中第二个和第三个比较重要。 num_ids表示一共有多少个不同的内存块(对应后续的指令可以显示指定操作哪个内存块，从而确保allocator对malloc和free的顺序没有任何依赖的保证)，num_ops表示操作数，也就是malloc(对应'a'),realloc(对应'r'),free(对应'f')三种操作的个数。
1 while (fscanf(tracefile, &amp;#34;%s&amp;#34;, type) != EOF) { 2 switch (type[0]) { 3 case &amp;#39;a&amp;#39;: 4 fscanf(tracefile, &amp;#34;%u %u&amp;#34;, &amp;amp;index, &amp;amp;size); 5 trace-&amp;gt;ops[op_index].type = ALLOC; 6 trace-&amp;gt;ops[op_index].</description></item><item><title>【推荐系统】Toward the Next Generation of Recommender Systems: A Survey of the State-of-the-Art and Possible Extensions</title><link>https://111qqz.com/2020/01/toward-the-next-gen-of-recom-sys/</link><pubDate>Sat, 23 Jan 2021 17:42:15 +0800</pubDate><guid>https://111qqz.com/2020/01/toward-the-next-gen-of-recom-sys/</guid><description>
迫于生计，从今天开始学习推荐系统相关的内容，今天先来读一篇推荐系统领域的综述 Toward the next generation of recommender systems: a survey of the state-of-the-art and possible extensions
由于目前的工作其实是偏向推荐系统的serving,训练的开发，因此这些paper可能都是粗读，也不会把paper中的内容逐句翻译，而是找出我认为最为重要的一些概念加以记录。
INTRODUCTION 推荐的问题简单可以归纳成对user未看见的item进行打分的过程，这个分一般称之为rating.有了rating,推荐前top k 个最好的rating给用户即可。 推荐系统的预测内容有两种不同的类别，一种是预测绝对的rating，另外一种是预测一个user对不同item的相对喜好，称为“preference- based recommender systems”. 本文只讲前者，也就是预测具体的rating数值 根据使用的方法不同，推荐系统又分为三类: 基于内容的推荐：user会被推荐与他之前喜欢的item相似的item 基于协同过滤的推荐: user会被推荐其他和该user品味相近的user喜欢的item 将上述两种方法结合在一起使用 基于内容的方法( Content-Based Methods ) 常用在基于text内容的领域，可以用一些keyword来描述内容。具体做法是先拿到keyword的weight,然后基于这些weight来做推荐。计算keyword weight的方法中，比较有名的是 TF-IDF
TF-IDF tf–idf 是一个用来衡量一篇text中，每个keyword的重要性(或者叫weight)的方法。 从名字就可以看出，这个方法分为两部分。 tf和idf
tf是&amp;quot;term frequency&amp;quot;的缩写，表示的是某个keyword在一篇text里的频率，也就是出现的次数除以所有字词出现的次数 idf是&amp;quot;inverse document frequency&amp;quot;的缩写，衡量的是某个keyword在语料库里的普遍性。越普遍，改指越小（比如结构助词&amp;quot;的&amp;quot;，几乎在每一个text里都会出现，那么idf值就会很小)
tf和idf两部分都有一个公式来计算得到数值，tf-idf算法是将两个数值相乘起来，使得最终结果可以被这两部分影响。 tf-idf算法认为，某个keyword的tf值越高，idf越小，说明这个keyword对这篇text越重要。
直观地说,tf-idf的tf是保留高频重要词语，idf是将常见的词语去除的过程。
我们刚刚说tf-idf可以用来分析一个text(也就是item)中，每个Keyword的weight 那么实际上，tf-idf也可以用来分析对于一个user,每个keyword的weight 这样我们就得到了两个weight vector,分别表示每个keyword对一个user的重要性和每个keyword对一个item(text)的重要性
此时可以算一下两个向量的相似度，比如算个cos距离。 然后根据这个相似度进行推荐
缺点 非text-based的item不好提取feature top k keyword相同的两个item,不好区分 只会推荐之前打分过的item,使得推荐系统缺乏多样性 新用户的冷启动问题，推荐系统中没有新用户的喜好，导致无法做推荐 基于协同过滤的方法 找到和某个user taste类似的user group，然后将这个user group喜欢的item 推给这个user 根据使用的方法不同，通常分为两类:memory-based(or heuristic-based) and model-based。前者我更多的基于某个rule类做预测，后者是通过ML以及之后的DL方法来train 一个model,用这个model 做预测 由于可能需要计算任意两个user的相似度来判断taste,很多sys会先将任意两个user的相似度预处理出来。 虽然协同过滤的方法最初是用于计算user的相似度来做推荐，但是后面也有基于item的相似度来做推荐的方法，通常被写作&amp;quot;user-based CF&amp;quot;和&amp;quot;item-based CF&amp;quot; 优点 能够推荐给user他没见过，但是和他品味类似的user group喜欢的item 由于是基于ratings算相似度，所以适用于任何形态的内容（而不仅仅是text-based content，说白了就是当时其他形态的内容不容易拿到feature) 缺点 new user problem: 不知道新用户的喜好,不知道哪些才是与new user taste 相似的user new item problem: 新item没有被足够的用户打分，很难被推荐给其他user Sparsity: 协同过滤依赖于大量的user.</description></item><item><title>使用github actions来部署 github pages</title><link>https://111qqz.com/2020/01/using-github-actions-to-deploy-gh-pages/</link><pubDate>Sat, 23 Jan 2021 17:08:00 +0800</pubDate><guid>https://111qqz.com/2020/01/using-github-actions-to-deploy-gh-pages/</guid><description>
目前我的博客是部署在github pages上，源码是一个repo,渲染出来的静态页面是一个repo. 更新的时候是把后者作为前者的submodule. 感觉这种方式有些落后了，简直和某司内部的平台有的一比。因此尝试采用了下github actions，来自动化这个部署的流程。
build github pages 其实类似gitlab ci. 最开始我以为需要自己配置服务器，结果发现并不需要，直接用公用的就可以。 详细内容可以阅读github actions
遇到的主要问题其实是，在一个repo的github actions的pipeline 里推送到另外一个repo提示一些权限方面的错误。 解决的办法是配置下ssh key. 假设源码的repo称为A,渲染得到的静态页面的repo称为B 那么先生成一对ssh-key 然后在 A里，settings-&amp;gt;secrets 添加一个secret,名称为&amp;quot;ACTIONS_DEPLOY_KEY&amp;quot;，内容为private key的内容 然后在B里，settings-&amp;gt;deploy keys, 添加一个key,名称无所谓，内容为public key的内容
这样每次push到源码的repo A,就可以自动触发github actions,将静态页面推送到repo B.然后repo B 自动触发github pages机制
附一个github actions的配置文件
1# This is a basic workflow to help you get started with Actions23name:CI45# Controls when the action will run. 6on:7# Triggers the workflow on push or pull request events but only for the master branch8push:9branches:[master ]10pull_request:11branches:[master ]1213# Allows you to run this workflow manually from the Actions tab14workflow_dispatch:1516# A workflow run is made up of one or more jobs that can run sequentially or in parallel17jobs:18# This workflow contains a single job called &amp;#34;build&amp;#34;19build:20# The type of runner that the job will run on21runs-on:ubuntu-18.</description></item><item><title>2020年终总结</title><link>https://111qqz.com/2020/01/my-2020/</link><pubDate>Sun, 03 Jan 2021 16:54:57 +0800</pubDate><guid>https://111qqz.com/2020/01/my-2020/</guid><description>
本来不知道写什么所以不打算写了，不过后来觉得可以把今年做的一些重大的决定写出来，把当时的分析和想法记录下来。这样若干年后再回看，就能找到，是哪些明智或愚蠢的决定，对人生产生了巨大的影响。
职业选择 在商汤待了1234天之后，还是离开了这个一毕业就在地方。新的岗位完全远离了cv方向，主要和推荐相关了。
在换工作方面其实一直特别迷茫，迷茫在我不知道我在商汤的岗位是在做什么。想起19年的时候，猎头都是先默认我是做cv算法的。当得知我虽然不是做算法研究的，就没兴趣聊了2333. 或者有些猎头会觉得，既然不是做算法研究的那就是做工程的了，那对后端一定很熟悉吧？ 我觉得这个也和行业内重刷点，轻落地的氛围有很大关系。
这个氛围感觉2020年有了很大好转，有很多拿着“算法工程”的岗位jd的猎头出现，聊起来都是说，客户暂时不需要能训模型的人，比较急需做算法工程的同学。这个时候就感觉，我做的内容终于配有一个岗位名字了2333. 也感觉到市场上对岗位的需求比之前旺盛了很多。
这里想起了一件趣事。一个关系比较好的猎头和我吐槽给b站招算法工程的人，找了好久也找不到合适的。然后看了下要求。。是在算法工程领域有五年以上经验。。。 我就拉着猎头小姐姐算了一下，2020年的五年前是2015年。 15年那个时候，大部分公司可能还没有组建算法团队，甚至后面还要经历过几年疯狂的刷点比拼。。。 甚至cv落地里面非常重要的TensorRT的前身GIE都还没有公布出来。。。
虽然感觉市场需求开始旺盛了。。但是基本没有考虑再去一个cv公司，只是用某友商练了个手。 原因是我觉得，这些公司有的和商汤半斤八两，有的还不如商汤。尤其是从规模和抗风险能力上。商汤遇到的问题在这些公司上可能都会有（除了盘子太大以至于太烧钱）。
出来面了一圈非cv创业公司发现，面试的岗位真的是奇奇怪怪，做什么的都有。有推我去做算子优化的（类似优化矩乘),有推我去做k8s服务调度的，稍显正常的其实就是做移动端推理框架和机器学习平台的了。被推到各种岗位其实不是什么好事，因为这说明没有什么岗位是完全匹配的。我觉得这主要是因为商汤的to B属性，和互联网公司的技术栈其实是有区别的。次要原因可能就是，cv在小的创业公司需求旺盛，但是在互联网公司好像真的有些鸡肋。面了一圈，只有一个做超市购物结算的美帝公司和某个友商面试问过我和cv相关的问题。
其实本来倾向于去字节的。。花了半年时间刷了700 leetcode。 可惜最初投的部门面试体验比较差，后面又约了另一个部门。。感觉完全不匹配。。。我再也不相信字节hr所谓的“很match”了。。。 之后先前面的鹅厂一直就在催答复。。感觉包裹也算有诚意。。做的事情也算比较理想。。。向朋友们打听了一圈。。给的评价都还可以。。。 尤其是被frog学姐强推。。就接了offer。。。 接了之后又被字节三个不同的部门捞了一遍。。。其中一个部门的hr说。。部门老大看了我的面评一定要聊一下。。。 那似乎面评中没有什么很糟糕的部分。。算是比较欣慰吧。。 有缘再见。
其他 毕业两年半，厉害的同学已经年薪百万了orz
虽然说当年读CS的时候就业还是红牌，也不是为了钱。但是财务上相对自由才能有更大的自由去做自己喜欢的事情吧。 所以还是挺羡慕
2021,希望自己变得更强！</description></item><item><title>[施工完成] CSAPP Cachelab</title><link>https://111qqz.com/2020/12/csapp-cache-lab/</link><pubDate>Sat, 26 Dec 2020 16:40:42 +0800</pubDate><guid>https://111qqz.com/2020/12/csapp-cache-lab/</guid><description>
背景 CSAPP:3e 的配套实验 地址 分成了两个部分，第一部分是模拟一下cache的miss,hit,evict的规则。第二部分是优化一个矩阵的转置，使得miss尽可能少。
PART A 给了一个标程csim-ref,要求实现一个程序，输出与该标程一致。
写的时候太心急了。。导致没看完作业要求就开始写了。。 然后就纠结了好久。。如果要访问的地址超过了一个block line的边界该怎么办。。
然而实际上题目里已经把这种情况排除了。。
For this this lab, you should assume that memory accesses are aligned properly, such that a single memory access never crosses block boundaries. By making this assumption, you can ignore the request sizes in the valgrind traces
这样的话。。就没什么难度了。。 LRU的替换策略用纯c去撸hashmap+list有点烦。。。干脆就写了暴力的实现。。反正是模拟题(x
1 2#include &amp;lt;getopt.h&amp;gt;3#include &amp;lt;stdbool.h&amp;gt;4#include &amp;lt;stdio.h&amp;gt;5#include &amp;lt;stdlib.h&amp;gt;6#include &amp;lt;string.h&amp;gt;7#include &amp;lt;unistd.h&amp;gt;8 9#include &amp;#34;cachelab.h&amp;#34;10 11const unsigned int address_space_size = 64; 12// https://stackoverflow.</description></item><item><title>【施工中】torch2trt　学习笔记</title><link>https://111qqz.com/2020/09/torch2trt/</link><pubDate>Fri, 18 Sep 2020 11:02:50 +0800</pubDate><guid>https://111qqz.com/2020/09/torch2trt/</guid><description>
前言 偶然发现了 torch2trt 的模型转换方案，思路是直接将pytorch op映射到TensorRT的python api. 在pytorch进行每个op　forward的时候，tensorrt也相应往network上添加op. 这里会先涉及torch2trt的使用，后面会补充这个转换工具的代码学习
使用torch2trt torch2trt pytorch可以直接安装，但是torchvision根据 pytorch-for-jetson-version-1-6-0-now-available 中的说法，需要编译安装
1git clone https://github.com/pytorch/vision 然后切换到tag v0.7.0 执行
1sudo python3 setup.py install 可以正常安装
然后报错: ModuleNotFoundError: No module named 'termcolor'
尝试 sudo apt install python3-termcolor 后解决
接下来尝试trt samples中的　/python/network_api_pytorch_mnist 发现安装pycuda报错找不到cuda.h的头文件 参考　pycuda installation failure on jetson nano 执行了如下命令后成功:
1export LIBRARY_PATH=/usr/local/cuda/targets/aarch64-linux/lib/:$LIBRARY_PATH 2export CPATH=/usr/local/cuda/include:$CPATH 3 然后尝试使用TensorRT python api对一个engine file 做inference的时候，报错: pycuda._driver.LogicError: explicit_context_dependent failed: invalid device context - no currently active context? 在　import pycuda.</description></item><item><title>Jetson Nano踩坑记录</title><link>https://111qqz.com/2020/09/jetson-nano/</link><pubDate>Tue, 08 Sep 2020 14:41:34 +0800</pubDate><guid>https://111qqz.com/2020/09/jetson-nano/</guid><description>
写在前面 主要是需要在jetson nano做模型转换，来记录下踩的坑 目前有两条路径，一条是我们现有的转换路径，也就是pytorch-&amp;gt;onnx(-&amp;gt;caffe)-&amp;gt;trt的路径 在这条路径上踩了比较多的坑，最终暂时放弃，最直接的原因是cudnn8.0升级接口发生改动，编译caffe遇到较多问题 这里其实仍然采用了两条平行的路径，一条是直接在nano上构建环境，另外一种是基于docker(包括构建交叉编译环境用于加快编译速度)
另一条路径是基于torch2trt,是一条直接pytorch-&amp;gt;trt的路径 这里主要记录在第一条路径上踩过的坑
环境准备 先过一遍开发者手册 主要是介绍了下nano的硬件和jetpack的组件 jetpack可以理解成一个nvidia用在嵌入式设备上的SDK工具包
镜像烧录 然后需要烧录镜像，参考Write Image to the microSD Card 最初使用 Etcher 来烧录，没有启动起来，原因未知。使用终端命令烧录就没问题了。
更换国内apt源 我拿到的jeston nano是基于ubuntu 18.04 lts的版本，默认源比较慢，换成国内源。需要注意要换arm版本的源
1wget -O /etc/apt/sources.list https://repo.huaweicloud.com/repository/conf/Ubuntu-Ports-bionic.list 2apt update 基于docker的模型转换 由于在x86上模型转换的工具是基于docker的，因此最初的想法是在nano上也基于docker进行转模型，这样或许可以复用一些x86上的工作。
确认了Jetson Nano上是可以跑docker和NVIDIA Container Runtime on Jetson (Beta)的 但是最初发现arm的cuda docker image最低支持cuda11.0的版本 cuda-arm64 docker image tag 然而目前(2020年9月)最新的jetpack4.4版本只支持到cuda10.2的版本 尝试了下使用cuda-arm64的docker image　发现驱动版本不够，而nano上似乎很难升级驱动版本，因此差点就放弃这条路径了。
然而发现，在nano上要用的cuda镜像并不应该是cuda-arm,而是NVIDIA L4T Base
结论 参考https://docs.nvidia.com/jetson/archives/，发现一个可能的问题是，jetpack中cuDNN,TensorRT等库的版本不是连续的。
jetpack4.4: CUDA10.2,TensorRT 7.1.3,cuDNN 8.0.0 jetpack4.3: CUDA 10.0.326, TensorRT 6.0.1.10, cuDNN 7.</description></item><item><title>k8s nodes is forbidden user cannot list resource nodes in api group at the cluster scope</title><link>https://111qqz.com/2020/05/install-k8s-get-nodes-forbidden-error/</link><pubDate>Thu, 07 May 2020 16:01:52 +0800</pubDate><guid>https://111qqz.com/2020/05/install-k8s-get-nodes-forbidden-error/</guid><description>
继续将k8s用于模型转换和部署的自动化流程...然后发现之前安装k8s的文档不work了．． 时间是2020年5月7日，当前最新的k8s版本是　v1.18.2
报错如下:
1 2 3&amp;lt;2kzzqw6rsjid0 --discovery-token-ca-cert-hash sha256:c6c72bdc96c0ff4d59559ff915eee61ba7ac5e8b93c0b2f9e11e813412387ec2 --v=5 4W0507 15:45:12.608784 4768 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set. 5I0507 15:45:12.608822 4768 join.go:371] [preflight] found NodeName empty; using OS hostname as NodeName 6I0507 15:45:12.608853 4768 initconfiguration.go:103] detected and using CRI socket: /var/run/dockershim.sock 7[preflight] Running pre-flight checks 8I0507 15:45:12.608902 4768 preflight.go:90] [preflight] Running general checks 9I0507 15:45:12.608933 4768 checks.go:249] validating the existence and emptiness of directory /etc/kubernetes/manifests 10I0507 15:45:12.</description></item><item><title>caffe 源码学习笔记(11) argmax layer</title><link>https://111qqz.com/2020/05/caffe-source-code-analysis-part11/</link><pubDate>Wed, 06 May 2020 21:26:03 +0800</pubDate><guid>https://111qqz.com/2020/05/caffe-source-code-analysis-part11/</guid><description>
背景 似乎没什么背景,继续看caffe代码
argmax的作用是返回一个blob某个维度或者batch_size之后的维度的top_k的index(或者pair(index,value))
proto 还是先看proto
12message ArgMaxParameter {3 // If true produce pairs (argmax, maxval) 4 optional bool out_max_val = 1 [default = false];5 optional uint32 top_k = 2 [default = 1];6 // The axis along which to maximise -- may be negative to index from the 7 // end (e.g., -1 for the last axis). 8 // By default ArgMaxLayer maximizes over the flattened trailing dimensions 9 // for each index of the first / num dimension.</description></item><item><title>caffe 源码学习笔记(10) eltwise layer</title><link>https://111qqz.com/2020/05/caffe-source-code-analysis-part10/</link><pubDate>Sun, 03 May 2020 17:53:22 +0800</pubDate><guid>https://111qqz.com/2020/05/caffe-source-code-analysis-part10/</guid><description>
背景 这个layer和reduce layer有一些相似,就干脆一起看了. 作用是输入至少两个blob,然后对每个blob中的元素所一些运算,最后得到一个blob.
caffe 支持的运算有&amp;quot;PROD&amp;quot;,&amp;quot;SUM&amp;quot;,&amp;quot;MAX&amp;quot;三种
顺便提一句,TensorRT支持的要多一些:
1 2enum class ElementWiseOperation : int 3{ 4 kSUM = 0, //!&amp;lt; Sum of the two elements. 5 kPROD = 1, //!&amp;lt; Product of the two elements. 6 kMAX = 2, //!&amp;lt; Maximum of the two elements. 7 kMIN = 3, //!&amp;lt; Minimum of the two elements. 8 kSUB = 4, //!&amp;lt; Substract the second element from the first. 9 kDIV = 5, //!</description></item><item><title>caffe 源码学习笔记(9) reduce layer</title><link>https://111qqz.com/2020/05/caffe-source-code-analysis-part9/</link><pubDate>Sun, 03 May 2020 15:16:53 +0800</pubDate><guid>https://111qqz.com/2020/05/caffe-source-code-analysis-part9/</guid><description>
背景 其实没什么背景,继续啃caffe代码而已2333
reduce layer其实就是做reduce操作,把一个任意shape的blob通过某种运算变成一个scalar.
caffe目前支持求和(SUM),绝对值的和(ASUM),平方和(SUMSQ),以及对得到的scalar的总数求平均的求和(MEAN).
说句题外话,TensorRT支持的操作是求和,求积,max,min和ave. 还是有一些gap的
proto 先看proto
12message ReductionParameter {3 enum ReductionOp {4 SUM = 1;5 ASUM = 2;6 SUMSQ = 3;7 MEAN = 4;8 }910 optional ReductionOp operation = 1 [default = SUM]; // reduction operation 1112 // The first axis to reduce to a scalar -- may be negative to index from the 13 // end (e.g., -1 for the last axis). 14 // (Currently, only reduction along ALL &amp;#34;tail&amp;#34; axes is supported; reduction 15 // of axis M through N, where N &amp;lt; num_axes - 1, is unsupported.</description></item><item><title>Focal Loss for Dense Object Detection(RetinaNet) 学习笔记</title><link>https://111qqz.com/2020/05/retinanet-notes/</link><pubDate>Sat, 02 May 2020 18:50:06 +0800</pubDate><guid>https://111qqz.com/2020/05/retinanet-notes/</guid><description>
先写个简略版的笔记..看之后的情况要不要读得更精细一点..
背景 two stage的检测比one stage的检测效果好,原因是啥?
作者认为是正负样本不平衡导致的. two stage的方法在proposal 的时候干掉了大部分负样本,所以效果好.
因为作者提出了一种新的loss,称为Focal Loss 是对交叉熵loss的改进,作用是提高没有正确分类的样本的权重,降低正确分类的样本的权重.
然后设计了个retinaNet 来验证效果. 主要是用了Focal Loss 作为损失函数,以及backbone比起之前的one stage的检测用上了FPN.
Focal Loss 一图胜千言
Focal loss是在交叉熵loss的基础上增加了一个指数衰减. 对正确分类的样本影响很小,对错误分类的样本影响很大.
从图上我们可以看出,CE对正确分类的样本仍然有不小的loss,这样的样本数很多的话,就会被训练的时候模型被带歪... 因此需要减少这些正确分类的样本对loss的影响.
RetinaNet 单阶段检测,主要在于使用Focal Loss训练,以及backbone用上了FPN</description></item><item><title>caffe 源码学习笔记(8) loss function</title><link>https://111qqz.com/2020/04/caffe-source-code-analysis-part8/</link><pubDate>Sat, 18 Apr 2020 18:33:29 +0800</pubDate><guid>https://111qqz.com/2020/04/caffe-source-code-analysis-part8/</guid><description>
背景 虽然不太care 训练的过程，但是由于容易看懂的layer都看得差不多了 所以打算看一下这些loss function.
Euclidean Loss (L2 loss) 一般用于“real-valued regression tasks” 。　比如之前的项目上用的人脸年龄模型，就是用了这个Loss
这个loss没什么额外的参数，实现也很简单。
1 2template &amp;lt;typename Dtype&amp;gt; 3void EuclideanLossLayer&amp;lt;Dtype&amp;gt;::Reshape( 4 const vector&amp;lt;Blob&amp;lt;Dtype&amp;gt;*&amp;gt;&amp;amp; bottom, const vector&amp;lt;Blob&amp;lt;Dtype&amp;gt;*&amp;gt;&amp;amp; top) { 5 LossLayer&amp;lt;Dtype&amp;gt;::Reshape(bottom, top); 6 CHECK_EQ(bottom[0]-&amp;gt;count(1), bottom[1]-&amp;gt;count(1)) 7 &amp;lt;&amp;lt; &amp;#34;Inputs must have the same dimension.&amp;#34;; 8 diff_.ReshapeLike(*bottom[0]); 9} 10 11template &amp;lt;typename Dtype&amp;gt; 12void EuclideanLossLayer&amp;lt;Dtype&amp;gt;::Forward_cpu(const vector&amp;lt;Blob&amp;lt;Dtype&amp;gt;*&amp;gt;&amp;amp; bottom, 13 const vector&amp;lt;Blob&amp;lt;Dtype&amp;gt;*&amp;gt;&amp;amp; top) { 14 int count = bottom[0]-&amp;gt;count(); 15 caffe_sub( 16 count, 17 bottom[0]-&amp;gt;cpu_data(), 18 bottom[1]-&amp;gt;cpu_data(), 19 diff_.</description></item><item><title>caffe 源码学习笔记(7) slice layer</title><link>https://111qqz.com/2020/04/caffe-source-code-analysis-part7/</link><pubDate>Mon, 13 Apr 2020 21:22:54 +0800</pubDate><guid>https://111qqz.com/2020/04/caffe-source-code-analysis-part7/</guid><description>
背景　 ocr组那边有个shuffle net 的网络,里面有个pytorch op叫chunk,转成的onnx对应的op是 split
作用是:
Split a tensor into a list of tensors, along the specified 'axis'. Lengths of the parts can be specified using argument 'split'. Otherwise, the tensor is split to equal sized parts.
然后发现这个op模型转换里不支持转到caffe的layer,于是想办法支持了一下. 发现是要转到caffe的slice layer.(caffe也有一个split layer,但是这个split layer是除了一个输出blob作为多个layer的输入时用的)
proto 12message SliceParameter {3 // The axis along which to slice -- may be negative to index from the end 4 // (e.g., -1 for the last axis).</description></item><item><title>thinkpad t430 manjaro系统安装nvidia驱动</title><link>https://111qqz.com/2020/04/Install-nvidia-Driver-on-Thinkpad-T430-Manjaro/</link><pubDate>Sun, 12 Apr 2020 07:10:14 +0800</pubDate><guid>https://111qqz.com/2020/04/Install-nvidia-Driver-on-Thinkpad-T430-Manjaro/</guid><description>
前几天装驱动把笔记本搞崩溃了..重新装了kde桌面环境的manjaro
首先根据 Configure NVIDIA (non-free) settings and load them on Startup
直接装驱动。 装之后mhwd -li命令会显示新安装的驱动，带有nvidia字样的。
然而发现inxi -G 命令下，nvidia GPU显示的drivier是 N/A
参考Inxi -G in Terminal: Graphics card N/A?
发现需要手动load driver
执行 sudo modprobe nvidia 后发现inxi -G 命令可以找到驱动了，nvidia-smi也可以正常显示了。
接下来是设置开启加载driver.
参考Automatic module loading with systemd
需要修改 /etc/modules-load.d/modules.conf
加入一行
1 2nvidia 3 重启后发现仍然不work.
然后看到/etc/modules-load.d/ doesn’t load nvidia on boot
发现原因是nvidia驱动被设置为黑名单了。 在 /usr/lib/modprobe.d/bumblebee.conf 文件中，把所有内容注释掉即可。
重新启动，发现已经可以正常加载驱动了。</description></item><item><title>caffe 源码学习笔记(6) reshape layer</title><link>https://111qqz.com/2020/04/caffe-source-code-analysis-part6/</link><pubDate>Thu, 09 Apr 2020 21:03:06 +0800</pubDate><guid>https://111qqz.com/2020/04/caffe-source-code-analysis-part6/</guid><description>
背景　 最近在魔改 tensorRT 的caffe parser 之前caffe模型转到trt模型时，有一个修改是需要将reshape　layer的param末尾补1,比较繁琐，于是看了下caffe的reshape layer的实现．
proto 12message ReshapeParameter {3 // Specify the output dimensions. If some of the dimensions are set to 0, 4 // the corresponding dimension from the bottom layer is used (unchanged). 5 // Exactly one dimension may be set to -1, in which case its value is 6 // inferred from the count of the bottom blob and the remaining dimensions. 7 // For example, suppose we want to reshape a 2D blob &amp;#34;input&amp;#34; with shape 2 x 8: 8 // 9 // layer { 10 // type: &amp;#34;Reshape&amp;#34; bottom: &amp;#34;input&amp;#34; top: &amp;#34;output&amp;#34; 11 // reshape_param { .</description></item><item><title>caffe 源码学习笔记(5) 卷积</title><link>https://111qqz.com/2020/04/caffe-source-code-analysis-part5/</link><pubDate>Wed, 08 Apr 2020 20:29:37 +0800</pubDate><guid>https://111qqz.com/2020/04/caffe-source-code-analysis-part5/</guid><description>
caffe中卷积运算的实现 暴力实现的卷积大概是这样子的
1 2for w in 1..W 3 for h in 1..H 4 for x in 1..K 5 for y in 1..K 6 for m in 1..M 7 for d in 1..D 8 output(w, h, m) += input(w+x, h+y, d) * filter(m, x, y, d) 9 end 10 end 11 end 12 end 13 end 14end 15 这种方式的效率显然很低，不意外地,caffe中并不是这样实现的．
注释里面说:
Caffe convolves by reduction to matrix multiplication. This achieves high-throughput and generality of input and filter dimensions but comes at the cost of memory for matrices.</description></item><item><title>tensorrt INT8 量化debug记录（cuda error 700）</title><link>https://111qqz.com/2020/04/cuda-error-700-when-using-tensorrt-calibration/</link><pubDate>Wed, 08 Apr 2020 14:58:16 +0800</pubDate><guid>https://111qqz.com/2020/04/cuda-error-700-when-using-tensorrt-calibration/</guid><description>
背景是要把某个caffe model,转换成tensorrt的INT8 模型。 然后遇到如下报错:
1 2E0403 08:54:35.951987 5704 engine.h:62] engine.cpp (572) - Cuda Error in commonEmitTensor: 1 (invalid argument) 3E0403 08:54:35.952157 5704 engine.h:62] Failure while trying to emit debug blob. 4engine.cpp (572) - Cuda Error in commonEmitTensor: 1 (invalid argument) 5E0403 08:54:35.952235 5704 engine.h:62] cuda/caskConvolutionLayer.cpp (355) - Cuda Error in execute: 1 (invalid argument) 6E0403 08:54:35.952291 5704 engine.h:62] cuda/caskConvolutionLayer.cpp (355) - Cuda Error in execute: 1 (invalid argument) 7W0403 08:54:35.952324 5704 calibrator.</description></item><item><title>caffe 源码学习笔记(4) 激活函数</title><link>https://111qqz.com/2020/04/caffe-source-code-analysis-part4/</link><pubDate>Tue, 07 Apr 2020 23:21:40 +0800</pubDate><guid>https://111qqz.com/2020/04/caffe-source-code-analysis-part4/</guid><description>
在看过caffe代码的三个核心部分,blob,layer,net之后，陷入了不知道以什么顺序继续看的困境。
blob,layer,net只是三个最基本的概念，关键还是在于各个layer. 但是layer这么多，要怎么看呢？ 想了一下决定把相同作用的layer放在一起分析。 今天打算先分析一下激活函数。
sigmoid 表达式为 f(t) = 1/(1+e^-t)
caffe GPU实现，非常直接
1 2template &amp;lt;typename Dtype&amp;gt; 3__global__ void SigmoidForward(const int n, const Dtype* in, Dtype* out) { 4 CUDA_KERNEL_LOOP(index, n) { 5 out[index] = 1. / (1. + exp(-in[index])); 6 } 7} 8 sigmoid激活函数的一大优点是求导非常容易，因此backward函数其实也很简单。
1 2template &amp;lt;typename Dtype&amp;gt; 3__global__ void SigmoidBackward(const int n, const Dtype* in_diff, 4 const Dtype* out_data, Dtype* out_diff) { 5 CUDA_KERNEL_LOOP(index, n) { 6 const Dtype sigmoid_x = out_data[index]; 7 out_diff[index] = in_diff[index] * sigmoid_x * (1 - sigmoid_x); 8 } 9} 10 然后proto里面也没什么内容。因为sigmoid函数没什么参数</description></item><item><title>Faster Rcnn 目标检测算法</title><link>https://111qqz.com/2020/04/faster-rcnn/</link><pubDate>Sun, 05 Apr 2020 20:38:28 +0800</pubDate><guid>https://111qqz.com/2020/04/faster-rcnn/</guid><description>
背景 2019年对了好几次faster rcnn，第一次是赛事之窗项目和北京的同事，对齐sdk和训练的实现。 第二次是被tensorRT4和tensorRT5之间默认参数不一致的问题坑了一下。 第三次是被caffe proto中roi align 的默认参数坑了。
虽然debug了这么多次，踩了一堆坑，但是一段时间不用，细节就会慢慢不记得了。因此来记录一下。
faster rcnn，是一种&amp;quot;two stage&amp;quot;的目标检测算法。
所谓&amp;quot;two stage&amp;quot;，是说在实际进行目标检测之前，先会通过某种&amp;quot;region proposals&amp;quot; algorithm，来获得一定数量的RoI(Regions of Interest),我们下一阶段要检测的obejct有极大可能被包含在这些RoI. 这种&amp;quot;Region based&amp;quot;的方法是对基于&amp;quot;sliding windows&amp;quot;方法的极大改进，因为不需要遍历每一个可能的位置以及crop大小，只需要对这些RoI进行检测，有效地减小了计算量。
下面简单说一下这一类&amp;quot;Region based&amp;quot;方法的历史脉络
rcnn RCNN的做法是通过一种传统方法&amp;quot;selective search&amp;quot;来得到若干RoI,然后把每一个RoI，后面接CNN进行后续的检测。 显然，这个方法的问题在于计算量非常大。
selective search的策略是，既然是不知道尺度是怎样的，那我们就尽可能遍历所有的尺度，但是不同于暴力穷举，我们可以先得到小尺度的区域，然后一次次合并得到大的尺寸.
fast rcnn 明眼人可以看出，rcnn计算量过大的原因之一是做了非常多的重复计算。
因此fast rcnn做的改进是，与其把每一个通过&amp;quot;selective search&amp;quot;得到的RoI在原图上crop出来送进CNN,不如先让整张图过一段CNN,然后把通过&amp;quot;selective search&amp;quot;在原图上得到的RoI先映射到这段CNN的某个conv feature map. 相当于这部分CNN只做了一次，与RoI数量无关，极大地减小了计算量。
faster rcnn 终于轮到主角登场了。 fast rcnn极大提高了检测的速度。 然后发现，速度的瓶颈已经不在后续的检测部分了，而是在于“region proposals” algorithm.
于是，faster-rcnn提出&amp;quot;Region proposal network&amp;quot;来替代&amp;quot;selective search&amp;quot;,进一步提高了检测速度。
放一张结构图，非常清楚。 Region proposal network(RPN) anchor 介绍RPN网络首先就要介绍一下anchor.
（被坑过一次，某个足球项目上，training和inference用的anchor竟然是不一致的。。）
其实anchor这个概念很简单，用大白话说就是，根据要检测的物体的形状（高矮胖瘦等），预先 设置一些不同尺寸（高矮胖瘦）的粗略的框，然后对这些框做一个二分类，判断前景还是背景，同时做bbox regression 来微调坐标，最终得到proposals.
设置anchor的思路其实就是修改了proposals的默认位置为生成的anchors的位置。对这些anchors进行微调总要比从零开始生成容易得多。
要注意的是，anchors是在进入网络前预先生成的。 实际项目中，通常设置长宽比为[1:1,2:1,1:2]三种比例，然后通过 generate_anchors.py 来生成anchors.</description></item><item><title>resnet 学习笔记</title><link>https://111qqz.com/2020/04/resnet-learning-notes/</link><pubDate>Sun, 05 Apr 2020 16:49:44 +0800</pubDate><guid>https://111qqz.com/2020/04/resnet-learning-notes/</guid><description>
背景 基于Conv的方法在某年的ImageNet比赛上又重新被人想起之后，大家发现网络堆叠得越深，似乎在cv的各个任务上表现的越好。
然而事情当然没有无脑退跌深度那么简单，人们发现，当网络深到一定程度时，结果还不如浅一些的网络结构。
可能第一反应是，网路那么深，多了那么多参数，有那么多数据吗？ overfit了吧
然而情况没有那么简单。如果只是单纯得overfit，那么应该只有test error很高才对。然而现在的情况是training error也很高。
那这是怎么回事呢？ Resnet的团队认为，是因为深层的网络在训练的时候很难收敛。
这个想法是有依据的，因为我们可以通过构造一个较深的网络结构，使得后面的layer学成一个&amp;quot;identity mapping&amp;quot;的函数。这样training error和test error应该至少和一个浅层网络的结果一样好才对。
那么问题很可能就出在，深层的网络没办法学到这样的函数。
基于这样的想法，resnet团队提出了一种新的结构，称之为&amp;quot;skip connection&amp;quot;,来验证该假设。
resnet网络结构 我们可以看到，该结构把原来网络要学的H(x)，变成了F(X)+X的形势。 因此网络只需要学习F(X),也就是在 &amp;quot;identity mapping&amp;quot;上学习一个偏移。
实验表明，这种结构对于深层的网络是非常有效的，因为这种结构将默认设置变为了&amp;quot;identity mapping&amp;quot;,整个网络变得更加容易收敛。
resnet也成了目前工业界各种网络结构的标准backbone
resnet 结构的caffe prototxt 放了resnet50的部分结构，截止到第一个resnet block
12name: &amp;#34;ResNet-50&amp;#34;3input: &amp;#34;data&amp;#34;4input_dim: 15input_dim: 36input_dim: 2247input_dim: 22489layer {10 bottom: &amp;#34;data&amp;#34;11 top: &amp;#34;conv1&amp;#34;12 name: &amp;#34;conv1&amp;#34;13 type: &amp;#34;Convolution&amp;#34;14 convolution_param {15 num_output: 6416 kernel_size: 717 pad: 318 stride: 219 }20}2122layer {23 bottom: &amp;#34;conv1&amp;#34;24 top: &amp;#34;conv1&amp;#34;25 name: &amp;#34;bn_conv1&amp;#34;26 type: &amp;#34;BatchNorm&amp;#34;27 batch_norm_param {28 use_global_stats: true29 }30}3132layer {33 bottom: &amp;#34;conv1&amp;#34;34 top: &amp;#34;conv1&amp;#34;35 name: &amp;#34;scale_conv1&amp;#34;36 type: &amp;#34;Scale&amp;#34;37 scale_param {38 bias_term: true39 }40}4142layer {43 bottom: &amp;#34;conv1&amp;#34;44 top: &amp;#34;conv1&amp;#34;45 name: &amp;#34;conv1_relu&amp;#34;46 type: &amp;#34;ReLU&amp;#34;47}4849layer {50 bottom: &amp;#34;conv1&amp;#34;51 top: &amp;#34;pool1&amp;#34;52 name: &amp;#34;pool1&amp;#34;53 type: &amp;#34;Pooling&amp;#34;54 pooling_param {55 kernel_size: 356 stride: 257 pool: MAX58 }59}6061layer {62 bottom: &amp;#34;pool1&amp;#34;63 top: &amp;#34;res2a_branch1&amp;#34;64 name: &amp;#34;res2a_branch1&amp;#34;65 type: &amp;#34;Convolution&amp;#34;66 convolution_param {67 num_output: 25668 kernel_size: 169 pad: 070 stride: 171 bias_term: false72 }73}7475layer {76 bottom: &amp;#34;res2a_branch1&amp;#34;77 top: &amp;#34;res2a_branch1&amp;#34;78 name: &amp;#34;bn2a_branch1&amp;#34;79 type: &amp;#34;BatchNorm&amp;#34;80 batch_norm_param {81 use_global_stats: true82 }83}8485layer {86 bottom: &amp;#34;res2a_branch1&amp;#34;87 top: &amp;#34;res2a_branch1&amp;#34;88 name: &amp;#34;scale2a_branch1&amp;#34;89 type: &amp;#34;Scale&amp;#34;90 scale_param {91 bias_term: true92 }93}9495layer {96 bottom: &amp;#34;pool1&amp;#34;97 top: &amp;#34;res2a_branch2a&amp;#34;98 name: &amp;#34;res2a_branch2a&amp;#34;99 type: &amp;#34;Convolution&amp;#34;100 convolution_param {101 num_output: 64102 kernel_size: 1103 pad: 0104 stride: 1105 bias_term: false106 }107}108109layer {110 bottom: &amp;#34;res2a_branch2a&amp;#34;111 top: &amp;#34;res2a_branch2a&amp;#34;112 name: &amp;#34;bn2a_branch2a&amp;#34;113 type: &amp;#34;BatchNorm&amp;#34;114 batch_norm_param {115 use_global_stats: true116 }117}118119layer {120 bottom: &amp;#34;res2a_branch2a&amp;#34;121 top: &amp;#34;res2a_branch2a&amp;#34;122 name: &amp;#34;scale2a_branch2a&amp;#34;123 type: &amp;#34;Scale&amp;#34;124 scale_param {125 bias_term: true126 }127}128129layer {130 bottom: &amp;#34;res2a_branch2a&amp;#34;131 top: &amp;#34;res2a_branch2a&amp;#34;132 name: &amp;#34;res2a_branch2a_relu&amp;#34;133 type: &amp;#34;ReLU&amp;#34;134}135136layer {137 bottom: &amp;#34;res2a_branch2a&amp;#34;138 top: &amp;#34;res2a_branch2b&amp;#34;139 name: &amp;#34;res2a_branch2b&amp;#34;140 type: &amp;#34;Convolution&amp;#34;141 convolution_param {142 num_output: 64143 kernel_size: 3144 pad: 1145 stride: 1146 bias_term: false147 }148}149150layer {151 bottom: &amp;#34;res2a_branch2b&amp;#34;152 top: &amp;#34;res2a_branch2b&amp;#34;153 name: &amp;#34;bn2a_branch2b&amp;#34;154 type: &amp;#34;BatchNorm&amp;#34;155 batch_norm_param {156 use_global_stats: true157 }158}159160layer {161 bottom: &amp;#34;res2a_branch2b&amp;#34;162 top: &amp;#34;res2a_branch2b&amp;#34;163 name: &amp;#34;scale2a_branch2b&amp;#34;164 type: &amp;#34;Scale&amp;#34;165 scale_param {166 bias_term: true167 }168}169170layer {171 bottom: &amp;#34;res2a_branch2b&amp;#34;172 top: &amp;#34;res2a_branch2b&amp;#34;173 name: &amp;#34;res2a_branch2b_relu&amp;#34;174 type: &amp;#34;ReLU&amp;#34;175}176177layer {178 bottom: &amp;#34;res2a_branch2b&amp;#34;179 top: &amp;#34;res2a_branch2c&amp;#34;180 name: &amp;#34;res2a_branch2c&amp;#34;181 type: &amp;#34;Convolution&amp;#34;182 convolution_param {183 num_output: 256184 kernel_size: 1185 pad: 0186 stride: 1187 bias_term: false188 }189}190191layer {192 bottom: &amp;#34;res2a_branch2c&amp;#34;193 top: &amp;#34;res2a_branch2c&amp;#34;194 name: &amp;#34;bn2a_branch2c&amp;#34;195 type: &amp;#34;BatchNorm&amp;#34;196 batch_norm_param {197 use_global_stats: true198 }199}200201layer {202 bottom: &amp;#34;res2a_branch2c&amp;#34;203 top: &amp;#34;res2a_branch2c&amp;#34;204 name: &amp;#34;scale2a_branch2c&amp;#34;205 type: &amp;#34;Scale&amp;#34;206 scale_param {207 bias_term: true208 }209}210211layer {212 bottom: &amp;#34;res2a_branch1&amp;#34;213 bottom: &amp;#34;res2a_branch2c&amp;#34;214 top: &amp;#34;res2a&amp;#34;215 name: &amp;#34;res2a&amp;#34;216 type: &amp;#34;Eltwise&amp;#34;217}218219layer {220 bottom: &amp;#34;res2a&amp;#34;221 top: &amp;#34;res2a&amp;#34;222 name: &amp;#34;res2a_relu&amp;#34;223 type: &amp;#34;ReLU&amp;#34;224}可视化的结构为: 重点要关注的是 res2a 这个layer，把两个分支的结果直接加在了一起。 eltwise的layer是按照元素操作的，支持乘积，相加，或者取最大值，默认是相加。 可以参考caffe的proto文件</description></item><item><title>tensorRT 模型兼容性说明</title><link>https://111qqz.com/2020/03/tensorrt-model-compatibility-notes/</link><pubDate>Tue, 24 Mar 2020 12:26:01 +0800</pubDate><guid>https://111qqz.com/2020/03/tensorrt-model-compatibility-notes/</guid><description>
名词说明 CUDA. 一般来说指的是CUDA SDK. 目前经常使用的是CUDA 8.0和CUDA 10.1两个版本. 8.0和10.1都是SDK的版本号. CUDNN. The NVIDIA CUDA® Deep Neural Network library (cuDNN). 是一个可以为神经网络提供GPU加速的库 compute capability. 是GPU的固有参数,可以理解为GPU的版本.越新的显卡该数值往往越高. tensorRT.NVIDIA TensorRT™ is an SDK for high-performance deep learning inference. 是一个深度学习推理库,旨在提供高性能的推理速度. plan file,也称为 engine plan. 是生成的tensorRT 模型文件. 兼容性说明 Engine plan 的兼容性依赖于GPU的compute capability 和 TensorRT 版本, 不依赖于CUDA和CUDNN版本.
简单来说,在使用同样TensorRT版本的前提下,在具有相同compute capability 的GPU上的模型是可以通用的.
但是cuda版本是依赖于GPU的compute capability的. 也就是比较新的GPU(对应较高的compute capability)无法使用低版本的cuda.
CUDA SDK 8.0 support for compute capability 2.0 – 6.x CUDA SDK 9.0 – 9.</description></item><item><title>【施工完成】CSAPP archlab</title><link>https://111qqz.com/2020/02/csapp-archlab/</link><pubDate>Wed, 26 Feb 2020 22:54:33 +0800</pubDate><guid>https://111qqz.com/2020/02/csapp-archlab/</guid><description>
背景 CSAPP:3e第四章配套的实验。 第四章是讲处理器架构的，章节的重点是实现一个六阶段流水线。
lab的内容也是，需要实现一个Y86-64的流水线，并进行性能调优。
准备工作 材料里面sim.tar解压之后，有可能是没办法编译通过的。 原因是tk（a windowing toolkit ）在8.5版本的时候废弃了某个接口，与8.6版本不兼容。
因此需要安装tk 8.5或者更低的版本。 在archlinux/manjaro下可以通过aur安装tk85.
use tk&amp;lt;=8.5,8.6 or above will not compile Modify the corresponding header file in seq/ssim.c and pipe/psim.c (assmue tk8.5 header file is located in /usr/local/tk8.5) 1 2#ifdef HAS_GUI 3#include &amp;lt;tk8.5/tk.h&amp;gt; // #include &amp;lt;tk/tk.h&amp;gt;4#endif /* HAS_GUI */5 6 7 modify Makefile in sim 1 2 3 4# Comment this out if you don&amp;#39;t have Tcl/Tk on your system 5 6GUIMODE=-DHAS_GUI 7 8# Modify the following line so that gcc can find the libtcl.</description></item><item><title>2020 to do List</title><link>https://111qqz.com/2020/02/2020-to-do-list/</link><pubDate>Fri, 21 Feb 2020 20:12:51 +0800</pubDate><guid>https://111qqz.com/2020/02/2020-to-do-list/</guid><description>
就..终于再次出现了to do list. 原因是之前一直不知道如何置顶文章....
竟然一下子就2020年了...
学习模型量化 学习onnx CSAPP（随缘 ai system 课程</description></item><item><title>【施工完成】CSAPP attacklab</title><link>https://111qqz.com/2020/02/csapp-attacklab/</link><pubDate>Sat, 15 Feb 2020 23:24:23 +0800</pubDate><guid>https://111qqz.com/2020/02/csapp-attacklab/</guid><description>
背景 CSAPP 处理器那章快看完了，猛然发现竟然还有个attacklab.. 之前以为每一章只有一个lab
这个lab是教大家如何找到程序的漏洞并实施攻击。 知道如何实施攻击，才能更好地写出安全的代码。
包含5个phase
前三个没有什么保护措施,栈地址是固定的,可以注入可执行代码,比较容易. 后两个加了随机栈地址以及栈上地址不可执行的保护措施,需要用Return-oriented_programming 的方式搞定.
phase 1 第一个比较简单，利用buffer overflow 来将函数的返回地址，替换成一个已知函数的地址，达到执行特定函数的目的。
回忆一下函数调用的机器代码实现，需要先把函数的返回地址压栈，然后开辟栈空间，做些有的没的，做完之后析构开辟的栈空间，并把之前压入栈中的地址赋值给%ip(或者叫PC)，作为下一条指定的地址。函数的返回地址通常就是函数后面第一条指令的地址。
可以参考如下两张图。
我们观察getbuf的反汇编代码:
1 2(gdb) disas getbuf 3Dump of assembler code for function getbuf: 4 0x00000000004017a8 &amp;lt;+0&amp;gt;: sub $0x28,%rsp 5 0x00000000004017ac &amp;lt;+4&amp;gt;: mov %rsp,%rdi 6 0x00000000004017af &amp;lt;+7&amp;gt;: callq 0x401a40 &amp;lt;Gets&amp;gt; 7 0x00000000004017b4 &amp;lt;+12&amp;gt;: mov $0x1,%eax 8 0x00000000004017b9 &amp;lt;+17&amp;gt;: add $0x28,%rsp 9 0x00000000004017bd &amp;lt;+21&amp;gt;: retq 10End of assembler dump. 11 看到getbuf函数开辟了0x28大小的栈空间
也就是说输入至多0x28个字符，不会有问题。
那么为了达成我们的目的，我们可以前0x28个字符任意输入，后面输入我们希望执行的touch1函数的地址，也就是 0x00000000004017c0</description></item><item><title>【施工完成】CSAPP bomb lab</title><link>https://111qqz.com/2020/02/csapp-bomblab/</link><pubDate>Sat, 01 Feb 2020 19:36:23 +0800</pubDate><guid>https://111qqz.com/2020/02/csapp-bomblab/</guid><description>
背景 疫情肆虐,在家百无聊赖,于是开始拆炸弹. 炸弹分为6个阶段,每个阶段必须输入一个特定的字符串,否则炸弹就会爆炸. 提供给我们的是一个.c文件和一个linux可执行文件bomb
1 2/*************************************************************************** 3* Dr. Evil&amp;#39;s Insidious Bomb, Version 1.1 4* Copyright 2011, Dr. Evil Incorporated. All rights reserved. 5* 6* LICENSE: 7* 8* Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the 9* VICTIM) explicit permission to use this bomb (the BOMB). This is a 10* time limited license, which expires on the death of the VICTIM. 11* The PERPETRATOR takes no responsibility for damage, frustration, 12* insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other 13* harm to the VICTIM.</description></item><item><title>caffe 源码学习笔记(3) Net</title><link>https://111qqz.com/2020/01/caffe-source-code-analysis-part3/</link><pubDate>Sun, 12 Jan 2020 19:18:15 +0800</pubDate><guid>https://111qqz.com/2020/01/caffe-source-code-analysis-part3/</guid><description>
Net 基本介绍 网络通过组成和自微分共同定义一个函数及其梯度。
网络是一些Layer组成的DAG,也就是有向无环图，在caffe中通常由prototxt定义．
比如
1name: &amp;#34;LogReg&amp;#34;2layer {3 name: &amp;#34;mnist&amp;#34;4 type: &amp;#34;Data&amp;#34;5 top: &amp;#34;data&amp;#34;6 top: &amp;#34;label&amp;#34;7 data_param {8 source: &amp;#34;input_leveldb&amp;#34;9 batch_size: 6410 }11}12layer {13 name: &amp;#34;ip&amp;#34;14 type: &amp;#34;InnerProduct&amp;#34;15 bottom: &amp;#34;data&amp;#34;16 top: &amp;#34;ip&amp;#34;17 inner_product_param {18 num_output: 219 }20}21layer {22 name: &amp;#34;loss&amp;#34;23 type: &amp;#34;SoftmaxWithLoss&amp;#34;24 bottom: &amp;#34;ip&amp;#34;25 bottom: &amp;#34;label&amp;#34;26 top: &amp;#34;loss&amp;#34;27}定义了
值得强调的是，caffe中网络结构的定义与实现是无关的,这点比pytorch之类的深度学习框架不知高到哪里去了，也是caffe作为部署端的事实标准的重要原因．
Net 实现细节 我们先看下NetParameter的proto
12 message NetParameter {3 optional string name = 1; // consider giving the network a name 4 // DEPRECATED.</description></item><item><title>caffe 源码学习笔记(2) Layer</title><link>https://111qqz.com/2020/01/caffe-source-code-analysis-part2/</link><pubDate>Sat, 11 Jan 2020 17:47:05 +0800</pubDate><guid>https://111qqz.com/2020/01/caffe-source-code-analysis-part2/</guid><description>
layer 整体介绍 layer是模型计算的基本单元 类似于pytorch或者其他深度学习框架的op layer中的数据流向为,输入若干个blob，称之为&amp;quot;bottom blob&amp;quot;,然后经过layer的计算，输出若干个blob,称之为&amp;quot;top blob&amp;quot;
也就是数据是从“bottom”流向“top”
layer通常会进行两种计算，forward和backward
forward是指，根据bottom blob计算得到top blob backward是指，根据top blob的结果和参数值计算得到的gradient,回传给前面的layer.
layer 实现细节 layer作为一个base class,实现了所有layer都需要的common的部分。 比如:
1 /** 2* @brief Implements common layer setup functionality. 3* 4* @param bottom the preshaped input blobs 5* @param top 6* the allocated but unshaped output blobs, to be shaped by Reshape 7* 8* Checks that the number of bottom and top blobs is correct. 9* Calls LayerSetUp to do special layer setup for individual layer types, 10* followed by Reshape to set up sizes of top blobs and internal buffers.</description></item><item><title>caffe 源码学习笔记(1) Blob</title><link>https://111qqz.com/2020/01/caffe-source-code-analysis-part1/</link><pubDate>Fri, 10 Jan 2020 11:24:23 +0800</pubDate><guid>https://111qqz.com/2020/01/caffe-source-code-analysis-part1/</guid><description>
迫于生计，开始看caffe代码。 会侧重于分析inference部分。
blob 整体介绍 blob的含义及目的 blob在逻辑上表示的就是所谓的tensor,blob是tensor在caffe中的叫法。 在框架层面上，blob的意义在于对数据进行封装，提供统一的接口。 这里的数据包含训练/inference时用的数据，也包含模型参数，导数等数据。 深度学习离不开在GPU上的计算。 blob对数据的封装使得用户不必关心和cuda有关的数据传输细节。
blob的表示 对于图像数据，blob通常为４-dim，也就是N*C*H*W 其中N表示number,也就是batch_num C表示channel H表示height W表示width
在内存中，blob是按照&amp;quot;C-contiguous fashion&amp;quot;存储的，也就是&amp;quot;row-major &amp;quot;
因此，位于(n,c,h,w)的下标在OS中的位置是　((n * C + c) * H + h) * W + w.
在代码blob.hpp中，我们也可以看到名为offset的函数是其对应的实现。
1 inline int offset(const int n, const int c = 0, const int h = 0, 2 const int w = 0) const { 3 CHECK_GE(n, 0); 4 CHECK_LE(n, num()); 5 CHECK_GE(channels(), 0); 6 CHECK_LE(c, channels()); 7 CHECK_GE(height(), 0); 8 CHECK_LE(h, height()); 9 CHECK_GE(width(), 0); 10 CHECK_LE(w, width()); 11 return ((n * channels() + c) * height() + h) * width() + w; 12 } 13 // 给一个indices,计算这是第几个值。 14 inline int offset(const vector&amp;lt;int&amp;gt;&amp;amp; indices) const { 15 CHECK_LE(indices.</description></item><item><title>记一次faster-rcnn debug记录</title><link>https://111qqz.com/2019/12/debug-faster-rcnn-once-again/</link><pubDate>Fri, 13 Dec 2019 16:32:14 +0800</pubDate><guid>https://111qqz.com/2019/12/debug-faster-rcnn-once-again/</guid><description>
问题描述 一年debug 三次faster rcnn,每次都有新感觉（不
接到一个bug report,现象为某人脸模型，转换成trt模型，当batch size为1时结果完全正确，但是batch size大于1时结果不正确。 具体的现象是，如果跑多张不同的图，只有第一张图有结果，后面的图都没有结果。 如果跑的图中有相同的，那么和第一张相同的图都会有结果，其余的图没有结果。
1layer {2 name: &amp;#34;POD_proposal&amp;#34;3 type: &amp;#34;RPRoIFused&amp;#34;4 bottom: &amp;#34;Reshape_105&amp;#34;5 bottom: &amp;#34;Conv_100&amp;#34;6 bottom: &amp;#34;Add_95&amp;#34;7 bottom: &amp;#34;im_info&amp;#34;8 top: &amp;#34;rois&amp;#34;9 top: &amp;#34;tmp_pooling&amp;#34;10 rpn_proposal_param{11 feat_stride: 1612 anchor_ratios: 113 anchor_scales: 114 anchor_scales: 215 anchor_scales: 416 anchor_scales: 817 anchor_scales: 1618 anchor_scales: 3219 test_desc_param {20 rpn_pre_nms_top_n: 200021 rpn_post_nms_top_n: 5022 rpn_min_size: 1623 rpn_nms_thresh: 0.724 }25 }2627 roi_pooling_param{28 pooled_h: 729 pooled_w: 730 spatial_scale: 0.06253132 }33}3435特别地，proposal layer中 rpn_post_nms_top_n的参数值如果使用默认的300,那么结果都是对的。把这个值改小（只要小于300)，结果就像上面所述。
debug 经过 首先根据rpn_post_nms_top_n的值一修改，结果就是错的来看，怀疑是哪里参数写死了。 然而很快就排除了这个问题。因为faster rcnn的模型已经在另一个产品中经过长期验证了。 而且proposal layer是tensorrt自己实现的，有bug早就有人发现了。</description></item><item><title>FPN:Feature Pyramid Networks 学习笔记</title><link>https://111qqz.com/2019/12/feature-pyramid-networks/</link><pubDate>Sun, 08 Dec 2019 17:30:50 +0800</pubDate><guid>https://111qqz.com/2019/12/feature-pyramid-networks/</guid><description>
检测不同尺度的物体一直是计算机视觉领域中比较有挑战性的事情．我们先从之前的工作出发，并对比FPN比起之前的工作有哪些改进．
之前的工作 Featurized image pyramid 思路是对于同一张图，生成不同的scale，然后每个scale的image单独去做检测． 这个方法是手工设计feautre时代的常用办法． 这个办法是比较显然的，也的确可以解决检测不同尺度物体的问题． 缺点非常明显...inference的速度几乎和scale的个数线性相关． 以及由于显存的开销，没办法做end-to-end 的training.
Single feature map 再之后，手工设计的feature逐渐被由CNN生成的feature取代了． 这种办法更加鲁棒，对image的一些变化不敏感． 但是如果只有一个scale 的图片去过这个feature map,只有最终的feature map去做predict..准确率不太行．．因此还是要与Featurized image pyramid一起．只是优化了得到feature 的部分．
Pyramidal feature hierarchy 就..CNN本身就有显然的层次结构啊．．． 为什么不直接拿来用，而是提前scale image呢．．．
也就是选若干个feature map直接去做predict.. 这个办法美滋滋，既有多个feature map保证了一定的准确率，同时也没有增加很多inference的cost.
SSD应该是率先使用这种方法的． 但是这种办法仍然有不足之处，就是低层的高分辨率的feature map的semantics 太弱了．． 这就导致说对小物体的检测效果不太理想．．．
那么该怎么办呢．．．这时候就该介绍FPN啦
Feature Pyramid Networks 后面再更．
FPN 用于 faster rcnn FPN同时作用于RPN阶段和fast-rcnn detector
以下的代码实现出自　fpn.pytorch
FPN 作用于RPN 感觉直接上代码比较容易理解
先看　整个网络的forward函数
1 2 3 def forward(self, im_data, im_info, gt_boxes, num_boxes): 4 batch_size = im_data.</description></item><item><title>SSD: Single Shot MultiBox Detector　学习笔记</title><link>https://111qqz.com/2019/12/single-short-detector/</link><pubDate>Sun, 08 Dec 2019 15:00:15 +0800</pubDate><guid>https://111qqz.com/2019/12/single-short-detector/</guid><description>
概述 SSD是一种单阶段目标检测算法．所谓单阶段，是指只使用了一个deep neural network,而不是像faster-rcnn这种两阶段网络． 为什么有了faster-rcnn还要使用SSD? 最主要是慢... 两阶段网络虽然准确率高，但是在嵌入式等算力不足的设备上做inference速度非常感人，很难达到real time的要求． （实际业务上也是这样，公有云上的检测模型几乎都是faster-rcnn,而到了一些盒子之类的硬件设备，检测模型就全是SSD等single stage 模型了)
之前一直没有写SSD是因为相比faster rcnn的细节，SSD的问题似乎并不是很多．直到最近转模型的时候被FASF模型的一个细节卡了蛮久，因此决定还是记录一下．
基本概念 这部分描述SSD中涉及到的一些想法．
prior box prior box的概念其实与faster-rcnn中anchor的概念是一样的，没有本质区别． 与faster-rcnn中的anchor不同的是，SSD会在多个feature map中的每个cell 都生成若干个prior_box.
对于一个特定的feature map,尺寸为m*n,假设有k个prior box,c种类别． 那么feature map的每个location会生成 k*(c+4) 个结果，其中c代表每一类的confidence. ４代表相对prior_box中心点的offset. 整个feature_map会生成　 kmn(c+4) 个结果．
prior_box的参数选择,以及一些训练有关的细节可以参考原论文,这里不再赘述. 这里主要想强调一下和priox box有关的inference 细节. 主要是decode box的部分.
由于模型输出的bbox其实是相对每个prior_box的offset,不是真正的bbox,因此需要由网络输出的box_pred和prior box得到真正的bbox 坐标.这部分通常称为decode box,其实已经算是后处理部分了.
pytorch中decode box的代码如下:
1 variance1, variance2 = variance 2 cx = box_prior[:, :, 3 0] + box_pred[:, :, 0] * variance1 * box_prior[:, :, 2] 4 cy = box_prior[:, :, 5 1] + box_pred[:, :, 1] * variance1 * box_prior[:, :, 3] 6 w = box_prior[:, :, 2] + torch.</description></item><item><title>rankboost 算法学习笔记</title><link>https://111qqz.com/2019/11/rankboost-Algorithm/</link><pubDate>Tue, 26 Nov 2019 20:59:04 +0800</pubDate><guid>https://111qqz.com/2019/11/rankboost-Algorithm/</guid><description>
boosting 算法是什么． 机缘使然，接触到了 Boosting 算法．Boosting是一种通过组合弱学习器来产生强学习器的通用且有效的方法.
动机是基于如下观察:尽管委员会中每个成员只提供一些不成熟的判断,但整个委员会却产生较为准确的决策。通过组合多个弱学习器来解决学习问题。给定训练数据,弱学习算法(如决策树)可以训练产生弱学习器,这些弱学习器只需要比随机猜测的准确率好一些。用不同的训练数据训练可以得到不同的弱学习器。这些弱学习器作为委员会成员,共同决策。
ranking task是什么 此处的ranking task指的的pairwise ranking
排名(ranking)的学习问题出现在许多现代应用程序中，包括搜索引擎，信息提取平台和电影推荐系统的设计。 在这些应用程序中，返回文档或电影的顺序是系统的关键方面。 在二进制情况下，对分类进行排名的主要动机是资源的限制：对于非常大的数据集，显示或处理由分类器标记为相关的所有项目可能是不切实际的，甚至是不可能的。 搜索引擎的标准用户不愿意查询响应查询而返回的所有文档，而只查询前十名左右。 同样，信用卡公司欺诈检测部门的成员不能调查被分类为潜在欺诈的数千笔交易，而只能调查几十个最可疑的交易。
所以到底什么才是一个ranking task呢?
ranking task是一种有监督学习，通过label 信息，来对所有的数据点做出排名的预测．这里的label是一种关系信息，与数据点对一一对应的．设label函数为f,一般来说，假设有数据点x1,x2,那么有
1f(x1,x2) = 1 if x1 ranks higher than x2 2f(x1,x2) = -1 if x1 ranks lower than x2 3f(x1,x2) = 0 if there is no enough info to compare x1 and x2 需要注意的是，通常来说label并没有传递性．也就是说，从f(x1,x2) = 1和　f(x2,x3) =1 并不能推断出f(x1,x3) = 1.原因是在比较x1,x2,x3时，可能使用了不同的feature(通俗的解释就是，我喜欢A胜过B是因为A比B有钱，我喜欢B胜过C是因为B比C可爱，但是我可能因为其他原因喜欢C胜过A)
rankboost 算法 字面理解，rankboost算法就是将boosting算法用于pairwise ranking task. 该过程的伪代码为: 要注意的是算法的输入为
1S=((x1,x1&amp;#39;,y1),...(xm,xm&amp;#39;,ym)) 其中　(x1,x1')为一个pair,y1为与这个pair对应的label.</description></item><item><title>Kubernetes(k8s)在深度学习模型转换方面的探索</title><link>https://111qqz.com/2019/11/K8s-for-Model-Conversion/</link><pubDate>Fri, 22 Nov 2019 11:14:19 +0800</pubDate><guid>https://111qqz.com/2019/11/K8s-for-Model-Conversion/</guid><description>
年中的时候接了离职的同事模型转换的锅，在不断地更新迭代的过程中，发现了一些痛点。 发现k8s能够解决一部分痛点，因此来分享一下在这方面的探索。
什么是模型转换 简单来说，深度学习模型的流程分为training和inference两部分。训练时用的一般是pytorch等框架，这些框架训练出的model是没办法直接部署在各个硬件平台上做inference的。因此需要将使用训练框架得到的模型，转换为能够部署到各个硬件平台上的模型。这个过程就是模型转换。
模型转换的一般流程为，先将pytorch等训练框架训练得到的模型转换为caffe model（是的，caffe才是业界中间表示的事实标准，而不是号称支持所有框架中间表示的onnx)，再将caffe model 转换到各种硬件上（包括但不限于nvidia系列显卡，华为的海思系列设备等）
（事实上这个转换流程是有硬伤存在的，这个硬伤在于pytorch的模型权重和模型结构是分离的。调研过业界一些其他模型转换的解决方案，包括百度的X2Paddle,其做法是不把pytorch模型作为模型转换的起点，而是从caffe model/onnx model 开始转换。还调研过微软的MMdnn,里面似乎也没有提到这个问题。不知道pytorch 1.0版本新增的torchscript是不是一条出路...)
模型转换的痛点 最初模型转换的痛点是依赖比较多，从pytorch,onnx,caffe再到tensorrt,cuda等．　尤其编译caffe,又是出了名的坑多．　解决办法是用了docker,将所有环境封装好．这样其他人可以直接拉镜像下来进行模型转换．
然而，在用了docker之后，还是有其他痛点，主要是以下三个:
权限申请的繁琐．
caffe模型转换到不同硬件上（主要是nvidia显卡），需要在对应的机器上进行转换．通常是客户确定使用某型号的显卡，然后我们采购对应显卡的机器．接下来需要一系列权限申请，包括服务器的权限，docker命令的权限，以及docker镜像仓库的权限．　除此之外，用户还需要将模型文件从其他位置放置到新服务器上，这件事也非常麻烦．
docker 镜像的版本控制.
docker的image虽然可以打tag，但是这个tag几乎对版本控制没有帮助．由于模型转换工具更新频繁（包括但是不限于，添加新的op/layer,caffe对新显卡的编译支持，caffe2tensorrt工具的更新），这么弱的版本管理就是灾难．如果我们对于每次升级docker image,都使用一个新的tag来标记的话，docker似乎没有一个机制来通知这个新的tag的存在．用户还是可以在这个旧的镜像上用到天荒地老．如果复用之前的tag的话,同样，用户还是可以不更新．
对docker commit 的滥用．
本来docker image的大小只有7G+,但是由于用户非常钟爱docker cp命令以及docker commit 命令．曾经有用户把整个数据集都docker cp进去之后docker commit ..　然后现在镜像大小已经有35G了．．
上述几个痛点，恰好k8s可以比较好的解决．
k8s用于模型转换. 官方的说法是,k8s是一个生产级别的容器编排系统，用于容器化应用的自动部署、扩缩和管理
然而似乎我对k8s的使用是非常非主流的(其实对docker的使用也很非主流...)
不过我觉得没有规定一项技术只能用来做什么,只要解决的问题多于引入的问题,就可以尝试.
k8s的引入使得用户不再能直接接触到docker image. 这直接解决了第一和第三两个痛点. 以及可以使用 imagePullPolicy 来进行强制更新,也基本解决了版本控制的问题. 这样就不用天天push 其他用户&amp;quot; 你先docker pull一下&amp;quot;...
此外,k8s的label机制也很有用. 我们可以通过给node打上不同显卡型号的label.然后维护一个显卡的列表.这样用户不再需要知道哪台服务器上有哪个显卡,只需要添写显卡型号,k8s就可以分配一台对应的机器供用户进行模型转换.
不过实际上k8s用户模型转换也有一些缺点:
k8s对显卡的调度是对于pod(pod就是一组container)独占的.也就是说,在一台服务器上,通过k8s只能开启与显卡个数一样多的pod.目前来看不会有什么大的影响,不过这对于对性能要求不敏感的应用,确实算个缺点.
pod名称的全局唯一性.由于开启任务需要显式提供一个名称,如果多个用户使用了相同的名称的话,结果显然不是我们期望的. 目前的解决方案是制定一个命名规范,要求用户遵守.但是这种规范并没有任何检查的机制,因此只能算一个tricky的办法,算不上真正的解决方案.</description></item><item><title>faster rcnn 模型 tensorrt4与tensorrt5 结果不一致 踩坑记录</title><link>https://111qqz.com/2019/11/debug-Frcnn-Model-When-Upgrading-From-Tensorrt4-to-Tensorrt5/</link><pubDate>Thu, 07 Nov 2019 23:40:39 +0800</pubDate><guid>https://111qqz.com/2019/11/debug-Frcnn-Model-When-Upgrading-From-Tensorrt4-to-Tensorrt5/</guid><description>
最近有同事report给我们,用同一个模型转换工具,转同一个faster rcnn 模型, 同样的sdk代码,在有些显卡上结果正常,但是再比较新的显卡上(比如Titan V)上 结果完全不正确.
听说之后我的内心其实是 **喵喵喵喵喵?**的
先在模型转换工具中infer了一下,发现...结果竟然真的不一样!
于是又开始了debug faster rcnn 的旅程(奇怪..我为什么要说又)
一份典型的faster rcnn 的
prototxt
按照经验,我们先对照了ROIS,来判断RPN 是否存在问题
惊讶地发现,竟然是没有问题的...
那看一下模型的输出 cls_score 和 bbox_pred好了 发现cls_score 完全对不上,bbox_pred 倒是没问题... 这和之前遇到的情况不太一样啊... 从proposal layer 到 最后... 全都是些很常见的layer... 哪里会有问题呢...
最终发现有问题的layer 是softmax!
cls_score 的维度应该为 N*K*C*H*W
softmax应该按照C这一维度来做,因此softmax_param中axis应该为2.
查阅&amp;quot;tensorrt support matrix&amp;quot; ，发现 tensorrt5中，softmax会按照用户指定的维度进行。
而对于tensorrt4.0, softmax layer 与设定的softmax_param无关，只会在channel 的维度上来做softmax.
所以，比较好的解决办法是，干脆不写softmax_param这个参数 对于trt4，会直接按照channel 维度来做 对于trt5，会在第N-3的axis上进行。对于SSD的 N*C*H*W或者 faster rcnn 的N*K*C*H*W, N-3都是channel所在的维度。
问题解决！</description></item><item><title>yuv 图像格式初探</title><link>https://111qqz.com/2019/07/Yuv-Image-Format/</link><pubDate>Wed, 03 Jul 2019 20:31:11 +0800</pubDate><guid>https://111qqz.com/2019/07/Yuv-Image-Format/</guid><description>
概述 YUV是一种图像编码方式,或者称为色彩空间,与RGB是同级的概念. YUV是三个分量,Y,U和V,其中:
Y 表示明亮度(Luminance或Luma),也就是灰度值, U,V表示色度,浓度（Chrominance、Chroma）,可以简单理解成用来表示某个像素的颜色的量. YUV格式的特点是,在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。 也就是说,YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。
其中YCbCr是YUV压缩和偏移的版本。YCbCr的Y与YUV中的Y含义一致，Cb和Cr与UV同样都指色彩，Cb指蓝色色度，Cr指红色色度，在应用上很广泛，JPEG、MPEG、DVD、摄影机、数字电视等皆采此一格式。因此一般俗称的YUV大多是指YCbCr。
YUV采样方式 主流的采样方式有三种: 其中Y 分量用叉表示，UV 分量用圆圈表示。
YUV4:4:4 YUV4:2:2 YUV4:2:0 下面三张图分别为YUV444,YUV422和YUV420的采样方式. 但是注意,上面的三张图只是说明了每个分量的比例,并不能说明排列方式.
需要注意的是yuv420并不是说只采样U分量或者只采样V分量,而是指，在每一行扫描时，只扫描一种色度分量（U 或者 V），和 Y 分量按照 2 : 1 的方式采样。比如，第一行扫描时，YU 按照 2 : 1 的方式采样，那么第二行扫描时，YV 分量按照 2:1 的方式采样
YUV封装格式 采样方式主要是告诉我们各个分量的比例,下面看一下封装格式. YUV格式有两大类：planar和packed。
planar: 先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 packed: 每个像素点的Y,U,V是连续交错存储的。 其中,planar格式还分为SEMI PLANAR和PLANAR
semi planar:先连续存储所有的Y, 然后UV交错存储. planar:先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 以YUV420为例,前面的图为平面的封装格式,也就是YUV420P(Planar) 后面的图为半平面的封装格式,也就是YUV420SP(semi planar) 或者以1920*1080的图片具体举例:
左边的图为平面的封装格式,也就是YUV420P(Planar) 右边的图为半平面的封装格式,也就是YUV420SP(semi planar) YUV格式的名称,傻傻分不清楚 由于最近使用的YUV420格式的,因此主要会涉及这一种. YUV420分为YUV420P和YUV420SP两种. 其中YUV420P又有两种,一种是Y(w×h) + U(w×h/4) + V(w×h/4)的格式,这一种也叫I420或者420P或者IYUV(存疑,参考opencv convert_color函数文档) 另一种是Y(w×h) + V(w×h/4) + U(w×h/4)的格式,这一种也叫YV12</description></item><item><title>Anchor Box Algorithm</title><link>https://111qqz.com/2019/07/Anchor-Box-Algorithm/</link><pubDate>Mon, 01 Jul 2019 19:53:24 +0800</pubDate><guid>https://111qqz.com/2019/07/Anchor-Box-Algorithm/</guid><description>
动机 将一张图分成多个grid cell进行检测之后,每个cell只能检测到一个object. 如果这个grid cell中不止有一个物体要怎么办呢? 因此提出了anchor box algorithm来解决这个问题.
什么是anchor anchor其实就是一组预设的参考框,每个框有不同的长宽比和大小. 提供参考框可以将问题转换为&amp;quot;这个固定参考框中有没有认识的目标，目标框偏离参考框多远&amp;quot;. 这样如果一个grid cell中有多个物体,那么就可以形状最姐姐的anchor box来负责检测该物体. anchor的其他用途 实际上当grid cell很多的时候,一个grid cell中有多个object的情况是很少的.但是anchor box仍然是十分重要的.因为我们可以通过预设一些特殊的anchor box,来帮助检测到一些极端形状的物体(比如很长的物体或者很宽的物体)
输出结果 有了anchor之后,每个grid cell的输出可能不再唯一. 于是从之前的每个grid cell对应一个输出结果,变成了每个二元组(grid_cell,anchor box)对应一个结果. 结果的格式呢,一图胜千言: 局限性 由于anchor box是要预设的,那么如果我只预设了两个anchor box,但是一个grid cell中有三个object,怎么办呢? 很遗憾,是没有办法的. 另外一个case是,如果两个object都与其中一个anchor的形状最为接近,也是没有办法检测出两个物体的.
anchor box的生成 最初anchor box是通过人手工设定的,之后的YOLO的paper中提出了使用k-means的算法来生成anchor box.</description></item><item><title>目标检测领域的滑动窗口算法</title><link>https://111qqz.com/2019/06/sliding-windows/</link><pubDate>Sun, 30 Jun 2019 16:55:40 +0800</pubDate><guid>https://111qqz.com/2019/06/sliding-windows/</guid><description>
对象检测（Object Detection）的目的是”识别对象并给出其在图中的确切位置”，其内容可解构为三部分：
识别某个对象（Classification）； 给出对象在图中的位置（Localization）； 识别图中所有的目标及其位置（Detection）。 本文将介绍滑动窗口这一方法.
滑动窗口 滑动窗口是这些方法中最暴力的一个.简单来说,就是暴力枚举侯选框的尺寸和位置,每次crop得到一张小图,将每个小图送进后面的分类器进行分类. 早年后面通常会接一个计算量比较小的分类器,比如SVM,随着算力的提升,现在常常后面会接CNN. 值得一提的是,原始的滑动窗口方法是将每个小图,分别放入后面的分类器.但是实际上,小图和小图之间,是有overlap的,也就是说做了很多重复的计算. 因此一个显然的改进是使用CNN来实现滑动窗口算法, 这种方法的优点是比较无脑,实现和理解起来都很简单.缺点是计算量还是比较大.
参考链接 Sliding Windows for Object Detection with Python and OpenCV
深度学习基础 - 对象检测（滑窗、CNN、YOLO）</description></item><item><title>写在毕业一年之后</title><link>https://111qqz.com/2019/06/one-yeaf-after-graduation/</link><pubDate>Sat, 29 Jun 2019 01:04:09 +0800</pubDate><guid>https://111qqz.com/2019/06/one-yeaf-after-graduation/</guid><description>
转眼毕业一整年了，是时候做一个复盘了。 依稀记得刚入职的时候leader提醒我要有职业规划时的场景。总体来说，这一年虽然没有完全走在最正确的路线上，但是大方向应该没有太偏。
工作之中 其实前半年做的事情非常杂，c++,java,爬虫，前端... 技术的广度和深度，我个人觉得是深度更重要的。 但是在规模不够大的公司，很多时候不得已去现学一些个人技术栈以外的东西。好在后半年以及之后的工作都会比较focus.
总体来说，这一年里主要是如下技能得到了一些提升：
c++/cuda 图像编解码 CV算法 还点了一些奇奇怪怪的技能点，我觉得算不上什么竞争力，就不写了。
工作之外 这一年里，工作之外，主要做了两个方面的事情。 第一个方面补了一下计算机专业课，主要是操作系统和计算机网络。具体来说，看完了&amp;quot;自顶向下方法&amp;quot;，还有&amp;quot;OS:Three easy pieces&amp;quot;,MIT 的6.828做了一部分。 补这部分的内容是因为它们很重要,而我在学校的时候又没怎么听过课。没听课是因为当时沉迷ACM，而且觉得学院课程的质量和深度都不够理想。
第二个方面是学了更多的CV相关的知识。最开始的想法是，身边的同事好多是CS名校的Phd,又在CV领域有着丰富的经验，如果在商汤的职业生涯中，没能在这方面取得比较大的收货，其实是有点亏的。但是后来发现，这其实对我的工作也很有帮助。所以可能并不是一个任务来了之后，才发现去要学习什么，而是技术栈变宽了之后，才有机会做以前没机会做的任务吧。
一些其他感悟 毕业之前觉得，代码能力是很重要的能力。现在觉得，某个领域的知识和经验才是核心，代码能力只是锦上添花。
对我而言，职业初期，最不重要的其实是薪水。最重要的是个人成长，其次是职业声誉的积累，最后才是薪水吧。当然个人成长其实是一个很难衡量的东西，我觉得并不是学会了之前不会的东西就是成长，只有掌握了与主线有关的内容才是成长。 至于主线是什么呢，目前希望能在系统优化和CV算法两个方面获得一些收获。
结语 工作一年，整体体验还是非常好的。 感觉比起在学校的日子要开心得多，因为在学校还要应付奇奇怪怪，没什么用的考试，而在公司，可以比较纯粹得学习技术，并用新学到的东西解决一个又一个问题，非常有成就感。 工作上虽然说不上顺风顺水，但是也没遇到过什么大的困难。 虽然要学习好多新的内容，但是ICPC的经历是会给人很多信心的（虽然我很菜），那就是只要时间充足，没有什么学不会的东西。当然，能学会的东西未必值得去学，不过迫于生计嘛，有的时候也是没办法的事情。
新的周期，加油！</description></item><item><title>迁移博客到hugo</title><link>https://111qqz.com/2019/05/hello-hugo/</link><pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate><guid>https://111qqz.com/2019/05/hello-hugo/</guid><description>
发现工作之后更新博客的频率低了很多，以及迫于不想在自己维护服务器了，因此决定把博客迁移到hugo上。
由于原本的博客内容实在是太多了，因此目前只做了大致的迁移，基本可以保证每篇文章都是可以访问的。
原博客 在2023年之前应该仍然可以访问，不过会逐步停止维护。</description></item><item><title>BattleBlock Theater linux下无法启动的解决办法　（　void* MemoryBlock::Alloc(unsigned int): Assertion failed ）</title><link>https://111qqz.com/2019/05/battleblock-theater-linux-start-failed/</link><pubDate>Wed, 01 May 2019 12:09:18 +0000</pubDate><guid>https://111qqz.com/2019/05/battleblock-theater-linux-start-failed/</guid><description>
在steam上买了　BattleBlock Theater，　官方说支持linux，但是却无法启动。
在steam里启动看不到log,于是找到游戏的安装目录。
/home/coder/.steam/steam/steamapps/common/BattleBlock Theater
在终端下启动，报错:
BattleBlockTheater: /media/BGBS/BBT_Linux/Core/MemorySystem.cpp:161: void* MemoryBlock::Alloc(unsigned int): Assertion `(!&amp;quot;Got request for zero bytes!&amp;quot;)' failed. ^C[1] 22303 abort (core dumped) ./BattleBlockTheater
google了一下发现这似乎是游戏本身的bug,这里有一个workaround
办法是使用hex editor将游戏的可执行文件中， 从offset 0x24F2BE 开始的6个字节替换成0x90
我使用的hex editor 是hexcurse,　这里有一个使用指南　可以参考。</description></item><item><title>【施工中】MIT 6.828 lab 3: User Environments</title><link>https://111qqz.com/2019/03/mit-6-828-lab-3-user-environments/</link><pubDate>Sun, 03 Mar 2019 12:45:25 +0000</pubDate><guid>https://111qqz.com/2019/03/mit-6-828-lab-3-user-environments/</guid><description>
JOS的environments基本可以理解成&amp;quot;process&amp;quot;进程的同义词，但是由于&amp;quot;process&amp;quot;是一个unix术语，因此使用environment这个词．
Part A: User Environments and Exception Handling 查看　kern/env.c文件，看到三个全局变量:
1 struct Env *envs = NULL; // All environments 2 struct Env *curenv = NULL; // The current env 3 static struct Env *env_free_list; // Free environment list envs会在JOS启动后会指向一个Env structures的数组，表示JOS中的全部environments. 理论上，JOS kernel最多能支持NENV个同时运行的environments.　但是实际上不会远不会达到这个数量．
env_free_list是一个链表结构，用来存放当前没有在运行的Env structure.. 和page_free_list　类似．
curenv表示的是当前正在运行的environment,当JOS刚刚启动，第一个environment运行之前，curenv的值为NULL.
接下来我们来阅读一下inc/env.h文件
1 2 /* See COPYRIGHT for copyright information. */ 3 4 #ifndef JOS_INC_ENV_H 5 #define JOS_INC_ENV_H 6 7 #include &amp;lt;inc/types.h&amp;gt;8 #include &amp;lt;inc/trap.</description></item><item><title>【施工完成】CSAPP data lab</title><link>https://111qqz.com/2019/02/csapp-data-lab/</link><pubDate>Thu, 28 Feb 2019 14:06:42 +0000</pubDate><guid>https://111qqz.com/2019/02/csapp-data-lab/</guid><description>
CSAPP第二章的内容以前组成原理基本都学过...所以就简单翻了翻。
对应的lab是用位运算实现各种有的没的...
题目基本都很tricky...
除了用到一些常规的位运算性质，还用到了一些奇怪的条件:
* ~0x7FFFFFFF = 0x7FFFFFFF + 1 * 0xFFFFFFFF +1 = 0x00000000 * 0 == ~0+1
唯一让我觉得比较有趣的是how many bits这道题
题目要求是给一个32-bit signed int,问最少用多少位能得到它的补码表示。
考虑正数，显然，高位的连续的多个0是不必要的，只需要一个符号位的0即可。
那么对于负数，**高位的连续的多个1也是不必要的。 **原因是，-2^k + 2^(k-1) = -2^(k-1),也就是说，去掉两个连续的1中高位的那个，数值没有改变。
我们可以将正数和负数统一来看，都是找到最高位的0和1的交界。
这可以通过和相邻的位置求异或，找到最高位的1的方式来实现。
接下来就是如何找一个数的最高位的1的位置了。
方法是构造一个单调的函数f,假设最高位位置为a,那么f((a,32))=0,f([0,a])=1.
然后在函数f上二分。
全部问题的代码如下,思路写在注释里了。还有3个涉及浮点数的问题之后补。
/* * bitXor - x^y using only ~ and &amp;amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp;amp; * Max ops: 14 * Rating: 1 */ /* 0 0 -&amp;gt; 0 0 1 -&amp;gt; 1 1 0 - &amp;gt; 1 1 1 - &amp;gt; 0 */ // ~(~a &amp;amp; ~b)&amp;amp;~(a&amp;amp;b) int bitXor(int x, int y) { int ans = ~(~x &amp;amp; ~y)&amp;amp;(~(x&amp;amp;y)); // printf(&amp;quot;%d\n&amp;quot;,ans); return ans; } /* * tmin - return minimum two's complement integer * Legal ops: !</description></item><item><title>manjaro /archlinux 下 steam 文明5/6(civilization V/VI)的运行方法</title><link>https://111qqz.com/2019/02/manjaro-archlinux-civilization/</link><pubDate>Sat, 23 Feb 2019 14:28:01 +0000</pubDate><guid>https://111qqz.com/2019/02/manjaro-archlinux-civilization/</guid><description>
系统版本为Manjaro 18.0.3 Illyria
运行文明5比较容易，只需要设置启动选项为:
LD_PRELOAD=/usr/lib32/libopenal.so.1 %command%
文明6运行会报错 undefined symbol: FT_Done_MM_Var
解决办法是 在终端中用如下办法运行steam:
LD_PRELOAD=/usr/lib/libfreetype.so steam
参考链接</description></item><item><title>【施工中】 halide学习笔记</title><link>https://111qqz.com/2019/02/halide-notes/</link><pubDate>Mon, 18 Feb 2019 06:00:51 +0000</pubDate><guid>https://111qqz.com/2019/02/halide-notes/</guid><description>
**Halide is a programming language designed to make it easier to write high-performance image and array processing code on modern machines. ** halide有两个特性比较吸引人。一个是对于各种平台架构的支持。
* CPU architectures: X86, ARM, MIPS, Hexagon, PowerPC * Operating systems: Linux, Windows, macOS, Android, iOS, Qualcomm QuRT * GPU Compute APIs: CUDA, OpenCL, OpenGL, OpenGL Compute Shaders, Apple Metal, Microsoft Direct X 12 另一个是把计算什么和怎么计算(何时计算)分离开来。
Halide的Schedule可以由程序员来指定一些策略，指定硬件的buffer大小，缓冲线的相关设置，这样可以根据不同的计算硬件的特性来实现高效率的计算单元的调度，而图像算法的计算实现却不需要修改。</description></item><item><title>【施工完毕】MIT 6.828 lab 2: Memory Management</title><link>https://111qqz.com/2019/02/mit-6-828-lab-2/</link><pubDate>Thu, 14 Feb 2019 14:01:46 +0000</pubDate><guid>https://111qqz.com/2019/02/mit-6-828-lab-2/</guid><description>
2019年2月24:完成了除了&amp;quot;Challenge&amp;quot;以外的全部练习和问题. 总共花费15个小时. 2019年2月26:完成&amp;quot;Challenge 2&amp;quot;(应该是最简单的一个orz，只花了不到一个小时) Part 1: Physical Page Management 操作系统必须时刻追踪哪些物理内存在使用，哪些物理内存没有在使用。
一个问题是，
Ex 1. In the file kern/pmap.c, you must implement code for the following functions (probably in the order given). boot_alloc() mem_init() (only up to the call to check_page_free_list(1)) page_init() page_alloc() page_free()
check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.</description></item><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。
stdarg.h 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考x86-calling-conventions 简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **
在实现上，需要了解的是：
* va_list，一个类型，可以看做是变长参数列表； * [va_start](http://en.cppreference.com/w/cpp/utility/variadic/va_start)，用来初始化变长参数列表的宏，声明为void va_start( va_list ap, parm_n ); ap为va_list变量，parm_n为变长参数前一个变量（C语言要求至少有一个named variable作为函数的parameter) * [va_arg](http://en.cppreference.com/w/cpp/utility/variadic/va_arg),用来得到下一个参数的宏，声明为T va_arg( va_list ap, T ); **返回的类型取决于传入的类型T。特别注意:&amp;quot;If `va_arg` is called when there are no more arguments in `ap`, the behavior is undefined.&amp;quot;** * [va_end](http://en.cppreference.com/w/cpp/utility/variadic/va_end) ,用来将va_list释放的宏。 下面看一个例子就明白怎么用了orz
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* print all args one at a time until a negative argument is seen; all args are assumed to be of int type */ void printargs(int arg1, .</description></item><item><title>x86 calling conventions</title><link>https://111qqz.com/2019/01/x86-calling-conventions/</link><pubDate>Thu, 31 Jan 2019 12:12:22 +0000</pubDate><guid>https://111qqz.com/2019/01/x86-calling-conventions/</guid><description>
x86的调用约定主要说的是这几件事:
* The order in which atomic (scalar) parameters, or individual parts of a complex parameter, are allocated * How parameters are passed (pushed on the stack, placed in registers, or a mix of both) * Which registers the called function must preserve for the caller (also known as: callee-saved registers or non-volatile registers) * How the task of preparing the stack for, and restoring after, a function call is divided between the caller and the callee 调用约定实际上并不唯一</description></item><item><title>【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping</title><link>https://111qqz.com/2019/01/mit-6-828-lab-1/</link><pubDate>Thu, 24 Jan 2019 12:27:58 +0000</pubDate><guid>https://111qqz.com/2019/01/mit-6-828-lab-1/</guid><description>
花费了30+小时，终于搞定了orz Part 1: PC Bootstrap The PC's Physical Address Space 8086/8088时代 +------------------+ &amp;lt;- 0x00100000 (1MB) | BIOS ROM | +------------------+ &amp;lt;- 0x000F0000 (960KB) | 16-bit devices, | | expansion ROMs | +------------------+ &amp;lt;- 0x000C0000 (768KB) | VGA Display | +------------------+ &amp;lt;- 0x000A0000 (640KB) | | | Low Memory | | | +------------------+ &amp;lt;- 0x00000000 由于8086/8088只有20跟地址线，因此物理内存空间就是2^20=1MB.地址空间从0x00000到0xFFFFF.其中从0x00000开始的640k空间被称为&amp;quot;low memory&amp;quot;，是PC真正能使用的RAM。从 0xA0000 到 0xFFFFF　的384k的non-volatile memory被硬件保留，用作video display buffers和BIOS等。
80286/80386时代及以后 为了保持向后兼容，因此0-1MB的空间还是和原来保持一致。因此地址空间似乎存在一个“洞”（为什么我觉得其实是两个“洞”。。。不是空着的才叫“洞”吗），PC能使用的RAM被这个“洞”（也就是0xA0000 到 0xFFFFF)分成了0x00000000到0x000BFFFF的640k和 0x00100000到0xFFFFFFFF两部分。
+------------------+ &amp;lt;- 0xFFFFFFFF (4GB) | 32-bit | | memory mapped | | devices | | | /\/\/\/\/\/\/\/\/\/\ /\/\/\/\/\/\/\/\/\/\ | | | Unused | | | +------------------+ &amp;lt;- depends on amount of RAM | | | | | Extended Memory | | | | | +------------------+ &amp;lt;- 0x00100000 (1MB) | BIOS ROM | +------------------+ &amp;lt;- 0x000F0000 (960KB) | 16-bit devices, | | expansion ROMs | +------------------+ &amp;lt;- 0x000C0000 (768KB) | VGA Display | +------------------+ &amp;lt;- 0x000A0000 (640KB) | | | Low Memory | | | +------------------+ &amp;lt;- 0x00000000 此外，在地址空间的最上面一部分，通常被BIOS保留用于 32-bit PCI devices的memory mapped.</description></item><item><title>优化学习笔记(1):Loop unrolling</title><link>https://111qqz.com/2019/01/loop-unrolling/</link><pubDate>Wed, 23 Jan 2019 11:51:46 +0000</pubDate><guid>https://111qqz.com/2019/01/loop-unrolling/</guid><description>
迫于生计，最近要学习halide
先去学习/复习一下常见的编译优化技巧。
loop unrolling，也就是循环展开，顾名思义，就是把循环展开来写。
normal loop: int x; for (x = 0; x &amp;lt; 100; x++) { delete(x); } after loop unrolling: int x; for (x = 0; x &amp;lt; 100; x += 5 ) { delete(x); delete(x + 1); delete(x + 2); delete(x + 3); delete(x + 4); } 循环展开是一种优化，可以手动实现也可以编译器自动实现。
为什么要将循环展开？ * 循环每次都需要判断终止条件，展开后可以消除这部分开销。 * 减少[分支预测](https://en.wikipedia.org/wiki/Branch_predictor)开销。循环里的分支是指“跳出循环”还是“进行下一次迭代” * [vectorization](https://en.wikipedia.org/wiki/Automatic_vectorization) for (int y = 0; y &amp;lt; 4; y++) { for (int x_outer = 0; x_outer &amp;lt; 2; x_outer++) { // The loop over x_inner has gone away, and has been // replaced by a vectorized version of the // expression.</description></item><item><title>【施工中】MIT 6.828 Operating System Engineering 学习笔记</title><link>https://111qqz.com/2019/01/mit-6-828-overview/</link><pubDate>Tue, 15 Jan 2019 16:39:18 +0000</pubDate><guid>https://111qqz.com/2019/01/mit-6-828-overview/</guid><description>
课程主页
这课稍微有点硬核...感觉基础稍微有些不扎实就做不下去orz.
网上似乎是有博客写了6.828的学习笔记，不过我更希望自己能够独立完成，二手的知识，谁知道是对的错的呢...况且课程本身给的参考资料应该还是足够多的。
环境的话，手头没有ubuntu系统，恰好半年前剁了阿里云的轻应用服务器，就在上面做吧。
为了这门课，我读了/计划读以下书籍（随时更新）。大概也是为了检查一遍自己的知识体系。
* [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/) 已读完，大概需要120小时 * [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf) 6.828给的汇编参考书籍 每个lab用到的网页形式的参考资料，会在每个lab的博客中分别给出。
最后，放一段《游褒禅山记》中的文字，与君共勉！
夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？</description></item><item><title>codeforces round 530 div2</title><link>https://111qqz.com/2019/01/codeforces-round-530-div2/</link><pubDate>Sun, 06 Jan 2019 06:43:12 +0000</pubDate><guid>https://111qqz.com/2019/01/codeforces-round-530-div2/</guid><description>
A,B,C:都很简单，不说了。
D:一棵树，给出树的结构，以及从树根到某个深度为偶数的节点的路径和，问能否构造一种所有节点点权和最小的树，输出最小点权和。
思路：
容易知道，如果想要点权和最小，那么尽可能让靠近树根的点承担更多的点权。
具体做法是，bfs，对于每个节点u，取其儿子中最小的S值求节点u的信息。
比赛的时候wa16...最后发现是答案要用long long存...因为单个路径和是&amp;lt;=1E9的。。多个加起来会超过int... 长时间不打连这种常见的坑都不敏感了啊。。。
#include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; vector&amp;lt;int&amp;gt;edge[N]; int s[N]; int d[N]; bool vis[N]; int a[N]; // void dfs(int u,int dep) // { // int siz = edge[u].</description></item><item><title>codeforces hello 2019</title><link>https://111qqz.com/2019/01/codeforces-hello-2019/</link><pubDate>Sat, 05 Jan 2019 06:29:49 +0000</pubDate><guid>https://111qqz.com/2019/01/codeforces-hello-2019/</guid><description>
好久没玩cf了，竟然还能涨分（虽然我用的小号Orz)
三题，D应该是数学+DP...数学实在是忘干净了。。。
前面三题大体还好，都是1A,不过因为没有提前配置环境。。耽误了一些时间。。。
A:给出一个扑克牌x，和另一个包含5个扑克牌的集合。问扑克牌x是否和扑克牌集合中至少一张扑克牌的花色或者数字相同。
不多说了。
B:一块钟表（只有一个指针），初始指向12点，需要拨动指针恰好n次(n&amp;lt;=15)，每次可能顺时针，也可能逆时针，拨动的角度范围在[1,180],问是否有一种方案，使得拨动n次后，指针回到12点。
思路：观察下数据范围,n最大才15，最多也不过2^15的情况...既然如此，不如暴力。
枚举的话我记得有三种方法来着。。。但是已经不记得怎么写了。。所以用了最朴素的办法。。。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int inf = 0x3f3f3f3f; #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; int n; int a[30]; vector&amp;lt;int&amp;gt;bin; void cal( int x) { bin.clear(); while (x&amp;gt;0) { bin.push_back(x%2); x/=2; } while (bin.size()&amp;lt;n) { bin.push_back(0); } } int main() { cin&amp;gt;&amp;gt;n; for ( int i = 1 ; i &amp;lt;= n ; i++) cin&amp;gt;&amp;gt;a[i]; if (n==1) { puts(&amp;quot;NO&amp;quot;); return 0; } int total = 1 &amp;lt;&amp;lt; n; for ( int i = 0 ; i &amp;lt; total ; i++) { cal(i); int ang = 0; // for ( auto x : bin) cout&amp;lt;&amp;lt;x; // cout&amp;lt;&amp;lt;&amp;quot;bin size:&amp;quot;&amp;lt;&amp;lt;bin.</description></item><item><title>2019 to do list</title><link>https://111qqz.com/2019/01/2019-to-do-list/</link><pubDate>Tue, 01 Jan 2019 13:13:04 +0000</pubDate><guid>https://111qqz.com/2019/01/2019-to-do-list/</guid><description>
* &amp;lt;del&amp;gt;Operating Systems: Three Easy Pieces&amp;lt;/del&amp;gt; * fluent python * &amp;lt;del&amp;gt;《计算机网络:自顶向下方法》&amp;lt;/del&amp;gt; * 《mysql必知必会》 * PC Assembly Language ( for mit 6.828 )</description></item><item><title>我在公司的服务器上执行了sudo rm -rf /*</title><link>https://111qqz.com/2018/11/when-I-execute-sudo-rm-rf-on-the-company-server/</link><pubDate>Sat, 24 Nov 2018 08:31:19 +0000</pubDate><guid>https://111qqz.com/2018/11/when-I-execute-sudo-rm-rf-on-the-company-server/</guid><description>
TL;DR
* 依靠人的小心谨慎是不靠谱的，人总有失误的时候 * 看了下docker volume的权限机制，貌似是从docker image中继承。 * 写了两个脚本，用来把rm alias到mv，避免手滑 又是一个可以摸鱼的周五晚上，sensespider系统测试了一天，fix了几个Bug,似乎可以发布了。系统一直是部署在了docker中..这几天测试产生了不少结果文件在host的volume中... 看着不舒服，干脆删一下好了
嗯？怎么所有者是root。。。那我sudo一下，也没什么大不了的嘛
然而手滑了... 打了个 sudo rm -rf /* ...
提示无法删除/boot device is busy...
吓了一跳，下意识Ctrl-C...
从新在本地ssh到服务器，发现已经登不上去了...报错在找不到sh
看了一下，果然服务器的/bin 目录已经被删干净了...
google了一些从rm中恢复文件的帖子...
试图用 sudo apt-get install 装一些工具包...
这个时候已经提示我找不到apt-get 了。。。
非常慌。花了3分钟思考了我到目前为止的一生
看了下scp命令还在，赶紧趁着这个终端回话还没关，把本地的/bin目录拷贝了上来。
试了下，ssh命令可以用了。 这样至少后续的修复（在不麻烦IT同事的情况下)不用跑机房了。有些镇定。
然后发现apt-get 命令还是用不了。。。思考了1分钟。。。
然后发现服务器用的是centos.......
再试了各种常用命令，试了docker相关的各种命令，都可以正常工作。
然而整个人都被吓傻了....睡了一觉才回过神。
又查了下docker volume权限的事情，发现挂载目录继承docker image中用户的权限是feature Volumes files have root owner when running docker with non-root user. 那似乎就没办法了。
以及写了两个脚本，来避免手滑，分别是zsh环境和bash环境下的。
kkrm</description></item><item><title>docker network 与 本地 network 网段冲突</title><link>https://111qqz.com/2018/11/docker-network-conflict-with-local-subnetwork/</link><pubDate>Tue, 20 Nov 2018 08:33:20 +0000</pubDate><guid>https://111qqz.com/2018/11/docker-network-conflict-with-local-subnetwork/</guid><description>
起因: 公司部署在hk的爬虫服务器突然挂掉了。后来发现只是在深圳办公区无法访问。排查后发现原因是docker的网络(包括docker network的subnet或者是某个容器的ip)与该host在内网的ip段相同，导致冲突。
排查过程： 有两个方面需要排查。一个是docker服务启动时的默认网络。
默认网络使用bridge桥接模式，是容器与宿主机进行通讯的默认办法。
修改默认网段可以参考 http://blog.51cto.com/wsxxsl/2060761
除此之外，还需要注意docker创建的network的网段。
使用docker network ls 命令查看当前的网络
然后可以使用docker inspect 查看每个network的详细信息。
也可以直接使用ip addr 来查看各种奇怪的虚拟网卡的ip,是否有前两位的地址和host的ip地址相同的。
解决办法: 本想在docker-compose up 时指定默认网络的subnet
结果发现好像并不支持？version 1.10.0 error on gateway spec
Was there any discussion on that? I do need to customize the network, because my company uses the 172.16.0.0/16 address range at some segments and Docker will simply clash with that by default, so every single Docker server in the whole company needs a forced network setting.</description></item><item><title>记一次在 docker compose 中使用volume的踩坑记录</title><link>https://111qqz.com/2018/11/docker-compose-default-volume-name-makes-me-confused/</link><pubDate>Wed, 14 Nov 2018 08:06:57 +0000</pubDate><guid>https://111qqz.com/2018/11/docker-compose-default-volume-name-makes-me-confused/</guid><description>
现象: 使用docker compose 挂载 named volume 无效（且没有错误提示)
排查过程: 一开始是没有使用docker-compose命令，直接使用docker run -v 命令，挂载两个绝对路径，没有问题。
然后使用named volume，在这里使用了local-persist 插件，来指定数据卷(volume)在host上的位置。直接用docker run -v 命令，依然没有问题。
接下里打算放到docker compose里面，发现并没有挂载成功。
但是在docker compose里面，挂载两个绝对路径是ok的。
于是怀疑是volume的问题
此时使用docker inspect 查看 用docker compose 启动起来的，挂载named volume的容器
发现mount里面，挂载的named volume并不是我在docker-compose.yml填写的名称，而是多了一个前缀，这个前缀恰好是docker-compose.yml 文件所在的目录名称。
查了一下，发现果然不止我一个人被坑到orz Docker-compose prepends directory name to named volumes
其实应该直接使用docker inspect来排查的...应该会更快找到问题
解决办法： 有几种解决办法：
* 不手动创建volume，而是在docker-compose.yml中，设置volume的mountpoint * 在docker-compose.yml中，添加external: true的选项到 volume中，参考[external](https://docs.docker.com/compose/compose-file/#external) 顺便附上我的docker-compose.yml文件
version: '3' services: django: image: &amp;quot;registry.sensetime.com/spider/sensespider:v1.0&amp;quot; volumes: - spiderdata:/data privileged: true ports: - &amp;quot;8000:8000&amp;quot; working_dir: /home/renkuanze/workspace/sensespider entrypoint: bash run.</description></item><item><title>How to use Scrapy with Django Application（转自medium）</title><link>https://111qqz.com/2018/11/how-to-use-scrapy-with-django-application/</link><pubDate>Tue, 06 Nov 2018 13:33:00 +0000</pubDate><guid>https://111qqz.com/2018/11/how-to-use-scrapy-with-django-application/</guid><description>
在meidum上看到一篇很赞的文章...无奈关键部分一律无法加载出来...挂了梯子也不行，很心塞...刚刚突然发现加载出来了...以防之后再次无法访问，所以搬运过来．
There are couple of articles on how to integrate Scrapy into a Django Application (or vice versa?). But most of them don’t cover a full complete example that includes triggering spiders from Django views. Since this is a web application, that must be our main goal.
What do we need ? Before we start, it is better to specify what we want and how we want it. Check this diagram:</description></item><item><title>lua学习笔记</title><link>https://111qqz.com/2018/10/lua-notes/</link><pubDate>Fri, 26 Oct 2018 02:47:59 +0000</pubDate><guid>https://111qqz.com/2018/10/lua-notes/</guid><description>
lua是一门轻量级的脚本语言...好像比较适合写游戏？在 太阳神三国杀 中见过很多lua脚本。 由于splash 的渲染脚本需要用lua来写，因此来学习一波。
直接上语法...看到了python和pascal的影子orz
-- Two dashes start a one-line comment. --[[ Adding two ['s and ]'s makes it a multi-line comment. --]] ---------------------------------------------------- -- 1. Variables and flow control. ---------------------------------------------------- num = 42 -- All numbers are doubles. -- Don't freak out, 64-bit doubles have 52 bits for -- storing exact int values; machine precision is -- not a problem for ints that need &amp;lt; 52 bits. s = 'walternate' -- Immutable strings like Python.</description></item><item><title>golang 学习笔记</title><link>https://111qqz.com/2018/10/golang-notes/</link><pubDate>Sat, 20 Oct 2018 11:06:56 +0000</pubDate><guid>https://111qqz.com/2018/10/golang-notes/</guid><description>
先放资料,可能比较侧重于go在系统调用方面的内容.
这里不会记录详细的go的语法,只会记录学习的过程,踩到的坑,以及其他我认为值得记录的内容.
go的switch语句终于是人类思维的语句了...匹配中了不需要加break..
defer关键字可以延迟语句到上层函数退出时再执行,而且是会把延迟的语句压入栈,然后按照FILO的顺序执行...好像有点有意思?
参数列表..如果有多个变量的类型相同,只写一个类型关键字就行...
:=并不是pascal中的赋值符号(浪费感情...,而是简洁定义变量的语法,不能使用在函数以外.
感觉go中同时有一点C++和很多python的影子...
30分钟上手GO语言--基础语法
A Go Programmer’s Guide to Syscalls
视频笔记：Go 和 syscall - Liz Rice</description></item><item><title>爬虫学习笔记</title><link>https://111qqz.com/2018/10/web-crawler-notes/</link><pubDate>Fri, 19 Oct 2018 08:18:53 +0000</pubDate><guid>https://111qqz.com/2018/10/web-crawler-notes/</guid><description>
再次迫于生计。。。
参考了面向新人的 Python 爬虫学习资料
大致的学习路线为:
一： 简单的定向脚本爬虫（ request --- bs4 --- re ） 二： 大型框架式爬虫（ Scrapy 框架为主）
三：浏览器模拟爬虫 （ Mechanize 模拟 和 Selenium 模拟）
有Python基础和一点html基础的话。。。貌似上手是0难度的
年轻人的第一个爬虫(虽然代码是直接copy的...
''' 抓取百度贴吧---生活大爆炸吧的基本内容 爬虫线路： requests - bs4 Python版本： 3.6 OS： mac os 12.12.4 ''' import requests import time from bs4 import BeautifulSoup # 首先我们写好抓取网页的函数 def get_html(url): try: r = requests.get(url, timeout=30) r.raise_for_status() # 这里我们知道百度贴吧的编码是utf-8，所以手动设置的。爬去其他的页面时建议使用： # r.endcodding = r.apparent_endconding r.encoding = 'utf-8' return r.text except: return &amp;quot; ERROR &amp;quot; def get_content(url): ''' 分析贴吧的网页文件，整理信息，保存在列表变量中 ''' # 初始化一个列表来保存所有的帖子信息： comments = [] # 首先，我们把需要爬取信息的网页下载到本地 html = get_html(url) # 我们来做一锅汤 soup = BeautifulSoup(html, 'lxml') # 按照之前的分析，我们找到所有具有‘ j_thread_list clearfix’属性的li标签。返回一个列表类型。 liTags = soup.</description></item><item><title>java-grpc 踩坑记录</title><link>https://111qqz.com/2018/10/java-grpc-notes/</link><pubDate>Wed, 17 Oct 2018 03:29:03 +0000</pubDate><guid>https://111qqz.com/2018/10/java-grpc-notes/</guid><description>
最近的项目需要java和python之间的进程通信，想到了之前使用过的的grpc.
参考官方quickstart
* JDK: version 7 or higher 看起来只依赖jdk,美滋滋
然后按照文档执行
./gradlew installDist
报错:
Task :grpc-compiler:compileJava_pluginExecutableJava_pluginCpp FAILED FAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':grpc-compiler:compileJava_pluginExecutableJava_pluginCpp'. &amp;gt; No tool chain is available to build for platform 'x86_64': - Tool chain 'visualCpp' (Visual Studio): Visual Studio is not available on this operating system. - Tool chain 'gcc' (GNU GCC): Could not determine GCC metadata: could not find vendor in output of /usr/local/gcc-4.</description></item><item><title>2018 to do list</title><link>https://111qqz.com/2018/10/2018-to-do-list/</link><pubDate>Sun, 14 Oct 2018 15:30:52 +0000</pubDate><guid>https://111qqz.com/2018/10/2018-to-do-list/</guid><description>
迫于最近的事情有点多，还是记录一下。 果然to do list什么的，还是要按照年份记录啊。
* &amp;lt;del&amp;gt;了解linux strace命令&amp;lt;/del&amp;gt; * 速成go语言，并了解go于系统调用https://hackernoon.com/strace-in-60-lines-of-go-b4b76e3ecd64 * 熟悉hustoj V2版本目前的代码 * &amp;lt;del&amp;gt;看完&amp;lt;code in practice&amp;gt;&amp;lt;/del&amp;gt; * mit 6.828 lab1。。。感觉要咕 * 看完&amp;lt;unix 系统系统手册&amp;gt;的20，21章信号部分, 为hustoj的重构补充基础知识.</description></item><item><title>spring 学习笔记</title><link>https://111qqz.com/2018/10/spring-notes/</link><pubDate>Wed, 10 Oct 2018 09:56:46 +0000</pubDate><guid>https://111qqz.com/2018/10/spring-notes/</guid><description>
迫于生计，又要从零开始学习spring.
在这篇文章之前，对java的基础是2015年写过一个java大作业，对spring是一无所知。
为了学习spring，我按顺序做了以下事情:
* 学习了一下java语法，教程关键词是&amp;quot;java tutorial for cpp programmers&amp;quot;,比如[Learning a New Programming Language: Java for C++ Programmers ](http://pages.cs.wisc.edu/~hasti/cs368/JavaTutorial/) * 对spring有个大体的了解。视频教程要比官方文档或者博客迅速得多。推荐java brains的 [spring boot quick start](https://javabrains.io/courses/spring_bootquickstart/) ,一天时间就基本可以了解个大概。 * 简单看了下java brains的另一门课程 [spring_core](https://javabrains.io/courses/spring_core/)，主要是为了了解spring中一些常见概念，比如bean,依赖注入，以及常用注解。 * 然后了解了下spring与数据库的连接，这里有一个比官网更详细的教程[Spring Boot, MySQL, JPA, Hibernate Restful CRUD API Tutorial](https://www.callicoder.com/spring-boot-rest-api-tutorial-with-mysql-jpa-hibernate/) ，代码整理在[github](https://github.com/111qqz/Spring-Boot-mysql-sample) ,这个时候感受到了代码直接操作数据库（而不用写sql语句)的美妙。</description></item><item><title>spring 依赖注入</title><link>https://111qqz.com/2018/10/spring-dependency-injection/</link><pubDate>Tue, 09 Oct 2018 07:45:17 +0000</pubDate><guid>https://111qqz.com/2018/10/spring-dependency-injection/</guid><description>
真是个不明觉厉的术语...其实是个特别简单的概念orz
用白话讲，如果一个class A中用到了class B的实例，那么class B的实例就是class A的依赖，如果不是在class A中定义class B的实例，而是通过某个接口，将class B的实例传入classA,就叫依赖注入。
public class Example { // private DatabaseThingie myDatabase; // public Example() { // myDatabase = new DatabaseThingie(); // } public Example(DatabaseThingie useThisDatabaseInstead) { myDatabase = useThisDatabaseInstead; } public void DoStuff() { ... myDatabase.GetData(); ... } } 依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。
简单来说，a依赖b，但a不控制b的创建和销毁，仅使用b，那么b的控制权交给a之外处理，这叫控制反转（IOC），而a要依赖b，必然要使用b的instance，那么
1. 通过a的接口，把b传入； 2. 通过a的构造，把b传入； 3. 通过设置a的属性，把b传入； 这个过程叫依赖注入（DI）。
那么什么是IOC Container？
随着DI的频繁使用，要实现IOC，会有很多重复代码，甚至随着技术的发展，有更多新的实现方法和方案，那么有人就把这些实现IOC的代码打包成组件或框架，来避免人们重复造轮子。
所以实现IOC的组件或者框架，我们可以叫它IOC Container。</description></item><item><title>codeforces 501 B. Obtaining the String</title><link>https://111qqz.com/2018/10/codeforces-501-b-obtaining-the-string/</link><pubDate>Wed, 03 Oct 2018 10:15:31 +0000</pubDate><guid>https://111qqz.com/2018/10/codeforces-501-b-obtaining-the-string/</guid><description>
题目链接:http://codeforces.com/contest/1015/problem/B
题意: 给出字符串s和字符串t，问一个将s变为t的策略。 可以做的变换为，交换s中相邻的字符串，该操作最多不能超过4000次，字符串长度最大为50.
思路:
首先可以确定，当两个字符串的组成相同时（也就是有同样的字符组成，只是位置可能有所不同)一定有解。
考虑最坏情况，每个字符都要交换到最远的地方，总的操作数&amp;lt;50*50&amp;lt;4000,因此一定有解。
判断组成是否相同可以用multiset
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年10月03日 星期三 16时11分29秒 File Name :b.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; string s,t; multiset&amp;lt;char&amp;gt;A,B; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;.</description></item><item><title>codeforces edu #51 C. Vasya and Multisets (思维题)</title><link>https://111qqz.com/2018/10/codeforces-edu-51-c/</link><pubDate>Tue, 02 Oct 2018 10:49:29 +0000</pubDate><guid>https://111qqz.com/2018/10/codeforces-edu-51-c/</guid><description>
题目链接
题意:有n个数，现在要分成2个集合，使得2个集合中，仅出现1次的数的个数相同，问是否有解，以及具体的分法。
思路:
一开始考虑出现多个的数的思路麻烦了，比如对于出现2次的某个数x，与其一个集合中分得一个，使得两个结合中，仅出现1次的数的个数各+1，还不如都放在同一个集合中，使得仅出现1次的数的个数不增加。
因此思路是这样的:
先考虑出现1次的数的个数，如果为偶数，那么均分，然后把其他出现多次的数全都放在第一个集合；
如果出现1次的数的个数为奇数，我们还是尽可能均分，然后不妨假设第一个集合中的只出现1次的数的个数比第二个集合中多1个。
我们现在需要让第二个集合中，仅出现一次的数增加一个。
什么样的数可以满足这个条件呢？ 出现2次的数是不行的，因为这会使得两个集合中的数字各自+1
因此需要至少有一个出现3次或者以上的数。
具体见代码:
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年10月02日 星期二 15时28分39秒 File Name :c.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int cnt[N]; int a[N]; string ans=&amp;quot;&amp;quot;; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;.</description></item><item><title>解决ubuntu 14.04 下 壁纸软件 variety 崩溃 ValueError: bad marshal data (unknown type code) 的问题</title><link>https://111qqz.com/2018/09/the-way-to-fix-variety-crash-on-ubuntu-14-04/</link><pubDate>Sun, 30 Sep 2018 08:59:31 +0000</pubDate><guid>https://111qqz.com/2018/09/the-way-to-fix-variety-crash-on-ubuntu-14-04/</guid><description>
系统为ubuntu 14.04
迫于特别想定时换壁纸，查了下解决方案。
发现只要删除掉/usr目录下所有的'.pyc'文件就可以
命令为:sudo find /usr -name '*.pyc' -delete</description></item><item><title>[c++11] std::async std::packaged_task std::promise and std::future notes</title><link>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</link><pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</guid><description>
把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::future对象.简单来说,当某个线程需要等待一个特定的一次性事件(one-off event),它可以用一个&amp;quot;future&amp;quot;来表示这个事件.
std::async 有的时候可能你需要做一个花费事件比较长的计算,但是计算结果不是立刻需要.这个时候就可以用一个新的线程来做这个计算.这里比较关键的问题是如何将在新线程进行计算的结果传回到当前线程,因为std::thread并没有提供一个类似的机制.
这个时候就需要std::async登场了.
#include &amp;lt;future&amp;gt; #include &amp;lt;iostream&amp;gt; int find_the_answer_to_ltuae(); void do_other_stuff(); int main() { std::future&amp;lt;int&amp;gt; the_answer=std::async(find_the_answer_to_ltuae); do_other_stuff(); std::cout&amp;lt;&amp;lt;&amp;quot;The answer is &amp;quot;&amp;lt;&amp;lt;the_answer.get()&amp;lt;&amp;lt;std::endl; } 当然也可以与向std::thread包装的thread function中传参数一样,向std::async中传参数,如下:
#include &amp;lt;string&amp;gt; #include &amp;lt;future&amp;gt; struct X { void foo(int,std::string const&amp;amp;); std::string bar(std::string const&amp;amp;); }; X x; auto f1=std::async(&amp;amp;X::foo,&amp;amp;x,42,&amp;quot;hello&amp;quot;); // 调用p-&amp;gt;foo(42, &amp;quot;hello&amp;quot;)，p是指向x的指针 auto f2=std::async(&amp;amp;X::bar,x,&amp;quot;goodbye&amp;quot;); // 调用tmpx.bar(&amp;quot;goodbye&amp;quot;)， tmpx是x的拷贝副本 struct Y { double operator()(double); }; Y y; auto f3=std::async(Y(),3.141); // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到 auto f4=std::async(std::ref(y),2.718); // 调用y(2.718) X baz(X&amp;amp;); std::async(baz,std::ref(x)); // 调用baz(x) class move_only { public: move_only(); move_only(move_only&amp;amp;&amp;amp;) move_only(move_only const&amp;amp;) = delete; move_only&amp;amp; operator=(move_only&amp;amp;&amp;amp;); move_only&amp;amp; operator=(move_only const&amp;amp;) = delete; void operator()(); }; auto f5=std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到 此外,std:;async还有一个可选参数,值为std::launch::deferred或std::launch:async或std::launch::deferred|std::launch:async,第三种为默认参数.</description></item><item><title>[C++11]std::condition_variable notes</title><link>https://111qqz.com/2018/09/condition_variable-notes/</link><pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate><guid>https://111qqz.com/2018/09/condition_variable-notes/</guid><description>
condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_variable，也就是条件变量，是线程间通信的一种方式。
线程之间在很多时候需要通信，比如经典的生产者消费者问题
一个比较naive的方案是，用mutex来保护一个flag,然后另一线程不停得check这个flag的状态是否改变。以及在这个方案上的改进:让另一个线程check之后，可以先睡一段时间。
但是这两种方法都不够好。第一种不好的原因当然是不停得check，肯定会耗费大量的资源。而第二种，由于没办法准确估计要休眠的时间，因此不够实际。
这个时候我们可以考虑使用条件变量。
条件变量是可以用在如下场景: 一个或者多个线程在等某个条件的成立，而这个条件由另外的线程所控制。当该条件成立时，控制该条件的线程会主动通知这些线程，将这些线程唤醒。
如下是一个最简单的例子:
std::mutex mut; std::queue&amp;lt;data_chunk&amp;gt; data_queue; // 1 std::condition_variable data_cond; void data_preparation_thread() { while(more_data_to_prepare()) { data_chunk const data=prepare_data(); std::lock_guard&amp;lt;std::mutex&amp;gt; lk(mut); data_queue.push(data); // 2 data_cond.notify_one(); // 3 } } void data_processing_thread() { while(true) { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(mut); // 4 data_cond.wait( lk,[]{return !data_queue.empty();}); // 5 data_chunk data=data_queue.front(); data_queue.pop(); lk.unlock(); // 6 process(data); if(is_last_chunk(data)) break; } } 接下来是一个较为复杂的例子，一个线程安全的队列的实现,
#include &amp;lt;queue&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;lt;mutex&amp;gt; #include &amp;lt;condition_variable&amp;gt; template&amp;lt;typename T&amp;gt; class threadsafe_queue { private: mutable std::mutex mut; // 1 互斥量必须是可变的 std::queue&amp;lt;T&amp;gt; data_queue; std::condition_variable data_cond; public: threadsafe_queue() {} threadsafe_queue(threadsafe_queue const&amp;amp; other) { std::lock_guard&amp;lt;std::mutex&amp;gt; lk(other.</description></item><item><title>std::call_once &amp;&amp; std::once_flag notes</title><link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link><pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate><guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid><description>
多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。
资源初始化一般遵循&amp;quot;lazy initialization&amp;quot;的原则，也就是在用到该资源最近的地方再初始化。
比较容易想到的办法是用std::mutex，将资源初始化的地方锁起来，如下:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::mutex resource_mutex; void foo() { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(resource_mutex); if(!resource_ptr) { resource_ptr.reset(new some_resource); } lk.unlock(); resource_ptr-&amp;gt;do_something(); } 这确实是一个办法。但是初始化时如果需要耗费比较多的时间，当有比较多的线程时，一个线程初始化时，其他线程会耗时间在不必要的等待上。
在c++11以后，我们可以使用std::once_flag和std::call_once来解决资源初始化时加锁的问题。比起显示调用std::mutex的好处是，资源消耗更少。
下面是两个例子:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::once_flag resource_flag; b void init_resource() { resource_ptr.reset(new some_resource); } void foo() { std::call_once(resource_flag,init_resource); resource_ptr-&amp;gt;do_something(); } class X { private: connection_info connection_details; connection_handle connection; std::once_flag connection_init_flag; void open_connection() { connection=connection_manager.open(connection_details); } public:62 C HAPTER 3 Sharing data between threads X(connection_info const&amp;amp; connection_details_): connection_details(connection_details_) {} void send_data(data_packet const&amp;amp; data) { std::call_once(connection_init_flag,&amp;amp;X::open_connection,this); connection.</description></item><item><title>react 中setState的更新策略</title><link>https://111qqz.com/2018/09/react-setstate-Update-strategy/</link><pubDate>Tue, 18 Sep 2018 13:31:06 +0000</pubDate><guid>https://111qqz.com/2018/09/react-setstate-Update-strategy/</guid><description>
起因是想更新一个array类型的state,结果setState更新之后用console.log() debug 结果，发现结果特别玄学。。。
查了下发现this.setState是个异步操作。。。
参考资料:
深入理解React 组件状态（State）
React中setState同步更新策略
https://react.docschina.org/docs/react-component.html</description></item><item><title>learn java in 21 minutes for C++ Programmers</title><link>https://111qqz.com/2018/09/learn-java-in-21-minutes-for-c-programmers/</link><pubDate>Mon, 10 Sep 2018 11:53:31 +0000</pubDate><guid>https://111qqz.com/2018/09/learn-java-in-21-minutes-for-c-programmers/</guid><description>
先放资料:
Learning a New Programming Language: Java for C++ Programmers
java package 先说几条重要的人话:
* 一个java文件第一行可以声明该文件所属于的package，package的名字必须与整个工作目录的路径名相同。 * 同一个package下的class默认有互相访问的权限。 * 访问属性设置为public的class，如果该class所在的file声明了package，那么可以被其他package下的class访问到。 * .java的文件名必须与文件中设置为public的class名保持一致（如果没有public的类，那么名称任意) * Every class is part of some _package_. * All classes in a file are part of the same package. * You can specify the package using a _package declaration_: * package
name ; as the first (non-comment) line in the file. * Multiple files can specify the same package name.</description></item><item><title>[c++11 ]std::move 右值引用 转移语义 完美转发 notes</title><link>https://111qqz.com/2018/09/c11-stdmove-notes/</link><pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid><description>
起因是在看&amp;lt;CplusplusConcurrencyInAction_PracticalMultithreading&amp;gt;，里面讲到转移一个std::thread的ownership提到了std::move.
之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要用引用的时候却进行了拷贝，得到不符合期望的结果。现在的情况是，有些object或许是不支持拷贝构造的。比如std::unique_str,std::ifstream，这个时候如果我们需要传参数进去，就可以使用std::move来实现。比如下面这个例子:
void process_big_object(std::unique_ptr&amp;lt;big_object&amp;gt;); std::unique_ptr&amp;lt;big_object&amp;gt; p(new big_object); p-&amp;gt;prepare_data(42); std::thread t(process_big_object,std::move(p)); 当然这只是使用std::move的一种情形，即传递不允许拷贝构造的object作为参数。
另外，std::move可以更有效率地传递资源。内容之后补orz
实际上std::move()的作用是传进去一个object,返回这个object的右值引用（rvalue reference）
首先区分左值和右值，这其实是一个c语言中就有的概念（作为区分，右值引用是C++11中新引入的概念）
一般来说，右值是不能被取地址的值。在C++11之前，右值是不能被引用的。
语法上为了区分C++11之前的引用（也就是左值引用&amp;amp;）,右值引用的符号为&amp;amp;&amp;amp;
void process_value(int&amp;amp; i) { std::cout &amp;lt;&amp;lt; &amp;quot;LValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } void process_value(int&amp;amp;&amp;amp; i) { std::cout &amp;lt;&amp;lt; &amp;quot;RValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } int main() { int a = 0; process_value(a); process_value(1); } LValue processed: 0 RValue processed: 1 那么为什么要引入“右值引用”这个概念？ 主要有两个目的：完美转发(Perfect Forwarding)和转移语义(Move Sementics)</description></item><item><title>[C++11 ] std::ref&amp;&amp;std::reference_wrapper notes</title><link>https://111qqz.com/2018/09/reference_wrapper-notes/</link><pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate><guid>https://111qqz.com/2018/09/reference_wrapper-notes/</guid><description>
起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化std::thread的时候，如果thread funtion的参数列表中有引用，需要传入std::ref才可以得到符合预期的结果。
查阅发现std::ref是用来生成std::reference_wrapper。 按照 cppreference 上的话来说
`std::reference_wrapper` 是包装引用于可复制、可赋值对象的类模板。它常用作将容器存储入无法正常保有引用的标准容器（类似 [std::vector](https://zh.cppreference.com/w/cpp/container/vector) ）的机制。 用人话来说，就是有的时候一些地方（比如STL容器中传值，又比如std::bind）会默认使用复制，这可能与我们想使用引用的期望不符。
具体见下面的几个例子：
#include &amp;lt;functional&amp;gt; #include &amp;lt;iostream&amp;gt; void f(int&amp;amp; n1, int&amp;amp; n2, const int&amp;amp; n3) { std::cout &amp;lt;&amp;lt; &amp;quot;In function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; ++n1; // increments the copy of n1 stored in the function object ++n2; // increments the main()'s n2 // ++n3; // compile error } int main() { int n1 = 1, n2 = 2, n3 = 3; std::function&amp;lt;void()&amp;gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &amp;lt;&amp;lt; &amp;quot;Before function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; bound_f(); std::cout &amp;lt;&amp;lt; &amp;quot;After function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; } Before function: 10 11 12 In function: 1 11 12 After function: 10 12 12 我们发现直接传进去的参数n1的值没有改变，而使用std::ref传进去的值的结果符合预期。</description></item><item><title>前端To do list</title><link>https://111qqz.com/2018/09/front-end-to-do-list/</link><pubDate>Thu, 06 Sep 2018 09:56:57 +0000</pubDate><guid>https://111qqz.com/2018/09/front-end-to-do-list/</guid><description>
20181014update: 可以不写了，开心
迫于生计，要从零开始学习前端。
由于之前的to do list 年代久远+ 前端的技术栈可之前几乎没有关系，因此新开一篇记录。
* css盒子模型 * 布局,flex * 前端debug的方法 * &amp;lt;del&amp;gt;javascript,&amp;lt;/del&amp;gt;有空可以使用js刷leetcode练习语法 * &amp;lt;del&amp;gt;typescript&amp;lt;/del&amp;gt; * jsx，以及jsx的typescript版tsx * 学习axios https://alligator.io/react/axios-react/ * 学习dva: https://github.com/sorrycc/blog/issues/62 * 学习umijs https://umijs.org/zh/guide/with-dva.html#</description></item><item><title>typescript学习笔记</title><link>https://111qqz.com/2018/09/typescript-notes/</link><pubDate>Wed, 05 Sep 2018 08:02:42 +0000</pubDate><guid>https://111qqz.com/2018/09/typescript-notes/</guid><description>
先放参考资料:
TypeScript 入门教程
React &amp;amp; Webpack
react-typescript-cheatsheet (强推一波，讲了很多react+ts的实践）
typescript是javascript的语法扩展。。。好处是提供了类型。。可以在编译（结果为js文件)的时候提供静态的类型检查。。。
typescript的问号语法:标记某个参数为可选。
例子:
export class Thread { id: string; lastMessage: Message; name: string; avatarSrc: string; constructor(id?: string, name?: string, avatarSrc?: string) { this.id = id || uuid(); this.name = name; this.avatarSrc = avatarSrc; } } 关于typescript的类型推断。。如果在定义时直接赋值则会进行推断，否则会推断类型为any.
let myFavoriteNumber = 'seven'; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. //上面的写法会编译错误，原因是定义时已经推断类型为string //但是下面的写法没有问题 let myFavoriteNumber; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; let myFavoriteNumber: string | number; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; 这里的 let myFavoriteNumber: string | number 的含义是， 允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</description></item><item><title>[设计模式] 观察者( Observer )模式学习笔记</title><link>https://111qqz.com/2018/09/observer-pattern-notes/</link><pubDate>Sat, 01 Sep 2018 09:27:40 +0000</pubDate><guid>https://111qqz.com/2018/09/observer-pattern-notes/</guid><description>
最近在学习node.js，里面讲到node.js的事件机制使用了观察者模式，因此来学习一下。
观察者模式的目的是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
因此观察者模式又叫发布-订阅模式。
下面放一个简化之后的例子:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Secretary; // 看股票的同事类（观察对象，观察者） class StockObserver { public: StockObserver(string strName, Secretary* strSub) { name = strName; sub = strSub; } void Update(); private: string name; Secretary* sub;我所理解的设计模式（C++实现）——观察者模式（Observer Pattern） }; // 秘书类（主题对象，通知者） class Secretary { public: string action; void Add(StockObserver ob) { observers.push_back(ob); } void Remove(int addIndex) { if(addIndex &amp;gt;=0 &amp;amp;&amp;amp; addIndex &amp;lt; observers.size()) observers.erase(observers.begin() + addIndex); } void Notify() { vector&amp;lt;StockObserver&amp;gt;::iterator it; for (it=observers.</description></item><item><title>Redux 学习笔记</title><link>https://111qqz.com/2018/08/redux-notes/</link><pubDate>Thu, 30 Aug 2018 12:05:35 +0000</pubDate><guid>https://111qqz.com/2018/08/redux-notes/</guid><description>
Redux是Flux架构的一种实现。
至于Flux架构是什么，可以参考Flux 架构入门教程
粗略得讲，和MVC架构是同一类东西，最大的区别是单向数据流，禁止了Model和VIEW层之间数据的流动。</description></item><item><title>JavaScript 学习笔记</title><link>https://111qqz.com/2018/08/javascript-notes/</link><pubDate>Thu, 30 Aug 2018 03:42:19 +0000</pubDate><guid>https://111qqz.com/2018/08/javascript-notes/</guid><description>
暂时没空从头开始搞...用到哪里先记录一下好了orz
我觉得不行，还是要先大致了解一下。
参考资料:
A re-introduction to JavaScript (JS tutorial)
继承与原型链
// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b： // {a: 1, b: 2} // o 的 [[Prototype]] 有属性 b 和 c： // {b: 3, c: 4} // 最后, o.[[Prototype]].[[Prototype]] 是 null. // 这就是原型链的末尾，即 null， // 根据定义，null 没有[[Prototype]]. // 综上，整个原型链如下: // {a:1, b:2} ---&amp;gt; {b:3, c:4} ---&amp;gt; null console.log(o.a); // 1 // a是o的自身属性吗？是的，该属性的值为1 console.log(o.b); // 2 // b是o的自身属性吗？是的，该属性的值为2 // 原型上也有一个'b'属性,但是它不会被访问到.这种情况称为&amp;quot;属性遮蔽 (property shadowing)&amp;quot; console.</description></item><item><title>react学习笔记</title><link>https://111qqz.com/2018/08/react-notes/</link><pubDate>Tue, 28 Aug 2018 10:16:16 +0000</pubDate><guid>https://111qqz.com/2018/08/react-notes/</guid><description>
首先介绍一个fb家的快速开发react的工具 create-react-app
这个东西依赖node6.0或者更高版本。
关于在ubuntu 14.04上安装node ，可以参考这个链接
发现执行nvm install 6.0会没有任何相应...但是实际上已经安装好了。
接下来安装create-react-app
命令是: npm install --global create-react-app
然后创建一个react app
命令为:create-react-app first_react_app
挂着代理大概需要半小时左右。
或者可以使用淘宝npm镜像:
设置方法为：npm config set registry https://registry.npm.taobao.org，设置完成后，重新执行create-react-app first-app
实现的第一个组件，功能是点击按钮增加计数...
import React, { Component } from 'react'; class ClickCounter extends Component{ constructor(props){ super(props); this.onClickButton = this.onClickButton.bind(this); this.state = {count:0}; } onClickButton(){ this.setState({count: this.state.count+1}); } render(){ return( &amp;lt;div&amp;gt; &amp;lt;button onClick={this.onClickButton}&amp;gt;Who am I?&amp;lt;/button&amp;gt; &amp;lt;div&amp;gt; click Count: {this.state.count} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) } } export default ClickCounter; JSX是JS的语法扩展。JSX中使用的元素包含html中的元素和React中的组件。React 判断一个元素是 HTML 元素还是 React 组件的原则就是看第一个字母是否大 写。</description></item><item><title>[设计模式] 组合模式（composite） 学习笔记</title><link>https://111qqz.com/2018/08/Composite-Pattern-notes/</link><pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate><guid>https://111qqz.com/2018/08/Composite-Pattern-notes/</guid><description>
目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个tree 。如果某个节点是叶子节点了，那么对应的tree都为NULL. 只不过这里用了更加面向对象的实现。
具体看代码：
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月28日 星期二 14时21分51秒 File Name :composite.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Component { // 为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为 protected: string name; public: Component(string n) { name = n; } virtual ~Component() {} virtual void Add(Component* c) = 0; virtual void Remove(Component* c) = 0; virtual void Display(int depth) = 0; }; class Leaf : public Component { // 在组合中表示叶节点对象，叶节点没有子节点 public: Leaf(string name) : Component(name) {} void Add(Component* c){} // 叶节点没有Add功能，但这样做能使接口具备一致性，这就是透明方式，如果不加入Add和Remove方法，那就是安全方式。 void Remove(Component* c){} // 同上 void Display(int depth) { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; endl; } }; class Composite : public Component { // 定义有枝节点行为，用来存储子部件 private: list&amp;lt;Component* &amp;gt; children; public: Composite(string name) : Component(name) {} void Add(Component* c) { children.</description></item><item><title>[C++11] promise &amp;&amp; future leanrning notes</title><link>https://111qqz.com/2018/08/promise-future-notes/</link><pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate><guid>https://111qqz.com/2018/08/promise-future-notes/</guid><description>
用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程返回的某个结果），需要通过主线程中的promise object 得到对应的future object(每个promise 对应一个 future),然后调用future 的get方法。如果附属线程没有执行作为参数传入的promise的set方法去返回结果，那么程序就会block住。
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月23日 星期四 10时37分07秒 File Name :future_sample.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; #include &amp;lt;future&amp;gt; void initiazer(std::promise&amp;lt;int&amp;gt; * promObj) { //std::cout&amp;lt;&amp;lt;&amp;quot;Inside Thread&amp;quot;&amp;lt;&amp;lt;std::endl; for ( int i = 1 ; i &amp;lt;= 2000000000 ; i++); //promObj-&amp;gt;set_value(35); } int main() { std::promise&amp;lt;int&amp;gt; promiseObj; std::future&amp;lt;int&amp;gt; futureObj = promiseObj.get_future(); std::thread th(initiazer, &amp;amp;promiseObj); std::cout&amp;lt;&amp;lt;futureObj.get()&amp;lt;&amp;lt;std::endl; th.join(); return 0; } 参考资料:</description></item><item><title>把二进制文件按字节读到vector中</title><link>https://111qqz.com/2018/08/how-to-read-binary-data-into-cpp-vector/</link><pubDate>Tue, 21 Aug 2018 06:08:56 +0000</pubDate><guid>https://111qqz.com/2018/08/how-to-read-binary-data-into-cpp-vector/</guid><description>
std::vector&amp;lt;unsigned char&amp;gt; readFromFile1(const char* filePath) { FILE* file = fopen(filePath, &amp;quot;rb&amp;quot;); std::vector&amp;lt;unsigned char&amp;gt; result; if (file == nullptr) { return result; } // 获取文件大小，尽量一次读完 size_t fileSize = getFileSize(file); if (fileSize != 0) { result.resize(fileSize); size_t n = fread(&amp;amp;result[0], 1, fileSize, file); assert(n &amp;lt;= fileSize); if (n != fileSize) { result.resize(n); } } // 在读取过程当中，有可能文件大小有变化，再尝试读取 const size_t read_len = 1024; char buf[read_len]; for (;;) { size_t n = fread(buf, 1, read_len, file); result.</description></item><item><title>boost:property_tree 学习笔记</title><link>https://111qqz.com/2018/08/boost_property_tree-notes/</link><pubDate>Mon, 20 Aug 2018 08:10:16 +0000</pubDate><guid>https://111qqz.com/2018/08/boost_property_tree-notes/</guid><description>
先放资料:
How to use boost::property_tree to load and write JSON
How to iterate a boost property tree?
不出现key的方法遍历一个json文件:
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月17日 星期五 15时29分23秒 File Name :ptree.cpp ************************************************ */ #include &amp;lt;boost/property_tree/ptree.hpp&amp;gt; #include &amp;lt;boost/property_tree/json_parser.hpp&amp;gt; #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; using boost::property_tree::ptree; string indent(int level) { string s; for (int i=0; i&amp;lt;level; i++) s += &amp;quot; &amp;quot;; return s; } void printTree (ptree &amp;amp;pt, int level) { if (pt.</description></item><item><title>记录一次因动态库符号表可见性导致的未定义的引用(undefined reference)</title><link>https://111qqz.com/2018/08/symbol-table-visibility/</link><pubDate>Wed, 15 Aug 2018 13:12:17 +0000</pubDate><guid>https://111qqz.com/2018/08/symbol-table-visibility/</guid><description>
编译某代码，发现报错某函数未定义的引用。该函数的是先前编译得到的动态库中。
先去check了该函数的实现，还有接口与头文件中的声明是否统一。发现没有问题。
然后怀疑.cpp文件没有被编译到，于是在该函数中添加
#pragma message(&amp;quot;******************************8&amp;quot;)
发现的确被编译到了。
使用nm来查看动态库中的符号表，发现也可以找到这个函数的符号。
于是怀疑编译代码的时候没有链接到该动态库。
于是在make的时候打印详细信息。make VERBOSE=1
发现也的确链接了动态库....
见鬼了Orz
然后用readelf -s 来查看动态库，惊讶得发现要找的那个符号的BIND怎么是LOCAL..也就是只有文件内可见。
最后发现...是公司内部的工具和CMakeLists中的add_library冲突...
虽然这个坑的解决方案没什么价值...不过因为这个坑了解了一些之前没有了解的部分，也算值得。
关于动态库的符号可见性：
控制的原因是，如果不控制，那么不同的cpp文件可能有相同的变量名字，如果把所有的符号都暴露，很可能在链接时产生冲突。 另外一个原因是，暴露没有必要的符号，会导致符号表的size变大，从而使得link时速度变慢。
参考资料:
Introduction to symbol visibility
readelf elf文件格式分析
Hiding what's exposed in a shared library
Why is the new C++ visibility support so useful?</description></item><item><title>使用python计算误差代码</title><link>https://111qqz.com/2018/08/calculate-error-with-python/</link><pubDate>Mon, 06 Aug 2018 11:54:35 +0000</pubDate><guid>https://111qqz.com/2018/08/calculate-error-with-python/</guid><description>
import os import math ave_err=0.0 max_err=0.0 max_err_rate=0.0 length=0 with open(&amp;quot;cpu_result.txt&amp;quot;,&amp;quot;r&amp;quot;) as fp1, open(&amp;quot;cuda_ppl_result.txt&amp;quot;,&amp;quot;r&amp;quot;) as fp2: for l1 in fp1: l2 = fp2.readline() l1=l1[:-2] l2=l2[:-2] lst = l1.split(' ') lst2 = l2.split(' ') #print lst lst = [float(x) for x in lst ] length = length + len(lst) lst2 = [float(x) for x in lst2] #print (lst) #print (lst2)
for index,x in enumerate(lst): y = lst2[index] ave_err = ave_err + abs(x-y) max_err = max(max_err,abs(x-y)) max_err_rate = max(max_err_rate,abs(x-y)/x) print(&amp;quot;len=&amp;quot;,length) print(&amp;quot;max_err=&amp;quot;,max_err) print(&amp;quot;max_err_rate=&amp;quot;,max_err_rate*100,&amp;quot;%&amp;quot;) print(&amp;quot;ave_err=&amp;quot;,ave_err/length) 需要提供两个文件，并且两个文件的数据格式相同。</description></item><item><title>c++11 function 与bind 学习笔记</title><link>https://111qqz.com/2018/07/cpp11-function-bind-notes/</link><pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate><guid>https://111qqz.com/2018/07/cpp11-function-bind-notes/</guid><description>
C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作
见下面的例子
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月19日 星期四 17时41分00秒 File Name :bind.cpp ************************************************ */ #include &amp;lt;functional&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; float foo( int x,int y,int z){return x+y+z+1.;} int main() { function&amp;lt;int(int,int)&amp;gt;func = foo; int y = 10; function&amp;lt;int(int)&amp;gt;fun = [&amp;amp;]( int value)-&amp;gt;int { return 1+value+y; }; cout&amp;lt;&amp;lt;func(15,4,9)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;fun(8)&amp;lt;&amp;lt;endl; return 0; } std::bind 则是用来绑定函数调用的参数的,它解决的需求是我们有时候可 能并不一定能够一次性获得调用某个函数的全部参数,通过这个函数,我们可以将 部分调用参数提前绑定到函数身上成为一个新的对象,然后在参数齐全后,完成调 用
看下面的例子:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;functional&amp;gt; using namespace std; int FUN( int x,int y,int z) { return x+y+z; } int main() { using namespace std::placeholders; //int (*fp)(int ,int,int) = FUN; auto bindfoo = bind(FUN,_1,1,2); int ans = bindfoo(0); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>intel tbb 学习笔记</title><link>https://111qqz.com/2018/07/intel-tbb-notes/</link><pubDate>Wed, 18 Jul 2018 06:57:38 +0000</pubDate><guid>https://111qqz.com/2018/07/intel-tbb-notes/</guid><description>
tbb是**Threading Building Blocks library的缩写,**是一个为开发者提供并行解决方案的库.
先放个文档https://www.threadingbuildingblocks.org/intel-tbb-tutorial
再放一个代码示例:
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月18日 星期三 14时20分54秒 File Name :parallel_for.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;quot;tbb/tbb.h&amp;quot; #include &amp;lt;chrono&amp;gt; using namespace std; using namespace tbb; const int N=1E9+7; float a[N+5]; void Foo(float &amp;amp;x) { x -= 100; } void SerialApplyFoo( float a[], size_t n ) { for( size_t i=0; i!=n; ++i ) Foo(a[i]); } class ApplyFoo { float *const my_a; public: void operator()(const blocked_range&amp;lt;size_t&amp;gt; &amp;amp;r) const { float *a = my_a; for (size_t i = r.</description></item><item><title>C++ 记录代码运行时间</title><link>https://111qqz.com/2018/07/Record-code-run-time-with-cpp/</link><pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate><guid>https://111qqz.com/2018/07/Record-code-run-time-with-cpp/</guid><description>
以前用的办法太老土啦
看到一个since C++11的方法，我觉得比较优雅
#include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms = t2 - t1; // integral duration: requires duration_cast auto int_ms = std::chrono::duration_cast&amp;lt;std::chrono::milliseconds&amp;gt;(t2 - t1); // converting integral duration to integral duration of shorter divisible time unit: // no duration_cast needed std::chrono::duration&amp;lt;long, std::micro&amp;gt; int_usec = int_ms; std::cout &amp;lt;&amp;lt; &amp;quot;f() took &amp;quot; &amp;lt;&amp;lt; fp_ms.</description></item><item><title>gdb学习笔记</title><link>https://111qqz.com/2018/07/gdb-notes/</link><pubDate>Fri, 06 Jul 2018 07:44:38 +0000</pubDate><guid>https://111qqz.com/2018/07/gdb-notes/</guid><description>
用gdb调试c++的时候，需要添加-g编译选项add_compile_options(-g)，并且关掉各种编译优化
如果是多线程程序，可以用info threads 查看每个线程的信息
然后用thread [id] 查看指定线程，并用bt查看调用栈。
gdb调试的时候，可以用ctrl+c 停住程序，来查看调用栈，然后按c(continue)继续程序的运行。
emmm
先放一些相关的。
Linux 下如何产生core文件（core dump设置）
ulimit -a 查看限制
ulimit -c unlimited 表示这只为不限制core文件大小
用gdb的调试命令如下:
gdb ./test core.2065</description></item><item><title>Kafka 学习笔记</title><link>https://111qqz.com/2018/07/kafka-notes/</link><pubDate>Mon, 02 Jul 2018 08:56:52 +0000</pubDate><guid>https://111qqz.com/2018/07/kafka-notes/</guid><description>
先放资料．
kafka简明教程</description></item><item><title>linux 下C++ 连接mysql 数据库</title><link>https://111qqz.com/2018/07/connect-mysql-with-cpp-under-linux/</link><pubDate>Mon, 02 Jul 2018 07:02:28 +0000</pubDate><guid>https://111qqz.com/2018/07/connect-mysql-with-cpp-under-linux/</guid><description>
资料推荐这个:MySQL C API programming tutorial
环境为ubuntu 14.04 lts
需要安装mysql 和mysql 开发包
sudo apt-get install libmysqlclient15-dev mysql-server mysql-client
先在mysql 中建立test数据库和test表格
　mysql&amp;gt;create database test; mysql&amp;gt;use test; //切换到test数据库中 mysql&amp;gt; create table test(name varchar(255),num int(10) ); //创建一个叫test的表 mysql&amp;gt;show create table test; //显示刚才创建的表信息 mysql&amp;gt; select * from test; //查询test表中数据 mysql&amp;gt;quit 然后用如下cpp代码连接
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;mysql.h&amp;gt; #include &amp;lt;cstring&amp;gt; int main(int argc,char *argv[]) { MYSQL conn; int res; mysql_init(&amp;amp;conn); if (mysql_real_connect(&amp;amp;conn,&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;2254965&amp;quot;,&amp;quot;test&amp;quot;,0,NULL,CLIENT_FOUND_ROWS)) { puts(&amp;quot;connect success&amp;quot;); res = mysql_query(&amp;amp;conn,&amp;quot;insert into test values('sensetime','23333')&amp;quot;); if (res) puts(&amp;quot;error&amp;quot;); else puts(&amp;quot;success&amp;quot;); printf(&amp;quot;res=%d\n&amp;quot;,res); } return 0; } 编译:</description></item><item><title>使用haproxy中转酸酸流量</title><link>https://111qqz.com/2018/05/shadowsocks-with-haproxy/</link><pubDate>Tue, 15 May 2018 06:27:35 +0000</pubDate><guid>https://111qqz.com/2018/05/shadowsocks-with-haproxy/</guid><description>
一个国内vps，一个国外vps.
前提是国外vps已经配置好。
接下来，我们在国内vps上安装haproxy
yum -y install haproxy 或者 apt-get install haproxy
然后修改配置文件,位置在/etc/haproxy/haproxy.cfg
global defaults log global mode tcp option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend ss-in bind *:[port] default_backend ss-out backend ss-out server server1 [ip]:[port] maxconn 20480 把其中的[ip]和[port]替换成国外vps的ip和相应服务的port
然后在客户端，ip填写国内vps的ip,密码还是酸酸的密码，其他保持一致。</description></item><item><title>wordpress 开启全站https</title><link>https://111qqz.com/2018/05/enable-https-for-wordpress/</link><pubDate>Mon, 14 May 2018 13:08:30 +0000</pubDate><guid>https://111qqz.com/2018/05/enable-https-for-wordpress/</guid><description>
20190511更新:
证书到期了,写一下更换证书的流程.
重新申请好证书之后,直接把Apache里面对应的123放到/data/cert文件夹.
其中1对应server-ca.crt,2对应server.crt,3对应server.key
由于从套路云转移到良心云，迫于国内某些蛋疼的政策，以及一些其他原因，决定全站上https.
首先是申请SSL证书，这个良心云就可以申请，也有其他地方。
这里要注意的是，有些证书是只能对应一个域名，腾讯云貌似就是这样，不过好像www.111qqz.com的证书也可以用于111qqz.com
得到证书中有Apache,Nginx,Tomcat和IIS四个文件夹，由于我们使用的是Apache，所以其他三个不用管。
1. 将证书上传到服务器证书目录：/data/cert（没有cert目录可以自己新建） 2. 在/etc/httpd/conf.d目录下新建一个https配置文件，假设命名为mydomain-ssl.conf。 3. 拷贝下面的https配置文件模板到mydomain-ssl.conf文件中，并保存 &amp;lt;VirtualHost *:443&amp;gt; ServerName www.111qqz.com ServerAlias 111qqz.com DocumentRoot &amp;quot;/data/wwwroot/default/wordpress&amp;quot; #ErrorLog &amp;quot;logs/www.mydomain.com-error_log&amp;quot; #CustomLog &amp;quot;logs/www.mydomain.com-access_log&amp;quot; common &amp;lt;Directory &amp;quot;/data/wwwroot/default/wordpress&amp;quot;&amp;gt; Options Indexes FollowSymlinks AllowOverride All Require all granted &amp;lt;/Directory&amp;gt; SSLEngine on SSLCertificateFile /data/cert/server.crt SSLCertificateKeyFile /data/cert/server.key SSLCertificateChainFile /data/cert/server-ca.crt &amp;lt;/VirtualHost&amp;gt; 需要注意的是，servername那里要写带www的域名，不带www的写在serveralias 4. 修改配置文件中相关项，并保存 ServerName #主域名，务必修改 ServerAlias #副域名，可选项 DocumentRoot #网站路径，务必填写网站实际路径，例如:/data/wwwroot/default/wordpress Directory #同上 SSLCertificateFile #证书，务必填写网站实际路径 SSLCertificateKeyFile #证书私钥，务必填写网站实际路径 SSLCertificateChainFile #证书链（CA文件），务必填写网站实际路径
然后由于我是迁移了服务器，很大可能是主页可以访问，但任何一个其他页面都会因报错500 internal error 之类，查看日志，位置在/var/log/httpd 里面，发现报错AH00124: Request exceeded the limit of 10 internal redirects due to probable configuration error.</description></item><item><title>C++ STL Algotithms 学习笔记</title><link>https://111qqz.com/2018/05/c-stl-algotithms-notes/</link><pubDate>Sun, 06 May 2018 09:45:50 +0000</pubDate><guid>https://111qqz.com/2018/05/c-stl-algotithms-notes/</guid><description>
迫于拙劣的cpp水平，这次来记录一些关于STL算法部分的内容。
参考内容是CS106L的course reader
Iterator Categories Iterators分为以下五种:
* Output Iterators:可以使用&amp;quot;++&amp;quot;；可以用*myItr = value,不能用value = *myItr * Input Iterators:可以使用&amp;quot;++&amp;quot;;可以用value = *myItr，不能用*myItr = value * Forward Iterators: 可以使用&amp;quot;++&amp;quot;,可以同时用value = *myItr和*myItr = value * Bidirectional Iterators:比起Forward Iterator 对了&amp;quot;--&amp;quot;,但是不能+或者+= * Random-Access Iterators：比起Bidirectional Iterators多了+和+= Algorithm Naming Conventions 一些关于STL Algorithm的命名规则
后缀_if表示只有当满足一定条件的时候该算法才会执行一定任务。
比如:
bool IsEven(int value) { return value % 2 == 0; } cout &amp;lt;&amp;lt; count_if(myVec.begin(), myVec.end(), IsEven) &amp;lt;&amp;lt; endl; _n表示执行一个特定的操作n次。
比如:
fill_n(myDeque.begin(), 10, 0); Reordering Algorithms * sort: 传入的必须是Random-Access Iterators，记得定义&amp;lt;函数 * random_shuffle:传入的必须是Random-Access Iterators,作用是将一个区间内的元素打乱重排。 可以在使用之前先使用srand函数。 * rotate：作用是循环改变容器中元素的顺序。rotate(v.</description></item><item><title>C++ IO Streams 学习笔记</title><link>https://111qqz.com/2018/05/cpp-io-streams-notes/</link><pubDate>Fri, 04 May 2018 03:48:37 +0000</pubDate><guid>https://111qqz.com/2018/05/cpp-io-streams-notes/</guid><description>
迫于拙劣的cpp水平，来补补以前忽略掉的cpp细节。
老规矩，先放资料。
参考资料:
A Gentle Introduction to C++ IO Streams
"Designing and implementing a general input/output facility for a programming language is notoriously difficult" - Bjarne Stroustrup Stream的基本认识 说说我的理解。stream(流)可以看做输入输出的抽象。我们通过流可以忽略掉device的细节，采取同样的输入输出方式。
对于任何原生的cpp类型，都可以用stream来处理。用户自定义的类，也可以通过重载&amp;lt;&amp;lt;和&amp;gt;&amp;gt;而让stream可以处理。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; // timestamp returns the current time as a string std::string timestamp(); class LogStatement; ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; ost, const LogStatement&amp;amp; ls); class LogStatement { public: LogStatement(std::string s): data(s), time_string( timestamp() ) { }; //This method handles all the outputs.</description></item><item><title>vim 插件 NERDTree 学习笔记</title><link>https://111qqz.com/2018/04/vim-NERDTree-plugin/</link><pubDate>Mon, 30 Apr 2018 05:54:33 +0000</pubDate><guid>https://111qqz.com/2018/04/vim-NERDTree-plugin/</guid><description>
迫于要在服务器上写cpp代码，又由于各种原因，没办法把同步到本地。因此要在服务器上配置一个cpp的环境orz.
我是用vim-plug来管理插件的，只需要添加
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } 就好了。 下面记录一些会用到的快捷键:
ctrl+w类似tmux里面的功能键。
crtl+w+w: 光标自动在左右侧窗口切换
cril+w+r:调换左右侧窗口的布局位置
t 在新 Tab 中打开选中文件/书签，并跳到新 Tab T 在新 Tab 中打开选中文件/书签，但不跳到新 Tab gT 前一个 tab gt 后一个 tab</description></item><item><title>gRPC学习笔记</title><link>https://111qqz.com/2018/04/grpc-notes/</link><pubDate>Sun, 29 Apr 2018 16:18:47 +0000</pubDate><guid>https://111qqz.com/2018/04/grpc-notes/</guid><description>
gRPC 是 google 最新发布的开源 RPC 框架, 声称是&amp;quot;一个高性能，开源，将移动和HTTP/2放在首位的通用的RPC框架.&amp;quot;. 技术栈非常的新, 基于HTTP/2, netty4.1, proto3, 拥有非常丰富而实用的特性, 堪称新一代RPC框架的典范.
//上面这段话是我抄的，其实我之前连RPC是什么都不知道，
关于RPC，如果你和我一样根本不知道是什么，请参考这里 
我对RPC的理解就是，一层封装，使得不在同一个机器上的程序A可以一个调用另一个程序B，而不需要考虑这两台机器，以及这两个程序使用的语言的不同。
而gRPC是诸多RPC框架中比较新，也比较好用的一个。
学习gRPC需要会使用protobuf3,关于protobuf，可以参考protobuf学习笔记
官方文档 还是要给出的，虽然我没怎么看就是了orz
gRPC的安装 参考这个，从源码编译安装
$ [sudo] apt-get install build-essential autoconf libtool pkg-config $ [sudo] apt-get install libgflags-dev libgtest-dev $ [sudo] apt-get install clang libc++-dev $ git clone -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc $ cd grpc $ git submodule update --init $ make $ [sudo] make install 如果出现
configure: error: cannot find install-sh, install.</description></item><item><title>8102年了，来更新一波vim配置</title><link>https://111qqz.com/2018/04/vim-config-in-2018/</link><pubDate>Wed, 25 Apr 2018 16:46:51 +0000</pubDate><guid>https://111qqz.com/2018/04/vim-config-in-2018/</guid><description>
现在用的vim配置还是2015年7月的时候写的。
三年过去了，vim到了8.0,很多功能也有了更多选择。因此打算来更新一波vim配置。目前还在更新过程中。。。等差不多折腾完再来记录一些信息。
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; for vim &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; set ru set nu set clipboard+=unnamed &amp;quot; 映射全选+复制 ctrl+a map &amp;lt;C-A&amp;gt; ggvG&amp;quot;+Y &amp;quot;去空行 nnoremap &amp;lt;F2&amp;gt; :g/^\s*$/d&amp;lt;CR&amp;gt; &amp;quot; 自动缩进 set autoindent set tabstop=4 set softtabstop=4 set shiftwidth=4 filetype on &amp;quot; 载入文件类型插件 filetype plugin on &amp;quot; 为特定文件类型载入相关缩进文件 filetype indent on &amp;quot; 高亮显示匹配的括号 set showmatch &amp;quot; 高亮当前行 set cursorline hi CursorLine cterm=bold ctermbg=blue ctermfg=yellow &amp;quot;C，C++ 按F5编译运行 map &amp;lt;F5&amp;gt; :call CompileRunGcc()&amp;lt;CR&amp;gt; func! CompileRunGcc() exec &amp;quot;w&amp;quot; if &amp;amp;filetype == 'c' exec &amp;quot;!</description></item><item><title>protobuf学习笔记</title><link>https://111qqz.com/2018/04/protobuf-notes/</link><pubDate>Tue, 24 Apr 2018 03:05:09 +0000</pubDate><guid>https://111qqz.com/2018/04/protobuf-notes/</guid><description>
Protobuff 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。
之前由于要用levelDB存feature,而levelDB的key只能是string(?,反正不能是一个数组)， 使用了protobuf. protobuf本身还比较easy,不过目前似乎protobuf2仍然是主流，但是由于最近在看gRPC的缘故，要使用protobuf3.　如果protobuf2没有卸载干净，绝对欲仙欲死...记录一些坑．详细一点的笔记之后补．
// protobuf3坑好多啊...语法全靠猜，也是有毒 
行吧，怪我没找到orz,生成的cpp语法部分在 这里。
先放参考资料好了。一开始找到一个pdf文档，说是官方文档的翻译版...但实际上感觉，讲得很烂。直接看官方文档比较好。
其中Language Guide (proto3) 讲了protobuf3的proto文件的语法相关。
Protocol Buffer Basics: C++ 讲了怎么从编写proto文件到在cpp中使用的一般步骤（注意此处貌似是按照protobuf2讲的）
C++ Generated Code 讲了生成的cpp代码的接口，并且强调了protobuf2和protobuf3的区别。
syntax = &amp;quot;proto3&amp;quot;; package test; message Feature { int32 ver = 1; int32 idx = 2; int32 len = 3; repeated float feat = 4; } 生成相应代码的语法为: protoc --cpp_out=. test.proto
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;quot;test.pb.h&amp;quot; using namespace std; using namespace test; int main() { float arr[10]={4,5,6,7,8,9}; Feature feature; puts(&amp;quot;def feature&amp;quot;); float ft; for ( int i = 0 ; i &amp;lt; 4 ; i++) { feature.</description></item><item><title>levelDB 使用笔记</title><link>https://111qqz.com/2018/04/leveldb-notes/</link><pubDate>Thu, 19 Apr 2018 15:58:40 +0000</pubDate><guid>https://111qqz.com/2018/04/leveldb-notes/</guid><description>
2022-02-26 update:
说学习笔记听起来像在分析代码。。。但是实际上什么都没干，还是写&amp;quot;使用笔记&amp;quot;好了
大三的时候看过一点levelDB的源码，不过没有怎么用过。
最近有个需求是存人脸的feature到硬盘，似乎使用levelDB比较合适，因此来学习一下使用。
先放参考资料。
关于levelDB的语法，看这里就好了。
以及由于caffe中使用了levelDB，因此也可以参考下caffe源码。不过caffe中对levelDB的使用是又封装了一层。
具体可以参考：
#ifdef USE_LEVELDB #ifndef CAFFE_UTIL_DB_LEVELDB_HPP #define CAFFE_UTIL_DB_LEVELDB_HPP #include &amp;lt;string&amp;gt; #include &amp;quot;leveldb/db.h&amp;quot; #include &amp;quot;leveldb/write_batch.h&amp;quot; #include &amp;quot;caffe/util/db.hpp&amp;quot; namespace caffe { namespace db { class LevelDBCursor : public Cursor { public: explicit LevelDBCursor(leveldb::Iterator* iter) : iter_(iter) { SeekToFirst(); CHECK(iter_-&amp;gt;status().ok()) &amp;lt;&amp;lt; iter_-&amp;gt;status().ToString(); } ~LevelDBCursor() { delete iter_; } virtual void SeekToFirst() { iter_-&amp;gt;SeekToFirst(); } virtual void Next() { iter_-&amp;gt;Next(); } virtual string key() { return iter_-&amp;gt;key().ToString(); } virtual string value() { return iter_-&amp;gt;value().</description></item><item><title>caffe2 添加自定义operater</title><link>https://111qqz.com/2018/04/add-custom-operation-in-caffe2/</link><pubDate>Fri, 13 Apr 2018 03:08:19 +0000</pubDate><guid>https://111qqz.com/2018/04/add-custom-operation-in-caffe2/</guid><description>
记录一些一个没有之前没有接触过caffe/caffe2的人为了添加自定义的op 到caffe2需要做的工作.
首先参考caffe2 tutorial,随便跑个op来试试,不妨以比较简单的 Accumulate_op 为例子.
这个op的作用就是计算Y=X+gamma*Y, 其中X为输入,Y为输出,gamma是参数.
跑起来这个运算所需要的代码如下:
from caffe2.python import workspace, model_helper import numpy as np # Create the input data data = np.arange(6).reshape(2,3).astype(np.float32) print (&amp;quot;data=&amp;quot;,data) # Create labels for the data as integers [0, 9]. workspace.FeedBlob(&amp;quot;data&amp;quot;, data) # Create model using a model helper m = model_helper.ModelHelper(name=&amp;quot;my first net&amp;quot;) output = m.net.Accumulate([&amp;quot;data&amp;quot;], &amp;quot;output&amp;quot;) print(m.net.Proto()) workspace.RunNetOnce(m.param_init_net) workspace.CreateNet(m.net) workspace.RunNet(m.name,2) # run 2 times print(&amp;quot;output=&amp;quot;,workspace.FetchBlob('output')) c之后我们仿照caffe2/operators/accumultate_op.h和affe2/operators/accumultate_op.cc,仿写一个我们自己的运算atest_op.h和atest_op.cc
实现的功能为Y=5X+gammaY
 #include &amp;quot;caffe2/operators/atest_op.</description></item><item><title>Eigen: C++开源矩阵学习笔记</title><link>https://111qqz.com/2018/04/eigen-notes/</link><pubDate>Thu, 05 Apr 2018 07:14:54 +0000</pubDate><guid>https://111qqz.com/2018/04/eigen-notes/</guid><description>
接触Eigen的原因是最近在看caffe/caffe2源码,caffe2中使用了Eigen库. Eigen 是一个基于C++模板的线性代数库，直接将库下载后放在项目目录下，然后包含头文件就能使用，非常方便。对于Linux用户,只需要把头文件放到/usr/include 下即可此外，Eigen的接口清晰，稳定高效。
之后会更新一些,Eigen中我使用过的函数.
ubuntu14.04LTS 下使用方式: sudo apt-get install libeigen3-dev cd /usr/include/eigen3 sudo cp -R Eigen /usr/include 然后尝试运行如下代码,直接编译即可.如果可以正常运行,表明安装完毕.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;Eigen/Dense&amp;gt; //using Eigen::MatrixXd; using namespace Eigen; using namespace Eigen::internal; using namespace Eigen::Architecture; using namespace std; int main() { cout&amp;lt;&amp;lt;&amp;quot;*******************1D-object****************&amp;quot;&amp;lt;&amp;lt;endl; Vector4d v1; v1&amp;lt;&amp;lt; 1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v1=\n&amp;quot;&amp;lt;&amp;lt;v1&amp;lt;&amp;lt;endl; VectorXd v2(3); v2&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v2=\n&amp;quot;&amp;lt;&amp;lt;v2&amp;lt;&amp;lt;endl; Array4i v3; v3&amp;lt;&amp;lt;1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v3=\n&amp;quot;&amp;lt;&amp;lt;v3&amp;lt;&amp;lt;endl; ArrayXf v4(3); v4&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v4=\n&amp;quot;&amp;lt;&amp;lt;v4&amp;lt;&amp;lt;endl; } map的使用办法: double arr[9]={1,2,3,4,5,6,7,8,9}; Map A(arr,3,3); 得到 1 4 7 2 5 8 3 6 9</description></item><item><title>linux/win双系统 更新win后 grub 出现 Error: unknown filesystem 的解决办法</title><link>https://111qqz.com/2018/04/the-way-to-fix-unkown-filesystem-error-in-grub/</link><pubDate>Sun, 01 Apr 2018 06:28:30 +0000</pubDate><guid>https://111qqz.com/2018/04/the-way-to-fix-unkown-filesystem-error-in-grub/</guid><description>
windows自己更新把grub更新挂了....
更新的时候要重启几次,重启一次挂一次...
讲真,windows(或者说win10?) 是我见过的最辣鸡的OS了... 自己把自己弄挂这事不是一两次了.
下面说修复办法:
先ls,得到一堆诸如(hd0,gpt7) 这种
然后选设X=第一个(x,y)形式的输出
之后
&amp;lt;code&amp;gt;set root=X set prefix=X/boot/grub insmod normal normal &amp;lt;/code&amp;gt; 然后记得要进入linux分区..... 执行: sudo update-grub sudo grub-install /dev/sda
总结:珍爱生命,远离辣鸡windows!!!!! 珍爱生命,远离辣鸡windows!!!!! 珍爱生命,远离辣鸡windows!!!!!</description></item><item><title>cmake 学习笔记</title><link>https://111qqz.com/2018/03/cmake-notes/</link><pubDate>Sun, 18 Mar 2018 10:27:26 +0000</pubDate><guid>https://111qqz.com/2018/03/cmake-notes/</guid><description>
前置技能点：
gnu make
linux下.so,.a,.o文件
cmake是一个工具，也可以看成一门语言。
学习cmake最大的障碍在于看不懂全是大写的英文
学习cmake主要参考了《cmake practice》
不过感觉作者有些啰嗦...不重要的东西讲了半天，重要的东西却一带而过。。。表述得也不是特别流畅。。。但是还是感谢作者的分享吧orz...
cmake的定位是大型项目构建工具。
目前适用于C/C++/JAVA的项目。
可以不需要自己写makefile文件。
既然cmake可以看做一门语言，那么自然就有语法。
下面只是列举一些常用的。不常用的可以用到的时候再去查。这里也会不定期补充。
cmake的语法中，对于变量大小写敏感，对于cmake的关键字大小写不敏感，不过习惯于全部大写。
cmake有两种编译方式，一种叫in source 编译（就是直接在工程目录编译）
一种叫out of source 编译，就是在工程目录下新建build,然后在build文件夹里编译。
一般都采用out of source的方式编译，这样可以使得编译得到的结果都存放在build文件夹里，不会和源代码混在一起。
set 命令用来定义变量：
SET(HELLO_SRC main.SOURCE_PATHc)
然后就可以用${HELLO_SRC}　来引用这个变量了（例外：在if语句中，是直接使用变量名引用，而不需要${}）
ADD_EXECUTABLE来定义生成的可执行文件的名字：
ADD_EXECUTABLE(hello SRC_LIST)
表示源文件是SRC_LIST 中定义的源文件列表，生成一个文件名为hello的可执行文件。
如果有多个参数，可以写成：
ADD_EXECUTABLE(hello main.c func.c)或者 ADD_EXECUTABLE(hello main.c;func.c)
ADD_SUBDIRECTORY指令：
ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制存 放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除,比如,工程 的 example,可能就需要工程构建完成后,再进入 example 目录单独进行构建(当然,你 也可以通过定义依赖来解决此类问题)。
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})：生成动态(共享)库
语法为：ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)
常用到的是SHARED动态库，STATIC静态库
SET_TARGET_PROPERTIES：可以修改生成的库的名字
SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &amp;quot;hello&amp;quot;)</description></item><item><title>非极大值抑制（Non-Maximum Suppression，NMS）</title><link>https://111qqz.com/2018/03/non-maximum-suppression/</link><pubDate>Fri, 16 Mar 2018 02:56:14 +0000</pubDate><guid>https://111qqz.com/2018/03/non-maximum-suppression/</guid><description>
NMS是为了在诸多CV任务如边缘检测，目标检测等，找到局部最大值
其主要思想是先设定一个阈值，然后计算检测框的IOU(所谓IOU，也就是intersection-over-union，指的是相交面积除以相并面积，是来衡量overlap程度的指数）。如果IOU大于阈值，说明overlap过大，我们要通过某种算法来将其剔除。
比如下图，在经典的人脸识别任务中，出现了多个检测框，每个检测框有一个置信度confidence，我们通过某个算法，保留一个最好的。
顺便说一下算法的实现步骤把，其实不太重要。就是贪心。
其基本操作流程如下： * 首先，计算每一个 bounding box 的面积： * (x1, y1) ⇒ 左上点的坐标，(x2, y2) ⇒ 右下点的坐标； * (x2-x1+1)x(y2-y1+1) * 根据 scores 进行排序（一般从小到大），将 score 最大的bounding box置于队列，接下来计算其余 bounding box 与当前 score 最大的 bounding box 的 IoU，抑制（忽略也即去除）IoU大于设定阈值的 bounding box； * 重复以上过程，直至候选 bounding boxes 为空； 最后上一段python代码吧...也很简单，直接转载了别人的...
def nms(dets, thresh): x1 = dets[:, 0] y1 = dets[:, 1] x2 = dets[:, 2] y2 = dets[:, 3] scores = dets[:, 4] areas = (x2 - x1 + 1) * (y2 - y1 + 1) # 每个boundingbox的面积 order = scores.</description></item><item><title>mysql 出现　innoDB: Cannot allocate memory for the buffer pool　的解决办法</title><link>https://111qqz.com/2018/03/the-way-to-fix-mysql-innodb-cannot-allocate-memory/</link><pubDate>Thu, 15 Mar 2018 04:56:58 +0000</pubDate><guid>https://111qqz.com/2018/03/the-way-to-fix-mysql-innodb-cannot-allocate-memory/</guid><description>
emmm,博客的数据库又挂了。
看了下log，发现innoDB: Cannot allocate memory for the buffer pool　的error
查了下，貌似是内存不够了？　orz
用free 命令看了下，阿里云ecs貌似是默认没有swap分区的。
于是参考云服务器 ECS Linux SWAP 配置概要说明 
设置了swap分区。看下还会不会挂orz</description></item><item><title>reid 相关任务记录</title><link>https://111qqz.com/2018/02/reid-task-notes/</link><pubDate>Sat, 24 Feb 2018 04:34:02 +0000</pubDate><guid>https://111qqz.com/2018/02/reid-task-notes/</guid><description>
被师兄（同事？）普及了一番实验规范orz...
我还是太年轻了
所谓的一个fc的版本是右边的．一个放着不动，另一个在sequence_len（１０）的维度上做ave,然后再expand成原来的维度．如下图．
任务命名规则：
如D1V2_a_1,D1表示使用第一个数据集，V2表示是第二个大版本，ａ表示在V２大版本上的微调，最后的数字表示这是第几次运行该任务（跑三次以减少波动的影响）
logdir的地址为:/mnt/lustre/renkuanze/Data_t1/reid/log/｛$jobname｝
* D1:使用ilivids 数据集 * D1V1表示最初始的　baseline model * D1V2表示改为使用一个fc * D1V2_a是一个在一个FC上，不添加光流的修改版本 * D1V2_b是在一个FC上的baseline版本（也就是有光流） * D1V2_c是在一个FC上，有光流，batchsize从３２改为６４，gpu数目从4改为8的版本 * D1V3表示将softmax改为sigmod * D1V3_b表示将softmax改为sigmod的baseline版本 * D2:使用prid2011数据集 * D2V1表示初始的baseline model * D2V2表示改为使用一个fc * D2V2_b是在一个FC上的baseline版本 *</description></item><item><title>分类评价指标之Cumulative Match Characteristi (CMC)曲线</title><link>https://111qqz.com/2018/02/cumulative-Match-characteristi/</link><pubDate>Fri, 23 Feb 2018 08:20:55 +0000</pubDate><guid>https://111qqz.com/2018/02/cumulative-Match-characteristi/</guid><description>
CMC曲线全称是Cumulative Match Characteristic (CMC) curve，也就是累积匹配曲线，同ROC曲线Receiver Operating Characteristic (ROC) curve一样，是模式识别系统，如人脸，指纹，虹膜等的重要评价指标，尤其是在生物特征识别系统中，一般同ROC曲线（ 多标签图像分类任务的评价方法-mean average precision(mAP) 以及top x的评价方法）一起给出，能够综合评价出算法的好坏。
转一篇通俗易懂的解释：
Shortly speaking, imagine that you have 5 classes. For simplicity, imagine you have one test per class. Each test produces a score when compared to each class. Let's start from test1 which belongs to class1:
As your similarity measure, here, is Euclidian distance, the more distance a test has compared to a class, the less similarity is obtained.</description></item><item><title>pytorch 函数笔记</title><link>https://111qqz.com/2018/02/pytorch-function-notes/</link><pubDate>Fri, 23 Feb 2018 02:55:25 +0000</pubDate><guid>https://111qqz.com/2018/02/pytorch-function-notes/</guid><description>
记录一些常用的...总去查文档也是有点麻烦
* tensor.view 的作用是reshape 比如 a = torch.range(1, 16) 得到一个tensor that has 16 elements from 1 to 16. 在a=a.view(4,4)就得到了一个44的tensor。 需要注意reshape之后元素的个数不能改变(16==44) 参数-1的作用是，我懒得算这一维度应该是多少,（由于元素个数不能改变）所以希望自动被计算。**需要注意的是，只有一个维度可以写-1。 **不过view和reshape有些区别：reshape always copies memory. view never copies memory * torch.squeeze 将输入张量形状中的1 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)，那么输出形状就为： (A×B×C×D)当给定dim时，那么挤压操作只在给定维度上。例如，输入形状为: (A×1×B), squeeze(input, 0) 将会保持张量不变，只有用 squeeze(input, 1)，形状会变成 (A×B)。注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。 * torch.unsqueeze 返回一个新的张量，对输入的制定位置插入维度 1 注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。如果dim为负，则将会被转化dim+input.dim()+1 &amp;gt;&amp;gt;&amp;gt; x = torch.Tensor([1, 2, 3, 4]) &amp;gt;&amp;gt;&amp;gt; torch.unsqueeze(x, 0) 1 2 3 4 [torch.FloatTensor of size 1x4] &amp;gt;&amp;gt;&amp;gt; torch.</description></item><item><title>光流法初探</title><link>https://111qqz.com/2018/02/Optical-flow-notes/</link><pubDate>Thu, 22 Feb 2018 09:03:48 +0000</pubDate><guid>https://111qqz.com/2018/02/Optical-flow-notes/</guid><description>
算是CV领域的传统算法了
只写两句话就够了。
**它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。** 研究光流场的目的就是为了从图片序列中近似得到不能直接得到的运动场。运动场，其实就是物体在三维真实世界中的运动；光流场，是运动场在二维图像平面上（人的眼睛或者摄像头）的投影。
参考资料：
光流Optical Flow介绍与OpenCV实现</description></item><item><title>end-to-end 神经网络</title><link>https://111qqz.com/2018/02/end-to-end-neural-network/</link><pubDate>Thu, 22 Feb 2018 02:53:01 +0000</pubDate><guid>https://111qqz.com/2018/02/end-to-end-neural-network/</guid><description>
所谓end-to-end 神经网络，更多是一种思想。
这种思想的核心是，比如对于图像处理，输入原始图像数据，输出的是直接有用的结果（有用取决于具体的任务，比如自动驾驶)
也就是尽可能少得减少人为干预，使训练是end (原始数据) to end (对应用问题直接有用的结果)
端到端指的是输入是原始数据，输出是最后的结果，原来输入端不是直接的原始数据，而是在原始数据中提取的特征，这一点在图像问题上尤为突出，因为图像像素数太多，数据维度高，会产生维度灾难，所以原来一个思路是手工提取图像的一些关键特征，这实际就是就一个降维的过程。 那么问题来了，特征怎么提？ 特征提取的好坏异常关键，甚至比学习算法还重要，举个例子，对一系列人的数据分类，分类结果是性别，如果你提取的特征是头发的颜色，无论分类算法如何，分类效果都不会好，如果你提取的特征是头发的长短，这个特征就会好很多，但是还是会有错误，如果你提取了一个超强特征，比如染色体的数据，那你的分类基本就不会错了。 这就意味着，特征需要足够的经验去设计，这在数据量越来越大的情况下也越来越困难。 于是就出现了端到端网络，特征可以自己去学习，所以特征提取这一步也就融入到算法当中，不需要人来干预了。
简单得说，符合end-to-end 的神经网络，特征应该是网络自己学习，而不是人为提取。
参考资料：
什么是 end-to-end 神经网络？</description></item><item><title>Pose-driven Deep Convolutional Model for Person Re-identification 阅读笔记</title><link>https://111qqz.com/2018/02/pose-driven-deep-convolutional-model-for-person-re-identification/</link><pubDate>Thu, 22 Feb 2018 02:25:00 +0000</pubDate><guid>https://111qqz.com/2018/02/pose-driven-deep-convolutional-model-for-person-re-identification/</guid><description>
1709.08325
Reid问题指的是判断一个probe person 是否在被不同的camera捕获的gallery person 中出现。
通常是如下情景：给出一个特定camera下某个特定人的probe image 或者 video sequence，从其他camera处询问这个人的图像，地点，时间戳。
ReID问题至今没有很好得解决，主要原因是，不同camera下，人的姿势（pose),观察的视角(viewpoint) 变化太大了。
传统方法主要在两个大方向上努力:
1. **用一些在图像上抽取的不变量来作为人的特征feture** 2. **去学习一个不同的距离度量方式，以至于同一个人在不同camera之间的距离尽可能小。** 但是由于在实际中，行人的pose和 摄像机的viewpoint不可控，因此与之相关的feture可能不够健壮。
学习新的不同的距离度量方式需要每对camera分别计算距离，然而这是O(n^2)的时间复杂度，凉凉。
近些年Deep learning发展迅猛，并且在很多CV任务上表现良好。所以自然有人想把Deep learning 方法应用到Reid任务上。
目前Deep learning的做法一般分为两部分：
* 使用softmax loss 结合person ID labels得到一个global representation * 首先用预定义好的body 刚体模型去得到local representation,然后将global 和local representation 融合。 目前用deep learning的方法效果已经不错了，比传统方法要好。但是目前的deep learning方法没有考虑到人的姿势(pose)的变化。
虽然目前也有些deep learning的办法在处理Reid问题时使用pose estimation algorithms 来预测行人的pose,
但是这种办法是手动完成而不是一个end-to-end（什么是end-to-end 神经网络） 的过程
所以考虑pose的潜力还没有被完全发掘。
这篇paper主要做了以下工作：
* 提出了一种新的深层结构，将身体部分转化成相应的特征表示，以此来克服pose变化带来的问题 * 提出了一个用来自动学习各部分权值的sub-network 这两部分工作都是end-to-end的</description></item><item><title>Deep Mutual Learning（相互学习） 阅读笔记</title><link>https://111qqz.com/2018/02/deep-mutual-learning-notes/</link><pubDate>Sun, 18 Feb 2018 10:46:35 +0000</pubDate><guid>https://111qqz.com/2018/02/deep-mutual-learning-notes/</guid><description>
原始论文
DNN在很多问题上效果很不错，但是由于深度和宽度过大，导致需要的执行时间和内存过大。我们需要讨论一些能快速执行并且对内存的需要不大的模型。
已经有很多方法来做这件事，比较重要的是Model distillation（模型蒸馏）
基于蒸馏的模型压缩的有效性是基于一个发现：小的网络有和大的网络一样的表达能力，只不过是更难以训练找到合适的参数。
也就是说，难点在于优化(以找到合适的参数）而不在于网络的尺寸。
蒸馏的模型的做法是把一个有效的(deep or/and wide) network 作为teacher network,让一个size 较小的 student network 模仿teacher network.
这样做的好处是，size小的多的student network训练如何模仿teacher network通常要比直接训练得到目标函数容易，而效果上与teacher network相当，甚至超过teacher network.
在这篇paper中，作者提出了一个和蒸馏模型相关但是不同的模型: Deep Mutual Learning (相互学习，以下缩写为DML)
蒸馏模型开始于一个强大的教师网络，并通过教师网络**单向(one way)**教授学生网络知识。
相反，DML中,开始于一群没有经受过训练的学生网络。
具体来说，每个学生训练有两种损失:
* **常规的监督学习损失和对齐的模仿损失** * **每个学生的在班级中落后于其他学生的概率。** 结果表明，DML的方式：比每个学生网络单独学习要好，也比传统的传统的蒸馏模型要好。
此外，我们发现，对几个tearcher network 使用 DML，要往往有更好的结果。
另外一些发现：
* 效果随着班级中学生网络的数量的增加而增加 * 它适用于各种网络体系结构和异构群组 关于DML为什么有效的直觉讨论：
* 常规的监督学习损失保证每个学生单独学习时，整体上结果是越来越好的。 * 由于初始条件不同，对下一个最可能的class的预测概率不同，这是额外信息的来源。</description></item><item><title>Similarity learning 和Metric learning</title><link>https://111qqz.com/2018/02/similarity-learning-metric-learning/</link><pubDate>Sun, 18 Feb 2018 08:14:10 +0000</pubDate><guid>https://111qqz.com/2018/02/similarity-learning-metric-learning/</guid><description>
Similarity_learning 相似性学习（Similarity learning ）有监督机器学习，它与回归和分类密切相关，但目标是从实例中学习一个相似函数，以衡量两个对象的相似程度或相关程度。
Similarity learning通常有四种setups:
* regression similarity learning 在这种方式中，给出的数据是 ![(x_{i}^{1},x_{i}^{2})](https://wikimedia.org/api/rest_v1/media/math/render/svg/cfa249357a1b4a7baf332041d67e480d6bb1f8fb)  和他们的相似度 . 目标是学习到一个函数 ，对于 给出yi的近似值。 * Classification similarity learning 给出数据 和他们是否相似 。目标是训练出一个分类器，能够完成对一组 是否相似的二分类判断。 * Ranking similarity learning 给出有序三元组 ，其中 is known to be more similar to than to 。目标是训练出一个函数，使得对于新的三元组 ，满足 。容易看出，这种方式采取了比回归更弱的监督形式，因为不需要提供精确的相似性度量，只需要提供相似性的相对顺序。因此，这种ranking-based的相似性学习更容易应用于实际的大规模应用 * Locality sensitive hashing (LSH) 局部敏感哈希和普通哈希的不同就是，相似的项有更大的概率被放到同一个桶中。
顺便一提，这里有一个叫triplet loss 的概念，
如上图所示，triplet是一个三元组，这个三元组是这样构成的：从训练数据集中随机选一个样本，该样本称为Anchor，然后再随机选取一个和Anchor (记为x_a)属于同一类的样本和不同类的样本,这两个样本对应的称为Positive (记为x_p)和Negative (记为x_n)，由此构成一个（Anchor，Positive，Negative）三元组。
我们发现，triplet loss 其实就是在ranking similarity learning 问题中，学习similarity function时的loss
Metric learning 相似性学习与距离度量学习密切相关。度量学习的目标是在对象上学习一个距离函数。度量或距离函数必须遵循四个公理:非负性、不可分辨的恒等式、对称性和次可加性/三角形不等式。在实际应用中，度量学习算法忽略了不可分辨物体的身份条件，学习了一个伪度量。</description></item><item><title>persion reid 论文列表</title><link>https://111qqz.com/2018/02/persion-reid-paper-list/</link><pubDate>Sat, 17 Feb 2018 07:17:49 +0000</pubDate><guid>https://111qqz.com/2018/02/persion-reid-paper-list/</guid><description>
Key:
(1). Pose-driven, body part alignment, combine whole feature and body part feature, focus on alignment of part model,
(2). Combine image label and human attributes classes, do classification with attributes and identity learning
(3). Based on triplet loss, improve metric learning for an end to end learning
(4). Post-process, re-ranking
AlignedReID: Surpassing Human-Level Performance in Person Re-Identification
Hydraplus-net: Attentive deep features for pedestrian analysis.
Darkrank: Accelerating deep metric learning via cross sample similarities transfer.</description></item><item><title>CUDA C Best Practices Guide 阅读笔记（二） Heterogeneous Computing</title><link>https://111qqz.com/2018/02/cuda-c-best-practices-guide-heterogeneous-computing/</link><pubDate>Tue, 13 Feb 2018 06:38:38 +0000</pubDate><guid>https://111qqz.com/2018/02/cuda-c-best-practices-guide-heterogeneous-computing/</guid><description>
CUDA 编程涉及到在不同的平台上同时运行代码:包含CPU的host 和包含GPU的device.
所以了解host和device的对性能优化是非常重要的。
2.1. Differences between Host and Device Threading resources host 上能同时运行的线程数目比较少（比如24个）
device上能同时运行的线程数目比较多（数量级通常为1E3，1E4等）
Threads 操作系统必须交换CPU执行通道上和下的线程以提供多线程功能。因此，上下文切换(当交换两个线程时)既慢又昂贵。
相比之下，GPU上的线程非常轻量级。在典型的系统中，成千上万的线程排队等待工作(每个线程有32个线程)。如果GPU必须等待 one warp of threads，它只需开始在另一个线程上执行工作。
简而言之，CPU内核被设计为每次最小化一个或两个线程的等待时间，而GPU被设计为处理大量并发的轻量级线程以最大化吞吐量。
RAM host和device 各自具有各自不同的附接物理存储器。host和device内存由PCI Express ( PCIe )总线分隔，因此host内存中的项目必须偶尔通过总线传送到device内存，反之亦然
2.2. What Runs on a CUDA-Enabled Device? 下面谈谈应该把应用的哪些部分放在device 上运行
* 大数据集上的算术运算 * 为了获得最佳性能，设备上运行的相邻线程的内存访问应该具有一定的一致性。**某些内存访问模式使硬件能够将多个数据项的读或写组合并到一个操作中**。当在CUDA上的计算中使用时，无法布局以实现合并的数据，或者没有足够的局部性来有效地使用L1或纹理缓存的数据，将倾向于看到较小的加速比。 * host和device之间的数据交换尽可能少 * **换到device上执行的数据一定会被做足够多的运算**，不然数据从Host传送到device的代价 可能与该运算在device上并行计算的优势向抵消，甚至得不偿失。 * **数据应尽可能长时间保存在设备上。**因为传输应该最小化，所以在同一数据上运行多个内核的程序应该倾向于在内核调用之间将数据保留在设备上，而不是将中间结果传输到主机，然后再将它们发送回设备进行后续计算。就是说，如果有一段连续的操作要处理某些数据，就算其中的部分操作在host上运行要比在device上快（比如不是算数运算而是逻辑处理），那么考虑到数据传输的巨大代价，将所有数据都放在device上处理可能会更好。这种处理原则即使相对较慢的内核也可能是有利的，如果它避免了一个或多个PCIe传输。</description></item><item><title>CUDA C Best Practices Guide 阅读笔记（1） 并行计算方法论(APOD)</title><link>https://111qqz.com/2018/02/cuda-c-best-practices-parallel-computing-methodology/</link><pubDate>Mon, 12 Feb 2018 04:58:31 +0000</pubDate><guid>https://111qqz.com/2018/02/cuda-c-best-practices-parallel-computing-methodology/</guid><description>
APOD指的是Assess, Parallelize, Optimize, Deploy
如图所示，APOD过程是一个循环的过程，每次只进行一部分，从A到P到O到D,然后再进行下一轮的APOD
Assess 对于一个项目，第一步要做的是接触(Assess)项目，得到项目代码中每部分的执行时间。有了这部分内容，开发者就可以找到并行优化的瓶颈所在，并开始尝试用GPU加速。
根据Amdahl's and Gustafson's laws，开发者可以确定并行优化的性能上界。
Parallelize 找到瓶颈所在并确定了优化的目标和期望，开发者就可以优化代码了。调用一些如cuBLAS, cuFFT, or Thrust 的 GPU-optimized library 可能会很有效。
另一方面，有些应用需要开发者重构代码，以此让可以被并行优化得部分被暴露出来。
Optimize 确定了需要被并行优化的部分之后，就要考虑具体得实现方式了。
具体得实现方式通常不过只有一种，所以充分理解应用的需求是很有必要的。
要记得，APOD是一个反复迭代的过程（找到可以优化的点，实现并测试优化，验证优化效果，然后再重复）
因为对于开发者来说，没有必要最初就找到解决所有性能瓶颈的策略。
优化可以在不同的level上进行，配合性能分析工具是很有帮助的。
Deploy 大的原则是当优化完一处之后，立刻将这一部分部署到生产环境，而不是再去寻找其他可以优化的地方。
这样做有很多重要的原因，比如这会使得用户尽早从这个优化中收益（尽管提速只是部分的，但是仍然有价值）
此外，每次有改动就重新部署，也使得变化是平稳而不是激进的，这有助于减少风险。
Recommendations and Best Practice 优化根据对性能影响程度的不同有不同的优先级。
在先要处理低优先级的优化之前，一定要确保其他所有的高优先级优化都做完了。
这种方法将倾向于为所投入的时间提供最佳结果，并且将避免过早优化的陷阱。
需要说明的一点是，教程中的代码为了方便简洁没有关于任何 check error的部分。
在实际上这是不可取的（这不同于编写C++代码!）</description></item><item><title>cuda c++ 基础算法库 thrust 学习笔记</title><link>https://111qqz.com/2018/02/cuda-thrust-notes/</link><pubDate>Sat, 10 Feb 2018 08:43:54 +0000</pubDate><guid>https://111qqz.com/2018/02/cuda-thrust-notes/</guid><description>
可以了解成并行版的STL(?
过了一遍nvidia的官方网文档
发现如果熟悉STL的话,thrust没什么太多好说的,看起来很简单...
不过还是开一篇记录一下,一段时间内估计要和cuda c++ 打交道,就当记录使用过程中遇到的问题吧.</description></item><item><title>推荐系统之 LFM (Latent Factor Model) 隐因子模型 学习笔记</title><link>https://111qqz.com/2018/02/Latent-Factor-Model-notes/</link><pubDate>Fri, 09 Feb 2018 13:02:06 +0000</pubDate><guid>https://111qqz.com/2018/02/Latent-Factor-Model-notes/</guid><description>
起因是被assgin了一个新的任务.....要死.
参考资料:
推荐系统学习笔记之三 LFM (Latent Factor Model) 隐因子模型 + SVD (singular value decomposition) 奇异值分解
基于矩阵分解的隐因子模型
实时推荐系统的三种方式
先说下我的理解...
隐因子模型(LFM)是一种推荐算法,&amp;quot;隐&amp;quot;可以理解成用户喜欢某个item的间接原因.
该算法的核心思想是转化成一个矩阵分解问题..
然后用传统机器学习算法去优化分解得到的矩阵...
主要的优势如下： * 比较容易编程实现，随机梯度下降方法依次迭代即可训练出模型。 * 预测的精度比较高，预测准确率要高于基于领域的协同过滤以及基于内容CBR等方法。 * 比较低的时间和空间复杂度，高维矩阵映射为两个低维矩阵节省了存储空间，训练过程比较费时，但是可以离线完成；评分预测一般在线计算，直接使用离线训练得到的参数，可以实时推荐。 * 非常好的扩展性，如由SVD拓展而来的SVD++和 TIME SVD++。 矩阵分解的不足主要有：
* 训练模型较为费时。 * 推荐结果不具有很好的可解释性，无法用现实概念给分解出来的用户和物品矩阵的每个维度命名，只能理解为潜在语义空间。 我们用user1,2,3表示用户，item 1,2,3表示物品，Rij表示用户i对于物品j的评分，也就是喜好度。那么我们需要得到一个关于用户-物品的二维矩阵，如下面的R。
常见的系统中，R是一个非常稀疏的矩阵，因为我们不可能得到所有用户对于所有物品的评分。于是利用稀疏的R，填充得到一个满矩阵R’就是我们的目的。
下面我们就来看看LFM是如何解决上面的问题的？对于一个给定的用户行为数据集（数据集包含的是所有的user, 所有的item，以及每个user有过行为的item列表），使用LFM对其建模后，我们可以得到如下图所示的模型：（假设数据集中有3个user, 4个item, LFM建模的分类数为4）
 R矩阵是user-item矩阵，矩阵值Rij表示的是user i 对item j的兴趣度，这正是我们要求的值。对于一个user来说，当计算出他对所有item的兴趣度后，就可以进行排序并作出推荐。LFM算法从数据集中抽取出若干主题，作为user和item之间连接的桥梁，将R矩阵表示为P矩阵和Q矩阵相乘。其中P矩阵是user-class矩阵，矩阵值Pij表示的是user i对class j的兴趣度；Q矩阵式class-item矩阵，矩阵值Qij表示的是item j在class i中的权重，权重越高越能作为该类的代表。所以LFM根据如下公式来计算用户U对物品I的兴趣度
我们发现使用LFM后，
1. 我们不需要关心分类的角度，结果都是基于用户行为统计自动聚类的，全凭数据自己说了算。 2. 不需要关心分类粒度的问题，通过设置LFM的最终分类数就可控制粒度，分类数越大，粒度约细。 3. 对于一个item，并不是明确的划分到某一类，而是计算其属于每一类的概率，是一种标准的软分类。 4.</description></item><item><title>cuda error checking 学习笔记</title><link>https://111qqz.com/2018/02/cuda-error-checking-notes/</link><pubDate>Fri, 09 Feb 2018 06:55:00 +0000</pubDate><guid>https://111qqz.com/2018/02/cuda-error-checking-notes/</guid><description>
由于发现cuda c++ 的 debug方式和c++ 差别很大,因此打算再开一篇,专门记录一些和error checking 以及debug有关的内容.
Error checks in CUDA code can help catch CUDA errors at their source. There are 2 sources of errors in CUDA source code:
1. Errors from CUDA **API** calls. For example, a call to `cudaMalloc()` might fail. 2. Errors from CUDA **kernel** calls. For example, there might be invalid memory access inside a kernel. All CUDA API calls return a cudaError value, so these calls are easy to check:</description></item><item><title>多标签图像分类任务的评价方法-mean average precision(mAP) 以及top x的评价方法</title><link>https://111qqz.com/2018/02/mean-average-precision-for-multi-label-classification-task/</link><pubDate>Fri, 09 Feb 2018 03:53:09 +0000</pubDate><guid>https://111qqz.com/2018/02/mean-average-precision-for-multi-label-classification-task/</guid><description>
参考资料:
多标签图像分类任务的评价方法-mAP
wiki_Sensitivity and specificity
False Positives和False Negative等含义
mean average precision（MAP）在计算机视觉中是如何计算和应用的？
首先需要了解True(False) Positives (Negatives)的含义
True Positive （真正, TP）被模型预测为正的正样本；可以称作判断为真的正确率
True Negative（真负 , TN）被模型预测为负的负样本 ；可以称作判断为假的正确率
False Positive （假正, FP）被模型预测为正的负样本；可以称作误报率
False Negative（假负 , FN）被模型预测为负的正样本；可以称作漏报率
在图像中，尤其是分类问题中应用AP，是一种评价ranking方式好不好的指标：
举例来说，我有一个两类分类问题，分别5个样本，如果这个分类器性能达到完美的话，ranking结果应该是+1，+1，+1，+1，+1，-1，-1，-1，-1，-1.
但是分类器预测的label，和实际的score肯定不会这么完美。按照从大到小来打分，我们可以计算两个指标：precision和recall。比如分类器认为打分由高到低选择了前四个，实际上这里面只有两个是正样本。此时的recall就是2（你能包住的正样本数）/5（总共的正样本数）=0.4，precision是2（你选对了的）/4（总共选的）=0.5.
图像分类中，这个打分score可以由SVM得到：s=w^Tx+b就是每一个样本的分数。
从上面的例子可以看出，其实precision，recall都是选多少个样本k的函数，很容易想到，如果我总共有1000个样本，那么我就可以像这样计算1000对P-R，并且把他们画出来，这就是PR曲线：
这里有一个趋势，recall越高，precision越低。这是很合理的，因为假如说我把1000个全拿进来，那肯定正样本都包住了，recall=1，但是此时precision就很小了，因为我全部认为他们是正样本。recall=1时的precision的数值，等于正样本所占的比例。
所以AP，average precision，就是这个曲线下的面积，这里average，等于是对recall取平均。而mean average precision的mean，是对所有类别取平均（每一个类当做一次二分类任务）。现在的图像分类论文基本都是用mAP作为标准。
使用AP会比accuracy要合理。对于accuracy，如果有9个负样本和一个正样本，那么即使分类器什么都不做全部判定为负样本accuracy也有90%。但是对于AP，recall=1那个点precision会掉到0.1.曲线下面积就会反映出来。
precision 和 recall 的计算： &amp;amp;lt;img src=&amp;quot;https://pic2.zhimg.com/50/v2-761706f5b1fe36873ba1bb20c7d1d447_hd.jpg&amp;quot; data-rawwidth=&amp;quot;301&amp;quot; data-rawheight=&amp;quot;541&amp;quot; class=&amp;quot;content_image&amp;quot; width=&amp;quot;301&amp;quot;&amp;amp;gt; 图中上部分，左边一整个矩形中（false negative和true positive）的数表示ground truth之中为1的（即为正确的）数据，右边一整个矩形中的数表示ground truth之中为0的数据。
精度precision的计算是用 检测正确的数据个数/总的检测个数。
召回率recall的计算是用 检测正确的数据个数/ground truth之中所有正数据个数。
AP：average precision 假设我们有数据： &amp;amp;lt;img src=&amp;quot;https://pic1.</description></item><item><title>Non-local Neural Networks 阅读笔记</title><link>https://111qqz.com/2018/02/non-local-neural-networks-notes/</link><pubDate>Mon, 05 Feb 2018 02:24:34 +0000</pubDate><guid>https://111qqz.com/2018/02/non-local-neural-networks-notes/</guid><description>
先粗略读了2遍orz.可能不够严谨，先写一些high-level的理解。
对于序列或者图片数据，如果想获得一个long-range的依赖，通常的做法是循环神经网络（对于序列）或者深层的卷积神经网络（对于图片数据）
但是循环操作（当前的处理依赖于前面有限的若干个）和卷积操作都是一种局部操作。
但是这种局部操作是有一些局限的，比如不好优化，计算代价比较大等。
这篇paper提出了non-local 这个操作。
non-local操作是计算机视觉中广泛使用的一种降噪算法，即non-local mean的一般化。
non-local operation被认为是一个可以被广泛使用的操作，几乎可以和当前神经网络的其他部件结合。
含有non-local opetation的一个基本操作单元我们称之为一个 non-local block
含有non-local block 的神经网络我们可以称之为Non-local Neural Networks
non-local operation是非常有效的，及时神经网络只有很少的几层（比如5）
non-local operation和《Attention is all you need》 中提出的self-attention是相似的
全连接操作可以看做non-local operation的一个特例。
Non-local Neural Networks 原始论文</description></item><item><title>cuda 学习笔记</title><link>https://111qqz.com/2018/02/cuda-notes/</link><pubDate>Thu, 01 Feb 2018 07:20:04 +0000</pubDate><guid>https://111qqz.com/2018/02/cuda-notes/</guid><description>
uodate:有毒吧。kernel中出问题原来是不会报错的。。。。
请教了组里的hust学长orz..、
学到了cuda-memcheck命令和cudaGetLastError来查看问题。。可以参考What is the canonical way to check for errors using the CUDA runtime API?
先放一波资料。
* &amp;lt;del&amp;gt;[An Even Easier Introduction to CUDA](https://devblogs.nvidia.com/even-easier-introduction-cuda/)&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;[CUDA C/C++ Basics](https://drive.google.com/open?id=1kHYyM4yiJoyjkWjp7FJp0vae_TcvskjK)&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;[nvidia-thrust 官方文档](http://docs.nvidia.com/cuda/thrust/index.html)&amp;lt;/del&amp;gt; * [how-access-global-memory-efficiently-cuda-c-kernels](https://devblogs.nvidia.com/how-access-global-memory-efficiently-cuda-c-kernels/) * [efficient-matrix-transpose-cuda-cc](https://devblogs.nvidia.com/efficient-matrix-transpose-cuda-cc/) * [很强大的warp内shuffle](https://devblogs.nvidia.com/faster-parallel-reductions-kepler/) * [cuda-GDB官方文档](http://docs.nvidia.com/cuda/cuda-gdb/index.html) * [cuda-c-best-practices-guide](http://docs.nvidia.com/cuda/cuda-c-best-practices-guide/) cuda 提出的目的是能够让程序员透明地使用GPU来高效地进行并行运算。
kernel和c语言中的函数相似，函数名字前通常用global来标识。
下面考虑一个2个大小的1M的数组相加的例子。
总的思路是通过并行，来观察到计算速度的加快。
如果不考虑并行，2个数组相加的代码，如下：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;math.h&amp;gt; // function to add the elements of two arrays void add(int n, float *x, float *y) { for (int i = 0; i &amp;lt; n; i++) y[i] = x[i] + y[i]; } int main(void) { int N = 1&amp;lt;&amp;lt;20; // 1M elements float *x = new float[N]; float *y = new float[N]; // initialize x and y arrays on the host for (int i = 0; i &amp;lt; N; i++) { x[i] = 1.</description></item><item><title>non-local means algorithm 学习笔记</title><link>https://111qqz.com/2018/01/non-local-means-algorithm-notes/</link><pubDate>Thu, 25 Jan 2018 02:53:52 +0000</pubDate><guid>https://111qqz.com/2018/01/non-local-means-algorithm-notes/</guid><description>
终于忙完学校的事情可以干正事了orz
这里会记录一些第一遍看paper的过程中遇到的一些影响理解的概念，不过大多不会深究，只算做粗浅的理解。
1、高斯金字塔：
高斯金字塔是最基本的图像塔。首先将原图像作为最底层图像G0（高斯金字塔的第0层），利用高斯核（5*5）对其进行卷积，然后对卷积后的图像进行下采样（去除偶数行和列）得到上一层图像G1，将此图像作为输入，重复卷积和下采样操作得到更上一层图像，反复迭代多次，形成一个金字塔形的图像数据结构，即高斯金字塔。
2、拉普拉斯金字塔
在高斯金字塔的运算过程中，图像经过卷积和下采样操作会丢失部分高频细节信息。为描述这些高频信息，人们定义了拉普拉斯金字塔(Laplacian Pyramid， LP)。用高斯金字塔的每一层图像减去其高一层图像上采样并高斯卷积之后的预测图像，得到一系列的差值图像即为 LP 分解图像。
将Gl内插方法得到放大图像_Gl，使_Gl的尺寸与*Gl-1的尺寸相同，即放大算子Expand。
参考资料：
Gaussian and Laplacian Pyramids
拉普拉斯金字塔融合</description></item><item><title>20171214</title><link>https://111qqz.com/2017/12/20171214/</link><pubDate>Thu, 14 Dec 2017 12:31:33 +0000</pubDate><guid>https://111qqz.com/2017/12/20171214/</guid><description>
记得之前被人在群里刷“宽神是我们的红太阳”还不理解...
为什么我这种菜鸡要被如此对待
现在想想，大概是觉得，“111qqz那么菜的人都还一直坚持打竞赛，我为什么放弃呢”2333
hust有2年没icpc的金了，今年N队终于拿了一个很好名次的金，还是很开心。
其实一直都有一种奇怪的自责，因为自己作为壮年选手的时候，恰好是华科实力最弱的几年，总觉得是没有担当起应有的责任。 为什么是奇怪的自责...因为我的实力并不能决定华科的upper bound 。。。
现在有了训练场地，有了各方面的支持，17级还有个很厉害的学弟，希望明年或者后年能进final吧，期待
其实我科是传统弱校，就算进过final，但是感觉更多取决于选手的意志，而和学校关系不大。
希望我科能成为一个三线强校吧orz，不过还是有点难，因为华科好玩的团队实在太多了...
以及突然开始了毕设... 据说我司或者是其他这样的公司的配置都是几个Phd+一票能打的实习生发论文...
想想自己，好像并不很能打啊？不过还有点时间，虽然也不多了。
希望自己能成为一个“能打的实习生”吧orz</description></item><item><title>unicode 汉字表示不唯一的问题 (cjk字符集)</title><link>https://111qqz.com/2017/12/unicode-char-not-unique/</link><pubDate>Tue, 05 Dec 2017 02:44:46 +0000</pubDate><guid>https://111qqz.com/2017/12/unicode-char-not-unique/</guid><description>
update:
遇到的汉字：
丹：63838
李：63969
昨天写的正则发现死活识别不了 &amp;quot;年&amp;quot;字...
放到unicode编码转化公式 查了下发现竟然是不同的字orz..
其实猜想到也许是日文的&amp;quot;年&amp;quot;...结果查询了下发现是韩文的锅?
具体参考为何Unicode中有字形完全相同的CJK字符？
以及兼容汉字的参考表:UF900</description></item><item><title>正则匹配中文及常用正则表达式 (转载)</title><link>https://111qqz.com/2017/12/Common-regular-expression/</link><pubDate>Mon, 04 Dec 2017 11:34:06 +0000</pubDate><guid>https://111qqz.com/2017/12/Common-regular-expression/</guid><description>
先放一个同事安利给我的网站:regex101
查询匹配的中文字符unicode编码
正则表达式用于字符串处理、表单验证、日志数据分析等场合，实用高效。现将自己走网上搜索并总结的常用方法收集了一下：
匹配中文字符的正则表达式： [\u4e00-\u9fa5] 注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^\x00-\xff] 注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：\n\s*\r 注：可以用来删除空白行
匹配HTML标记的正则表达式：&amp;lt;(\S_?)[^&amp;gt;]&amp;gt;.?&amp;lt;/&amp;gt;|&amp;lt;._? /&amp;gt; 注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^\s_|\s_$ 注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)* 注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^\s]* 注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]$ 注：表单验证时很实用
匹配国内电话号码：\d-\d|\d-\d 注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9] 注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]\d(?!\d) 注：中国邮政编码为6位数字
匹配身份证：\d|\d 注：中国的身份证为15位或18位
匹配ip地址：\d+.\d+.\d+.\d+ 注：提取ip地址时有用
匹配特定数字： ^[1-9]\d_$　//匹配正整数 ^-[1-9]\d_$ //匹配负整数 ^-?[1-9]\d_$　//匹配整数 ^[1-9]\d_|0$　//匹配非负整数（正整数 + 0） ^-[1-9]\d_|0$　//匹配非正整数（负整数 + 0） ^[1-9]\d_.\d_|0.\d_[1-9]\d_$　//匹配正浮点数 ^-([1-9]\d_.\d_|0.\d_[1-9]\d_)$　//匹配负浮点数 ^-?([1-9]\d_.\d_|0.\d_[1-9]\d_|0?.0+|0)$　//匹配浮点数 ^[1-9]\d_.\d_|0.\d_[1-9]\d_|0?.0+|0$　//匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d_.\d_|0.\d_[1-9]\d*))|0?.0+|0$　//匹配非正浮点数（负浮点数 + 0） 注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串： ^[A-Za-z]+$　//匹配由26个英文字母组成的字符串 ^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串 ^[a-z]+$　//匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$　//匹配由数字和26个英文字母组成的字符串 ^\w+$　//匹配由数字、26个英文字母或者下划线组成的字符串 注：最基本也是最常用的一些表达式</description></item><item><title>PCA + kmeans</title><link>https://111qqz.com/2017/11/pca-kmeans/</link><pubDate>Sun, 26 Nov 2017 11:05:50 +0000</pubDate><guid>https://111qqz.com/2017/11/pca-kmeans/</guid><description>
先记录一下PCA实战需要用到的安装包(arch下,python2环境) python2-scikit-learn python2-numpy
python2-pandas
python2-matplotlib
python2-seaborn
pandas.DataFrame
pandas 数据结构介绍
几个和科学计算数据分析有关的重要的python库:Numpy、Matplotlib ,pandas
(之前数字图像处理课程都接触过了orz)
其中matplotlib 主要用于图像绘制
sklearn 是用于机器学习的python 模块
Seaborn也是用于图像绘制
str.fomat() 是 python2语法
format中的变量会按照str中{} 出现的顺序替换
import matplotlib.pyplot as plt import numpy as np import pandas as pd from sklearn.datasets import fetch_mldata from sklearn.decomposition import PCA import seaborn as sns mnist = fetch_mldata(&amp;quot;MNIST original&amp;quot;) X = mnist.data / 255.0 y = mnist.target #print X.shape, y.shape feat_cols = [ 'pixel'+str(i) for i in range(X.shape[1]) ] df = pd.</description></item><item><title>基础 Haskell 学习笔记</title><link>https://111qqz.com/2017/11/haskell-notes/</link><pubDate>Fri, 24 Nov 2017 03:18:01 +0000</pubDate><guid>https://111qqz.com/2017/11/haskell-notes/</guid><description>
出于对函数式编程语言这一技能点的缺失...以及退役之后闲得蛋疼
打算浅尝辄止地学一下haskell
这篇笔记不会写成文档那样的详尽..毕竟函数式编程语言也是编程语言...有很多和其他编程语言(命令式？)相似的地方...
所以只会写一些简单的语法+让我感到惊讶的地方orz
总体的感觉...在里面看到了些python和pascal的影子orz...比如子界...已经好久没见到了
变量 * 命令式语言中，变量用来跟踪状态（keeping track of state）。 * Haskell中，变量保存了一个值，**然后再也不可以修改它了。** * 变量不仅可以保存像3.14这样的数值，还可以保存任何Haskell表达式 函数 * 函数中的函数 Prelude&amp;gt; let areaRect l w = l * w Prelude&amp;gt; let areaSquare s = areaRect s s Prelude&amp;gt; areaSquare 5 25 列表 * 创建列表/添加元素 Prelude&amp;gt; let numbers = [1,2,3,4] Prelude&amp;gt; numbers [1,2,3,4] Prelude&amp;gt; 0:numbers [0,1,2,3,4] Prelude&amp;gt; 1:0:numbers [1,0,1,2,3,4] Prelude&amp;gt; 2:1:0:numbers [2,1,0,1,2,3,4] Prelude&amp;gt; 5:4:3:2:1:0:numbers [5,4,3,2,1,0,1,2,3,4] * 事实上所有的列表都是在一个空的列表（`[]`）的基础上通过附加数据创建的。逗号与方括号的记法实际上是一种**语法糖**般的令人愉快的形式。 换句话说，`[1,2,3,4,5]`精确地等同于`1:2:3:4:5:[]` * 列表中的元素必须有相同的类型 * 列表的嵌套(二维以及高维度) * 列表大概可以类比数组或者python 中的list * 将两个List合并是很常见的操作，这可以通过++运算符实现。运算时会遍历左边的list,**因此用:运算符往一个List前端插入元素会是更好的选择。** * 若是要按照索引取得List中的元素，可以使用!</description></item><item><title>2017 ACM-ICPC Beijing Regional 总结</title><link>https://111qqz.com/2017/11/2017-acm-icpc-beijing-regional/</link><pubDate>Tue, 21 Nov 2017 05:27:58 +0000</pubDate><guid>https://111qqz.com/2017/11/2017-acm-icpc-beijing-regional/</guid><description>
emmm 最后一场，果然还是写点什么记录一下吧。
DAY 0 到宾馆已经晚上八点了，惊讶得发现宾馆和15年来参加regional的是同一个，于是戳了下当时和我们一起来的@Always队的三个已经毕业的学长，求了波rp2333
之后大家一起去吃火锅....还算比较开心？
和我们一起去的有一个新生女队...看着她们蹦蹦跳跳的，仿佛自己也年轻了很多(逃
DAY 1 北大的衣服还是一如既往的好评。
热身赛的话...开场我先看了A，发现是个出过一万遍的傻逼题....隐约感觉15年热身赛也出了这道题...连题面都没变...
然后我就开始写A，中间队友发现B是个更傻逼的暴力题...不过还是让我先把A写完...写完发现A有奇怪的问题。。。打印下来调。。。然后队友把B过了。。。然后队友把D过了。。。然后发现竟然是抄板子少写了一对括号Orz..发现之后也过了A. 还好没浪费机时...然后还有个C...正解是最大流。。。？然而并没看出来，凉凉。索性就开始测试乱七八糟的东西。。
DAY 2 正赛。
开始前队友数了数气球，发现B题和J题的气球比较多。。。
于是开始以后，一个队友写vim配置，我和另一个队友一个看B一个看J.
看过B感觉是高斯消元+构造之类的东西。。。感觉不太像签到。
这个时候看了榜，发现了签到题，主代码手想了想，写了写，就1A了
然后发现了另一个签到题，于是2个队友继续大力干J,我首推了F的坐标变换，然后调了一小会，交，1A.
然后另两个队友的J好像差不多了，开始写，我开始开新题，发现G很可搞
队友的J写完WA了，打印代码发现是一个初始化放错位置了，再交，2A.
感觉G就是个BFS+几何，判下点是否在三角形内，于是我开始写，然后2个队友开了H.
看榜发现这个G。。大家WA得死去活来的...
写完瑟瑟发抖得交了一发，果然WA了。
想了下发现只判断终点是否在三角形里很错啊？因为过程中也不能进入三角形，因此应该是bfs的时候判断起点到终点连接的线段是否和三角形相交。于是开始改...
改了好久也过不了样例，最后发现，板子是错的......
这时候已经封榜之后半小时了。
中途队友讨论H，说应该是个线段树...数据结构题都是我来写的...然而几何题也是我来写...所以就。。。。凉凉。
就很绝望...卡得题都是我的题。。。
比赛结束，我们三个收拾好东西就走了...
到了宾馆正和队友嘿嘿嘿(误
突然另一个队友打电话过来说我们银了。。
？？？？
这也能银orz
封榜前看到那个G，我们后面的队伍交了得有100发。。。然而没什么人通过？
突然整个人都兴奋了orz
写在最后 最后一场区域赛。
其实去年(伪)退役到今年，大概有10个月没写代码了。。。
真正开始训练也就是10月7号回来以后.
所以能拿到这样的成绩已经很满意了。
我总觉得虽然大家都是北京是区域赛里的地狱模式...但是对于我们队来说，不管是15年，还是平常的训练赛，北京的题目，都是打得最舒服的。其实当时选赛区就是觉得，北京的题目比较稳以及觉得北大是我们的好运之地，所以坚持选了一个北京。看来没选错2333
退役了，退役了，愿看到这里的各位，都能拿到自己理想的成绩。</description></item><item><title>2014 Xi'An ACM-ICPC Regional Contest Problem G. The Problem to Slow Down You (回文自动机(模块化写法))</title><link>https://111qqz.com/2017/11/2014-xian-acm-icpc-regional-contest-problem-g/</link><pubDate>Tue, 14 Nov 2017 12:45:08 +0000</pubDate><guid>https://111qqz.com/2017/11/2014-xian-acm-icpc-regional-contest-problem-g/</guid><description>
http://codeforces.com/gym/100548
题意： 切换面板：标签 标签 添加新标签 ￼ 回文自动机、 给2个字符串，问2个字符串中，相等并且都是回文串的对数。
思路： 构建2个PAM.然后奇偶起点分别跑dfs即可。
PAM写成了模块化的形式orz
/* *********************************************** Author :111qqz Created Time :2017年11月14日 星期二 20时22分15秒 File Name :G.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; struct PAM { struct state { int fail,cnt,len; int nxt[26]; }st[N]; char S[N],RS[N]; int n,now,sz; void init() { ms(st,0); st[0].</description></item><item><title>bzoj 2160: 拉拉队排练 (回文自动机+快速幂)</title><link>https://111qqz.com/2017/11/bzoj-2160/</link><pubDate>Tue, 14 Nov 2017 11:50:39 +0000</pubDate><guid>https://111qqz.com/2017/11/bzoj-2160/</guid><description>
2160: 拉拉队排练 Time Limit: 10 Sec Memory Limit: 259 MB Submit: 1938 Solved: 743 [Submit][Status][Discuss]
Description 艾利斯顿商学院篮球队要参加一年一度的市篮球比赛了。拉拉队是篮球比赛的一个看点，好的拉拉队往往能帮助球队增加士气，赢得最终的比赛。所以作为拉拉队队长的楚雨荨同学知道，帮助篮球队训练好拉拉队有多么的重要。拉拉队的选拔工作已经结束，在雨荨和校长的挑选下，n位集优秀的身材、舞技于一体的美女从众多报名的女生中脱颖而出。这些女生将随着篮球队的小伙子们一起，和对手抗衡，为艾利斯顿篮球队加油助威。一个阳光明媚的早晨，雨荨带领拉拉队的队员们开始了排练。n个女生从左到右排成一行，每个人手中都举了一个写有26个小写字母中的某一个的牌子，在比赛的时候挥舞，为小伙子们呐喊、加油。雨荨发现，如果连续的一段女生，有奇数个，并且他们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。现在雨荨想找出所有和谐小群体，并且按照女生的个数降序排序之后，前K个和谐小群体的女生个数的乘积是多少。由于答案可能很大，雨荨只要你告诉她，答案除以19930726的余数是多少就行了。
Input 输入为标准输入。第一行为两个正整数n和K，代表的东西在题目描述中已经叙述。接下来一行为n个字符，代表从左到右女生拿的牌子上写的字母。
Output 输出为标准输出。输出一个整数，代表题目描述中所写的乘积除以19930726的余数，如果总的和谐小群体个数小于K，输出一个整数-1。
Sample Input 5 3 ababa
Sample Output 45 【样例说明】 和谐小群体女生所拿牌子上写的字母从左到右按照女生个数降序排序后为ababa, aba, aba, bab, a, a, a, b, b，前三个长度的乘积为。
HINT 总共20个测试点，数据范围满足： 思路： 直接PAM.
需要注意的是，PAM构建之后，再按照逆拓扑序更新一遍得到的cnt才是实际的cnt
需要注意的是，PAM构建之后，再按照逆拓扑序更新一遍得到的cnt才是实际的cnt
需要注意的是，PAM构建之后，再按照逆拓扑序更新一遍得到的cnt才是实际的cnt
/* *********************************************** Author :111qqz Created Time :2017年11月14日 星期二 19时05分14秒 File Name :2160.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL mod = 19930726; const int N=1E6+7; LL k; int n; char S[N]; struct PAM { int fail; LL cnt,len; int nxt[26]; }st[N]; int now,sz; int Right[N],Left[N]; void pam_init() { ms(st,0); st[0].</description></item><item><title>ural 1960. Palindromes and Super Abilities (回文自动机，统计本质不同的回文串个数)</title><link>https://111qqz.com/2017/11/ural-1960/</link><pubDate>Mon, 13 Nov 2017 18:14:23 +0000</pubDate><guid>https://111qqz.com/2017/11/ural-1960/</guid><description>
http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1960
题意： 给一个字符串S,依次输出字符串S的所有前缀中，本质不同的回文串个数。
思路： 考虑构建PAM是一个增量算法...所以一边构建一边输出答案就好了。。。
某一时刻本质不同的回文串个数就是sz-1 (标号是从0..sz，一共sz+1个，减去2个根，所以是sz-1)
/* *********************************************** Author :111qqz Created Time :2017年11月14日 星期二 01时01分03秒 File Name :2565.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; struct PAM { int fail,cnt,len; int nxt[26]; }st[N]; char S[N],RS[N]; int n,now,sz; void pam_init() { ms(st,0); st[0].</description></item><item><title>BZOJ 2565: 最长双回文串 (回文自动机)</title><link>https://111qqz.com/2017/11/bzoj-2565/</link><pubDate>Mon, 13 Nov 2017 18:02:49 +0000</pubDate><guid>https://111qqz.com/2017/11/bzoj-2565/</guid><description>
Description 顺序和逆序读起来完全一样的串叫做回文串。比如acbca是回文串，而abc不是（abc的顺序为“abc”，逆序为“cba”，不相同）。 输入长度为n的串S，求S的最长双回文子串T,即可将T分为两部分X，Y，（|X|,|Y|≥1）且X和Y都是回文串。
Input 一行由小写英文字母组成的字符串S。
Output 一行一个整数，表示最长双回文子串的长度。
Sample Input baacaabbacabb
Sample Output 12
HINT 样例说明
从第二个字符开始的字符串aacaabbacabb可分为aacaa与bbacabb两部分，且两者都是回文串。
对于100%的数据，2≤|S|≤10^5
2015.4.25新加数据一组
Source 2012国家集训队Round 1 day2
思路： 我们考虑增量构建PAM的时候
构建到pos,当前的状态的len其实就是到以pos位置结尾的最长回文串的长度。
那么我们只需要正着做一遍，再倒着做一遍，然后枚举断点就行了。
时间复杂度O(n)
/* *********************************************** Author :111qqz Created Time :2017年11月14日 星期二 01时01分03秒 File Name :2565.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; struct PAM { int fail,cnt,len; int nxt[26]; }st[N]; char S[N],RS[N]; int n,now,sz; int Right[N],Left[N]; //right[i]表示以i结尾的最长回文串的长度 //left[i]表示以i开头的最长回文串的长度,需要反转母串构建PAM求得 void pam_init() { ms(st,0); st[0].</description></item><item><title>hdu 3948 | 2011 Multi-University Training Contest 11 The Number of Palindromes (回文自动机模板题)</title><link>https://111qqz.com/2017/11/hdu-3948/</link><pubDate>Mon, 13 Nov 2017 15:56:30 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-3948/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=3948
题意： 给一个字符串，问本质不同的回文子串的个数。
思路： 考虑回文自动机。
我们知道，对于PAM上的一个节点，表示的就是一个本质不同的回文串。
UPDATE: 弃用了这种代码风格,新的写法见下面。
那么sz-2就是本质不同的回文子串个数了orz(减掉2是因为PAM有2个根，这2个根不表示回文串）
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; typedef long long LL; #define ri register int using namespace std; #define MAXALP 30 #define ms(a,x) memset(a,x,sizeof(a)) const int N = 3E5+7; struct PAM { int cnt,len,fail; int nxt[MAXALP]; }st[N]; int n, m, sz , last, cur; char s[N]; inline int new_node(int x) { st[sz].len = x; st[sz].cnt = 0; ms(st[sz].nxt,0); return sz++; } inline int get_fail(int x, int n) { while(s[n-st[x].</description></item><item><title>UOJ #103. 【APIO2014】Palindromes (回文自动机模板题)</title><link>https://111qqz.com/2017/11/uoj-103/</link><pubDate>Mon, 13 Nov 2017 15:25:57 +0000</pubDate><guid>https://111qqz.com/2017/11/uoj-103/</guid><description>
http://uoj.ac/problem/103
题意： 给你一个由小写拉丁字母组成的字符串 s。我们定义 s 的一个子串的存在值为这个子串在 s 中出现的次数乘以这个子串的长度。
对于给你的这个字符串 s，求所有回文子串中的最大存在值。
思路： 回文自动机，也叫回文树，但其实并不是树2333,所以以后还是称为回文自动机，缩写为PAM
学会了(?)SAM之后再看PAM真是简单得一逼。
学习笔记之后补。
对于这道题，PAM中一个状态的cnt表示的该状态所表示的回文串出现的次数
len表示的是该状态所表示的回文串的长度
UPDATE:
下面的代码风格太丑了，打算弃用。
更新的代码风格见最后
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; typedef long long LL; #define ri register int using namespace std; #define MAXALP 30 #define ms(a,x) memset(a,x,sizeof(a)) const int N = 3E5+7; struct PAM { int cnt,len,fail; int nxt[MAXALP]; }st[N]; int n, m, sz , last, cur; char s[N]; inline int new_node(int x) { st[sz].</description></item><item><title>codeforces 123D. String(后缀自动机)</title><link>https://111qqz.com/2017/11/codeforces-123d/</link><pubDate>Mon, 13 Nov 2017 11:03:24 +0000</pubDate><guid>https://111qqz.com/2017/11/codeforces-123d/</guid><description>
题目链接：http://codeforces.com/problemset/problem/123/D
题意： 如果字符串y在字符串x中出现n次，那么F(x,y)=n*(n+1)/2
现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串．
思路： 这道题可以考虑用后缀数组做，麻烦一点：codeforces-123D-解题报告(SA)
直接SAM
right[v]就是SAM上状态表示的所有字符串出现的次数。
那么每个状态的答案就是right[v](right[v]+1)/2(st[v].len-st[st[v].link].len)
累加即可。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :3518.cpp ************************************************ */ //#include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 55 //还有大写字母orz int k; struct state { int len, link, nxt[MAXALP]; }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int Right[2*N]; int cnt[2*N],rk[2*N];//for radix sort int dp[2*N],lazy[2*N]; void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>poj 3415 Common Substrings (后缀自动机+parent树上的lazy标记)</title><link>https://111qqz.com/2017/11/poj-3415/</link><pubDate>Sun, 12 Nov 2017 12:40:24 +0000</pubDate><guid>https://111qqz.com/2017/11/poj-3415/</guid><description>
http://poj.org/problem?id=3415
题意： 给出两个字符串，问公共长度大于等于k的子串个数（只要两个串的位置不同就认为是不同）
思路： 考虑SAM的性质。
SAM上的一个节点所能接受的本质不同的子串个数是**st[v].len - st[st[v].link].len**
而这些子串，都出现了right[v]次，因为不同子串的个数就是**(st[v].len-st[st[v].link].len)right[v]*
现在有了限制条件，要求长度大于等于k.
没有限制的话，SAM上的一个节点所能接受的字符串的长度范围是在[st[st[v].link].len+1,st[v].len]
那么现在范围其实就变成了**[MX,st[v].len],其中MX = max{st[st[v].link].len+1,k}**
对于A串构建SAM，然后B串在SAM上运行
考虑对于SAM的某个状态，B串此时的最大匹配长度为len，那么len&amp;gt;=MX时，满足条件的字符串的范围就变成了**[MX,len] **
len&amp;lt;MX时无贡献。
所以该状态(v)对答案的就是 (len-MX+1)*right[v]
然而这还不算完，和之前的LCS2一样，如果SAM上的一个节点能匹配字符串B的长度大于等于k，那么该节点的祖先节点（父亲节点，父亲的父亲的节点...)
能匹配的字符串B的长度也都大于等于k...
如果我们一边匹配一边沿着parent树自底向上传递的话...复杂度n^2,一首凉凉送给自己
但是正常人会这样？.jpg
我们先打个标记，最后沿parent树自底向上把标记传递上去就行了。。
需要注意的是，此题的字符集是大小写字母都会包含...RE了2发orz
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :3518.cpp ************************************************ */ //#include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 55 //还有大写字母orz int k; struct state { int len, link, nxt[MAXALP]; }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int Right[2*N]; int cnt[2*N],rk[2*N];//for radix sort int dp[2*N],lazy[2*N]; void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>hdu 4416 Good Article Good sentence (后缀自动机)</title><link>https://111qqz.com/2017/11/hdu-4416/</link><pubDate>Sat, 11 Nov 2017 22:44:03 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4416/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4416
题意： 给出一个字符串A和n个字符串B,问A的子串中，不在任何一个B中出现的本质不同的子串有多少。
思路： 还是根据len搞事情
我们知道，如果不加任何条件，SAM中一个节点所表示的本质不同的子串数量是st[i].len - st[st[i].link].len
现在加了限制条件。
那么该状态中，有一些长度的字符串就会不满足条件。
我们考虑对母串A构建SAM
那么只需要维护B的所有串，对于某个状态能匹配的最大长度，设为maxlen,那么 长度为[maxlen+1,st[i].len]的字符串可以贡献答案。
如果maxlen为0，则该状态所表示的所有本质不同的子串都可以贡献答案。
维护最大匹配长度 可以参考 spoj-lcs2 解题报告 
有所不同的是不需要在每一个B中都匹配，只需要至少一个匹配就行了，因此是取所有串的最大匹配长度即可。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :4416.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 30 const int mod = 2012; struct state { int len, link, nxt[MAXALP]; }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],rk[2*N];//for radix sort int dp[2*N]; void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>hdu 3518 Boring counting (后缀自动机)</title><link>https://111qqz.com/2017/11/hdu-3518/</link><pubDate>Sat, 11 Nov 2017 21:14:00 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-3518/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=3518
题意： 给一个字符串，问字符串中，至少出现2次且不相交的本质不同的子串有多少个。本质不同给的子串是说存在至少一位的字母不同。
思路： 考虑SAM
SAM上的一个节点表示的是一段长度从[st[st[i].link],len+1,st[i].len]的字符串。
考虑其right集合，如果right集合中最大的r设为rightmost,最小的r设为leftmost.
那么如果rightmost-leftmost+1 &amp;gt; st[i].len ，说明什么呢？
说明该状态所表示的最长的字符串能够至少放下两个而不重叠。
即从[leftmost-st[i].len+1,leftmost]一段 和 从[rightmost-st[i].len+1,rightmost]一段。
如果最长的能放下，那么其他的也一定能放下。因此对答案贡献为st[i].len - st[st[i].link].len
如果rightmost-leftmost+1&amp;lt;=st[i].len，也就是rightmost-leftmost&amp;lt;st[i].len
这个时候长的字符串因为重叠了不能出现2次，但是短的字符串仍然可以贡献答案。
考虑如下图：
此时对答案的贡献为rightmost-leftmost+1 - (st[st[i].link].len+1),化简得到rightmost-leftmost-st[st[i].link].len
综合2种情况，SAM中每个节点对答案的贡献是** min(rightmost-leftmost,st[i].len)-st[st[i].link].len**
需要注意的是只有在st[i].link存在并且rightmost-leftmost&amp;gt;st[st[i].link].len 时 才更新答案
leftmost可以在构建的时候直接求出,rightmost用拓扑序更新下即可。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :4436.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 30 const int mod = 2012; struct state { int len, link, nxt[MAXALP]; int leftmost; //由于要求出现位置最小的，所以维护某个状态的right集合中r值最小的 int rightmost; }; const int N =1E3+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],rk[2*N];//for radix sort void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>hdu 6059 | 2017 Multi-University Training Contest - Team 3 Kanade's trio (trie)</title><link>https://111qqz.com/2017/11/hdu-6059/</link><pubDate>Sat, 11 Nov 2017 18:04:34 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-6059/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6059
题意： 含 N 个数字的 A 数组，求有多少个三元组 (i,j,k) 满足 i&amp;lt;j&amp;lt;k 且a[i]^a[j] &amp;lt; a[j]^a[k]
思路: 考虑a[i]和a[k]二进制不同位中的最高位，此时满足题意的a[j]是该位与a[i]相同，其他位任意的所有a[j]的个数。
我们可以从1..n，依次插入a[k]到trie中,插入时，顺便用num[i][j]统计二进制第i位为j的数的个数。
当要插入a[k]时，a[1]..a[k-1]已经插入到了trie中。
trie上统计当某个节点，该位为0的数的个数和该为为1的数的个数。
需要注意这样统计出的数并不能保证i&amp;lt;j (但是可以保证i&amp;lt;k。。。)
因为我们的trie需要额外维护一部分ext.具体解释见代码注释。
/* *********************************************** Author :111qqz Created Time :2017年11月12日 星期日 01时30分29秒 File Name :6059.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int a[N]; int num[35][2];//cnt[i][j] 表示二进制表示中第i位为j的数的个数 struct Trie { struct Node { Node *nxt[2]; LL cnt[2];//需要统计前缀为某个串，该位置为0和该位置为1的个数。 LL ext[2]; Node() { for ( int i = 0 ; i &amp;lt; 2; i++) nxt[i] = NULL; cnt[0]=cnt[1]=0 ; ext[0]=ext[1]=0; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(int x) { Node *u = root; for ( int i = 29 ; i &amp;gt;= 0 ; i--) { int y = (x&amp;gt;&amp;gt;i)&amp;amp;1; num[i][y]++; //统计二进制第i位为y的数的个数 u-&amp;gt;cnt[y]++; //统计trie树上当前节点数的个数 u-&amp;gt;ext[y]+=num[i][y]; //把此时插入的数看做a[i]，那么u-&amp;gt;ext[y]就是满足j&amp;lt;=i 的j的数目 //因为之后要用到，所以要提前维护 if (u-&amp;gt;nxt[y]==NULL) u-&amp;gt;nxt[y] = new Node(); u = u-&amp;gt;nxt[y]; } } LL Cal( int x) { Node *u = root; LL res = 0 ; for ( int i = 29 ; i &amp;gt;= 0 ; i--) { int y = (x&amp;gt;&amp;gt;i)&amp;amp;1; res += num[i][y^1]*u-&amp;gt;cnt[y^1]-u-&amp;gt;ext[y^1]; //对于此时插入的a[k]的二进制第i位（从低往高）的数y,只有当a[i]和a[j]的第i位为1-y时，才会贡献答案。 // num[i][y^1]为第i位为1-y的a[j]的个数（a[j]的其他位，包括比i高的位和比i低的位都不受限制 // u-&amp;gt;cnt[y^1]表示trie树上，从rt到p节点所表示的二进制位上，a[i]与a[k]一直相同，p的下一个节点a[i]与a[k]的二进制位不同 的 a[i]的个数 u = u-&amp;gt;nxt[y]; if (u==NULL) break; } return res; } }trie; void solve() { trie.</description></item><item><title>hdu 5558 | 2015ACM/ICPC亚洲区合肥站 G Alice's Classified Message (后缀自动机)</title><link>https://111qqz.com/2017/11/hdu-5558/</link><pubDate>Sat, 11 Nov 2017 14:34:06 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-5558/</guid><description>
题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=5558
题意： 说了一大堆。。其实就是询问位置i开始的后缀和以位置[0...i - 1]开始的所有后缀中最大匹配的公共前缀长度
思路： 这个动态的过程很容易想到SAM啊。。
所以就一边匹配。。一边构建SAM就好了。。
需要注意的是，如果有多个最长，需要输出最左边的位置。
因此多维护一个leftmost,表示某个字符串第一次出现的结尾的位置。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :4436.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 30 struct state { int len, link, nxt[MAXALP]; int leftmost; //由于要求出现位置最小的，leftmost表示第一次出现的右端点位置。 }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],rk[2*N];//for radix sort void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>SPOJ LCS2 Longest Common Substring 2[后缀自动机+dp]</title><link>https://111qqz.com/2017/11/spoj-lcs2/</link><pubDate>Sat, 11 Nov 2017 07:11:25 +0000</pubDate><guid>https://111qqz.com/2017/11/spoj-lcs2/</guid><description>
题意： 求n个串的最长公共子串，n&amp;lt;=10
思路： 不会啊orz
先放一波参考资料&amp;amp;题解好了。
codeforces_Understanding Suffix Automaton in depth
code风景区_spoj_lcs2
code风景区_sam教学
candy SPOJ 1812 LCS2 [后缀自动机 DP]
首先参考下2个串的LCS的做法spoj-lcs
卧槽终于懂了...
一个串在上面走的时候记录与每个状态公共子串的最大值，注意**出现次数向父亲传递**，一个状态能到达说明了Suffix Link指向的状态可以取到最大子串，这一步对val后基数排序然后倒着更新就行了 ...代码之后补
关键是理解这句话：一个状态能到达说明了Suffix Link指向的状态可以取到最大子串
比如如果状态S（从初始状态到S状态所表示的子串是abcbc） 能够最长向前匹配的长度是x,那么状态s的par的状态Q(从初始状态到Q状态所表示的子串是bc）也至少为x.
所以dp[link[v]] = Max{dp[link[v]],dp[v]}
妈个鸡。。。
没事改什么字符集大小啊。。。
上道题做的是数字。。就手贱把字符集的大小改成了12.。。忘了改回来。。WA到死。。。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :4436.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 30 const int mod = 2012; struct state { int len, link, nxt[MAXALP]; }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],rk[2*N];//for radix sort int dp[2*N],maxlen[2*N]; void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>hdu 4819 2013 Asia Regional Changchun G (四叉树|| 二维线段树单点更新 模板题)</title><link>https://111qqz.com/2017/11/hdu-4819/</link><pubDate>Thu, 09 Nov 2017 12:59:36 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4819/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4819
题意： 给你一个n*n的矩阵， 每个点是一个数字， Q个操作，每次选择一个子矩阵， 把中心元素替换成子矩阵中最大值和最小值之和的二分之一。
思路: 显然是一个二维线段树.....
然而菜鸡如我，并没有写过二维线段树啊？
那怎么办呢
一首《凉凉》送给自己
然而我们还有四叉树2333
2A，写错一个地方。第一次写四叉树，orz
#include &amp;lt;bits/stdc++.h&amp;gt; #define ms(a,x) memset(a,x,sizeof(a)) #define lowbit(x) (x&amp;amp;(-x)) using namespace std; typedef long long LL; const double eps = 1e-8; const double PI = acos(-1.0); const int N=805; int n; int a[N][N]; struct Tree { int mn,mx; Tree() { mn = 1E9; mx = 0; } void init() { mn = 1E9; mx = 0; } }tree[N*10000]; int _max( int a,int b,int c,int d) { int ret = max(a,b); ret = max(ret,c); ret = max(ret,d); return ret; } int _min( int a,int b,int c,int d) { int ret = min(a,b); ret = min(ret,c); ret = min(ret,d); return ret; } void PushUp( int rt) { // cout&amp;lt;&amp;lt;&amp;quot;rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; tree[rt].</description></item><item><title>hdu 4436 | 2012 Asia Tianjin Regional Contest str2int (dp+后缀自动机，多串建立)</title><link>https://111qqz.com/2017/11/hdu-4436/</link><pubDate>Thu, 09 Nov 2017 05:55:24 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4436/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4436
题意： 给出n个仅由数字组成的字符串，问n个字符串的所有不同子串的和。
思路： SAM水题
从初始状态开始，走过所有路径，就是该SAM表示的所有的（不重复）子串。
因此只需要从根节点按照拓扑序（这回是根据len从小到大）转移好了。
考虑num[i]表示从SAM中的init状态到i状态能表示的子串的数量。
dp[i]表示从SAM中的init状态到i状态所表示的子串对应的和（也就是到该节点的子串的答案）
那么对于SAM中一个u-&amp;gt;v（其中u和v是状态，设转移边为j，j属于0..9）的转移
有num[v]+=num[u]
dp[v] = dp[u] * 10 + num[u] * j
初始根节点num[rt]=1,表示唯一的空串。
需要注意，前缀0的数不考虑，所以SAM中 init状态不转移0这条边。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :4436.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 12 const int mod = 2012; struct state { int len, link, nxt[MAXALP]; }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],rk[2*N];//for radix sort void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>SPOJ SUBLEX Lexicographical Substring Search （ 后缀自动机）</title><link>https://111qqz.com/2017/11/spoj-sublex/</link><pubDate>Wed, 08 Nov 2017 13:15:20 +0000</pubDate><guid>https://111qqz.com/2017/11/spoj-sublex/</guid><description>
http://www.spoj.com/problems/SUBLEX/en/
题意： 给一个字符串，每次询问字典序第k大的不重复子串。
思路： 先做个拓扑dp，求出SAM上，一个状态到种态的路径数。
拓扑dp其实就是按照拓扑序的dp啦...
然后从SAM的初始态开始，每次字典序从小到大得贪心寻找。思想类似可持久化线段树求区间第k大。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :sublex.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 26 struct state { int len, link, nxt[MAXALP]; }; const int N =3E5+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],a[2*N];//for radix sort int sum[2*N]; //表示状态i到终态的路径数 void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>spoj nsubstr Substrings (后缀自动机 模板题)</title><link>https://111qqz.com/2017/11/spoj-nsubstr/</link><pubDate>Wed, 08 Nov 2017 12:16:05 +0000</pubDate><guid>https://111qqz.com/2017/11/spoj-nsubstr/</guid><description>
http://www.spoj.com/problems/NSUBSTR/en/
题意： f[i]指长度为i的串出现次数的最大值。这里的不同出现指，可以有重复串，只要起始位置不同就视为不同的出现。
求f[1]..f[lenth]。
思路： 我们知道，SAM上的节点是right集合的等价类。
一个子串的right集合是指在一个母串中，某个子串所有出现位置的右端点的集合。
如果两个子串的right集合完全相同，那么就可以归结为同一个节点，也就是说这两个子串对于SAM是等价的。
因为在SAM上，这两个子串后，添加若干字符得到的后缀都是一样的。
所以一个SAM节点的个数，就是right集合等价类的个数（如果不考虑初始状态）
对于SAM某一个节点，其能表示的子串有一个范围，设为[MIN,MAX]
SAM的一个节点能表示的子串的含义是说，这些子串的right集合相同。
而一个子串出现的次数就是其right集合的大小。
考虑SAM上的某个节点，其表示的长度区间在[MIN,MAX]的子串都出现了|right|次
如果我们直接从MIN更新到MAX有点太暴力了，实际上这里我们可以只更新f[MAX]
由于长度i-1的子串出现的次数一定大于等于长度为i的子串出现的次数，所以最后长度从大到小更新f即可。
现在的问题就变成了如何求right集合。
实际上我们不需要知道right集合的具体组成，只需要知道right集合的大小。
考虑一棵parent树，树上某个节点的right集合就是该节点的所有儿子节点的right集合的并集
因此我们只需要在parent上自低向上更新right集合的大小就可以了。
如何保证在parent树上是自底向上更新呢？
我们只需要按照len,也就是SAM中所有节点能表示的子串的MAX值从大到小的顺序更新right集合。
原因是parent树上，儿子的len一定比父亲的len长。
注意到，对于parent树上的叶子节点，其right集合是1，这也是我们的初始状态。
部分实现细节见代码注释。
关于SAM的详细学习笔记日后补
20171109Update:
注释写错了一处，a[1]应该是len最短的状态的标号，之前写成了最长的。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :nsubstr.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 26 struct state { int len, link, nxt[MAXALP]; }; const int N =3E5+7; state st[N*2]; int Right[2*N]; //right[i]表示第i个状态的right集合大小 int sz, last,rt; char s[N]; int cnt[2*N],a[2*N];//for radix sort void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>poj 1949 Chores (拓扑排序+dp)</title><link>https://111qqz.com/2017/11/poj-1949/</link><pubDate>Wed, 08 Nov 2017 08:02:31 +0000</pubDate><guid>https://111qqz.com/2017/11/poj-1949/</guid><description>
http://poj.org/problem?id=1949 题意： 有n个任务，第i个任务需要时间xi来完成，并且第i个任务必须在它 “前面的” 某些任务完成之后才能开始。
给你任务信息，问你最短需要多少时间来完成任务。
思路： 拓扑排序+dp
拓扑排序的过程中做个dp，可以保证dp的顺序...
对于这道题，找出每条依赖链，然后做dp即可。
/* *********************************************** Author :111qqz Created Time :2017年11月07日 星期二 13时52分27秒 File Name :3249.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector &amp;lt;int&amp;gt;edge[N]; int in[N],out[N]; int n; int dp[N]; int val[N]; void init() { for ( int i = 0 ; i &amp;lt; N ; i++) edge[i].</description></item><item><title>hdu 4777 Rabbit Kingdom (树状数组+预处理)</title><link>https://111qqz.com/2017/11/hdu-4777/</link><pubDate>Wed, 08 Nov 2017 07:05:29 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4777/</guid><description>
https://vjudge.net/problem/47450/origin
题意： 有一个含有n个数的序列，m个询问。问 [l, r] 区间内与所有数都互质的数有几个？
思路： 想到了预处理每个数最左最右的，最远的互质的数的范围。。
之后对于询问区间[l,r]，我们要知道 对于 i&amp;gt;=L &amp;amp;&amp;amp; i &amp;lt;= R 并且 a[i].l&amp;lt;=L，a[i].r&amp;gt;=R的i的个数...
没有想到怎么维护,gg
转载一段题解：
先算出每个数的有效范围，l[i]，r[i]代表与第i个数一直互质到的最左端和最右端。这个处理方法是，预处理出一张因子表。然后对每个输入的数，判断其因子出现的最接近它的位置。从左到右扫一遍求出l[i]，从右到左扫一遍求出r[i]；我们还需要用一个vector记录下左边界为i时的所有数。 我们思考一个范围内，当一个数的l[i]和r[i]都在范围之外时，这个数会被统计在内。反过来讲就是一个范围在一个数的边界之内，当前的数会被统计到范围之内。
我们先对问题进行离线处理，先根据问题的左边界排序。我们需要维护一个树状数组来统计和增减值。
然后我们按照i从1到n扫一遍，i代表的意义是左边界。
当扫到第i个数时，我们统计左边界为i+1的问题(这样范围一定满足左边界，因为右边界接下来也进行了处理，所以可以直接统计）。
 我们还需要更新第i个数。i的意义是左边界，因为之后统计的问题左边界都大于i，都满足。所以我们找到所有左边界为i的数，将其+1处理。然后右边界-1处理。这样如果问题的边界大于右边界的话，这个数就不会统计在内。
 最后处理完i后，因为以后问题的左边界都大于i，所以第i个数不会再被统计了，所以我们要除去第i个数的影响，就是把其右边界+1（自身为什么不处理，因为处不处理都一样，不会在涉及到它本身了）
转载又一段题解：
先预处理出来每个数的贡献区间，每个数的贡献区间是 [左边最近不互质数的位置，右边最近不互质数的位置] ，现在问题就转化为了求区间 [L, R] 中有几个数的贡献区间能完整覆盖 [L, R] 区间。但是数据范围挺大的，可以考虑用树状数组离线处理来达到优化的目的。先对所有的查询进行排序 (按照L升序排列) ，然后从左到右依次处理。我们用树状数组区间和sum [L, R] 表示区间[L, R]中符合题意的有多少个数。假设现在需要查询 [L, R] 区间，我们可以考虑贡献区间L[i]</description></item><item><title>poj 3249 Test for Job (拓扑排序+dp)</title><link>https://111qqz.com/2017/11/poj-3249/</link><pubDate>Tue, 07 Nov 2017 06:13:22 +0000</pubDate><guid>https://111qqz.com/2017/11/poj-3249/</guid><description>
http://poj.org/problem?id=3249
题意： 给一个DAG,现要从一条入度为0的点到一个出度为0的点，问最大点权和。
思路： 其实比较容易想到搜...不过复杂度会炸？
由于到一个点的最大点权和，需要更新完所有到达它的路线之后才能确定。
容易联想到拓扑排序，我们可以在拓扑排序的同时做dp
dp[v] = max(dp[v],dp[u]+a[v])，初始化对于入度为0的点，dp[i] = val[i].
其实拓扑+dp是一种比较一般化的套路...？
因为拓扑保证了更新顺序
/* *********************************************** Author :111qqz Created Time :2017年11月07日 星期二 13时52分27秒 File Name :3249.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector &amp;lt;int&amp;gt;edge[N]; int in[N],out[N]; int n,m; int dp[N]; int val[N]; void init() { for ( int i = 0 ; i &amp;lt; N ; i++) edge[i].</description></item><item><title>hdu 6048 | 2017 Multi-University Training Contest - Team 2 D Puzzle (结论题)</title><link>https://111qqz.com/2017/11/hdu-6048/</link><pubDate>Mon, 06 Nov 2017 11:09:10 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-6048/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6048
题意： 有 n * m - 1 个数，每次选择第 1,p + 1,p * 2 + 1….. 的顺序选择数，先按左到右，再按从上到下的顺序填入n * m 的格子，空格子可以和相邻的数字交换位置，问最后能否在格子中形成 1~ n * m - 1的数按从左到右，从上到下的顺序。
思路： 傻逼结论题。
根据九宫格问题的结论：将矩阵中的数按先从左到下右再从上到下排成一列，其逆序对如果为偶数则一定有解，否则一定无解
根据九宫格问题的结论：将矩阵中的数按先从左到下右再从上到下排成一列，其逆序对如果为偶数则一定有解，否则一定无解
根据九宫格问题的结论：将矩阵中的数按先从左到下右再从上到下排成一列，其逆序对如果为偶数则一定有解，否则一定无解
然后我们可以观察发现，按照题目中填数的策略
按照填入的顺序，每个数对逆序对的贡献分别是0,p-1,2_(p-1)... 0,p-1,2_(p-1)...
注意到当总数小于等于p时，所有数对逆序对就没有贡献了。
然后直接算等差数列就好了。
$$ sum = n_a_{1} + \frac{n_(n-1)}{2}*d $$
由于首项一直为0，所以只要算后面那部分就好了。
/* *********************************************** Author :111qqz Created Time :2017年11月06日 星期一 18时45分04秒 File Name :6048.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m,p; int tot; LL ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;.</description></item><item><title>hdu 4782 | 2013 Asia Chengdu Regional Contest B (模拟)</title><link>https://111qqz.com/2017/11/hdu-4782/</link><pubDate>Mon, 06 Nov 2017 09:42:38 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4782/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4782
题意： 将格式混乱的html代码输出成标准格式。
思路： 模拟。
说下细节：
* 遇到open tag,先打印，后dep++ * 遇到close tag,先dep--,再打印 * 遇到空标签，直接在当前深度打印 * 遇到空白字符时，只有当前面出现了text以及后面也出现了text的时候才打印。**也就是说第一个string和最后一个string都是紧邻标签的。** 最坑的一点是...虽然题目给了数据组数，但是在所在行的同一行，可能出现下一组的开始
最坑的一点是...虽然题目给了数据组数，但是在所在行的同一行，可能出现下一组的开始
最坑的一点是...虽然题目给了数据组数，但是在所在行的同一行，可能出现下一组的开始
说好的多组数据呢...
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long LL; const int N = 1E5+10; const double eps = 1e-8; #define ms(a,x) memset(a,x,sizeof(a)) #define lowbit(x) (x&amp;amp;(-x)) char buff[N]; int len = 0; char ch; void skip() { while (ch=='\n'||ch==' '||ch=='\t') ch =getchar(); } void TAG() { len = 0; ch =getchar(); while (ch!</description></item><item><title>【施工中】SAM学习笔记</title><link>https://111qqz.com/2017/11/suffix-automaton-notes/</link><pubDate>Sat, 04 Nov 2017 07:07:26 +0000</pubDate><guid>https://111qqz.com/2017/11/suffix-automaton-notes/</guid><description>
***在学习后缀自动机之前需要熟练掌握WA自动机、RE自动机与TLE自动机*** 怕是老年人的最后一篇算法学习笔记了
心情不好，此文无限期tj
概述 主要讲解在我学习的过程中比较难理解的地方..并不保证全面
首先，后缀自动机是一个能且只能接受一个字符串的所有后缀的确定性有限状态自动机，也就是DFA
SAM同时具有自动机和树的性质。
节点（状态） SAM中的节点，也叫状态。
明确一个说法：“一个节点所表示的字符串”。
由于一个字符串的子串一定是某个后缀的前缀。
因此一个字符串的子串一定可以在SAM上运行。
因此“一个节点Q所表示的字符串”的含义是说，从初始状态开始，运行该字符串后，到达的状态是Q.
一个节点所表示的字符串长度属于范围[MIN,MAX]，并且区间中每个长度的字符串都出现一次
能表示的字符串长度范围有最大值很好理解，有最小值是因为：长度越小的字符串出现的位置越多，因此当长度小于MIN之后，其出现的位置增加。
由于后文见到，SAM中状态是终点位置集合的等价类，因此一个节点所表示的字符串长度存在一个最小值。
后文还问见到，一个节点的MIN恰好是其父亲节点的MAX+1
终点集合 (endpos / Right) 终点集合一般国内的资料叫right集合，国外好像更常见的叫法是endpos集合。
其实就是对于一个子串a,其在母串S中出现的位置的右端点的集合。
那么这个right集合有什么作用呢？
考虑naive的做法，一个串S有O(n^2)的后缀，凉凉
那么我们发现，对于right集合相同的两个子串，代表其子串的状态（意思是说，从初始状态到该状态所表示的字符串）是可以合并的。
为什么？因为这两个子串的所有出现位置的右端点相同，那么在其后面添加若干字符得到的后缀也一定完全相同。
那么我们可以根据right集合，将字符串的子串分成若干个等价类
对于一个等价类，我们在SAM中用一个状态表示就行了。
接下来考虑right集合的性质。
right[v]表示状态v所表示的子串出现的次数。
后缀链/parent树 对于不为初始状态的所有状态，一个状态对应着一个等价类，令w作为其中最长的子串，其余的子串都是w的后缀。
w的所有后缀中，一部分在w所在的等价类中，另外一部分位于其他的等价类中。于是定义后缀链link(v)连接w所有后缀中位于其他等价类并且长度最长的那个后缀所在的等价类。
那么根据后缀链的定义，以及后缀的长度是连续的(“后缀的长度是连续的”的含义是说，一个长度为k的字符串，一定有长度为k，为k-1，一直到长度为１的后缀）
因此一个节点的MIN恰好是其父亲节点的MAX+1　（MIN,MAX分别表示一个节点所能表示的字符串的最小值和最大值）
复杂度 后缀自动机·张的知乎专栏_震惊！SAM复杂度竟如此显然！
%%%qc大爷
构造方法 这个算法是**在线**的，每次在构造好的自动机的基础上增加一个字符。 对于每个状态，需要保存lenlen、linklink以及转移状态信息。
初始条件下，自动机只包含一个起始状态t0t0，len=0len=0并且linklink指向-1。所有算法要做的就是给后缀自动机增加一个新的字符c。
* 我们用lastlast来表示当前需要增加一个字符的状态，初始情况下last=0last=0，之后每次增加字符后都会修改。 * 创建一个新的状态curcur，要求len(cur)=len(last)+1len(cur)=len(last)+1，linklink先留着。 * 接下来进行这样的循环：从lastlast状态开始，如果不存在字符c的转移，那么增加一个到达curcur的字符c的转移，然后沿着后缀链继续检查——如果不存在字符串c的转移，那么增加一个转移；如果字符串c的转移已经存在，那么停止循环，将停止时检查的状态记为p。这个时候，会出现两种情况： * 如果一直没有遇到存在转移的状态，那么最终我们会到达伪状态-1，只需要让link(cur)=0link(cur)=0后退出。 * 如果遇到存在字符c转移的状态，另q为转移到的状态，那么又有了两种情况： * 如果len(p)+1=len(q)len(p)+1=len(q)，只需要令link(cur)=qlink(cur)=q后退出。 * 否则，创建一个新的状态cloneclone，将q的转移也拷贝给clone，令len(clone)=len(p)+1len(clone)=len(p)+1。然后，将状态cur和状态q的后缀链指向clone。最后需要完成的事情就是，遍历p的后缀链上的状态，如果存在指向状态q的字符c转移，那么将这个转移重定向到clone（如果不存在，遍历停止） * 在任何一种情况下，最后都需要将last设置为cur。 根据后缀链的定义，last开始的后缀链上的状态就是自动机的所有终止状态。
我的模板 出于太懒的原因，没有封装
需要注意的是，状态数要开到字符串长度的２倍，以及预处理之前先拓扑</description></item><item><title>poj 1509 Glass Beads (后缀自动机求最小循环表示)</title><link>https://111qqz.com/2017/11/poj-1509/</link><pubDate>Sat, 04 Nov 2017 06:58:49 +0000</pubDate><guid>https://111qqz.com/2017/11/poj-1509/</guid><description>
题意： 给定一个循环字符串，问字典序最小的串的开始位置。
思路： 之前用poj 1509 解题报告-字符串的最小表示法 A过
字符串的最小表示法的复杂度是O(n)，代码也不是很难写，不过由于最近在学SAM,所以用SAM写了一下。
参照张天扬的论文：
把原串复制一遍到后面，然后构建后缀自动机。 从初始状态开始，每次走字典序最小的转移，走|S|之后得到的就是最小循环表示。
如果求的是最小后缀，就在原串后加入一个比字符集中所有字符的字典序都小的字符作为终止后，再添加一遍原串。
/* *********************************************** Author :111qqz Created Time :2017年11月03日 星期五 18时20分42秒 File Name :2774_SAM.cpp ************************************************ */ //#include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cstring&amp;gt; #define PB push_back #define fst first #define sec second #define lnxt l,m,rt&amp;lt;&amp;lt;1 #define rnxt m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int maxn = 5E5; struct node{ node*nxt[26],*fail; LL len,cnt; }; struct SAM{ node no[maxn]; node*root; int cnt; node*newnode(){ ms(no[cnt].</description></item><item><title>hdu 4622 | 2013 Multi-University Training Contest 3 Reincarnation (后缀自动机)</title><link>https://111qqz.com/2017/11/hdu-4622/</link><pubDate>Sat, 04 Nov 2017 04:31:38 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4622/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4622
题意： 给一个字符串，给出若干询问，每组询问给一个区间[l,r]，问区间中本质不同的字符串的个数。
思路： 观察发现，有10000组查询，字符串的长度最多才2000，所以可以预处理一波。
我们先考虑如何处理整个区间中，本质不同的子串数量。
考虑SAM，由于后缀自动机中每一条从初始状态出发的路径都对应的一个子串，同时后缀自动机是最简的，所以问题也就变成了从初始状态开始不同路径的数量。
每个节点 u 表示的子串长度在 [min[u],max[u]]范围内.
又由于max(u.fail) = min(u)-1
因此u表示的子串的长度就是变成了**(max[u.fail],max[u] ] (注意区间，是左闭右开)**
由于每个长度的串都出现了一次，因此这个状态子串的个数就是max[u] - max[u.fail]
如果是统计整个串的本质不同的串的个数，那么buildSAM之后统计一下就行了。
现在是询问区间。
问题变成了，从[l,r]到[l,r+1]，答案的改变是什么。
在SAM上添加一个字符之后，SAM当前的状态变成了cur,那么实际上，对答案的贡献，就是初始状态到新的状态cur的不同路径数目。
也就是max[cur]-max[cur.fail]
#include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lnxt l,m,rt&amp;lt;&amp;lt;1 #define rnxt m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2017; const int maxn = 4017; LL ret; struct node{ node*nxt[26],*fail; LL len,cnt; void init() { for ( int i = 0 ; i &amp;lt; 26 ; i++) nxt[i]=NULL; fail=NULL; len=cnt=0; } }; struct SAM{ node no[maxn]; node*root; int cnt; node* newnode(){ ms(no[cnt].</description></item><item><title>SPOJ LCS Longest Common Substring （后缀自动机模板题）</title><link>https://111qqz.com/2017/11/spoj-lcs/</link><pubDate>Fri, 03 Nov 2017 11:44:35 +0000</pubDate><guid>https://111qqz.com/2017/11/spoj-lcs/</guid><description>
题意： 给出2个字符串(2.5E5)，问最长公共子串的长度。
思路： 拿一个串建SAM
由于SAM上的任何一个状态，都对应一个或者若干个子串，然后拿另一个串在SAM上面跑就行了
20171110UPdate:我好像说得太简略了。。
参考clj的冬令营讲稿：
* 给两个长度小于100000的字符串A和B，求出他们的最长公共连续子串。 Ê我们构造出A的后缀自动机SAM * 对于SAM的每个状态s，令r为Right(s)中任意的一个元素，它代表的是结束位置在r的，长度在[Min(s),Max(s)]之间的所有子串。 * 我们不妨对状态s，求出所有B的子串中，从任意r开始往前能匹配的最大长度L，那么min(L,Max(s))就可以更新答案了。 * 我们考虑用_SAM_读入字符串_B_。 * **令当前状态为_s_，同时最大匹配长度为_len _Ê我们读入字符_x_。如果_s_有标号为_x_的边，** * **那么_s=trans(s,x),len = len+1 _Ê否则我们找到_s_的第一个祖先_a_，它有标号为_x_的边，令** * **_s=trans(a,x),len=Max(a)+1__。 _Ê如果没有这样的祖先，那么令_s=root,len=0_。** * 在过程中更新状态的最大匹配长度 唯一不显然的地方在于，为什么当失配时，我们是沿着parent树向上找。
考虑如下例子：
我们知道，parent树，或者叫后缀链树，一个状态S指向的是，总起点开始到S的子串的后缀中，长度最长的后缀，满足该后缀所对应的某个状态Q(对应的意思是说，从初始状态到状态Q表示的子串恰好是该后缀)的right集合和状态S的集合不相等。
假设我们目前匹配到的状态表示的子串是abcbc,然后下一位要匹配的字母是b，而状态abcbc没有通过b转移的边（这些图上没有,我懒得画了orz)
这个时候考虑回退...对于abcbc的后缀，bcbc,cbc和abcbc面临的情况是一样的，因为bcbc,cbc,abcbc三个字符串的right集合相同，也就是出现的位置完全相同，那么既然abcbc没有通过b转移的边，bcbc,cbc也一定没有通过b转移的边。
这时候考虑转移到abcbc的par状态，也就是表示子串bc的状态，原因是bc的right集合和abcbc的right集合不同，更准确得说，bc的right集合是包含abcbc的right集合的。
而bc在之前匹配abcbc的时候，已经匹配过了，也就是说bc一定是可以匹配的，
如果此时bc有一条通过b转移的边，此时匹配的长度就变成了bc对应的状态所对应的max再+1
老年人的第一个SAM
关于SAM的笔记之后补。
用了动态的写法.
/* *********************************************** Author :111qqz Created Time :2017年11月03日 星期五 18时20分42秒hongchenzuoban File Name :2774_SAM.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lnxt l,m,rt&amp;lt;&amp;lt;1 #define rnxt m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5; struct SAM { struct node { node *nxt[26],*fa;int len; node(int M) {len=M;fa=0;memset(nxt,0,sizeof(nxt));} }; typedef node* P_node; P_node ro,lst; SAM() {ro=new node(0);lst=ro;} void Insert(char ch) { int ID=ch-'a';P_node p=lst,np=new node(lst-&amp;gt;len+1); while (p&amp;amp;&amp;amp;!</description></item><item><title>HDU 5970 | 2016 CCPC HeFei onsite J 最大公约数 (打表找规律)</title><link>https://111qqz.com/2017/11/hdu5970/</link><pubDate>Thu, 02 Nov 2017 02:33:54 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu5970/</guid><description>
题意： 有这样一个有关最大公约数的函数: 函数 f(x, y):
{ c=0 当 y&amp;gt;0: { c +=1 t = x % y x = y y = t } 返回 c * x * x } 给出三个正整数n,m,p，你需要计算:
$$ \sum_{i=1}^{n} \sum_{j=1}^{m} \left \lfloor \frac{i*j}{f(i,j))} \right \rfloor $$
n &amp;lt;= 666,666,666, m &amp;lt;= 666, p &amp;lt;= 666,666,666。
思路： 打表找规律。
但是找规律也要按照基本法
观察到m比较小，对于固定的j,容易看出f(i,j)和f(i+j*k,k)是等价的。
比赛的时候没做出来，因为纠结取整的问题...
解决办法竟然是....通过循环节观察orz
转载一篇靠谱的题解：
一开始，我自己假设先不考虑c。那么就变成了ΣΣi/gcd*j/gcd=Σj/gcd*Σi/gcd，如此一来，由于m比较小，我就可以枚举j，然后对应求出j所有的因子作为gcd，gcd确定之后再根据容斥来统计i/gcd的和。具体统计方法和15年沈阳regional的frog那题类似，用n的因子来进行暴力的容斥。但是很显然这样子很难把c的影响带进来，而且这里的c还要向下取整，更加的麻烦。 于是打表找规律，首先很容易知道f(i,j)=f(i+kj,j)。根据这个，在不考虑向下取整的情况下，对于同一个j，我们就可以列出一个等差数列，其中首项是ij/f(i,j)，公差为jj/f(i,j)。但是这里要考虑这个向下取整。我们设i为模9为7的数j为9，可以打出如下i*j/f(i,j)的表，括号内为相邻值的差：
可以发现，每c组i*j/f(i,j)是一个循环节，也就是说可以看作c个等差数列，然后对于每一个等差数列，它的首项我们可以暴力算出，而公差也很容易求出。利用等差数列求和公式可以很快速的计算出结果。复杂度的话，我们需要枚举j和在j剩余系下的i，然后还有c个等差数列，复杂度为O(m^2logN)在接受范围之内。具体见代码：
以及。。膜真的很浪费生命啊？
一开始取了5个%，TLE,4个%,50%概率AC,3个%就比较稳得过了...
一个%大概300ms orz
/* *********************************************** Author :111qqz Created Time :2017年11月02日 星期四 09时38分56秒 File Name :5970.</description></item><item><title>hdu 6038 | 2017 Multi-University Training Contest - Team 1 E Function (置换群找循环节)</title><link>https://111qqz.com/2017/11/hdu-6038/</link><pubDate>Wed, 01 Nov 2017 06:47:11 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-6038/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6038
题意： 给出两个序列 a 和 b ，求满足 f[i]= b_{f[a[i]]} 的函数个数。
思路： 分别找两个序列的循环节，这一点是比较容易想到的。
由于点都在0..n-1 或者0..m-1，因此没必要建图跑dfs找循环节，直接while就可以了。
然后发现一个循环节如果符合条件，那么对答案的贡献是循环节长度。
但是没有想清楚，什么才是符合条件的循环节。
结论是，b的循环节长度当且近当是A的循环节的长度的因子时，b的这个循环节会对答案贡献其长度的大小。
对于A的每个循环节，都是互不影响的。
而且我们只关心循环节的长度。
因此O（n）和O(m)的时间，处理出所有循环节的长度。
然后分别枚举累计答案即可。
但是我怎么感觉。。。这复杂度不太对啊。。。。
对于O(1E5)的序列。。我好像可以构造出1E5个长度为1的循环节？
那么1E5 * 1E5,1E10的复杂度了。。。
然而看了下官方题解。。。发现给出的复杂度分析是O(n+m)
？？？？？？？？？？？？？？？？？？？？？
所以这是说。。。数据保证O(n*m) &amp;lt; O (n+m)了么。。。
这是面向数据解题。。还是说我哪里想错了啊。。。orz
/* *********************************************** Author :111qqz Created Time :2017年11月01日 星期三 14时17分58秒 File Name :6038.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const LL mod = 1E9+7; int a[N],b[N]; bool vis[N]; int n,m; vector &amp;lt;int&amp;gt;loopa,loopb; vector &amp;lt;int&amp;gt; findloop( int *a,int n) { vector&amp;lt;int&amp;gt;res; ms(vis,false); for ( int i = 0 ; i &amp;lt; n ; i++) { int cur = i ; if (vis[cur]) continue; int len = 0; while (!</description></item><item><title>hdu 6034 2017 Multi-University Training Contest - Team 1 B Balala Power! (贪心)</title><link>https://111qqz.com/2017/11/hdu-6034/</link><pubDate>Wed, 01 Nov 2017 04:00:01 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-6034/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6034
题意： 有一个仅由小写字母组成的字符串，要求将a..z的字母，对应到0..25，每个数字只能被一个字母对应，得到一个26进制的数，现在问这个数最大是多少。注意不允许有前导0，除非这个数本身就是0.
思路： 贪心。看哪个字母的权值最大。
可以用类似高精度加法的方式处理。
对于前导0的部分，用一个bool标记首位（如果字符串长度为1就不标记）
对于26个高精度数的排序，可以用交换id的技巧。
以及，如果排序之后，发现权值最小的数被对应到数字0，但是又在某个长度大于1的字符串的首字母位置出现过。
我初始想当然得，把该字母和最小的可以出现在首位的字母交换....
然而这很错啊？
实际上，更优秀做法是，找到第一个可以出现在首位的字母，然后从该字母后面到结尾，依次前移一位，最后把这个可以出现在首位的字母放在最后。
比如这组数据：
7 abcdefghijklmnopqrstuvwxyz zz yy xx ww uu vv
权值按照从大到小排列
z u v w x y t 显然不如 u v w x y z t 优
/* *********************************************** Author :111qqz Created Time :2017年11月01日 星期三 00时56分26秒 File Name :6034.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const LL mod =1E9+7; int n; string st[N]; int cnt[26][N]; int maxlen; int id[26]; int power[26]; LL base26[N]; bool Beg[26]; void init() { ms(Beg,false); ms(cnt,0); maxlen = 0 ; for ( int i = 0 ; i &amp;lt; 26 ; i++) id[i] = i; } bool small(int *a,int *b) { for ( int i = maxlen-1 ; i &amp;gt;= 0 ; i--) { if (a[i]&amp;lt;b[i]) return true; if (a[i]&amp;gt;b[i]) return false; } return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;.</description></item><item><title>BZOJ 1230: [Usaco2008 Nov]lites 开关灯 (线段树区间修改，区间查询)</title><link>https://111qqz.com/2017/11/bzoj-1230/</link><pubDate>Wed, 01 Nov 2017 02:19:00 +0000</pubDate><guid>https://111qqz.com/2017/11/bzoj-1230/</guid><description>
1230: [Usaco2008 Nov]lites 开关灯 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 1676 Solved: 874 [Submit][Status][Discuss]
Description Farmer John尝试通过和奶牛们玩益智玩具来保持他的奶牛们思维敏捷. 其中一个大型玩具是牛栏中的灯. N (2 &amp;lt;= N &amp;lt;= 100,000) 头奶牛中的每一头被连续的编号为1..N, 站在一个彩色的灯下面.刚到傍晚的时候, 所有的灯都是关闭的. 奶牛们通过N个按钮来控制灯的开关; 按第i个按钮可以改变第i个灯的状态.奶牛们执行M (1 &amp;lt;= M &amp;lt;= 100,000)条指令, 每个指令都是两个整数中的一个(0 &amp;lt;= 指令号 &amp;lt;= 1). 第1种指令(用0表示)包含两个数字S_i和E_i (1 &amp;lt;= S_i &amp;lt;= E_i &amp;lt;= N), 它们表示起始开关和终止开关. 奶牛们只需要把从S_i到E_i之间的按钮都按一次, 就可以完成这个指令. 第2种指令(用1表示)同样包含两个数字S_i和E_i (1 &amp;lt;= S_i &amp;lt;= E_i &amp;lt;= N), 不过这种指令是询问从S_i到E_i之间的灯有多少是亮着的. 帮助FJ确保他的奶牛们可以得到正确的答案.
Input 第 1 行: 用空格隔开的两个整数N和M</description></item><item><title>hdu 6043 | 2017 Multi-University Training Contest - Team 1 K KazaQ's Socks （循环节）</title><link>https://111qqz.com/2017/11/hdu-6043/</link><pubDate>Tue, 31 Oct 2017 16:31:10 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-6043/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6043
题意： n双袜子标号1到n，初始在抽屉里，每天早晨穿一双标号最小的袜子，晚上把脏袜子放到盆里，如果放完之后喷子里已经有了n-1双脏袜子，那么就要洗，然后在第二天晚上放回抽屉里。问第k天穿的是标号为几的袜子。
思路： 手写了几个发现对于n双袜子,标号出现的情况是:
1,2,3...n,1,2,3...n-2,n-1,1,2,3...n-2,n
所以特判k&amp;lt;=n的情况然后算循环的次数即可。
/* *********************************************** Author :111qqz Created Time :2017年11月01日 星期三 00时14分38秒 File Name :6043.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n,k; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;.</description></item><item><title>hdu 6033 | 2017 Multi-University Training Contest - Team 1 A Add More Zero</title><link>https://111qqz.com/2017/10/hdu6033/</link><pubDate>Tue, 31 Oct 2017 15:51:43 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu6033/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6033
题意： 问最大的x,满足 $$ 10^{x} \geq 2^{m}-1 $$
思路： 看到指数的比较大小，直觉就是取下对数啦
其实直接可以把1忽略，因为2的幂次显然不会出现末尾是0，所以不会影响结果
两边对10取对数得到 $$ x\leq \log_{10} 2^{m} $$
右边用换底公式就是 $$ \frac{m}{\log_{2}10 } $$
代码：
/* *********************************************** Author :111qqz Created Time :2017年10月31日 星期二 23时12分47秒 File Name :6033.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int m; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;.</description></item><item><title>在wordpress 中输入数学公式</title><link>https://111qqz.com/2017/10/input-formula-on-wordpress/</link><pubDate>Tue, 31 Oct 2017 15:26:25 +0000</pubDate><guid>https://111qqz.com/2017/10/input-formula-on-wordpress/</guid><description>
查了一些资料。。发现不是要装各种插件（还不一定能用，比如和crayon冲突。。就是讲得很不清楚orz。。
又下一个win下的公式编辑器之类的软件是什么鬼啊？
干脆记录一下必要步骤。只有一步。
1. 配置mathjax. 加入下面代码到该主题的header.php中 &amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间（要放在**&amp;lt;?php wp_head(); ?&amp;gt;**） &amp;lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'&amp;gt;&amp;lt;/script&amp;gt; * **换行显示（displayed mathematics）**，它的分隔符是 $$...$$和 \[...\] ， * **行内显示（in-line mathematics）**，它的分割符号是 \\(...\\) (只有一个\) 不记得公式语法去latex online 查看即可</description></item><item><title>bzoj 1059: [ZJOI2007]矩阵游戏 (匈牙利算法)</title><link>https://111qqz.com/2017/10/bzoj-1059/</link><pubDate>Tue, 31 Oct 2017 14:49:12 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj-1059/</guid><description>
1059: [ZJOI2007]矩阵游戏 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 5251 Solved: 2512 [Submit][Status][Discuss]
Description 　小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个N
*N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择
矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换
对应格子的颜色）游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑
色。对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程
序来判断这些关卡是否有解。
Input 　第一行包含一个整数T，表示数据的组数。接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大
小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。
Output 　输出文件应包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。
Sample Input 2 2 0 0 0 1 3 0 0 1 0 1 0 1 0 0
Sample Output No Yes 【数据规模】 对于100%的数据，N ≤ 200
思路：
纠结了一下建图，由于每个黑点可以按照行换，也可以按照列换。所以我建了一个1..n到1..2n的二分图做匹配。
左边集合是n个对角线上的点，右边集合是行号+列号。
但是每次匹配的时候，一个对角线上的点会同时消耗到匹配的行号和列号。。感觉不是很对啊。。。
实际上发现，我们只需要建立一个n到n的二分图就行了。
原因是，如果有解，那么只需要行或者列的一种变换，就可以达到规定的图案。
比如现在(2,5)是1,（2,2)和(5,5)是0，我们只需要连一条边表示(2,5)可以换到(2,2)即可，不需要连表示(2,5)可以换到(5,5)的边
原因是，如果(2,5)换到(5,5)，那么(2,2)也跟着换到了(5,2)，我们不考虑之前的(2,2)是什么，被换之后的(2,2)必须是1才符合题意，也就是换之前的(5,2)必须是1.
既然(5,2)是1，那么从(5,2)换到(5,5)即可符合条件。
/* *********************************************** Author :111qqz Created Time :2017年10月31日 星期二 21时54分23秒 File Name :1059.</description></item><item><title>BZOJ 1191: [HNOI2006]超级英雄Hero (匈牙利)</title><link>https://111qqz.com/2017/10/bzoj-1191/</link><pubDate>Tue, 31 Oct 2017 13:40:03 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj-1191/</guid><description>
1191: [HNOI2006]超级英雄Hero Time Limit: 10 Sec Memory Limit: 162 MB Submit: 5221 Solved: 2356 [Submit][Status][Discuss]
Description 现在电视台有一种节目叫做超级英雄,大概的流程就是每位选手到台上回答主持人的几个问题,然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。 这里，我们把规则稍微改变一下。假设主持人总共有m道题，选手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？
Input 输入文件的一行是两个正整数n和m(0 &amp;lt; n &amp;lt;1001,0 &amp;lt; m &amp;lt; 1001)表示总共有n中“锦囊妙计”，编号为0~n-1，总共有m个问题。 以下的m行，每行两个数，分别表示第m个问题可以使用的“锦囊妙计”的编号。 注意，每种编号的“锦囊妙计”只能使用一次，同一个问题的两个“锦囊妙计”可能一样。
Output 第一行为最多能通过的题数p
Sample Input 5 6 3 2 2 0 0 3 0 4 3 2 3 2
Sample Output 4
思路： 从题目向2条锦囊妙计连边，注意判重。由于有一道题答错比赛就结束，因此在hung的过程中一旦不能find就直接break掉。</description></item><item><title>codeforces div 1 443 A. Short Program （位运算的理解）</title><link>https://111qqz.com/2017/10/codeforces-div1-443a/</link><pubDate>Sun, 29 Oct 2017 11:24:42 +0000</pubDate><guid>https://111qqz.com/2017/10/codeforces-div1-443a/</guid><description>
题目链接：
题目链接
题意： 一段程序，最多5E5个操作，每个操作的格式为 &amp;lt;opt,x&amp;gt; ，opt表示位或，位异或，位与 三种位运算的一种，x表示范围0..1023的数。现在要求将该程序化简至最多 5个操作，使得对于0..1023的输入，输出与该程序同样的结果。
思路 ： 关键在于想起，位运算还是按照二进制位的运算。我们考虑每位即可。
如果初始是0，现在变成了1，那么实际上我们并不确定，这个操作是xor 1 还是 or 1
因此我们需要两个初始的数，一个所有二进制位上都是0，另一个所有二进制位上都是1.
也就是0和1023
对于某个二进制位
如果初始的 （0，1）变成了 （1，1），那么说明这个位置上的位运算是or
如果初始的 （0，1）变成了（1，0） 那么说明这个位置上的位运算是xor
如果初始的 （0，1）变成了（0，0） 那么说明这个位置上的位运算是and
如果初始的 （0，1）变成了（1，0） 那么说明这个位置上没有进行位运算操作。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main() { int n; cin&amp;gt;&amp;gt;n; char opt[3]; int x; int a = 0; int b = 1023; for ( int i = 1 ; i &amp;lt;= n ; i++) { cin&amp;gt;&amp;gt;opt&amp;gt;&amp;gt;x; if (opt[0]=='|') a |=x,b|=x; if (opt[0]=='^') a^=x,b^=x; if (opt[0]=='&amp;amp;') a&amp;amp;=x,b&amp;amp;=x; } // 01 no // 11 or // 10 xor // 00 and int OR=0,XOR=0,AND=1023; for ( int i = 0 ; i &amp;lt; 10 ; i++) { int A = (a&amp;gt;&amp;gt;i)&amp;amp;1; int B = (b&amp;gt;&amp;gt;i)&amp;amp;1; // cout&amp;lt;&amp;lt;&amp;quot;A:&amp;quot;&amp;lt;&amp;lt;A&amp;lt;&amp;lt;&amp;quot; B:&amp;quot;&amp;lt;&amp;lt;B&amp;lt;&amp;lt;endl; if (A&amp;amp;&amp;amp;B) OR|=(1&amp;lt;&amp;lt;i); if (A&amp;amp;&amp;amp;!</description></item><item><title>2016 ICPC 大连 区域赛 A Wrestling Match （交叉染色法判断二分图）</title><link>https://111qqz.com/2017/10/2016-icpc-dalian-regional-A/</link><pubDate>Thu, 26 Oct 2017 09:16:15 +0000</pubDate><guid>https://111qqz.com/2017/10/2016-icpc-dalian-regional-A/</guid><description>
题意： 给出n个点m条边，以及已知的好点和坏点。一个边连接的2个点一定是一好一坏，问是否有合法方案，使得每个点被确定好坏。
思路： 判断二分图。
先染已知的，再染未知的。
注意判掉没有出现的点。
注意有多个联通块。
/* *********************************************** Author :111qqz Created Time :2017年10月26日 星期四 12时53分06秒 File Name :A.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; const int M=1E4+7; int n,m,a,b; vector &amp;lt;int&amp;gt;edge[N]; int col[N]; set&amp;lt;int&amp;gt;se; bool dfs( int u,int x) { col[u] = x; int siz = edge[u].</description></item><item><title>codeforces #346 div 2 E. New Reform (和图有关的的计数)</title><link>https://111qqz.com/2017/10/codeforces-346-div2-e/</link><pubDate>Wed, 25 Oct 2017 13:09:31 +0000</pubDate><guid>https://111qqz.com/2017/10/codeforces-346-div2-e/</guid><description>
题意： 给出n个点，条边的无向图，无重边，无自环。现在要求把所有的无向边换成有向边，使得入度为0的点最少。问最少的入度为0的点是多少。
思路： 对于每个联通快，如果有环，我们可以顺时针连接环上的点，以指向环的方向连接联通快上的其他点，这样就可以保证所有点的入度都不为0. 如果是树形结构，则不可避免得使得一个点的入度为0.
因此对于有环的联通块答案为0，没环的答案为1.
/* *********************************************** Author :111qqz Created Time :2017年10月25日 星期三 20时57分54秒 File Name :E.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 1E5+7; vector &amp;lt;int&amp;gt;edge[N]; bool vis[N]; bool dfs( int u,int pre) { vis[u] = true; // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; pre:&amp;quot;&amp;lt;&amp;lt;pre&amp;lt;&amp;lt;endl; int siz = edge[u].</description></item><item><title>BZOJ 1854: [Scoi2010]游戏 (并查集)</title><link>https://111qqz.com/2017/10/bzoj-1854/</link><pubDate>Wed, 25 Oct 2017 10:49:24 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj-1854/</guid><description>
Description lxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 游戏进行到最后，lxhgww遇到了终极boss，这个终极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此类推。 现在lxhgww想知道他最多能连续攻击boss多少次？
Input 输入的第一行是一个整数N，表示lxhgww拥有N种装备 接下来N行，是对这N种装备的描述，每行2个数字，表示第i种装备的2个属性值
Output 输出一行，包括1个数字，表示lxhgww最多能连续攻击的次数。
Sample Input 3 1 2 3 2 4 5
Sample Output 2
HINT 【数据范围】 对于30%的数据，保证N &amp;lt; =1000 对于100%的数据，保证N &amp;lt; =1000000
Source Day1
思路：
看到了二分图匹配的题解，但是感觉很错啊？
正确的做法是，将武器看成边，将每个武器的2种属性看成点。
使用某种属性，就要消耗一条边。
因此如果一个联通快是树形结构，k个点，k-1条边，因此有一个属性无法被使用。
由于要求是从1开始递增得攻击，因此显然使得属性最大的点不被使用是最优的。
如果一个联通块有环，那么所有的树型都可以被使用。
注意这个联通快有无环影响计数的思维，和codeforces # 440 div2 E. Points, Lines and Ready-made Titles 很像
/* *********************************************** Author :111qqz Created Time :2017年10月25日 星期三 17时00分25秒 File Name :1854.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; const int M=1E4+7; int n; bool ok[M]; int f[M]; void init() { ms(ok,false); for ( int i = 1 ; i &amp;lt; M ; i++) f[i] = i; } int root ( int x) { if (x!</description></item><item><title>codeforces 439 C - The Intriguing Obsession (和图有关的计数，组合数学)</title><link>https://111qqz.com/2017/10/codeforces-439-c/</link><pubDate>Wed, 25 Oct 2017 06:31:02 +0000</pubDate><guid>https://111qqz.com/2017/10/codeforces-439-c/</guid><description>
题意： 3个岛屿群，每个岛屿群有若干岛屿。现在要在岛屿之间连桥，桥的长度是1，规定2个属于相同岛屿群的岛屿的距离要大于等于3.
思路： 一直在纠结大于等于3的距离的事情。。。其实这句话等价于，同一个岛屿，对于另外两个岛屿群，都最多只能连接1个岛屿。
那么其实，对于每一对岛屿群，是相互独立的。
对于任意一对岛屿群，设两边岛屿的数量分别为a,b
我们可以从两边各取0个，1个，最多取min(a,b)
需要注意的是，选取了端点之后有顺序的区别。
所以对于该对岛屿，答案是SUM{C[a][k] * C[b][k] * k!} (k属于0..min(a,b) )
对于其他 两对同理。
/* *********************************************** Author :111qqz Created Time :2017年10月25日 星期三 13时55分25秒 File Name :C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL mod = 998244353; const int N=5005; LL C[N][N]; LL fac[N]; void init() { C[1][0] = C[1][1] = 1; C[2][0] = C[2][2] = 1; C[2][1] = 2; for ( int i = 3 ; i &amp;lt; N ; i++) { for ( int j = 0 ; j &amp;lt;= i ; j++) { if (j==0) C[i][j] = 1; else C[i][j] = (C[i-1][j] + C[i-1][j-1])%mod; } } fac[0] = fac[1] = 1; for ( int i = 2 ; i &amp;lt; N ; i++) fac[i] = (fac[i-1] * i)%mod; } int a,b,c; LL ans = 1; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;.</description></item><item><title>codeforces # 440 div2 E. Points, Lines and Ready-made Titles (和图有关的计数，思维题)</title><link>https://111qqz.com/2017/10/codeforces-440-div2-e/</link><pubDate>Tue, 24 Oct 2017 06:39:27 +0000</pubDate><guid>https://111qqz.com/2017/10/codeforces-440-div2-e/</guid><description>
题目链接
题意：有n个整点，每个点处可以什么都不画，或者画一条垂直方向的直线，或者画一条水平方向的直线。
现在给出n个点的坐标，问最多右多少种不同的图案。(只要有一处不同，就认为两个不同）
思路：
参考题解
好菜啊不会做，转载一段题解。
和[bzoj 1854](http://www.cnblogs.com/kkkkahlua/p/7666811.html)的并查集思路蜜汁契合 // 看完了题解的我这样想道 首先显然可以将图分为若干个联通块。
且慢，哪里来的图？ 那就先考虑建图？ 不急不急，先来想想看每一个联通块的性质。
如果该联通块中有环的话，肯定每条边都能取到；如果联通块是一棵树，那么必有一条边取不到（具体阐述见上bzoj 1854），所以只需要知道
1. 这个联通块中有多少条边 2. 这个联通块是不是环 这两个信息就可以了
那么可以直接上并查集。
什么样的点可以并到一起呢？横坐标相同的或者纵坐标相同的。
有没有环怎么维护呢？看有没有加进去的边的端点本身就在一个集合里。
联通块中边的数目又怎么知道呢？这倒还挺有意思的，其实只要直接看出现过多少个横坐标或者纵坐标就可以了，因为一个横坐标或者一个纵坐标就代表一条可以选的直线，所以这块联通块的贡献就是2^(x+y)或者2^(x+y)-1
然后呢？就做完了。
然而呢？比赛结束。一天了。
/* *********************************************** Author :111qqz Created Time :2017年10月23日 星期一 15时51分51秒 File Name :E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const LL mod = 1E9+7; struct point { int x,y; int id; bool operator &amp;lt; ( point b) { return id &amp;lt; b.</description></item><item><title>vimrc for ACM-ICPC (赛场用)</title><link>https://111qqz.com/2017/10/vimrc-for-acm-icpc/</link><pubDate>Sat, 21 Oct 2017 12:54:40 +0000</pubDate><guid>https://111qqz.com/2017/10/vimrc-for-acm-icpc/</guid><description>
弄了点比较短的，赛场上用的配置文件orz
map &amp;lt;F5&amp;gt; :call Co()&amp;lt;CR&amp;gt; func! Co() exec &amp;quot;w&amp;quot; exec &amp;quot;!g++ % -std=gnu++11 -Wall -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; endfunc syntax on set nu autocmd BufNewFile *.cpp exec &amp;quot;:call SetTitle()&amp;quot; func SetTitle() let l = 0 let l = l + 1 | call setline(l,'#include &amp;lt;bits/stdc++.h&amp;gt;') let l = l + 1 | call setline(l,'using namespace std;') let l = l + 1 | call setline(l,'const int inf = 0x3f3f3f3f;') let l = l + 1 | call setline(l,'#define ms(a,x) memset(a,x,sizeof(a))') let l = l + 1 | call setline(l,'typedef long long LL;') let l = l + 1 | call setline(l,'int main()') let l = l + 1 | call setline(l,'{') let l = l + 1 | call setline(l,' return 0;') let l = l + 1 | call setline(l,'}') endfunc 故地重游，rp++</description></item><item><title>广义Fibonacci数列找循环节 （二次剩余）</title><link>https://111qqz.com/2017/10/look-for-loop-section-in-generalized-fibonacci-sequence/</link><pubDate>Wed, 18 Oct 2017 05:38:43 +0000</pubDate><guid>https://111qqz.com/2017/10/look-for-loop-section-in-generalized-fibonacci-sequence/</guid><description>
**问题：**给定 ，满足 ，求 的循
环节长度。
原理见广义Fibonacci数列找循环节
这里只说做法
我们先写出递推式的特征式子 x^2 =ax + b,整理得到 x^2-ax-b=0求出 delta = a^2+4b
对于质因数小于等于delta的部分，我们选择暴力求循环节。
暴力求循环节的代码如下：
int get_loop( LL p) //暴力得到不大于13的素数的循环节。 { LL a,b,c; a = 0 ; b = 1 ; for ( int i = 2; ; i++) { c = (a+3*b%p)%p; //此处为递推式 a = b; b = c; if (a==0&amp;amp;&amp;amp;b==1) return i-1; } } 通常做法是先暴力求出来之后，写进一个表里。
通常不会有很多项。
对于质因数大于delta的部分，我们判断每个质因数是否是delta的二次剩余，如果是，枚举(prime-1)的因子,否则枚举2*(prime+1)的因子。
贴一个板子，需要注意如果是多个函数嵌套的形式，我们只需要从外向里，依次求循环节即可。
/* *********************************************** Author :111qqz Created Time :Mon 31 Oct 2016 08:22:17 PM CST File Name :code/hdu/4291_2.</description></item><item><title>可持久化线段树学习笔记</title><link>https://111qqz.com/2017/10/persistent-segment-tree-notes/</link><pubDate>Wed, 18 Oct 2017 05:12:08 +0000</pubDate><guid>https://111qqz.com/2017/10/persistent-segment-tree-notes/</guid><description>
起因是16长春CCPC遇到了一个全场万人过的主席树题目，然而我不会orz，哭哭
可持久化线段树的本质是很多棵形态完全相同的线段树。
也可以理解成是，保存了不同时刻版本的线段树的数据结构。
如果没有可持久化线段树，那么我们如果需要不同时刻的线段树，无脑的做法可能是，需要多少个时刻的线段树，就建多少棵线段树。
但是空间绝对gg，我们考虑每次修改，其实对于一次修改，线段树上只有很少一部分被修改了，其他部分都一样。
因此，我们很容易想到，我们何不只考虑修改的部分，其他部分共用，以减少时间和空间消耗呢？
* 可持久化线段树是利用函数式编程的思想，对记录的数据只赋值不修改，每次插入一个数据后保存一个历史版本，然后利用线段树的结构完全相同，可以直接相减的特性进行区间询问。 可持久化线段树有几个经典应用，比如求区间第k大 静态区间第k大 动态区间第k大 
静态区间第k大的思想：
* 首先,给你一颗值为横坐标的线段树,每个节点上存着该值出现了多少次,这样的一颗线段树你会求区间k大值吧.二分即可. * 然后,假设区间是数组arr[n],区间长度是n,那么给你n颗线段树,第i颗线段树是第i-1颗线段树插入arr[i]得到. * 如果你有了这n颗线段树,想求区间[l,r]中的第k大值,那么你需要在第r颗和第l-1颗线段树的**差线段树**上作二分,就可以求得区间第k大值. * 差线段树很好理解,比如你有一个部分和数组sum,sum[r]-sum[l-1]就是部分和的差,代表区间[l,r]的和,差线段树同理. * 现在,可持久化线段树出现为你解决最后一个问题,空间问题.内存很小,不能够存下n颗线段树,但是,第2条中提到,由于第i颗线段是是第i-1颗线段是插入仅一个值得到的,两颗线段树的区别不大,仅有log(n)个节点发生了改变,我们仅仅需要记录这log(n)的数据就可以记录这个增量,这就是可持久化线段树. 以及求区间中不同数的个数 spoj-dquery 求区间中不同数的个数
思想其实和离线线段树是一样的。
在学习可持久化线段树的时候，遇到过一个叫&amp;quot;权值线段树&amp;quot;的概念
其实并不是什么新东西，只不过是把值作为节点来考虑，参考逆序对的线段树|树状数组 求法...（由于是在值域上建立线段树，所以常常需要离散化）
这思想不是很常见么....感觉完全没必要安个名字...以及，怎么不给BIT也起个叫权值BIT啊orz
参考资料：
知乎-主席树是如何求区间k大的？
可持久化数据结构之主席树</description></item><item><title>2016 CCPC 长春 I 题 | hdu 5919 Sequence II （可持久化线段树求区间第k大+可持久化线段树求区间不同数个数）</title><link>https://111qqz.com/2017/10/hdu-5919/</link><pubDate>Wed, 18 Oct 2017 04:52:00 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-5919/</guid><description>
题目链接
题意： 给定一个序列 n，有 m次查询，每次查询一个区间[l,r]，求区间中每一种数在区间中第一次出现的位置的中位数，强制在线。
思路： 先分解一下问题，我们要求一段区间位置的中位数，其实可以分解成，求区间中不同数的个数+求区间中第k大的下标。
对于求区间中不同数的个数，离线可以随便线段树，树状数组，或者莫队也行（观察到数据范围&amp;lt;=2E5)
在线的话，就只能可持久化线段树了。
看到一些题解中说要倒序处理...但是之前写求区间不同数的个数，我都是倒序处理的啊？ （回想一下，当时似乎正序处理也行...
倒序处理是为了，处理到第i个的时候，第i个一定是当前后缀区间中，第一个出现的...
然后第二个问题，求区间中第k大的下标，离线做法不少，在线的话，也可以用可持久化线段树求。
所以感觉就是板子题，可持久化线段树的2个应用放在了一起orz
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;bitset&amp;gt; #include &amp;lt;stack&amp;gt; using namespace std; #define MP make_pair #define PB push_back #define SZ(x) (int((x).size())) #define ALL(x) (x).begin(), (x).end() #define X first #define Y second typedef long long LL; typedef long double LD; const int INF = 0x3f3f3f3f; typedef pair&amp;lt;LL, LL&amp;gt; pii; const int N = 2e5 + 10; const int M = 30 * 2 * N; int ls[M], rs[M], root[N], tot, data[M]; inline int new_node(int lst = 0) { ls[++ tot] = ls[lst]; rs[tot] = rs[lst]; data[tot] = data[lst]; return tot; } void build(int l, int r, int &amp;amp;rt) { rt = new_node(); if(l == r) return ; int m = (l + r) &amp;gt;&amp;gt; 1; build(l, m, ls[rt]); build(m + 1, r, rs[rt]); } void update(int pos, int val, int lst, int l, int r, int &amp;amp;rt) { rt = new_node(lst); data[rt] += val; if(l == r) return ; int m = (l + r) &amp;gt;&amp;gt; 1; if(pos &amp;lt;= m) update(pos, val, ls[lst], l, m, ls[rt]); else update(pos, val, rs[lst], m + 1, r, rs[rt]); } int query(int L, int R, int l, int r, int rt) { if(L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R) return data[rt]; int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if(L &amp;lt;= m) ret += query(L, R, l, m, ls[rt]); if(R &amp;gt; m) ret += query(L, R, m + 1, r, rs[rt]); return ret; } int ask_kth(int k, int l, int r, int rt) { if(l == r) return l; int m = (l + r) &amp;gt;&amp;gt; 1; return data[ls[rt]] &amp;gt;= k ?</description></item><item><title>bzoj 1901: Zju2112 Dynamic Rankings (可持久化线段树，区间动态第k大)</title><link>https://111qqz.com/2017/10/bzoj-1901/</link><pubDate>Mon, 16 Oct 2017 18:38:53 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj-1901/</guid><description>
Description 给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1
],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改
变后的a继续回答上面的问题。
Input 第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。
分别表示序列的长度和指令的个数。
第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。
接下来的m行描述每条指令
每行的格式是下面两种格式中的一种。
Q i j k 或者 C i t
Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）
表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。
C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t
m,n≤10000
Output  对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。
Sample Input 5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3
Sample Output 3 6
思路： 现在我们已经会了用可持久化线段树，去做静态区间第k大的问题。
考虑一次修改，修改的元素会影响后面所有建好的线段树，时间代价是无法承受的。
我们考虑root[i]表示的这颗线段树，它保存的是从第一个元素开始插入到第i个元素后的数字区间。也就是说每次我们进行线段树区间相减时，我们是对两个前缀和[1, l - 1]和[1, r]进行了相减。
所以我们需要的是，以一个可以接受的时间代价，维护一个前缀和。
显然是用BIT来维护。
所以带修改的可持久化线段树，本质上应该是BIT套可持久化线段树。
/* *********************************************** Author :111qqz Created Time :2017年10月16日 星期一 23时50分14秒 File Name :1901.</description></item><item><title>hdu 2665 Kth number (静态区间第k大，可持久化线段树模板题)</title><link>https://111qqz.com/2017/10/hdu-2665/</link><pubDate>Mon, 16 Oct 2017 14:39:39 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-2665/</guid><description>
题意： 求区间第k大数
思路： 可持久化线段树。
其实这东西在国内更常见的名字应该是 zhu xi 树？应该是由于“中国高端数据结构领导者”的hjt比较早得引入（？推广？）而得来的。
不过之前没写什么东西都被封，写个zhu xi 树，怕是政治敏感够枪毙100回了orz
似乎也叫函数式线段树。
写个模板题练下手。学习笔记之后补。
/* *********************************************** Author :111qqz Created Time :2017年10月16日 星期一 21时51分55秒 File Name :2104.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N],H[N]; int cnt; int Hash( int x){ return lower_bound(H,H+cnt,x)-H;} int n,m; int tot;//线段树的总数。 int root[N];//每个元素对应的根节点 struct PTree { int sum,left,right; }tree[N*30]; inline int add_node( int _sum,int _left,int _right) { int idx = ++tot; tree[idx].</description></item><item><title>poj 3301 Texas Trip (三分，模板题)</title><link>https://111qqz.com/2017/10/poj-3301/</link><pubDate>Sat, 14 Oct 2017 16:54:24 +0000</pubDate><guid>https://111qqz.com/2017/10/poj-3301/</guid><description>
题目链接
题意： 给定二维平面的n个点，要求一个面积最小的正方形，使其能覆盖所有的点。
思路： 先考虑如果水平竖直地放置正方形（边和坐标轴平行）圈住所有点的最小正方形的边长是:
L=max(xmax−xmin,ymax−ymin)
然后考虑如果正方形旋转的话，能圈住所有点的正方形边长是随着角度先减后增的，有凸性，可以三分。。。
但是枚举角度计算正方形的话比较麻烦，可以选择旋转平面上的点，使得正方形仍然是水平竖直放置的，因为这样计算正方形的边长比较方便。 如果把点表示成极坐标形式:
x=r×cosθ,y=r×sinθ,，θ是极角
那么顺时针旋转 α 角度后：
x′=r×cos(θ−α),y=r×sin(θ−α)
化简一下可得：
x′=r×cosθ×cosα+r×sinθ×sinα=x×cosα+y×sinα
y′=r×sinθ×cosα−r×cosθ×sinα=y×cosα−x×sinα
然后就是三分角度了。。。
三分的板子:
double sanfen(double l,double r) { double mid,midmid; while (r-l&amp;gt;eps) { mid = (2*l+r)/3; midmid = (l+2*r)/3; if (cal(mid)&amp;gt;=cal(midmid)) l = mid; //此处为求极小值 else r = midmid; } return cal(l); } /* *********************************************** Author :111qqz Created Time :2017年10月15日 星期日 00时33分09秒 File Name :3301.</description></item><item><title>hdu 5531 | 2015 ICPC 长春 regional onsite Rebuild (三分)</title><link>https://111qqz.com/2017/10/hdu-5531/</link><pubDate>Sat, 14 Oct 2017 15:55:31 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-5531/</guid><description>
题目链接
题意： 有n个点，表示n个圆的圆心，问一组圆的半径，满足相邻(i,i+1)或者(n,1) 圆相外切。
思路： 我们发现确定第一个半径之后，其他的圆的半径似乎能解出来？
然后发现，其实只有n为奇数的时候能解出来，n为偶数不行。
那么我们可以奇数偶数分别处理。
对于奇数，直接解出来。式子不写了，很好推。
对于偶数，我们发现，最后会是一个关于r1的二次表达式。
一眼三分。然后训练的时候我就直接三分了。。？？？
三分的过程中判断一下是否所有圆的半径都满足实际意义。。。
然而这是错得，而且错得很显然。因为。。如果不满足实际意义，是根本没办法判断，该往哪个方向继续三分的。
然而这是错得，而且错得很显然。因为。。如果不满足实际意义，是根本没办法判断，该往哪个方向继续三分的。
然而这是错得，而且错得很显然。因为。。如果不满足实际意义，是根本没办法判断，该往哪个方向继续三分的。
正确的做法是，三分之前一定先确定定义域范围，在定义域内三分。
正确的做法是，三分之前一定先确定定义域范围，在定义域内三分。
正确的做法是，三分之前一定先确定定义域范围，在定义域内三分。
所以我们先解一个不等式组，把三分的范围解出来之后再进行三分orz
我对三分一无所知...
/* *********************************************** Author :111qqz Created Time :2017年10月14日 星期六 16时08分51秒 File Name :E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-10; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; const double PI = acos(-1.</description></item><item><title>hdu 4794 Arnold (二次剩余，斐波那契循环节)</title><link>https://111qqz.com/2017/10/hdu-4794/</link><pubDate>Fri, 13 Oct 2017 12:23:49 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-4794/</guid><description>
题意： 给定一个 N∗N(N≤4e9) 的矩阵，现在经过这样一个变换：将 (x,y) 变为 ((x+y)%N,(x+2×y)%N)(0≤x&amp;lt;N,0≤y&amp;lt;N) 现在求经过多少次这样的变换之后在回到 N∗N 的原始矩阵。
思路： 在模n的剩余系下可以写成(fib(n)x+fib(n+1)y,fib(n+1)x+fib(n+2)y)的形式fib(n)表示Fibonacci数列的第n项
所以就成了斐波那契数列循环节。。经典题。注意会爆long long,要用ULL
又写了遍板子，去年的东西都忘得差不多了orz
/* *********************************************** Author :111qqz File Name :code/hdu/4794.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef unsigned long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } void pr() { for ( int i = 0 ; i &amp;lt; 2 ; i++) for ( int j = 0 ; j &amp;lt; 2 ; j++) printf(&amp;quot;%lld%c&amp;quot;,mat[i][j],j==1?</description></item><item><title>2016-2017 ACM-ICPC, NEERC, Northern Subregional Contest G Gangsters in Central City (LCA)</title><link>https://111qqz.com/2017/10/2016-NEERC-subregional-G/</link><pubDate>Thu, 12 Oct 2017 13:44:29 +0000</pubDate><guid>https://111qqz.com/2017/10/2016-NEERC-subregional-G/</guid><description>
题意：
有一棵树，水源在根节点1，房子在叶子节点。有若干操作，操作可能是歹徒占领或者离开一个房子。我们不想给歹徒供水，可以通过切断边实现（如果某个叶子节点到根节点的路径上有一条边被切掉，那么就不能供水了。）对于每次操作后，问不给所有歹徒供水最少要切多少条边，并且问在切满足前面最小的情况下，最少使得多少个良民受影响。初始没有歹徒。
思路：
我们先考虑第一个问题。容易知道，假设与根相连的有k条边，那么最多只需要切k次，就切断了所有房子的水源。
也就是说，从最少切的次数角度的考虑，切与水源相连的边一定是最优的。
我们可以考虑把树根1去掉，这样得到k棵子树
然后可以预处理出，对于每个叶子节点，其非根的最远祖先是谁，也就是k棵子树的根节点都是谁。
那么对于每次出现歹徒，假设其非根的最远祖先是x,只需要切1-x这条边即可。
现在考虑第二个问题，在保证问题一最小的情况下，一个比较直观的想法是，我们尽量往低了切，也就是尽量往原理根的边上切，这样才能使收到影响的良民比较少。
容易想到，一个子树上该切的点是，所有被歹徒占领的坏点的LCA。这样可以使得受到影响的良民最少。
因为我们要得到受到影响的良民的数量，所以用siz[i]维护以i为根的子树的叶子数量，以及歹徒的数量。
这道题的关键结论是，：树上多个点的LCA，就是DFS序最小的和DFS序最大的这两个点的LCA&amp;quot;
这道题的关键结论是，：树上多个点的LCA，就是DFS序最小的和DFS序最大的这两个点的LCA&amp;quot;
这道题的关键结论是，：树上多个点的LCA，就是DFS序最小的和DFS序最大的这两个点的LCA&amp;quot;
因此这题就是写个LCA就可以了，切掉的坏点的dfs序可以用个set维护下。
/* *********************************************** Author :111qqz Created Time :2017年10月12日 星期四 17时06分57秒 File Name :G.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,q; int val[N]; vector &amp;lt; int &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int fa[N]; int dp[2*N][20]; int siz[N]; //siz[i]表示以i为根的子树的叶子数量。 int FA[N]; //将树根去掉之后，每棵子树最上面能到达的顶点。 set&amp;lt;int&amp;gt;T[N];//T[i]表示与根节点直接连接的节点i 切掉的点的dfs序 id int a[N]; void dfs( int u,int dep,int d,int pre) { fa[u] = pre; p++; E[p] = u; depth[p] = dep; R[u] = p; dis[u] = d; int SIZ = edge[u].</description></item><item><title>uvalive 7675 | 2016 北京 regional onsite H - A New Ground Heating Device （二分+多个圆面积并）</title><link>https://111qqz.com/2017/10/uvalive-7675/</link><pubDate>Thu, 12 Oct 2017 08:26:53 +0000</pubDate><guid>https://111qqz.com/2017/10/uvalive-7675/</guid><description>
题目链接
题意： 在一个二维平面上，有n个加热设备，每个加热设备加热一个圆形，加热设备需要信号源才可以工作，信号源在原点上，但是高度不确定。假设设备的加热半径是一个与{信号源与设备的距离}有关的表达式。现在想要满足，至少有k个加热设备加热的面积大于s，问信号源的最高高度是多少。
思路： 训练的时候一眼二分，但是求圆并的时候gg了。。毫无思路。
搞定了多个圆面积并。。这题就很easy了。。
需要注意，每次二分的时候，记得初始化圆的d...
/* *********************************************** Author :111qqz File Name :H.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef vector &amp;lt;int&amp;gt; VI; const int INF = 0x3f3f3f3f; const double eps = 1e-6; const int MAXN = 1E3+7; const double PI = acos(-1.</description></item><item><title>SPOJ CIRUT - CIRU2 (多个圆交，求交任意次的面积，模板题)</title><link>https://111qqz.com/2017/10/spoj-cirut/</link><pubDate>Thu, 12 Oct 2017 04:47:03 +0000</pubDate><guid>https://111qqz.com/2017/10/spoj-cirut/</guid><description>
题目链接
题意&amp;amp;思路： 给出n个圆
求恰好k个圆相交的面积，k属于1..n
先放个别人的代码。。。
我真是体会到了。。。软件工程这门课的重要性。。。
这代码真是烂得印象深刻。。。几何题全是面向过程？
circle和point 类写在一起。。。感觉所有糟糕的写法这份代码全都占了。。。
/* *********************************************** Author :111qqz Created Time :2017年10月11日 星期三 19时53分30秒 File Name :ciru.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef vector &amp;lt;int&amp;gt; VI; const int INF = 0x3f3f3f3f; const double eps = 1e-10; const int MOD = 100000007; const int MAXN = 1E3+7; const double PI = acos(-1.</description></item><item><title>archlinux/manjaro fcitx 与 chrome 不兼容 中文掉字 解决办法</title><link>https://111qqz.com/2017/10/manjaro-fcitx-drop-chinese-words-randomly/</link><pubDate>Wed, 11 Oct 2017 16:24:11 +0000</pubDate><guid>https://111qqz.com/2017/10/manjaro-fcitx-drop-chinese-words-randomly/</guid><description>
[已解决]最近两个版本的 chrome（aura界面）有两个问题
https://github.com/fcitx/fcitx/issues/197
解决办法： 安装fcitx-im 包即可</description></item><item><title>spoj CIRU - The area of the union of circles (多个圆面积并，模板题)</title><link>https://111qqz.com/2017/10/spoj-ciru/</link><pubDate>Wed, 11 Oct 2017 12:36:52 +0000</pubDate><guid>https://111qqz.com/2017/10/spoj-ciru/</guid><description>
题目链接
题意： 多n个圆的面积并。
思路： 发现和求2个圆的完全不一样，具体请参考
SPOJ 8073 The area of the union of circles（计算几何の圆并）（CIRU）
圆的面积并 
格林公式在面积并问题中的应用
（用格林公式搞真是跪烂了。。。。
没有仔细看细节，当成板子好了(我最菜.jpg
将代码写成了自己熟悉的风格。
以及双倍经验题:SPOJ VCIRCLES
/* *********************************************** Author :111qqz Created Time :2017年10月11日 星期三 19时53分30秒 File Name :ciru.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const double PI = acos(-1.</description></item><item><title>hdu 5618 Jam's problem again （cdq分治+BIT，三维偏序）</title><link>https://111qqz.com/2017/10/hdu-5618/</link><pubDate>Tue, 10 Oct 2017 12:53:20 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-5618/</guid><description>
题目链接
题意: If two point such as (xi,yi,zi) and (xj,yj,zj) xi≥xj yi≥yj zi≥zj, the bigger one level add 1
问每个point的level是多少。
思路： cdq分治，先去重并统计相同的点的数量，需要注意要记录原id对应到了哪个新id
/* *********************************************** Author :111qqz Created Time :2017年10月10日 星期二 19时53分38秒 File Name :5618.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; struct point { int x,y,z; int id; int cnt,sum; void input( int _id) { scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z); id=_id; } bool operator &amp;lt; (const point &amp;amp;b)const { if (x!</description></item><item><title>BZOJ 3262: 陌上花开 (cdq分治模板题，三维偏序)</title><link>https://111qqz.com/2017/10/bzoj-3262/</link><pubDate>Tue, 10 Oct 2017 11:43:22 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj-3262/</guid><description>
Description 有n朵花，每朵花有三个属性：花形(s)、颜色(c)、气味(m)，又三个整数表示。现要对每朵花评级，一朵花的级别是它拥有的美丽能超过的花的数量。定义一朵花A比另一朵花B要美丽，当且仅当Sa&amp;gt;=Sb,Ca&amp;gt;=Cb,Ma&amp;gt;=Mb。显然，两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。
Input 第一行为N,K (1 &amp;lt;= N &amp;lt;= 100,000, 1 &amp;lt;= K &amp;lt;= 200,000 ), 分别表示花的数量和最大属性值。
以下N行，每行三个整数si, ci, mi (1 &amp;lt;= si, ci, mi &amp;lt;= K)，表示第i朵花的属性
Output 包含N行，分别表示评级为0...N-1的每级花的数量。
Sample Input 10 3 3 3 3 2 3 3 2 3 1 3 1 1 3 1 2 1 3 1 1 1 2 1 2 2 1 3 2 1 2 1
Sample Output 3 1 3 0 1 0 1 0 0 1</description></item><item><title>hdu 5950 Recursive sequence (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/10/hdu-5950/</link><pubDate>Tue, 10 Oct 2017 10:19:55 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-5950/</guid><description>
题目链接
题意： 给f[1],f[2],n,f[i] = 2*f[i-2] + f[i-1] + i^4,求f[n]的值。
思路： 很容易想到矩阵，但是i^4不是线性的差评，我们可以拆一下
i^4=(i-1+1)^4,然后二项式展开即可
i^4=(i-1)^4 + 4*(i-1)^3 + 6(i-1)^2 + 4(i-1) + 1
所以为了维护i^4这一项，需要(i-1)^4,(i-1)^3,(i-1)^2,(i-1),1,
再加上f[i-1]和f[i-2]两项，一共7项。
然后构造矩阵为
16沈阳 onsite的题，当时好像写了一个小时，现在看来，果然是个人尽皆知的傻逼题orz
/* *********************************************** Author :111qqz Created Time :2017年10月10日 星期二 17时38分11秒 File Name :5950.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=7; const LL MOD =2147493647LL; LL a,b,n; struct Mat { LL mat[N][N]; void clear() { ms(mat,0); } void print() { for ( int i = 0 ; i &amp;lt; N; i++) for ( int j = 0 ; j &amp;lt; N ; j++) printf(&amp;quot;%lld%c&amp;quot;,mat[i][j],j==N-1?</description></item><item><title>cdq分治学习笔记</title><link>https://111qqz.com/2017/10/cdq-divide-notes/</link><pubDate>Tue, 10 Oct 2017 08:03:06 +0000</pubDate><guid>https://111qqz.com/2017/10/cdq-divide-notes/</guid><description>
起因是队里的大佬们都会这东西，而我一个老年选手竟然还不会，实在说不过去。
cdq分治显然是分治的一种，cdq的意思就是超短裙啦（
这东西网上资料很多（然而还是学不会
先放一波资料：
资料1
【教程】简易CDQ分治教程&amp;amp;学习笔记
[偏序关系与CDQ分治]【学习笔记】
学习笔记——cdq分治
[学习笔记] CDQ分治 从感性理解到彻底晕菜
lwt菊苣的博客
下面转自lwt菊苣的博客，豁然开朗。
* 与普通分治的区别 普通分治中，每一个子问题只解决它本身（可以说是封闭的） CDQ分治中，对于划分出来的两个子问题，前一个子问题用来解决后一个子问题而不是它本身 * 适用的情况 在很多问题中（比如大多数数据结构题），经常需要处理一些动态问题 然而对动态问题的处理总是不如静态问题来的方便，于是就有了CDQ分治 但使用CDQ分治的前提是问题必须具有以下两个性质：
* 修改操作对询问的贡献独立，修改操作互不影响效果 * 题目允许使用离线算法。 * 一般步骤 * 将整个操作序列分为两个长度相等的部分（分） * 递归处理前一部分的子问题（治1） * 计算前一部分的子问题中的修改操作对后一部分子问题的影响（治2） * 递归处理后一部分子问题（治3） 特别说明： 在整个过程中，最核心的就是步骤3 此时前一部分子问题中的修改操作相对后一部分子问题来说是静态处理，因此可以更加方便地计算后一部分子问题
cdq分治求三维偏序美滋滋
一般是，第一维排序，第二维cdq,第三维套一层数据结构（不然的话就要数据结构套数据结构啦差评
cdq的复杂度和分治的复杂度一样也是O(nlgn),所以可以理解成cdq可以一层数据结构？因为比树套树之类好写，所以有广泛应用（？</description></item><item><title>BZOJ 2648: SJY摆棋子 (动态kd-tree,插入，曼哈顿距离,输入挂)</title><link>https://111qqz.com/2017/10/bzoj2648/</link><pubDate>Tue, 10 Oct 2017 06:58:32 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj2648/</guid><description>
Description 这天，SJY显得无聊。在家自己玩。在一个棋盘上，有N个黑色棋子。他每次要么放到棋盘上一个黑色棋子，要么放上一个白色棋子，如果是白色棋子，他会找出距离这个白色棋子最近的黑色棋子。此处的距离是 曼哈顿距离 即(|x1-x2|+|y1-y2|) 。现在给出N&amp;lt;=500000个初始棋子。和M&amp;lt;=500000个操作。对于每个白色棋子，输出距离这个白色棋子最近的黑色棋子的距离。同一个格子可能有多个棋子。
Input 第一行两个数 N M
以后M行，每行3个数 t x y
如果t=1 那么放下一个黑色棋子
如果t=2 那么放下一个白色棋子
Output 对于每个T=2 输出一个最小距离
Sample Input 2 3 1 1 2 3 2 1 2 1 3 3 2 4 2
Sample Output 1 2
其实就是BZOJ2716 的双倍经验题
写出来是因为，这道题要加输入挂才可以过orz
/* *********************************************** Author :111qqz Created Time :2017年10月10日 星期二 13时35分26秒 File Name :2716.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL linf = 1LL&amp;lt;&amp;lt;60; const int N=5E5+7; int n,m; int idx,rt; LL ans; LL getLL() { LL k = 0, fh = 1; char c = getchar(); for(; c &amp;lt; '0' || c &amp;gt; '9'; c = getchar()) if (c == '-') fh = -1; for(; c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9'; c = getchar()) k = k * 10 + c - '0'; return k * fh; } struct KDT { LL coor[2]; LL mn[2],mx[2]; //需要维护四个方向的最值，是因为是曼哈顿距离。 int son[2]; bool operator &amp;lt; (const KDT &amp;amp;u)const{ return coor[idx]&amp;lt;u.</description></item><item><title>BZOJ 2716: [Violet 3]天使玩偶 (动态kd-tree,带插入，曼哈顿距离模板题)</title><link>https://111qqz.com/2017/10/bzoj2716/</link><pubDate>Tue, 10 Oct 2017 06:49:55 +0000</pubDate><guid>https://111qqz.com/2017/10/bzoj2716/</guid><description>
题目链接 Description Input Output 样例太长了，就不写了。
题意是说，现在有n个在二维平面，m个操作，2种类型，一种是加入一个点，另一种是对于一个定点，询问距离其最近的点的距离。
动态kd-tree的模板题，带插入操作。
插入其实就是直接暴力插的。
需要注意的是，这道题的距离度量是曼哈顿距离，略麻烦。
对于每个点，我们需要维护四个方向的极值。也就是kd-tree中某个节点所代表的空间，能管到的上下左右的最大（最小）坐标。
题解参考了iwtwiioi大爷的博客
代码风格参考了【bzoj 2716】[Violet 3]天使玩偶a 
/* *********************************************** Author :111qqz Created Time :2017年10月10日 星期二 13时35分26秒 File Name :2716.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL linf = 1LL&amp;lt;&amp;lt;60; const int N=5E5+7; int n,m; int idx,rt; LL ans; struct KDT { LL coor[2]; LL mn[2],mx[2]; //需要维护四个方向的最值，是因为是曼哈顿距离。 int son[2]; bool operator &amp;lt; (const KDT &amp;amp;u)const{ return coor[idx]&amp;lt;u.</description></item><item><title>hdu 1724 Ellipse (辛普森积分模板题)</title><link>https://111qqz.com/2017/10/hdu-1724/</link><pubDate>Mon, 09 Oct 2017 13:33:36 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-1724/</guid><description>
hdu1724题目链接
题意： 求图示区域的面积。
思路： 辛普森积分学习笔记
容易推出被积函数为 f(x)=b_sqrt(1-(x_x/a/a));
/* *********************************************** Author :111qqz Created Time :2017年10月09日 星期一 21时09分36秒 File Name :1724.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-10; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double a,b,l,r; double dblcmp(double d){ return d&amp;lt;-eps?</description></item><item><title>辛普森积分学习笔记</title><link>https://111qqz.com/2017/10/Simpsons-rule-notes/</link><pubDate>Mon, 09 Oct 2017 13:10:43 +0000</pubDate><guid>https://111qqz.com/2017/10/Simpsons-rule-notes/</guid><description>
16沈阳的阴影还在orz，来学习一下辛普森积分。
参考资料：梯形多步法和辛普森积分
辛普森计算定积分
辛普森积分是一种数值积分方法（然后现在只记得教计算方法的是一个小姐姐，并不记得当时学了什么orz
大概就是用梯形近似计算曲边梯形面积，辛普森积分公式如下：
下面放代码：
double f(double x){return sin(x)*x;}//这是被积函数 double simpson(double l,double r){return (r-l)*(f(l)+f(r)+4*f((l+r)/2))/6;} double di(double l,double r){//越二分以得到更精确的结果 double m=(l+r)/2; double ans=simpson(l,r); if(sgn(ans-simpson(l,m)-simpson(m,r))==0)return ans; //在误差之内 return di(l,m)+di(m,r); //不再误差之内就继续将区间缩小 } 切了个练手题，慢慢补充总结。
需要注意的是，simpson对精度要求比较高。。。eps开到1E-10才过。。
hdu1724题目链接
hdu1724解题报告
所以问题就在于写出积分公式（如果是多重积分要变成累次积分？orz)</description></item><item><title>hdu 4347 The Closest M Points (kd-tree+优先队列，求M近邻)</title><link>https://111qqz.com/2017/10/hdu-4347/</link><pubDate>Mon, 09 Oct 2017 06:01:23 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-4347/</guid><description>
题目链接
题意： 给出若干个点，在给出一个定点，求距离该定点最近的m个点。
思路： 我们已经知道kd-tree可以得到最近邻，实际上M近邻，只需要维护一个size为M的优先队列就可以了。
需要注意，优先队列的元素一定要先定义小于关系orz
以及这次采用了轮盘转的策略划分维度，也就是按照深度，所有维度轮流作为split-method（实际用起来效果还是挺棒的orz
/* *********************************************** Author :111qqz Created Time :2017年10月08日 星期日 23时18分42秒 File Name :4347.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; const int M = 10; int n,m,k,t; int idx; struct Point { LL coor[M]; int id; void print() { for ( int i = 1 ; i &amp;lt;= k ; i++) printf(&amp;quot;%lld%c&amp;quot;,coor[i],i==k?</description></item><item><title>hdu 5992 Finding Hotels (kd-tree 裸题,查询)</title><link>https://111qqz.com/2017/10/hdu-5992/</link><pubDate>Sun, 08 Oct 2017 12:55:55 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-5992/</guid><description>
题目链接
题意： 有若干个(2E5)旅馆，分别给出旅馆的坐标和价格。有m个查询，每个查询给出一个人的位置(x0,y0),以及其能接受的最高价格。问在该人能接受的价格内，距离其最近的旅馆的坐标和价格是多少。
思路： kd-tree学习笔记
加了价格的限制其实无所谓，只要在更新的时候，先判一下价格就行了。
训练的时候不会kd-tree。。感觉有点可惜了。不然就6题了orz
/* *********************************************** Author :111qqz Created Time :2017年10月08日 星期日 18时43分38秒 File Name :5992.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; struct Point { LL x,y; int c; int id; }p[N]; bool dv[N]; //划分方式 bool cmpx( const Point &amp;amp; p1, const Point &amp;amp;p2) { return p1.</description></item><item><title>hdu 2966 In case of failure （ kd-tree（只有查询） 模板题）</title><link>https://111qqz.com/2017/10/hdu-2966/</link><pubDate>Sun, 08 Oct 2017 11:53:35 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-2966/</guid><description>
题目链接：hdu2966 
题意： 给出二维平面上n(1E5)个点，问对于每个点，其他距离其最近的点的距离是多少。
思路： kd-tree 裸题。
kd-tree 学习笔记
/* *********************************************** Author :111qqz Created Time :2017年10月08日 星期日 18时43分38秒 File Name :2996.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; struct Point { LL x,y; }p[N],p2[N]; //复制一份，因为nth_element的时候会把顺序打乱。 bool dv[N]; //划分方式 bool cmpx( const Point &amp;amp; p1, const Point &amp;amp;p2) { return p1.</description></item><item><title>kd tree 学习笔记</title><link>https://111qqz.com/2017/10/kd-tree-notes/</link><pubDate>Sun, 08 Oct 2017 11:46:46 +0000</pubDate><guid>https://111qqz.com/2017/10/kd-tree-notes/</guid><description>
老规矩，资料先行。
好久没学新算法了，有点忘记怎么学了orz
K-D tree 数据结构
hdu 2966 In case of failure　（k-d树　最近邻近点）
首先来看算法的提出。
现在二维平面上有n个点，知道这n个点的坐标，然后再添加一个点，问n个点中，距离新添加的点距离最近的点。
如果不做任何预处理，那么就是暴力枚举每个点，与该定点的距离。
如何优化呢？ 我们可以考虑把点域均等划分成若干个方块。
这样每次询问的时候只需要查询定点所在方格，以及定点相邻的8个方格中的点与该定点的距离即可。（除非这九个方格中没有点）
这种划分方法，对于随机数据大概是美滋滋，但是数据不会那么随机，因此划分也不能均等划 分。
这个时候， kd-tree 登场。k-d树（ **k-维树**的缩写）是在_k_维欧几里德空间组织点的数据结构
对于二维平面，kd-tree的思想是，提供一种平面的划分方法，使得对于任意输入数据，划分尽可能均匀。
**划分方法其实不唯一，常用的划分方法是，**对于k维中的每一维，按照方差最大的那一维划分。
（看到有些题解中，用该维度的极差（就是最大值-最小值）来作为度量，也就是按照极差最大的那一维度划分。）
(用方差的度量往往比较慢，看到根据二叉树的深度，交替维度也是一种常用做法 比如2016青岛 onsite)
下面是具体的划分过程。
 假设现在我们有平面上的点集 E ，其中有 5 个二维平面上的点 ： （1,4）（5,8） （4,2） （7,9） （10，11）
 它们在平面上的分布如图：
   首先，我们对区间 [ 1 , 5 ] 建树：
 先计算区间中所有点在第一维（也就是 x 坐标）上的方差：</description></item><item><title>2016 NEERC Northern Subregional Contest A Anniversary Cake （水题）</title><link>https://111qqz.com/2017/10/2016-NEERC-subregional-A/</link><pubDate>Tue, 03 Oct 2017 03:58:13 +0000</pubDate><guid>https://111qqz.com/2017/10/2016-NEERC-subregional-A/</guid><description>
题意： W_H的方格纸，共有(w+1)_(H+1)个整点，现在将2个蜡烛放在2个不同的整点上。蜡烛不会被放在边界上。现在给出方格纸的尺寸和2个蜡烛的坐标，求一条线段将方格纸拆成2部分，而且这条线段不经过任何一个蜡烛且使得每一部分恰好有一个蜡烛。问线段的起点和终点。
思路： 为了方便讨论，我们将x坐标小的设为蜡烛1，另一个设为蜡烛2.
分两种情况讨论，即横坐标相同和不同2种情况。
需要注意的是...要交文件orz
/* *********************************************** Author :111qqz Created Time :2017年10月02日 星期一 12时34分38秒 File Name :A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL w,h,ax,ay,bx,by; int main() { freopen(&amp;quot;anniversary.</description></item><item><title>codeforces 385 E. Bear in the Field (先记录想法）</title><link>https://111qqz.com/2017/10/codeforces-div2-385e/</link><pubDate>Mon, 02 Oct 2017 02:24:09 +0000</pubDate><guid>https://111qqz.com/2017/10/codeforces-div2-385e/</guid><description>
题目链接
题意： 有一只熊，初始在(sx,sy)处，如果当前的位置在(x,y)，那么下一秒会在((x+dx-1)%n+1,(y+dy-1)%n+1)处， dx[i] = k[i-1] + dx[i-1],dy[i]=k[i-1] + dy[i-1]，k表示的是某个点的花丛数目。
初始点(x,y)的花丛数为x+y,每经过一个时间，所有点的花丛数增加1.
所以，k[i] = x[i] + y[i] + i-1，现在问经过时间t后，熊的位置在哪里。也就是x[t],y[t]的值。
思路： 我们不妨先只考虑x方向的，因为y方向完全相同。
观察x[t]的式子， x[t] = (x[t-1] + dx[t-1] -1) % n +1。。这个%n之后+1简直蛋疼得一逼。。。
我们不妨构造_g[t] = x[t]-1_，这样原式子就变成了 _g[t] = (g[t-1] + dx[t-1]) %n _...看起来爽了很多。。。
观察式子_g[t] = (g[t-1] + dx[t-1]) % n_，我们发现这是一个前缀和的形式。
根据在hdu4686解题报告 中提到的经验，对于求和的式子，我们只需要考虑每一项的构造法。
因此问题转化成构造矩阵dx[t]
dx[t] = k[t-1] + dx[t-1]
其中_k[t] = x[t] + y[t] + t-1,_我们写成gx[t]和gy[t]的形式
有**k[t] = gx[t] + gy[t] + t + 1**</description></item><item><title>UVA - 10518 How Many Calls? (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/10/uva-10518/</link><pubDate>Sun, 01 Oct 2017 11:10:16 +0000</pubDate><guid>https://111qqz.com/2017/10/uva-10518/</guid><description>
题目链接
题意： 求f[n] = f[n-1] + f[n-2] + 1，在b(10000)进制下的最后一位数字的十进制表示。
思路： 构造矩阵即可，M矩阵是一个3_3的矩阵，M1矩阵是一个3_1的矩阵。。很easy，就不说了。
写题解的目的是，对于这种要求b进制下，最后一位或者最后两位的数字的十进制表示的问题，其实就是在说，取模的数是base或者base^2
1A美滋滋
/* *********************************************** Author :111qqz Created Time :2017年10月01日 星期日 18时39分17秒 File Name :10518.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 5; LL n,base; struct Mat { LL mat[N][N]; void clear() { ms(mat,0); } }M,M1; Mat operator * ( Mat a,Mat b) { Mat c; c.</description></item><item><title>hdu 4686 Arc of Dream (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/10/hdu-4686/</link><pubDate>Sun, 01 Oct 2017 06:33:48 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-4686/</guid><description>
hdu4686题目链接
题意： An Arc of Dream is a curve defined by following function:
where a 0 = A0 a i = a i-1_AX+AY b 0 = B0 b i = b i-1_BX+BY What is the value of AoD(N) modulo 1,000,000,007?
思路： 看n的1E18的范围也知道是矩阵快速幂。。
难点还是构造矩阵。
构造矩阵主要凭借经验，但是还是有一些规律可循：
1. 对于求和的式子，如 s[n] = sum{F[1]..F[n]}类似的式子，我们只需要考虑如何构造F[n]即可。 2. 尽量将要构造的表达式展开成，第n项，与前面项(第n-1项等)有关的形式。 3. 观察2中展开的表达式的系数，每一个系数都亚奥出现在转移矩阵M中。 4. 观察2中展开的表达式的项，基本每一项都要整体或者以其他形式出现在初始矩阵M1中 5. 我们并不很关心初始项。 6. 难点其实在于构造M1矩阵，也就是说哪些项是重要的。一般而言，**可能有的项是，s[n],f[n],常数项，以及为了构造出f[n]的辅助项。** 对于这道题：
然后矩阵快速幂即可。
1A
/* *********************************************** Author :111qqz Created Time :2017年10月01日 星期日 13时34分52秒 File Name :4686.</description></item><item><title>uva 10870 - Recurrences (矩阵加速线性递推式)</title><link>https://111qqz.com/2017/10/uva-10870/</link><pubDate>Sat, 30 Sep 2017 20:35:55 +0000</pubDate><guid>https://111qqz.com/2017/10/uva-10870/</guid><description>
uva10870题目链接
题意： f(n) = a1f(n − 1) + a2f(n − 2) + a3f(n − 3) + . . . + adf(n − d), for n &amp;gt; d
给出f[1]..f[d],a[1]..a[d],问 f[n]%m是多少。
思路： 构造矩阵，加速递推式。
趁着这道题说一下一般的构造法。
转移矩阵M(d*d)的构造方法是，最后一行倒序写a[1]..a[d], 除去第一列和最后一行外，用1填充对角线，其余的为0.
初始矩阵M1(d*1)的构造方法是从上到下，f[1]..f[d]即可。
需要注意的是
*最后答案是 (M^(n-d))M1.mat[d-1][0] (由于经常出现的是d=2的递推式，因此注意不要把此式子的d，写成不够一般化的错误的2
/* *********************************************** Author :111qqz Created Time :2017年10月01日 星期日 03时57分36秒 File Name :10870.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=20; int n,d; LL mod; LL a[N],f[N]; struct Mat { LL mat[N][N]; void clear() { ms(mat,0); } void print() { for ( int i = 0 ; i &amp;lt; d ; i++) for ( int j = 0 ; j &amp;lt; d ; j++) printf(&amp;quot;%lld%c&amp;quot;,mat[i][j],j==d-1?</description></item><item><title>uva 10655 - Contemplation! Algebra （构造矩阵，快速幂）</title><link>https://111qqz.com/2017/10/uva-10655/</link><pubDate>Sat, 30 Sep 2017 19:40:15 +0000</pubDate><guid>https://111qqz.com/2017/10/uva-10655/</guid><description>
uva10655题目链接
题意： 给出a+b和ab的值，问a^n+b^n
思路： 构造矩阵,手写一下很显然...
转移矩阵M=[0 , 1]
[-q,p ]
初始矩阵M1=[p ]
[p^2-2*q]
快速幂即可。
有个坑点在于..读入的结束是p=0&amp;amp;q=0,并且只有这两个输入。
如果用p=0&amp;amp;&amp;amp;q=0作为终止条件，那么就会将三个输入，但p==0&amp;amp;&amp;amp;q==0的情况错误得终止...
正确的做法是 while (~scanf(&amp;quot;%lld%lld%lld&amp;quot;,&amp;amp;p,&amp;amp;q,&amp;amp;n)==3)
/* *********************************************** Author :111qqz Created Time :2017年10月01日 星期日 03时01分38秒 File Name :10655.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL p,q,n; struct Mat { LL mat[105][105]; void clear() { ms(mat,0); } }M,M1; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>快速乘</title><link>https://111qqz.com/2017/09/fast-multiply-notes/</link><pubDate>Sat, 30 Sep 2017 12:50:42 +0000</pubDate><guid>https://111qqz.com/2017/09/fast-multiply-notes/</guid><description>
16年北京网络赛遇到了这个技巧...但是竟然忘记记了下来？
快速乘是为了解决 计算a_b % mod 时a_b溢出LL 的问题
比如a=1E16,b=1E16,mod=1E18，虽然最后的结果没有溢出，但是中间溢出了。
原理和快速幂很类似，具体可以参考 晴川大爷的专栏
ll fastMultiplication(ll a,ll b,ll mod){ ll ans = 0; while(b){ if(b%2==1){ b--; ans = ans + a; ans %= mod; }else{ b /= 2; a = a + a; a %= mod; } } return ans; } 完全就是把快速幂中的乘法变成加法了嘛（从记忆角度考虑orz
inline long long multi(long long x,long long y,long long mod) { long long tmp=(x*y-(long long)((long double)x/mod*y+1.0e-8)*mod); return tmp&amp;lt;0 ? tmp+mod : tmp; }</description></item><item><title>hdu 4990 Reading comprehension (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/09/hdu-4990/</link><pubDate>Sat, 30 Sep 2017 11:38:05 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu-4990/</guid><description>
题目链接
题意： 给出了一段程序，程序实际算的是f[n] = (f[n-1] + n%2)%m的值，其中f[1]=1,给出n,m(1E9)，问f[n]
思路： 显然是矩阵快速幂，终点在于构造矩阵。
通过经验可得（这次真的是经验了。。。其实也挺容易的，要点大概在于先把需要的项列在一起，然后增加0或者多个，为了转移需要的辅助项。
根据当前列和下一列，手动构造转移矩阵）
转移矩阵M为
[2, 1,0]
[0,-1,1]
[0,0 ,1]
4A..都是一个原因。。矩阵乘法那里。。。就算你%了m..也是两个1E9在相乘。。。然后就炸了23333,改成LL即可。
/* *********************************************** Author :111qqz Created Time :2017年09月30日 星期六 19时08分59秒 File Name :4990.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f;le int n; LL mod; struct Mat { LL mat[8][8]; void clear() { ms(mat,0); } }M,M1; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>hdu 5015 233 Matrix (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/09/hdu-5015/</link><pubDate>Sat, 30 Sep 2017 10:54:07 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu-5015/</guid><description>
hdu5015题目链接
题意： 给出矩阵的构造规则： a[0][j] (j&amp;gt;=1) 分别为233,2333,23333....给出a[i][0] (i&amp;gt;=1)，对于其余的i,j,a[i][j]=a[i-1][j] + a[i][j-1]
现在问a[n][m] 在% 1E7+7 下的值是多少 （n&amp;lt;=10,m&amp;lt;=1E9）
思路： 显然矩阵快速幂，但是不会构造矩阵，放弃。
看了很多题解...发现都是“显然”构造出矩阵。。。似乎是直接凑出来的。。。
可能需要积累一点经验。
对于这道题，我们观察到n很小
所以一个直觉就是从n-1列推到第n列，推到n+1列这样地推。
初始第一列的信息是（假设n为3）
[a1]
[a2]
[a3]
然后我们想要得到
[a1+233]
[a1+a2+233]
[a1+a2+a3+233]
我们发现我们需要233这个常数项体现在矩阵中
而且之后还需要233,2333,23333体现在矩阵中。
那么，我们可以在初始添加23和3两项，这样23...3就都可以构造出来了（我觉得关键点就在这一步，应该是凭借经验吧，虽然刚开始有点难想到orz)
因此现在初始列变成了(其实放置顺序无所谓，不过这样放可以让ai和行数对应，比较友好。
[23]
[a1]
[a2]
[a3]
[3]
设该矩阵为A
现在我们想得到下一列
[233]
[a1+233]
[a1+a2+233]
[a1+a2+a3+233]
[3]
设该矩阵为B
那么现在的问题就是构造一个矩阵5*5的矩阵X,使得X×A=B
凭借直觉（经验？
我们得到这样的矩阵X为
[10,0,0,0,1]
[10,1,0,0,1]
[10,1,1,0,1]
[10,1,1,1,1]
[0, 0,0,0,1]
接下来就是矩阵快速幂了，答案是 (X^m)×A.mat[n][0]
/* *********************************************** Author :111qqz Created Time :2017年09月30日 星期六 17时47分20秒 File Name :5015.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int a[15]; const LL MOD=10000007; struct Mat { LL mat[15][15]; void clear() { ms(mat,0); } void print() { for ( int i = 0 ; i &amp;lt;= n+1 ; i++) { for ( int j = 0 ; j &amp;lt;= n+1 ; j++) { printf(&amp;quot;%lld &amp;quot;,mat[i][j]); } printf(&amp;quot;\n&amp;quot;); } } }M,M1; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>20170929</title><link>https://111qqz.com/2017/09/20170929/</link><pubDate>Fri, 29 Sep 2017 17:10:29 +0000</pubDate><guid>https://111qqz.com/2017/09/20170929/</guid><description>
刚刚看了TBBT season 11 episode 1
Sheldon 和Amy 订婚了，Bernadette又怀孕了。
想想上一季结束的时候，大概半年前。
我好像还是只单身狗，手头没啥能看的offer，还有巨大的学业压力在前方。
感觉这半年收获了好多，多了一份担当，多了几个offer，可能是16年的运气真的太差了吧。
就沈阳打铁这事。。。就真的令人窒息。
这半年真的不知道是怎么过来的，虽然也知道“成年人的事情没有容易二字”，
也不是很愿意太过矫情...
而且日常警惕那种“毫无意义的自我感动”
不过还是真的想说
感谢菊苣@sxg的陪伴
感谢身边那些，在我最低沉最痛苦最萎靡的时候，一直给我加油打气，给我信心的小伙伴。
还要感谢自己....在最艰难的时候，也未曾想过放弃。
这几年真的是...过得太痛苦了...
真的好想大哭一场啊....</description></item><item><title>hdu 3642 Get The Treasury (线段树+扫描线，求长方体体积交)</title><link>https://111qqz.com/2017/09/hdu-3642/</link><pubDate>Fri, 29 Sep 2017 10:34:09 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu-3642/</guid><description>
hdu3642题目链接
题意：给出若干个（1000）长方体，求至少交三次的空间的体积。
尺寸为[x1,x2],[y1,y2],[z1,z2],其中x，y的坐标的绝对值不超过1E6,Z的坐标的绝对值不超过1E9.
思路：
线段树+扫描线。
由于Z的坐标范围比较小，我们的做法是 利用“微分”的思想，将每个长方体，想成若干的高度为1的矩形（矩形片）
因此就转化成了求矩形至少交三次的面积
其中和矩形交，也就是矩形至少交2次的面积比较类似，只不过线段树多维护一个至少三次覆盖的长度的域。
void PushUp(int l,int r,int rt) { //cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;&amp;quot; id:&amp;quot;&amp;lt;&amp;lt;id&amp;lt;&amp;lt;endl; if (tree[rt].cnt&amp;gt;=3) { tree[rt].one = tree[rt].two = tree[rt].three = X[r+1]-X[l]; } else if (tree[rt].cnt==2) { tree[rt].one = tree[rt].two = X[r+1]-X[l]; if (l==r) tree[rt].three = 0 ; else tree[rt].three = tree[rt&amp;lt;&amp;lt;1].one + tree[rt&amp;lt;&amp;lt;1|1].one; }else if (tree[rt].cnt==1) { tree[rt].one = X[r+1] - X[l]; if (l==r) tree[rt].two = tree[rt].three = 0; else { tree[rt].two = tree[rt&amp;lt;&amp;lt;1].</description></item><item><title>hdu 1828 Picture （线段树+扫描线 求 矩形周长并）</title><link>https://111qqz.com/2017/09/hdu1828/</link><pubDate>Thu, 28 Sep 2017 05:44:47 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu1828/</guid><description>
题目链接
题意: 求矩形周长并。
思路： 线段树+扫描线。
和前面的求面积并比较类似，我们先考虑平行x轴的线段，考虑线段树，维护的一段区间中被矩形覆盖的次数cnt和至少覆盖一次的长度的len.
只不过我们这次求的是每条扫描线的长度对周长的贡献，因此不需要乘高度。
需要注意的是，每条扫描线对周长的贡献，是目前扫描线的长度，与上一次扫描线长度的差的绝对值。（不是与上一次答案的差的绝对值！）
演示x轴求长度和的部分 图片来自 lwt聚聚的博客 以及一个小细节是，求面积的时候，最后一条扫描线对答案是没有贡献的（因为每次是求当前扫描线与下一条扫描线之间的面积）
但是求周长的时候，最后一条扫描线是一定会对答案有贡献的。
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 21时24分20秒 File Name :1828.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; struct Seg { double l,r,h; int d; Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp;rhs)const { return h &amp;lt; rhs.</description></item><item><title>hdu 1255 覆盖的面积 (扫描线+线段树 求矩形面积交)</title><link>https://111qqz.com/2017/09/hdu1255/</link><pubDate>Wed, 27 Sep 2017 13:20:23 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu1255/</guid><description>
题目链接
题意： 求n（1000）个矩形的面积交，也就是至少有2个矩形覆盖的区域的面积。
思路： 和矩形面积并_hdu1542解题报告  类似
面积并问题中，线段树len维护的是至少覆盖一次的区域的长度
在面积交的问题中，我们需要多维护一个&amp;quot;至少覆盖两次的区域的长度&amp;quot;的域（设为double two;）
同时也要维护至少覆盖一次的区域的长度（设为double one;），是因为至少覆盖两次的区域的长度可以由至少覆盖一次的区域长度得到（好像是废话）
PushUp的时候要格外注意当前节点被完整覆盖一次的情况。
此时tree[rt].two 可以由两个子区间的one的情况想加得到
（因为rt节点被完整覆盖了至少一次，那么如果rt儿子区间中被覆盖了至少一次，对于rt区间中被rt&amp;lt;&amp;lt;1和rt&amp;lt;&amp;lt;1|1覆盖至少一次的区间在对于rt区间就已经覆盖了至少2次）
以及要注意题意说得不够清楚。最后保留2位小数是四舍五入。
读入的实际上是左下角和右上角的点。。。。
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 19时10分37秒 File Name :1255.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n; struct Seg { double l,r,h; int d; Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp; rhs)const { return h&amp;lt;rhs.</description></item><item><title>hdu 1542 Atlantis (线段树+扫描线求矩形面积并，模板题)</title><link>https://111qqz.com/2017/09/hdu-1542/</link><pubDate>Wed, 27 Sep 2017 10:59:46 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu-1542/</guid><description>
hdu1542题目链接
题意： 求n(100)个矩形的面积并。
思路： 扫描线+线段树
题目是2000年中欧区域赛的题目，虽然年代久远，但是有好几个点还是很值得学习的。
首先是离散化的适用范围: 之前比较常用的是将比较大的整数值离散化，常常是因为数值太大无法作为下标。 那么其实，浮点数有的时候也需要进行离散化，比如作为数组的下标，比如用来枚举。 做法上是和将较大的整数值离散化没有区别，因为遇到的题目不多，所以特意记录一下。 第二点是扫描线的思想：
其实扫描线的思想很早就接触过，noip2011的时候，tyvj上有一道类似的题目，不过是一唯的，当时印象深刻的是@Ocean 兄的那个比喻：
一段公路上右很多区间要收不同的费用，区间的开始给一个标记，表示该段区间对答案有贡献，区间的结束拿走该标记，表示该段区间对答案的贡献结束。
这就是扫描线的思想。
第三个是处理线段覆盖问题的一般做法：
通常线段树的节点处理的都是点，处理线段的时候就会比较麻烦。
 另外很重要的一点就是， 线段树都是维护一个点集， 但是对于边的问题就会变得很麻烦， 我们可以按照区间左端点建立线段树， 那么一个点表示的就不是点了， 而是起点在这个点的一个线段。 这**样的话， 右区间就要相应的-1， 例如更新区间[1, 4]， 就相当于更新标号为[1, 3]的线段。** 这也是处理线段覆盖问题的通用方法。
对于上面引用中提到的例子中“更新[1,4]，就相当于更新标号为[1,3]的线段”，是因为标号为1的节点代表区间[1,2]，标号为2的节点代表区间[2,3],标号为3的节点代表期间[3,4]
接下来具体讨论这道题目的做法：
将矩形按平行x轴方形构建扫描线（只是思想，不用实际构造），
每个矩形2条平行x轴的边分类{上边，下边}2类，如果我们从下往上“扫描”线，那么[下边]就表示了对答案贡献的开始，[下边]就表示了对答案贡献的结束。
* 扫描线扫描的过程（建议配合代码模拟） **以下图转载自@kk303的博客** 初始状态
扫到最下边的线, 点1→3更新为1
扫到第二根线, 此时S=lcnt!=0∗h两根线之间, 得到绿色的面积, 加到答案中去, 随后更新计数
同上, 将黄色的面积加到答案中去
同上, 将灰色的面积加到答案中去
同上, 将紫色的面积加到答案中去
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 16时37分39秒 File Name :1542.</description></item><item><title>zoj 3606 Lazy Salesgirl (线段树，单点更新，区间合并)</title><link>https://111qqz.com/2017/09/zoj-3606/</link><pubDate>Tue, 26 Sep 2017 12:52:37 +0000</pubDate><guid>https://111qqz.com/2017/09/zoj-3606/</guid><description>
zoj3606题目链接
题意：有个小女孩卖火柴,有n个人会来买，分别在时间t[i]，以价格p[i]，买的火柴个数为1+(k-1)%3,其中k为这是小女孩第几次卖火柴。 如果有大于w的时间没人来买火柴，小女孩就会睡着。小女孩睡着后如果有人来买火柴，那小女孩就会醒过来，但是不会卖给这个人火柴。现在问使营业额最大的基础上最小的时间间隔w。
思路： 显然，w应该是某2个顾客的来访时间只差（而不是什么任意值）.
因此我们可以通过枚举相邻访问时间的顾客的访问之间之差。
我们可以从小到大枚举w，这样就可以保证得到的最大营业额的对应w最小。
构造一颗线段树，维护4个域，cnt表示区间中，确实购买了火柴的顾客的人数，sum[i] (i属于0..2) 表示一个区间中最左边的顾客购买了i+1根火柴后，该区间的最大利润。
所以其实这道题类似hdu4288解题报告 
维护sum[i]的时候，右一点绕，需要注意对于tree[rt].sum[i]，我们只是说该区间的最左边的人买了(i+1)根火柴，该区间的其他人买了几根火柴无所谓，我们只想知道该区间的利润。
wa了一次。。因为虽然我们分析出w一定是某2个连续的时间的差值，一定是整数值，但是为了迷惑人。。题目还是要以6位小数输出。
/* *********************************************** Author :111qqz Created Time :2017年09月26日 星期二 18时32分43秒 File Name :3606.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int total; struct node { int p,t; int id; bool operator &amp;lt; (const node &amp;amp;b) const { return t&amp;lt;b.</description></item><item><title>hdu 4288 Coder (离散化， 线段树，单点更新，区间合并)</title><link>https://111qqz.com/2017/09/hdu-4288/</link><pubDate>Tue, 26 Sep 2017 06:56:57 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu-4288/</guid><description>
题目链接
题意：n（1E5）个操作，分为三种，add x表示将x加到集合中（保证集合中之前没有x)，del x表示从集合中删掉x(保证集合中一定右x),sum表示求集合中所有元素按从小到大排列后，所有的下标中满足i%5=3的a[i]的和。1=&amp;lt;x&amp;lt;=1E9
思路：很容易想到的是，由于插入和删除元素造成的位置改变是剧烈的，因此要分别维护i%5==k,k属于0..4的元素的和。
这道题的核心点在于，由于只有1E5个操作，我们可以将元素离散化，这样做的目的是，将每个数和位置一一对应，每个位置用1或者0，表示该位置对应的元素是否在集合中。
考虑线段树，维护6个域，1个是区间中，在集合中的元素个数，剩下5个域，分别表示以该区间的端点为位置1，位置x%i=k的元素的和（k属于0..4)。因此每个叶子节点都是位置1.
考虑PushUp, 区间元素和之间累加，难点在于其他5个域的维护。
假设当前区间为rt,那么对于sum[0..4] (sum代表的就是上面说的要维护的5个域），显然区间rt&amp;lt;&amp;lt;1的答案可以直接贡献给rt.
对于rt&amp;lt;&amp;lt;1|1的答案，考虑rt&amp;lt;&amp;lt;1|1中位置为%5==x的元素和，rt&amp;lt;&amp;lt;1中的元素个数为len个，那么rt&amp;lt;&amp;lt;1|1中sum[x]对 rt中的sum[(x+len)%5]有贡献。
反推出对rt 中 sum[i]有贡献的是rt&amp;lt;&amp;lt;1|1中的sum[(i-len+5)%5)]
/* *********************************************** Author :111qqz Created Time :2017年09月26日 星期二 12时42分10秒 File Name :4288.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; struct Node { int cnt; //区间中，在集合中存在的元素的个数。 LL sum[5]; //sum[i]表示该区间中，以区间起点为下标1开始计算时，位置为x%5==i时的元素的和。 }tree[N&amp;lt;&amp;lt;2]; struct Opt { int opt; LL val; }qu[N]; LL H[N],A[N]; int cnt; int Hash( int x) { return lower_bound(H,H+cnt,x)-H; } void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 855 B. Marvolo Gaunt's Ring (前缀最大，dp)</title><link>https://111qqz.com/2017/09/codeforces-855-b/</link><pubDate>Mon, 25 Sep 2017 13:12:25 +0000</pubDate><guid>https://111qqz.com/2017/09/codeforces-855-b/</guid><description>
题目链接
题意：给出n,p,q,r,以及n（1E5）个数，所有数的范围都是[-1E9,1E9],现在问p_a[i]+q_a[j]+r*a[k]的最大值，满足1&amp;lt;=i&amp;lt;=j&amp;lt;=k&amp;lt;=n
思路：傻逼dp...
我。。好菜啊。。。万年dp苦手。
直接转载官方题解了。。。思路的重点是维护了一个最大前缀值。
_dp_[_i_][0] stores maximum of value _p_·_a__x_ for _x_ between 1 and _i_. Similarly _dp_[_i_][1] stores the maximum value of _p_·_a__x_ + _q_·_a__y_ such that _x_ ≤ _y_ ≤ _i_ and _dp_[_i_][2] stores maximum value of _p_·_a__x_ + _q_·_a__y_ + _r_·_a__z_ for _x_ ≤ _y_ ≤ _z_ ≤ _i_. To calculate the dp:
dp[i][0] = max(dp[i - 1][0], p·a__i)
dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·a__i)</description></item><item><title>codeforces edu #29 E. Turn Off The TV (思维，乱搞)</title><link>https://111qqz.com/2017/09/codeforces-edu-29e/</link><pubDate>Mon, 25 Sep 2017 10:55:57 +0000</pubDate><guid>https://111qqz.com/2017/09/codeforces-edu-29e/</guid><description>
题目链接
题意：有若干线段，给出起点和终点，问是否有一个线段是冗余的。冗余的意思是说，对于该线段所覆盖的所有整数点，没有该线段，也能被其他一个或者多个线段覆盖到。如果有，输出任意一个冗余线段即可。
思路：画画图？ 显然可以按照第一关键字左端点升序，第二关键字右端点降序（降序是为了处理 n=2,[1,2],[1,3] 这样的case容易一些），先考虑2种最简单的情况。
第一种是a[i+1]完全被a[i]包裹在里面，准确得说不一定是a[i]，而是之前所有线段的最大右端点的那条线段，此时a[i+1]就是冗余的线段。
第二种是a[i+1]的左端点在之前所有线段的最大右端点右边，此时没有冗余，继续进行。
接下来考虑比较复杂的相交情况，我们画图发现，当前线段是否冗余，只与a[i-1]和a[i+1]有关。
如果第i条线段的左端点，不超过第i-2条线段的右端点的右边一个位置，此时第i-1条线段就是冗余的。
wa了2次。。原因是没认真看题，l,r的范围的最小值是从0开始而不是1。所以总体来说是道水题（调教场的题这么水了么。。。
/* *********************************************** Author :111qqz Created Time :2017年09月25日 星期一 02时57分03秒 File Name :E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; struct Node { int l,r; int id; }a[N]; int n; int ans; vector&amp;lt;int&amp;gt;ret; bool cmp( Node x, Node y) { if (x.</description></item><item><title>Codeforces eductional round 29</title><link>https://111qqz.com/2017/09/codeforces-eductional-round-29/</link><pubDate>Sun, 24 Sep 2017 08:47:13 +0000</pubDate><guid>https://111qqz.com/2017/09/codeforces-eductional-round-29/</guid><description>
比赛链接
10个月没写题了，菜啊。进行一点恢复性训练好了。
A: 给一个数，可以在填写若干（或者0）个前缀0，问能否变成回文数。
思路是直接删掉后面可能的出现的0再判断回文数就好。
/* *********************************************** Author :111qqz Created Time :2017年09月24日 星期日 13时51分06秒 File Name :A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; bool check( int x) { vector&amp;lt;int&amp;gt;val; while (x) { int tmp = x; val.</description></item><item><title>反向传播学习笔记</title><link>https://111qqz.com/2017/09/back-propagation-notes/</link><pubDate>Tue, 05 Sep 2017 12:30:17 +0000</pubDate><guid>https://111qqz.com/2017/09/back-propagation-notes/</guid><description>
先说下自己目前很笼统的理解：
反向传播是用来快速计算梯度的一种方法；
过程大概是把计算过程用计算图表示，这样每一个中间步骤都有一个节点，每一个local gradient都会比较容易计算；
思想涉及 chain rule + 计算图 + 记忆化
因为计算不同自变量的偏导数会存在很多共同路径，这部分就只计算了一次，因此可以加快计算速度。
所以核心的东西大概是两点：
* 用计算图表示计算，局部gradient 替代繁琐的微积分计算 * 共同部分只计算一次，类似一个记忆化。</description></item><item><title>MPI 学习笔记</title><link>https://111qqz.com/2017/08/mpi-notes/</link><pubDate>Thu, 31 Aug 2017 03:04:27 +0000</pubDate><guid>https://111qqz.com/2017/08/mpi-notes/</guid><description>
参考资料：
消息传递接口（MPI）维基百科
MPI_TUTORIAL
MPI 在大规模机器学习领域的前景如何？
因为要和平台组对接工作以及写我们自己的BN同步...所以来了解一下MPI相关...感谢平台组@gyz 菊苣提供指导。
下面写一些自己的理解 ^_^
OVERVIEW MPI是一个跨语言的通讯协议，用于并行相关
MPI不是一种具体的语言实现，而是一种标准或者说接口，类比sql在关系型数据库中的地位，具体用的时候我们是用某个特定的实现，例如openmpi或者mpich2
对于机器学习问题，MPI很适合用在超算上...
下面随便补一些我认为需要了解的：
** **_communicator _是一个进程的group,该group里的所有进程可以相互通信。
在这组进程中，每个进程有一个唯一的rank,通信按照rank进行（做身份标识的作用？
MPI支持的通信方式有point-to-point 和 collective 两种，也就是点对点和广播
下面分别介绍这两种方式。
Blocking point-to-point communication Blocking communication 就是阻塞通信
**阻塞通信**是指消息发送方的send调用需要接受方的recv调用的配合才可完成 对于非阻塞通信，不必等到通信操作完全完成便可以返回，该通信操作可以交给特定的通信硬件去完成，在该通信硬件完成该通信操作的同时，处理机可以同时进行计算操作，这样便实现了计算与通信的重叠。通过计算与通信的重叠，可以大大提高程序执行的效率。这一方法和通过异步I/O实现I/O与计算的重叠思路是完全一样的。
MPI Send and Receive</description></item><item><title>tensorflow input pipline 学习笔记</title><link>https://111qqz.com/2017/08/tensorflow-input-pipline-notes/</link><pubDate>Thu, 24 Aug 2017 09:12:58 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-input-pipline-notes/</guid><description>
参考资料：
tf_doc_Reading data
TENSORFLOW INPUT PIPELINE EXAMPLE
tensorflow：理解tensorflow中的输入管道
第二个参考资料是第一个的翻译版本，翻译的水平一般，建议看原文，不是很长。
下面是我挑了文章中重点的部分+自己的理解。
TL;DR; 一个适用于不是很大的数据集的pipline input 的例子。
Load Data in Tensorflow input pipline 可以理解称一种load data的方式。 一般有两种方式load data,一种是比较传统的，使用feed 的方式。如果数据集比较大，这种方式就不适用了，因为这种方式需要将数据全部导入到memory中。因此tf提供了pipline input的读入数据的方式。
input pipline 会处理 csv file,解码文件格式，重构数据结构，打乱数据顺序，做数据扩充或者其他预处理，然后使用线程(threads)将数据导进batch.
Load the Label Data 确保使用正确的dataset,csv文件路径。
然后处理 得到train和test 的label
由于我们只是读数据而没有真的打算训练，所以没有使用one-hot的编码方式，而是直接将（本来也是由数字字符组成的）字符串，转化成int.
def encode_label(label): return int(label) def read_label_file(file): f = open(file, &amp;quot;r&amp;quot;) filepaths = [] labels = [] for line in f: filepath, label = line.split(&amp;quot;,&amp;quot;) filepaths.append(filepath) labels.append(encode_label(label)) return filepaths, labels # reading labels and file path train_filepaths, train_labels = read_label_file(dataset_path + train_labels_file) test_filepaths, test_labels = read_label_file(dataset_path + test_labels_file) Do Some Optional Processing on Our String Lists # transform relative path into full path train_filepaths = [ dataset_path + fp for fp in train_filepaths] test_filepaths = [ dataset_path + fp for fp in test_filepaths] # for this example we will create or own test partition all_filepaths = train_filepaths + test_filepaths all_labels = train_labels + test_labels # we limit the number of files to 20 to make the output more clear!</description></item><item><title>tensorflow 合并模型</title><link>https://111qqz.com/2017/08/tensorflow-model-merging/</link><pubDate>Mon, 21 Aug 2017 06:56:22 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-model-merging/</guid><description>
在这里存个备份，还有些问题没有解决。
raise ValueError(&amp;quot;GraphDef cannot be larger than 2GB.&amp;quot;)
记录一些思路好了。现在是没有生成.meta文件，爆掉应该是因为所有的变量都加载到了默认图里。
也就是说我处理完checkpoint 0 之后开始处理checkpoint1,但是checkpoint0的那些变量还是存在的...所以越来越多？
目前有两个想法，第一个想法是是受TensorFlow极简教程：创建、保存和恢复机器学习模型 中启发，用多个saver，每个saver指定要搞的图（但是这样好像要每个checkpoint都是不同的saver才有意义？）
第二个想法是，每次save完变量之后，将图恢复成默认状态（可以把图中所有变量清空。。
想法二大失败：
会遇到if self.stack[-1] is not default: │ IndexError: list index out of range 的问题。。
根据 reset_default_graph awkwardly breaks graph nesting
中提到了。。。reset_default_graph本身就不舍被设计成放在graph中清空变量用的。。。然后tf的代码也写得很不友好。。。没有 指明这个错误的原因。。。
For historical context, `tf.reset_default_graph()` was never designed to be used with `with g.as_default():` context managers. I think the proper fix here is to make `tf.reset_default_graph()` fail with an informative error message when used inside a `with g.</description></item><item><title>tensorflow checkpoint 学习笔记</title><link>https://111qqz.com/2017/08/tensorflow-checkpoint-notes/</link><pubDate>Mon, 21 Aug 2017 02:03:45 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-checkpoint-notes/</guid><description>
参考资料：
What is the TensorFlow checkpoint meta file?
TensorFlow: Restoring variables from from multiple checkpoints
合并模型的时候发现.meta一直在累加，而其他数据文件没有改变。因此来探究一下checkpoint的几个文件的含义。
This file contains a serialized [`MetaGraphDef` protocol buffer](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/protobuf/meta_graph.proto). The `MetaGraphDef` is designed as a serialization format that includes all of the information required to restore a training or inference process (including the [`GraphDef`](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/graph.proto) that describes the dataflow, and additional annotations that describe the variables, input pipelines, and other relevant information). For example, the `MetaGraphDef` is used by [TensorFlow Serving](https://tensorflow.</description></item><item><title>tensorflow variable 学习笔记</title><link>https://111qqz.com/2017/08/tensorflow-variable-notes/</link><pubDate>Sun, 20 Aug 2017 09:36:00 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-variable-notes/</guid><description>
参考资料：
programmers_guide/variables
tf/Variable
之前感觉对tensorflow 的variable的理解不是很深刻...跑个模型啥的倒不会有什么问题，但是涉及分布式，模型并行之类的，感觉有些地方还是要理解得仔细一点比较好。
OVERVIEW variable的目的是将状态可持久化。
Unlike tf.Tensor objects, a tf.Variable exists outside the context of a singlesession.run call.
通俗地说就是，variable可以用来存储一个可持久化的tensor
一些op允许读取或者修改tensor的值，这些修改是跨session可见的，也就是说，对于用variable可持久化过的tensor,多个worker（多卡之间）之间可以看到相同的值。
Creating a Variable 创建变量可以通过调用tf.get_variable function的方法实现。这个函数要求指明变量名称，这个名称会被作为标识该变量的key。
tf.get_variable也允许变量复用，意思是用之前创建过的有相同名字的变量，创建当前的变量。
my_int_variable = tf.get_variable(&amp;quot;my_int_variable&amp;quot;, [1, 2, 3], dtype=tf.int32, initializer=tf.zeros_initializer) #分别是变量名，shape，变量类型，初始化方法。 #默认类型为tf.float32，默认初始化方法是随机数。 #tf提供很多其他的初始化方法，以及也可以用一个tensor作为初始化。 #注意用tensor作为初始化时，shape就不用提供了，因为会用tensor的shape作为variable的shape Variable collections 由于在不同的部分创建了的变量可能有是够想一起访问，所以我们需要一个简单的能访问一个集合的变量的方法。tensorflow提供了collecetions,可以理解成python list,
是一个存储tensor，variable或者其他实例的容器。
默认情况下，tf.variable被收集到如下两个collcetions:
* tf.GraphKeys.GLOBAL_VARIABLES：放置可以被多个设备共享的variable(从名字中的GLOBAL也可以看出来...) * tf.GraphKeys.TRAINABLE_VARIABLES:用来放置用来计算梯度的variable 如果不想训练某个variable,那么将它加入名字叫tf.GraphKeys.LOCAL_VARIABLES 的默认collection...
下面是一个将名字叫my_local的variable加入tf.GraphKeys.LOCAL_VARIABLES的例子
my_local = tf.get_variable(&amp;quot;my_local&amp;quot;, shape=(), collections=[tf.GraphKeys.LOCAL_VARIABLES]) 一个等价写法是，将trainable属性设置为False
my_non_trainable = tf.get_variable(&amp;quot;my_non_trainable&amp;quot;, shape=(), trainable=False) 当然自定义collcetion也是可以的，名字可以是任何字符串。</description></item><item><title>20170819近况</title><link>https://111qqz.com/2017/08/20170819/</link><pubDate>Sun, 20 Aug 2017 08:56:15 +0000</pubDate><guid>https://111qqz.com/2017/08/20170819/</guid><description>
一转眼...暑假就要结束了...
秋招似乎也可以告一段落了...
投了蛮多的，但是昨天突然发现我用gmail邮箱发邮件有概率发不出去。。所以我也不知道到底哪些简历根本没有发出去orz
先是做了拼多多的笔试，感觉数据有点问题，390/400，没能AK有点不爽。还没面...
cvte的笔试....面了cpp和中央研究院的视觉计算...还不知道结果...面试官略菜....
奶茶厂广告部数据组（？的面试...本来说有两面，一面我也回答得不算差...结果一面之后说我技能不match他们的工作,不用二面了.。。。
看了下貌似是数据挖掘岗....听我讲了半个小时的dl cv.... 大概是我讲的太投入了orz
百度网页搜索部...rank算法工程师...因为有之前的实习记录，所以直接三面美滋滋....和面试官很聊得来...嗯...应该是拿到了...
阿里...投的cv岗位没理我...被阿里云捞了简历...还没面
sensetime给了offer.....还是比较满意的orz。。
其实好早之前基本确定了，但是仍然投了很多其他厂，一个是想体验一下秋招，一个大概是想拿到更高的offer去argue一个更好的package...
但是好像...没什么必要了....已经很满意了orz（其实是基本拿不到什么能去argue的offer了... 还是要知足常乐啊...
之后 的面试大厂还是会尝试一下（？如果工作紧就不尝试了。。。。
从2月初第一家 的hyperal到现在面了这么多家...
唯一印象深刻的就是实习时某价值观厂交叉面面试官，是非常糟糕的一次体验。
我被传达到的信息是“我厂天下第一，你连高star 的cpp项目都没有也敢来申请实习？快滚”...
感觉面试官非常不尊重人，一生黑倒不至于，但是没什么好印象就是了。对于这种大厂，惹不起，还是躲得起的...
不过还是很想拿到他们的offer,这样就可以也拒他们一次了..超记仇.jpg ...感觉最近特别流行拒绝该厂offer呢2333...我也想体验一下。</description></item><item><title>tensorflow Session 学习笔记</title><link>https://111qqz.com/2017/08/tensorflow-session-notes/</link><pubDate>Sun, 20 Aug 2017 08:21:57 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-session-notes/</guid><description>
tensorflow-session官方文档
说下我自己的理解：
session中文一般叫会话，可以理解成op执行时候需要的一层虚拟化的封装。
op必须在session中才能执行。
tensor也是在tensor中才可以存在（tf.variable和tensor几乎是一回事，只是tf.variable的会话不要求session，也可以理解成tf.variable在session中就成了tensor.
需要注意的是session一般会占据资源，所以在使用完记得释放，或者写成with的形式（看到with总想叫成开域语句...感觉暴露年龄orz
下面这两种形式是等价的：
# Using the `close()` method. sess = tf.Session() sess.run(...) sess.close() # Using the context manager. with tf.Session() as sess: sess.run(...) session本身有一些配置，我们使用configproto：
# Launch the graph in a session that allows soft device placement and # logs the placement decisions. sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)) allow_soft_placement的作用是自动选择可用的设备（如果指定的设备不可用（？）），防止指定的设备不可用而挂掉的情况。
log_device_placement :To find out which devices your operations and tensors are assigned to.</description></item><item><title>leetcode 146. LRU Cache(list+unordered_map)</title><link>https://111qqz.com/2017/08/leetcode-146-lru-cache/</link><pubDate>Fri, 18 Aug 2017 19:18:25 +0000</pubDate><guid>https://111qqz.com/2017/08/leetcode-146-lru-cache/</guid><description>
请实现最近最少使用缓存(Least Recently Used (LRU) cache)类,需要支持 get, set,操作。 get 操作,给出 key,获取到相应的 value (value 为非负数),如果不存在返回-1, 如果存在此 key 算作被访问过。 set 操作,设置 key,如果 key 存在则覆盖之前的 value (此时相当于访问过一次)。 如果 key 不存在,需要进行插入操作,如果此时已经 key 的数量已经到达 capacity, 这样需要淘汰掉最近最少使用(也就是上次被使用的时间距离现在最久的)的那 一项。
要求get和set的时间复杂度都是O(1)
/* *********************************************** Author :111qqz Created Time :2017年08月18日 星期五 00时00分22秒 File Name :LRU.cpp ************************************************ */ class LRUCache{ private: //map:&amp;lt;key,Value&amp;gt; //Value:pair&amp;lt;value,time&amp;gt; //time:vector? list? typedef unordered_map&amp;lt;int, pair&amp;lt;int , list&amp;lt;int&amp;gt;::iterator &amp;gt; &amp;gt;Cache; Cache cache; list&amp;lt;int&amp;gt;hit_seq; //头部最新元素，尾部最旧元素 int siz; #define fst first #define sec second #define MP make_pair void hit(Cache::iterator it) //access once { int key = it-&amp;gt;fst; hit_seq.</description></item><item><title>python只获取当前目录下的文件夹及文件名</title><link>https://111qqz.com/2017/08/python-get-dir-name-in-current-path/</link><pubDate>Wed, 16 Aug 2017 08:21:41 +0000</pubDate><guid>https://111qqz.com/2017/08/python-get-dir-name-in-current-path/</guid><description>
list = os.listdir(rootdir)#列出目录下的所有文件和目录 for line in list: filepath = os.path.join(rootdir,line) if os.path.isdir(filepath):#如果filepath是目录 print &amp;quot;dir:&amp;quot; + filepath else: print &amp;quot;file:&amp;quot; + filepath
如果需要遍历文件夹下的所以文件，可以使用os.walk()方法。
os.walk()返回一个三元素的tuple：当前路径、子文件夹名称、文件列表。 import os for root, dirs, files in os.walk(path): for filename in files: print filename for dirname in dirs: print dirname 举个列处当前目录所有文件夹的例子：
from os import listdir from os.path import isfile, join import os dir =os.listdir() for line in dir: if os.path.isdir(line): print (line) 参考资料</description></item><item><title>Distributed Tensorflow : Cannot assign a device for operation save</title><link>https://111qqz.com/2017/08/distributed-tensorflow-cannot-assign-a-device-for-operation-save/</link><pubDate>Mon, 14 Aug 2017 01:55:15 +0000</pubDate><guid>https://111qqz.com/2017/08/distributed-tensorflow-cannot-assign-a-device-for-operation-save/</guid><description>
是在使用分布式tensorflow遇到的一个错误
报错如下：
InvalidArgumentError (see above for traceback): Cannot assign a device for operation 'save/Rest│| 2 GeForce GTX 1080 On | 0000:08:00.0 Off | N/A | oreV2_888': Operation was explicitly assigned to /job:worker/task:0/device:CPU:0 but available │| 24% 39C P8 12W / 180W | 0MiB / 8114MiB | 0% Default | devices are [ /job:localhost/replica:0/task:0/cpu:0, /job:localhost/replica:0/task:0/gpu:0 ]. Make sure the device specification refers to a valid device.
其中看到Distributed Tensorflow : Cannot assign a device for operation.</description></item><item><title>面试相关</title><link>https://111qqz.com/2017/08/interview-record/</link><pubDate>Sat, 12 Aug 2017 04:03:44 +0000</pubDate><guid>https://111qqz.com/2017/08/interview-record/</guid><description>
随便记录一下面试中遇到的问题：
梯度下降和牛顿迭代的区别？为什么常用梯度下降？ **牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快**。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。 根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。
常用梯度下降的原因是牛顿迭代的计算时间复杂度太大了...
如果一个优化问题是n 维的，那么单轮梯度下降的复杂度是O(n) ，Quasi-Newton是O(n^2)
收敛速度和计算的时间复杂度是两回事，切记不要混淆。
拟牛顿法：拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。
[Math] 常见的几种最优化方法
优化函数有哪些方法？非凸函数怎么办？在ml中如何求全局最优值？ 梯度下降，牛顿法等数值计算方法（要求有二阶导数？
模拟退火，遗传算法等近似算法。
由于凸函数有一个很好的性质，即局部最优就是全局最优，所以求凸函数的最优解比较容易，梯度下降，贪心（比如爬山法）等局部算法都ok.
对于非凸函数的最优化比较困难，比较常见的有蒙特卡洛方法投点法，大概思想就是，投n次点，每次在该点附近用凸函数的优化方法求最值，最后取所有局部最值的max(min)
模拟退火应该也可以求解非凸函数？ 毕竟喝醉的人可能走错路，陷入局部最优的时候有几率跳出。
什么是过拟合?如何防止过拟合？ 我的理解，过拟合就是由于参数过多等原因导致训练出来的模型不够一般化，可能对当前训练用的数据集拟合得很好，但是换一个数据集就不能很好的拟合。
防止过拟合主要有几种方法：L1,L2,dropout,Early stopping，数据集扩增。
L1,L2都是正则化方法，通过在代价函数上添加一个关于features的惩罚项，使得每一个features尽可能小，从而降低每个features对cost的贡献程度。
dropout是指在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。
dropout有效的原因没有统一结论（？
Early stopping便是一种迭代次数截断的方法来防止过拟合的方法，即在模型对训练数据集迭代收敛之前(**如果可以认为loss不会再减少了)**停止迭代来防止过拟合。
通俗得讲，数据机扩增即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法：
* 从数据源头采集更多数据 * 复制原有数据并加上随机噪声 * 重采样 * 根据当前数据集估计数据分布参数，使用该分布产生更多数据等 L1,L2规范化有什么区别？ 核心：L2对大数，对异常值更敏感！
L1：计算绝对值之和，用以产生稀疏性，因为它是L0范式的一个最优凸近似，容易优化求解 L2：计算平方和再开根号，L2范数更多是防止过拟合，并且让优化求解变得稳定很快速（这是因为加入了L2范式之后，满足了强凸）。
L1 nrom几乎没有比L2 norm表现好的时候，优先使用L2 norm是比较好的选择。
特征值和奇异值的关系？ ...?
有哪些旋转不变性（计算机视觉） ...?
逻辑回归和svm的关系？ 内核通信（那是啥 如何改变一个常量的值（不能去除常量属性 #define定义的常量是真正的常量(保存在常量区)，而const却是由编译器判断实现的常量，是一个假常量。const常量本质上还是一个变量，只不过C++中提出的const机制在编译层面上对const常量提供了写保护，是为了防止意外修改。
答案：volatile 关键字
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：
#include &amp;lt;stdio.h&amp;gt; int main() { const volatile int i = 10; int* pi = (int*)(&amp;amp;i); *pi = 100; printf(&amp;quot;*pi: %d\n&amp;quot;,*pi); printf(&amp;quot;i: %d\n&amp;quot;,i); printf(&amp;quot;pi: %p\n&amp;quot;,pi); printf(&amp;quot;&amp;amp;i: %p\n&amp;quot;, &amp;amp;i); return 0; } 智能指针？ 智能指针的出现实际上就是为了可以方便的控制对象的生命期，在智能指针中，一个对象什么时候和在什么条件下要被析构或者是删除是受智能指针本身决定的，用户并不需要管理。</description></item><item><title>分布式 tensorflow 学习笔记(非最终版)</title><link>https://111qqz.com/2017/08/tensorflow-notes/</link><pubDate>Mon, 07 Aug 2017 12:54:23 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-notes/</guid><description>
感觉资料不是很多，先收集资料好了。
tf-distributed官网文档
SO-between-graph和in-graph的区别
inception.README.md
SyncReplicasOptimizer
SO_How does ps work in distribute Tensorflow?
update:在多个nodes（机）上跑。。。tf默认是异步更新的。。。同步的话。。大概需要syncreplicasoptimizer?
来直观感受下，不同task的之间并不同步
创建一个cluster 每一个task唯一对应一个server,server中有一个master，还有若干个worker
cluster是task的集合
cluster是在处理分布式问题时抽象出的概念，类似缩点。
cluster也可以划分成一个或者多个job，每个job包含一个或者多个task.
所以task,job,cluster的关系，从集合的角度考虑：
task的集合中的元素，job是task的（不相交？）子集，cluster是task的全集。
（似乎要求所有job的交为空，所有job的补为全集，也就是似乎不能越过job直接到taks(?)）
如下图：
_A TensorFlow "cluster" is a set of "tasks" that participate in the distributed execution of a TensorFlow graph. Each task is associated with a TensorFlow "server", which contains a "master" that can be used to create sessions, and a "worker" that executes operations in the graph.</description></item><item><title>tensorflow Supervisor 学习笔记</title><link>https://111qqz.com/2017/08/tensorflow-supervisor-notes/</link><pubDate>Fri, 04 Aug 2017 09:22:44 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-supervisor-notes/</guid><description>
update:supervisor的缺点是遇到问题只会抛异常，所以现在有一个better的管理工具,MonitoredSession
master,chief worker,Supervisor 这几个概念有点搞不清（我最菜.jpg 因此来学习一下。
概述 原生的tensorflow 是各种东西都需要自己手动，如果是小规模的训练问题倒是不大，但是如果是训练的数据量比较大，可能需要训练几天或者几个月。。。
那原生的tensorflow的健壮性可能就比较堪忧。。。
万一断电了之类。。。
这时候我们就可以使用supervisor
其主要提供下面三个功能，以增强训练的健壮性：
* Handles shutdowns and crashes cleanly. * Can be resumed after a shutdown or a crash. * Can be monitored through TensorBoard. supervisor可以看做一个工具，或者说是对原生tensorflow的一层封装，目的主要是通过定期save的方法增强训练健壮性，
就算程序挂掉了也可以从上一次save的checkpoint恢复，而不是从头再来（虽然这些也可以手动实现（？）
同时也可以简化代码量
除了supervisor,还有tf.learn库，里面提供对原生tensorflow更高层的封装，也提供更丰富的功能。
实例 来举个具体的例子好了：
在不使用supervisor的时候，我们的训练代码如下：
variables ... ops ... summary_op ... merge_all_summarie saver init_op with tf.Session() as sess: writer = tf.tf.train.SummaryWriter() sess.run(init) saver.restore() for ...: train merged_summary = sess.run(merge_all_summarie) writer.add_summary(merged_summary,i) saver.save 如果使用supervisor，代码如下：</description></item><item><title>k-means clustering 学习笔记</title><link>https://111qqz.com/2017/08/k-means-clustering-notes/</link><pubDate>Thu, 03 Aug 2017 13:09:17 +0000</pubDate><guid>https://111qqz.com/2017/08/k-means-clustering-notes/</guid><description>
其实这算法巨简单。。。。让我想到了均分纸牌（noip200?
还是大致说一下：
对于有 features 但是 **没有 **labels 的数据，没办法用监督学习，但是可以使用非监督学习的聚类算法。
所谓聚类，简单理解，就是把相似的分成一组。。。
k-means就是一个常见的聚类算法。。。
k代表可以把数据分成k组。
举一个平面上二维点的例子，算法步骤如下：
1. 随机k个点当做k个点作为k组的中心。 2. 根据现在的k个中心，将数据集中的点，按照【距离哪个中心最近就属于哪个中心】的原则，分组。 3. 在每一个组内求点的二维平均数，作为新的中心。**如果存在一个组的数据中心改变，那么返回2，否则结束**。![](http://stanford.edu/~cpiech/cs221/img/kmeansViz.png) 可以很容易推广到高维度，就只是求平均数和算距离的时候有区别。
一般化的流程：
然后该算法是Expectation Maximization的一个特例
该算法和KNN算法没有半毛钱关系。。。
参考资料：
k means 维基百科
CS221-kmeans</description></item><item><title>TensorFlow Architecture 学习笔记（二）Adding a New Op</title><link>https://111qqz.com/2017/08/tensorflow-architecture-notes-2/</link><pubDate>Wed, 02 Aug 2017 03:07:37 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-architecture-notes-2/</guid><description>
Adding a New Op * [目录](https://www.tensorflow.org/extend/adding_an_op#top_of_page) * [定义运算的接口](https://www.tensorflow.org/extend/adding_an_op#define_the_ops_interface) * [实现运算的核心部分(kernels)](https://www.tensorflow.org/extend/adding_an_op#implement_the_kernel_for_the_op) * [多线程cpu kernels](https://www.tensorflow.org/extend/adding_an_op#multi-threaded_cpu_kernels) * [GPU kernels](https://www.tensorflow.org/extend/adding_an_op#gpu_kernels) * [构建运算库](https://www.tensorflow.org/extend/adding_an_op#build_the_op_library) * [用系统编译器编译你的运算（TensorFlow binary installation）](https://www.tensorflow.org/extend/adding_an_op#compile_the_op_using_your_system_compiler_tensorflow_binary_installation) * [使用bazel编译你的运算(TensorFlow source installation)](https://www.tensorflow.org/extend/adding_an_op#compile_the_op_using_bazel_tensorflow_source_installation) * [在 Python 中使用你的运算](https://www.tensorflow.org/extend/adding_an_op#use_the_op_in_python) * [验证你添加的运算可以工作](https://www.tensorflow.org/extend/adding_an_op#verify_that_the_op_works) * [在你的运算中添加高级特性](https://www.tensorflow.org/extend/adding_an_op#building_advanced_features_into_your_op) * [条件检查和验证](https://www.tensorflow.org/extend/adding_an_op#conditional_checks_and_validation) * [Op registration](https://www.tensorflow.org/extend/adding_an_op#op_registration) * [GPU Support](https://www.tensorflow.org/extend/adding_an_op#gpu_support) * [用python 实现梯度](https://www.tensorflow.org/extend/adding_an_op#implement_the_gradient_in_python) * [Shape functions in C++](https://www.tensorflow.org/extend/adding_an_op#shape_functions_in_c) 对于要添加原生tensorflow中没有定义的运算的需求，首先建议在python层面，能不能将需要的op用其他原生的op拼凑起来。
如果不能这样做，或者这样做逻辑很复杂，或者这样做效率比较低的时候，我们才考虑在cpp层面添加一个新的op
去实现你自定义的运算需要如下步骤：
1. 在C++文件中注册该运算。包含参数个数，类型，返回值类型，运算名称等。大概就是C++头文件中函数的定义吧.同时在此处也要定义shape function 2. 用C++实现该运算，运算的实现被称之为kernel，该实现与第一步中的注册对应，相同功能的op对于不同的输入输出类型，或者是架构（GPU,CPU)可能 有不同的实现. 3. 创建一个python包装器（**可选**），该包装器使得可以在python层面用API对该运算进行调用。在运算注册阶段会生成默认的包装器 4. 编写计算该运算梯度 的函数**（可选）** 5. 测试你新添加的运算。为了方便一般在python层面进行测试，不过你想在C++层面测试也没什么问题。 Define the op's interface 直接看代码好了.</description></item><item><title>峰度（Kurtosis）和偏度（Skewness）</title><link>https://111qqz.com/2017/08/kurtosisskewness/</link><pubDate>Wed, 02 Aug 2017 01:34:58 +0000</pubDate><guid>https://111qqz.com/2017/08/kurtosisskewness/</guid><description>
昨天pinduoduo笔试遇到了，看心情蒙的2333，来学习一下
** 峰度（Kurtosis）和偏度（Skewness）**
重点：正太分布的峰度和偏度都是0
峰度是描述总体中所有取值分布形态陡缓程度的统计量。这个统计量需要与正态分布相比较，峰度为0表示该总体数据分布与正态分布的陡缓程度相同；峰度大于0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰；峰度小于0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。峰度的绝对值数值越大表示其分布形态的陡缓程度与正态分布的差异程度越大。
峰度的具体计算公式为：
[![](http://images.51cto.com/files/uploadimg/20100408/161046770.jpg) ](http://images.51cto.com/files/uploadimg/20100408/161046770.jpg) 偏度与峰度类似，它也是描述数据分布形态的统计量，其描述的是某总体取值分布的对称性。这个统计量同样需要与正态分布相比较，**偏度为0表示其数据分布形态与正态分布的偏斜程度相同**；偏度大于0表示其数据分布形态与正态分布相比为正偏或右偏，即有一条长尾巴拖在右边，数据右端有较多的极端值；偏度小于0表示其数据分布形态与正态分布相比为负偏或左偏，即有一条长尾拖在左边，数据左端有较多的极端值。偏度的绝对值数值越大表示其分布形态的偏斜程度越大。 偏度的具体计算公式为：
[![](http://images.51cto.com/files/uploadimg/20100408/161111811.jpg) ](http://images.51cto.com/files/uploadimg/20100408/161111811.jpg)</description></item><item><title>TensorFlow Architecture 学习笔记（一）</title><link>https://111qqz.com/2017/08/tensorflow-architecture-notes-1/</link><pubDate>Tue, 01 Aug 2017 03:01:12 +0000</pubDate><guid>https://111qqz.com/2017/08/tensorflow-architecture-notes-1/</guid><description>
这篇文章不会涉及tensorflow的具体使用，而是专注于介绍tensorflow的架构，目的是让开发者能够对tensorflow现有框架进行自定义的扩展。
tensorflow被设计用来处理大规模分布式训练，但是也足够灵活去处理新的machine learning模型或是系统层面的优化。
Overview tensorflow的结构图如下：
从下往上大致上抽象程度越来越高。
其中C API那一层将tensorflow底层的runtime core 封装成不同语言（python,cpp,etc)的用户层代码，并提供相应的接口
这篇文章主要侧重如下layer:
* **Client**: * 将计算定义为数据流图. * 使用 **[session](https://www.github.com/tensorflow/tensorflow/blob/r1.2/tensorflow/python/client/session.py)(**会话)启动图 的执行 * **Distributed Master** * 通过Session.run()中参数的定义，修改图中特定的子图 * 将子图分成多个pieces,使之运行在不同的进程和设备中） * 将得到的pieces分发到 worker services上 * 由worker services 启动graph pieces * **Worker Services** (one for each task) * Schedule the execution of graph operations using kernel implementations appropriate to the available hardware (CPUs, GPUs, etc). * 使用kernel中对于特定硬件设备(cpu,gpu,etc)合适的实现去安全图中操作的执行。 * 从其他worker service 处发送或接收运算结果 * **Kernel Implementations** * 完成各个操作的计算 client,master,worker的关系如下</description></item><item><title>Long Short-Term Memory （LSTM） 网络 学习笔记</title><link>https://111qqz.com/2017/07/lstm-notes/</link><pubDate>Mon, 31 Jul 2017 10:05:01 +0000</pubDate><guid>https://111qqz.com/2017/07/lstm-notes/</guid><description>
参考资料： 维基百科_长短期记忆(LSTM)
Understanding LSTM Networks
[译] 理解 LSTM 网络
LSTM笔记
翻译的比较一般，建议看原文....比如cell还是不要翻译成【细胞】比较好吧...让人以为和生物学的【细胞】有什么关系呢orz
说下我自己的理解：
LSTM是一种特殊的RNN，所谓RNN,也就是循环神经网络，对之前的信息存在“记忆”，可以解决带有时序性的问题。
所谓时序性的问题，简单理解就是，当前的结果依赖于之前的信息。
比如“我来自内蒙古，我能讲一口流利的____” 横线处大概率填写“蒙语”，这是因为前面的信息“内蒙古”
LSTM的全称是long short term memory, LSTM默认就可以记住长期信息，从而实现信息的持久化。
LSTM的本质是一种构造法，通过特定的设计完成信息的持久化。
LSTM有如下结构：
1、cell单元 最基本的单元，从上一个时间节点到当前时间节点是线性控制的。LSTM能够通过门结构增加或者减少信息。 门结构上有sigmoid层（输出0~1）作用，信息通过乘上一个0~1的来决定能够通过多少信息。 2、forget门 forget门决定有多少历史信息能够通过，这一层通过ht−1ht−1和xtxt决定，ft=sigmoid(w(f)xt+u(i)ht−1)∈[0,1]ft=sigmoid(w(f)xt+u(i)ht−1)∈[0,1]作用到Ct−1Ct−1上。 3、input门和新的cell input门是一个sigmoid层决定需要更新多少信息，新的cell是一个tanh层决定要添加多少信息进入记忆单元cell。分别为it=sigmoid(wixt+u(i)ht−1)it=sigmoid(wixt+u(i)ht−1)，与ct~=tanh(w(c)xt+ucht−1)ct~=tanh(w(c)xt+ucht−1) 4、更新记忆单元 forget门作用在ct−1ct−1上，input门和新的cell结合加入组合成新的记忆单元ct=ft.∗ct−1+it.∗ct~ct=ft.∗ct−1+it.∗ct~ 5、output门 添加sigmoid 的output门决定cell单元的信息有多少输出，而cell上套一个tanh使输出在-1到1之间，ot=sigmoid(w(o)xt+u(o)ht−1)ot=sigmoid(w(o)xt+u(o)ht−1)，ht=ot.∗tanh(ct)ht=ot.∗tanh(ct)。</description></item><item><title>hdu 3078 Network (LCA)</title><link>https://111qqz.com/2017/07/hdu-3078/</link><pubDate>Sun, 30 Jul 2017 17:45:18 +0000</pubDate><guid>https://111qqz.com/2017/07/hdu-3078/</guid><description>
题目链接
题意： 一棵树，给出点权，问一条树链上第k大的点权，点权可以动态修改。
思路： 暴力即可orz(数据是真的水啊。
求路径上的点的时候需要用到LCA
/* *********************************************** Author :111qqz Created Time :2017年07月31日 星期一 01时12分54秒 File Name :3078.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=8E4+7; int n,q; int val[N]; vector &amp;lt; pi &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int fa[N]; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; fa[u] = pre; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>codeforces #425 D. Misha, Grisha and Underground (dfs+rmq在线求LCA,讨论了一年)</title><link>https://111qqz.com/2017/07/codeforces-div2-425d/</link><pubDate>Sun, 30 Jul 2017 12:05:30 +0000</pubDate><guid>https://111qqz.com/2017/07/codeforces-div2-425d/</guid><description>
题目链接
题意： 给出一棵树，以及三个点（可能重合），问两两组成的3条路径中，哪2条路径重合部分最长。
思路： LCA还是一下就能想到的，rmq+dfs在线求。
然后我开始分情况讨论，讨论了一年也没讨论完，哭哭
结论是：求出三个lca，并取深度最大的那个，就是我们要的三岔路口K，然后分别求出K到a，b，c三点的路径长度，取最大值+1就是答案。
所以我的问题在于，没有试图往一般性的方向考虑，以为讨论一下就可以了...
这大概就是所谓的猜结论？
感性的理解的话，LCA越深，意味着另一个点到LCA的距离越远，也就是相交的路径越长
但是我的话，估计还是很难在短短不到一个小时内得出这样一般性的结论orz...
这大概就是数学方面的天赋差距把...T T
/* *********************************************** Author :111qqz Created Time :2017年07月30日 星期日 15时12分34秒 File Name :D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,q; vector &amp;lt; pi &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>codeforces #425 B. Petya and Exam (暴力)</title><link>https://111qqz.com/2017/07/codeforces-div2-425b/</link><pubDate>Sun, 30 Jul 2017 06:46:23 +0000</pubDate><guid>https://111qqz.com/2017/07/codeforces-div2-425b/</guid><description>
题目链接
题意： 给出由小写字母，'?'和'*'组成的字符串s，仅由小写字母组成的字符串t,问按照规则s能否变成t.
规则如下：首先给出定义的[好字母]的字符串，[好字母]之外的都是[坏字母],对于s中每个‘?’，规定其必须替换为一个[好字母]
对于s中的每个‘*’，规定其必须替换为0个或者多个坏字母。
思路： 显然带的会比较难搞。所以只说带的情况
我WA了好多次，原因是一开始读错题（或者题意不太清楚？），认为*只能最多替换一个[坏字母]
后来在这个思路上改，越改越复杂orz
仔细想一下，关键点有两个，一个是当前位置有三种情况{没有经过*,经过且仍在的作用域内，经过且已经出了的作用域}
如何知道的作用域呢？由于的替换是连续的，因此只要对比s和t的长度差就可以了。
对于不同的作用域，普通字母的判断位置是不同的，在经过*的作用域之后，普通字母（包括‘？’）记得加一个offset
所以第二个关键点就是，对于*的替换，一次判断完多个。
除此之外，注意下*可能为空的特殊情况，特判一下比较保险。
/* *********************************************** Author :111qqz Created Time :Mon 24 Jul 2017 10:32:44 PM CST File Name :B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string good; int len,len2; vector&amp;lt;char&amp;gt;go; string st; int n; string tmp; vector&amp;lt;int&amp;gt;zimu; //字母的位置 vector&amp;lt;int&amp;gt;fuhao; //符号的位置 bool star; bool vis[26]; bool solve() { len2 = tmp.</description></item><item><title>hdu 2815 Mod Tree (扩展BSGS算法)</title><link>https://111qqz.com/2017/07/hdu-2815/</link><pubDate>Fri, 28 Jul 2017 14:23:36 +0000</pubDate><guid>https://111qqz.com/2017/07/hdu-2815/</guid><description>
题意：k^D=n(%p),求最小的D (1&amp;lt;=K, P, N&amp;lt;=10^9)
思路：出题人英文水平捉鸡。。。。
扩展BSGS算法即可，注意p&amp;gt;=n的时候显然是无解的，判掉。
/* *********************************************** Author :111qqz Created Time :Mon 24 Jul 2017 09:43:41 PM CST File Name :2815.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL k,p,n; map&amp;lt;LL,LL&amp;gt;mp; LL ksm(LL a,LL b,LL p) { LL res = 1LL; while (b) { if (b&amp;amp;1) res = res * a % p; b = b&amp;gt;&amp;gt;1LL; a = a * a % p; } return res; } LL gcd( LL a,LL b){return b?</description></item><item><title>manjaro(archlinux) 安装 YouCompleteMe</title><link>https://111qqz.com/2017/07/install-YouCompleteMe-on-manjaro/</link><pubDate>Fri, 28 Jul 2017 09:13:34 +0000</pubDate><guid>https://111qqz.com/2017/07/install-YouCompleteMe-on-manjaro/</guid><description>
来来回回折腾了好多次，aur直接安装或者手动编译，安装后都无法补全
ycm的log文件是在/tmp目录下的。
发现问题是缺少libtinfo.so.5
2017-07-28 17:02:12,667 - ERROR - Error occurred while loading global extra conf /home/coder/.ycm_extra_conf.py Traceback (most recent call last): File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/extra_conf_store.py&amp;quot;, line 94, in _CallGlobalExtraConfMethod module = Load( global_ycm_extra_conf, force = True ) File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/extra_conf_store.py&amp;quot;, line 173, in Load module = LoadPythonSource( _RandomName(), module_file ) File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/utils.py&amp;quot;, line 400, in LoadPythonSource return imp.load_source( name, pathname ) File &amp;quot;/home/coder/.ycm_extra_conf.py&amp;quot;, line 32, in &amp;lt;module&amp;gt; import ycm_core ImportError: libtinfo.so.5: cannot open shared object file: No such file or directory 2017-07-28 17:02:12,667 - ERROR - libtinfo.</description></item><item><title>BZOJ 2480: Spoj3105 Mod (扩展BSGS算法，模板)</title><link>https://111qqz.com/2017/07/bzoj-2480/</link><pubDate>Mon, 24 Jul 2017 13:37:40 +0000</pubDate><guid>https://111qqz.com/2017/07/bzoj-2480/</guid><description>
Description 已知数a,p,b，求满足a^x≡b(mod p)的最小自然数x。
Input  每个测试文件中最多包含100组测试数据。
 每组数据中，每行包含3个正整数a,p,b。
 当a=p=b=0时，表示测试数据读入完全。
Output  对于每组数据，输出一行。
 如果无解，输出“No Solution”（不含引号），否则输出最小自然数解。
Sample Input 5 58 33 2 4 3 0 0 0
Sample Output 9 No Solution
HINT  100%的数据，a,p,b≤1e9。 2016.3.29新加数据一组 by 1430586275
思路：BSGS算法，需要注意这里没有保证(a,p)=1，因此不能直接使用BSGS算法。
我们称之为扩展BSGS算法...
但是其实并不是什么新东西，不过是几次gcd,将条件转化成满足BSGS算法的情况
/* *********************************************** Author :111qqz Created Time :Mon 24 Jul 2017 08:54:25 PM CST File Name :2480.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; map&amp;lt;LL,LL&amp;gt;mp; LL a,b,p; LL ksm(LL a,LL b,LL p) { LL res = 1LL; while (b) { if (b&amp;amp;1) res = res * a % p; b = b&amp;gt;&amp;gt;1LL; a = a * a % p; } return res; } LL gcd( LL a,LL b){return b?</description></item><item><title>python numpy 用法 简明手册</title><link>https://111qqz.com/2017/07/python-numpy-notes/</link><pubDate>Mon, 24 Jul 2017 03:08:35 +0000</pubDate><guid>https://111qqz.com/2017/07/python-numpy-notes/</guid><description>
原文链接
感谢stanford,感谢原作者的翻译，我调整了一下代码格式，可以当做手册来用了，毕竟之前没怎么写过py 23333
**译者注**：本文[智能单元](https://zhuanlan.zhihu.com/intelligentunit)首发，翻译自斯坦福CS231n课程笔记[Python Numpy Tutorial](http://link.zhihu.com/?target=http//cs231n.github.io/python-numpy-tutorial/)，由课程教师[Andrej Karpathy](http://link.zhihu.com/?target=http//cs.stanford.edu/people/karpathy/)授权进行翻译。本篇教程由[杜客](https://www.zhihu.com/people/du-ke)翻译完成，[Flood Sung](https://www.zhihu.com/people/flood-sung)、[SunisDown](https://www.zhihu.com/people/sunisdown)、[巩子嘉](https://www.zhihu.com/people/gong-zi-jia-57)和一位不愿透露ID的知友对本翻译亦有贡献。 原文如下 这篇教程由Justin Johnson创作。
我们将使用Python编程语言来完成本课程的所有作业。Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。
我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。
一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 numpy for Matlab users页面。
你们还可以查看本教程的IPython notebook版。该教程是由Volodymyr Kuleshov和Isaac Caswell为课程CS 228创建的。
内容列表：
* Python * 基本数据类型 * 容器 * 列表 * 字典 * 集合 * 元组 * 函数 * 类 * Numpy * 数组 * 访问数组 * 数据类型 * 数组计算 * 广播 * SciPy * 图像操作 * MATLAB文件 * 点之间的距离 * Matplotlib * 绘制图形 * 绘制多个图形 * 图像 Python Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：</description></item><item><title>BSGS（Baby steps giant steps）算法学习笔记</title><link>https://111qqz.com/2017/07/bsgs-algorithm-notes/</link><pubDate>Sun, 23 Jul 2017 12:41:46 +0000</pubDate><guid>https://111qqz.com/2017/07/bsgs-algorithm-notes/</guid><description>
离散对数（Discrete Logarithm）问题是这样一个问题，它是对于模方程
a^x=b(mod prime)，求满足条件的X，或者得出不存在这样的X
最暴力的思路，那么就是枚举x? 根据费马小定理，只需要枚举[0,p-1)
但是还是很大...我们不禁想到把x写成x=A*m+B的形式，m=ceil(sqrt(p))
因此有 ，变形得到 然后预处理一边存到map中，从小到大枚举另一边看是否存在...
我们可以设 ，其中 , ，这样的话化简后的方程就是
就可以不用求出逆元，要注意只是不用求出逆元，而不是没有用到逆元的存在
就可以不用求出逆元，要注意只是不用求出逆元，而不是没有用到逆元的存在
就可以不用求出逆元，要注意只是不用求出逆元，而不是没有用到逆元的存在
其实在m=sqrt(p)的时候你可能就有预感了...
BSGS算法的本质，就是个分块啊，而分块的本质就是暴力乱搞...所以BSGS看起来很高大上的算法不过是暴力乱搞2333
而BSGS的名字也很贴切...A的变化是giant step？B的变化是baby step? (纯属yy...但是我感觉这样想很好理解啊？
需要注意的是，这里介绍的是常规的BSGS算法，
前提条件是a和P互质
前提条件是a和P互质
前提条件是a和P互质
放一个板子好了，poj 2417
/* *********************************************** Author :111qqz Created Time :2017年07月23日 星期日 11时11分00秒 File Name :2417.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL p,b,n; map&amp;lt;LL,LL&amp;gt;Hash; map&amp;lt;LL,LL&amp;gt;::iterator it; inline LL ksm(LL a,LL b,LL MOD) { LL res = 1LL; while (b) { if (b&amp;amp;1) res = (res*a)%MOD; b = b &amp;gt;&amp;gt; 1; a = (a*a)%MOD; } return res; } LL BSGS(LL a,LL b ,LL p) // a^x = b (mod p),求x { a%=p; b%=p; if (!</description></item><item><title>poj 2417 Discrete Logging (BSGS算法)</title><link>https://111qqz.com/2017/07/poj-2417/</link><pubDate>Sun, 23 Jul 2017 12:13:28 +0000</pubDate><guid>https://111qqz.com/2017/07/poj-2417/</guid><description>
题目链接
题意：
Given a prime P, 2 &amp;lt;= P &amp;lt; 231, an integer B, 2 &amp;lt;= B &amp;lt; P, and an integer N, 1 &amp;lt;= N &amp;lt; P, compute the discrete logarithm of N, base B, modulo P. That is, find an integer L such that BL == N (mod P)
思路：bsgs算法
详情见BSGS算法笔记
然后被map的count坑了一下？ 我想判断map中某个key是否存在，用count会TLE，find也会TLE,[]可以通过....不太懂，复杂度不都是log吗，差常数？还是有人会退化？
不过似乎[]比较安全就对了。
/* *********************************************** Author :111qqz Created Time :2017年07月23日 星期日 11时11分00秒 File Name :2417.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL p,b,n; map&amp;lt;LL,LL&amp;gt;Hash; map&amp;lt;LL,LL&amp;gt;::iterator it; inline LL ksm(LL a,LL b,LL MOD) { LL res = 1LL; while (b) { if (b&amp;amp;1) res = (res*a)%MOD; b = b &amp;gt;&amp;gt; 1; a = (a*a)%MOD; } return res; } LL BSGS(LL a,LL b ,LL p) // a^x = b (mod p),求x { a%=p; b%=p; if (!</description></item><item><title>stanford cs 231n:常用激活函数</title><link>https://111qqz.com/2017/07/common-activation-functions/</link><pubDate>Sat, 22 Jul 2017 08:56:08 +0000</pubDate><guid>https://111qqz.com/2017/07/common-activation-functions/</guid><description>
其实我觉得这部分可以直接黑箱。。。直接无脑上Leaky ReLU或者Maxou？不过对这些激活函数的特点有个high-level的了解应该总是没坏处的，只要别太纠结细节就好了把。。 每个激活函数（或非线性函数）的输入都是一个数字，然后对其进行某种固定的数学操作。下面是在实践中可能遇到的几种激活函数： ————————————————————————————————————————
左边是Sigmoid非线性函数，将实数压缩到[0,1]之间。右边是tanh函数，将实数压缩到[-1,1]。
————————————————————————————————————————
**Sigmoid。**sigmoid非线性函数的数学公式是 ，函数图像如上图的左边所示。在前一节中已经提到过，它输入实数值并将其“挤压”到0到1范围内。更具体地说，很大的负数变成0，很大的正数变成1。在历史上，sigmoid函数非常常用，这是因为它对于神经元的激活频率有良好的解释：从完全不激活（0）到在求和后的最大频率处的完全饱和（saturated）的激活（1）。然而现在sigmoid函数已经不太受欢迎，实际很少使用了，这是因为它有两个主要缺点：
* _Sigmoid函数饱和使梯度消失_。sigmoid神经元有一个不好的特性，就是当神经元的激活在接近0或1处时会饱和：在这些区域，梯度几乎为0。回忆一下，在反向传播的时候，这个（局部）梯度将会与整个损失函数关于该门单元输出的梯度相乘。因此，如果局部梯度非常小，那么相乘的结果也会接近零，这会有效地“杀死”梯度，几乎就有没有信号通过神经元传到权重再到数据了。还有，为了防止饱和，必须对于权重矩阵初始化特别留意。比如，如果初始化权重过大，那么大多数神经元将会饱和，导致网络就几乎不学习了。 * _Sigmoid函数的输出不是零中心的_。这个性质并不是我们想要的，因为在神经网络后面层中的神经元得到的数据将不是零中心的。这一情况将影响梯度下降的运作，因为如果输入神经元的数据总是正数（比如在![f=w^Tx+b](http://www.zhihu.com/equation?tex=fwTxb) 中每个元素都 ），那么关于 的梯度在反向传播的过程中，将会要么全部是正数，要么全部是负数（具体依整个表达式 而定）。这将会导致梯度下降权重更新时出现z字型的下降。然而，可以看到整个批量的数据的梯度被加起来后，对于权重的最终更新将会有不同的正负，这样就从一定程度上减轻了这个问题。因此，该问题相对于上面的神经元饱和问题来说只是个小麻烦，没有那么严重。
**Tanh。**tanh非线性函数图像如上图右边所示。它将实数值压缩到[-1,1]之间。和sigmoid神经元一样，它也存在饱和问题，但是和sigmoid神经元不同的是，它的输出是零中心的。因此，在实际操作中，tanh非线性函数比sigmoid非线性函数更受欢迎。注意tanh神经元是一个简单放大的sigmoid神经元，具体说来就是： 。
————————————————————————————————————————
左边是ReLU（校正线性单元：Rectified Linear Unit）激活函数，当 时函数值为0。当 函数的斜率为1。右边是从 Krizhevsky等的论文中截取的图表，指明使用ReLU比使用tanh的收敛快6倍。
————————————————————————————————————————
**ReLU。**在近些年ReLU变得非常流行。它的函数公式是 。换句话说，这个激活函数就是一个关于0的阈值（如上图左侧）。使用ReLU有以下一些优缺点：
* 优点：相较于sigmoid和tanh函数，ReLU对于随机梯度下降的收敛有巨大的加速作用（ [Krizhevsky ](http://link.zhihu.com/?target=http//www.cs.toronto.edu/fritz/absps/imagenet.pdf)等的论文指出有6倍之多）。据称这是由它的线性，非饱和的公式导致的。 * 优点：sigmoid和tanh神经元含有指数运算等耗费计算资源的操作，而ReLU可以简单地通过对一个矩阵进行阈值计算得到。 * 缺点：在训练的时候，ReLU单元比较脆弱并且可能“死掉”。举例来说，当一个很大的梯度流过ReLU的神经元的时候，可能会导致梯度更新到一种特别的状态，在这种状态下神经元将无法被其他任何数据点再次激活。如果这种情况发生，那么从此所以流过这个神经元的梯度将都变成0。也就是说，这个ReLU单元在训练中将不可逆转的死亡，因为这导致了数据多样化的丢失。例如，如果学习率设置得太高，可能会发现网络中40%的神经元都会死掉（在整个训练集中这些神经元都不会被激活）。通过合理设置学习率，这种情况的发生概率会降低。 **Leaky ReLU。**Leaky ReLU是为解决“ReLU死亡”问题的尝试。ReLU中当x&amp;lt;0时，函数值为0。而Leaky ReLU则是给出一个很小的负数梯度值，比如0.01。所以其函数公式为 其中 是一个小的常量。有些研究者的论文指出这个激活函数表现很不错，但是其效果并不是很稳定。Kaiming He等人在2015年发布的论文Delving Deep into Rectifiers中介绍了一种新方法PReLU，把负区间上的斜率当做每个神经元中的一个参数。然而该激活函数在在不同任务中均有益处的一致性并没有特别清晰。
**Maxout。**一些其他类型的单元被提了出来，它们对于权重和数据的内积结果不再使用 函数形式。一个相关的流行选择是Maxout（最近由Goodfellow等发布）神经元。Maxout是对ReLU和leaky ReLU的一般化归纳，它的函数是： 。ReLU和Leaky ReLU都是这个公式的特殊情况（比如ReLU就是当 的时候）。这样Maxout神经元就拥有ReLU单元的所有优点（线性操作和不饱和），而没有它的缺点（死亡的ReLU单元）。然而和ReLU对比，它每个神经元的参数数量增加了一倍，这就导致整体参数的数量激增。
以上就是一些常用的神经元及其激活函数。最后需要注意一点：在同一个网络中混合使用不同类型的神经元是非常少见的，虽然没有什么根本性问题来禁止这样做。
一句话：“那么该用那种呢？”用ReLU非线性函数。注意设置好学习率，或许可以监控你的网络中死亡的神经元占的比例。如果单元死亡问题困扰你，就试试Leaky ReLU或者Maxout，不要再用sigmoid了。也可以试试tanh，但是其效果应该不如ReLU或者Maxout。</description></item><item><title>how to copy &amp; modify nets model on tensorflow slim</title><link>https://111qqz.com/2017/07/how-to-copy-modify-nets-model-on-tensorflow-slim/</link><pubDate>Wed, 19 Jul 2017 06:21:40 +0000</pubDate><guid>https://111qqz.com/2017/07/how-to-copy-modify-nets-model-on-tensorflow-slim/</guid><description>
想要修改tensorflow-slim 中 nets中的某个model,例如明明为kk_v2.py
观察到train_image_classifier.py中调用模型的部分
network_fn = nets_factory.get_network_fn( FLAGS.model_name, num_classes=(dataset.num_classes - FLAGS.labels_offset), weight_decay=FLAGS.weight_decay, is_training=True) 调用了nets_factory.get_network_fn，get_network如下：
def get_network_fn(name, num_classes, weight_decay=0.0, is_training=False): &amp;quot;&amp;quot;&amp;quot;Returns a network_fn such as `logits, end_points = network_fn(images)`. Args: name: The name of the network. num_classes: The number of classes to use for classification. weight_decay: The l2 coefficient for the model weights. is_training: `True` if the model is being used for training and `False` otherwise. Returns: network_fn: A function that applies the model to a batch of images.</description></item><item><title>Inception-v4,Inception-ResNet 和残差连接对学习的影响</title><link>https://111qqz.com/2017/07/inception-resnet-notes/</link><pubDate>Tue, 18 Jul 2017 02:42:50 +0000</pubDate><guid>https://111qqz.com/2017/07/inception-resnet-notes/</guid><description>
原始论文
翻译链接
**——前言：**作者认为残差连接在训练深度卷积模型是很有必要的。至少在图像识别上，我们的研究似乎并不支持这一观点。 摘要： 近年来，深度卷积神经网络对图像识别性能的巨大提升发挥着关键作用。以Inception网络为例，其以相对较低的计算代价取得出色的表现。最近，与传统结构相结合的残差连接网络在2015ILSVRC挑战赛上取得非常优异的成绩；它的性能跟最新的Inception-v3 网络非常接近。因此也就引出了结合残差连接的Inception结构能否对性能进行提高的问题。本文给出实验证明，残差连接可以明显加速Inception网络的训练。同时实验也证明，相比没有残差连接的消耗相似的Inception网络，残差Inception网络在性能上具有微弱的优势。针对是否包含残差连接的Inception网络，本文同时提出了一些新的简化网络。这些网络的变体在ILSVRC2012分类任务上很明显的改善了单一框架的识别性能。本文进一步展示了适当的激活缩放如何使得很宽的残差Inception网络的训练更加稳定。本文通过对三个残差和一个Inception-v4进行组合，在top-5错误率上达到了 3.08%。
前言： 自从Krizhevsky等人于2012年赢得Image Net比赛，其网络“AlexNet”已在越来越多的机器视觉任务中得到成功应用，比如目标检测、分割、人体姿态估计、视频分类、目标跟踪、超分辨率等。这些都是使用深度卷积网络的成功案例。 本研究结合最近的两个想法：残差连接和最近的Inception网络结构除了直接的融合，我们也研究了Inception本身通过变得更深更宽能否能变得更加高效。为了实现这个目的，我们设计了一个新版本的Inception-v4，相比Inception-v3，它有更加统一简化的网络结构和更多的inception模块。从历史观点来看，Inception-v3继承了之前的很多方法。技术性局限主要在于使用DistBelief对分布式训练进行模型划分。 如今，将训练迁移到TensorFlow上以后，这些问题也就随之解决，这样就允许我们对结构进行简化。简化的网络结构详见第三节。 在本文中，我们将两个单一Inception变体——Inception-v3和v4与消耗相似的 InceptionResNet混合版本进行比较。这些模型的挑选主要满足以下约束条件，即和非残差模型具有相似的参数和计算复杂度。事实上我们对更深更宽的Inception-ResNet变体也进行测试，它们在ImageNet分类任务上表现性能相似。 最新的实验对组合模型的性能进行了评估。结果显示Inception-v4和Inception-ResNetv2的性能都很好，在ImageNet验证集上其性能已超过业界领先的单个框架模型，我们想看这种结合如何将业界领先水准继续推进，令人惊讶的是，我们发现单个框架性能的提升不会引起组合性能大幅的提高。尽管如此，我们仍然用四个模型组合在验证集上取得了top-5上3.1%的错误率。 在最后一部分，我们分析了分类任务失败的原因，并总结出组合模型在标注数据上的类标噪声上仍然没有达到很好的效果，同时对于预测还有很有大的提升空间。
近期工作： 卷积网络在大规模图像识别任务上的运用非常广泛。主要的模型有Network-in-network、VGGNet、GoogleLeNet(Inception-v1)。残差连接在引文5中提出，并指出附加残差网络对于图像识别尤其是目标检测具有很大的优势，并给出理论和实验验证。作者认为残差连接在训练深度卷积模型是很有必要的。至少在图像识别上，我们的研究似乎并不支持这一观点。然而，残差连接所带来的潜在优势可能需要在更深网络结构中来展现。在实验部分，我们展示了不使用残差连接时深度网络的训练并不难做到。然而，使用残差连接能够极大的提高训练速度，单单这一点就值的肯定。 Inception深度卷积网络被称为GoogleLeNet或Incention-v1。继而我们通过各种方法对 Inception结构进行优化，首先引入batch normalization(Inception-v2)。后来在第三代中增加factorization因子，即本文中提到的Inception-v3。
图1.残差连接
图2.优化版本的ResNet连接 3.结构选择 3.1纯净的Inception模块 我们对以前的Inception模型通过分布式进行训练，将每个副本被划分成一个含多个子网络的模型，以达到在内存中对整个模型进行拟合的目的。然而，Inception结构是高度可调的，这就意味着各层滤波器（filter）的数量可以有多种变化，而整个训练网络的质量不会受到影响。为了优化训练速度，我们对层大小进行调整以平衡不同子网络的计算。 相反，随着TensorFlow的引入，大部分最新的模型无需分布式的对副本进行训练。它通过反向传播（back propagation）进行内存优化，并仔细考虑梯度计算需要的tensors，以及通过结构化计算减少这类tensors的数量。从历史观点来讲，我们对网络结构的更迭已经做得非常保守，并限制实验改变独立网络的组分，同时保持其余网络的稳定性。 由于之前没有对网络进行简化，导致网络看起来更加复杂。在最新的实验中，针对 Inception-v4网络，我们决定丢掉不必要的包袱，对于inception块的每个网格大小进行统一。如图9，展示了大尺寸的Inceptionv4网络结构。图3至8是每个部分的详细结构。所有图中没有标记“V”的卷积使用same的填充原则，意即其输出网格与输入的尺寸正好匹配。使用“V”标记的卷积使用valid的填充原则，意即每个单元输入块全部包含在前几层中，同时输出激活图（output activation map）的网格尺寸也相应会减少。
图3 Inception-v4网络和Inception-ResNet-v2网络的结构。这是网络的输入部分。
图 4 Inception-v4网络35×35网格的框架。对应图9中Inception-A块。
图 5 Incep-v4网络17×17网格块的框架。对应图9中Inception-B块。
图 6 Inception-v4网络的8×8网格模块的框架。对应图9中Inception-C块。
图7 35×35到17×17减少模块的框架。这个块不同的变化（不同滤波器）在图9和15中使用，同时在网络Inception(-v4,-ResNet-v1,-ResNet-v2).k,l,m,n数量表示滤波器尺寸大小，如表1所示。
图 8 17×17到8×8网格缩减框架。减少的模块在图9中Inception-v4网络。</description></item><item><title>stanford CS231n notes：Linear classification</title><link>https://111qqz.com/2017/07/cs231n-linear-classification/</link><pubDate>Mon, 17 Jul 2017 02:02:43 +0000</pubDate><guid>https://111qqz.com/2017/07/cs231n-linear-classification/</guid><description>
课程链接 知乎翻译链接
之前看的原版，后来发现知乎上有翻译，正好想到之前看完没有整理总结，干脆就写一下自己的理解，顺便贴一下课程翻译（感觉翻译的质量好像还可以？
分类器就是一个函数,自变量是图像信息，因变量是类别信息。
比如线性分类器，SVM,softmax
不同的分类器有着不同的score function,对应着不同的cost function.
之所以选择不同的cost function的原因是，要保证cost funtion是凸函数，不然会存在很多局部极值。
分类器使得分类问题变成了一个优化问题，在最优化过程中，将通过更新评分函数的参数来最小化损失函数值。
然后，所谓overfit,就是参数太多而训练集太小，导致可以完美符合这些训练集，但是无法一般化。
解决overfit有很多方法，这里介绍了正则化（Regularization）
思路是在cost funtion中添加一项Regularization loss
,用作对参数值的惩罚，lambda为惩罚因子
这样就可以使得每个参数尽可能小，这样每个参数对于cost function的贡献就比较小，可以改善overfit的问题
原文如下 内容列表：
* 线性分类器简介 * 线性评分函数 * 阐明线性分类器 _**译者注：上篇翻译截止处**_ * 损失函数 * 多类SVM * Softmax分类器 * SVM和Softmax的比较 * 基于Web的可交互线性分类器原型 * 小结 线性分类 上一篇笔记介绍了图像分类问题。图像分类的任务，就是从已有的固定分类标签集合中选择一个并分配给一张图像。我们还介绍了k-Nearest Neighbor （k-NN）分类器，该分类器的基本思想是通过将测试图像与训练集带标签的图像进行比较，来给测试图像打上分类标签。k-Nearest Neighbor分类器存在以下不足：
* 分类器必须_记住_所有训练数据并将其存储起来，以便于未来测试数据用于比较。这在存储空间上是低效的，数据集的大小很容易就以GB计。 * 对一个测试图像进行分类需要和所有训练图像作比较，算法计算资源耗费高。 概述：我们将要实现一种更强大的方法来解决图像分类问题，该方法可以自然地延伸到神经网络和卷积神经网络上。这种方法主要有两部分组成：一个是评分函数（score function），它是原始图像数据到类别分值的映射。另一个是损失函数（loss function），它是用来量化预测分类标签的得分与真实标签之间一致性的。该方法可转化为一个最优化问题，在最优化过程中，将通过更新评分函数的参数来最小化损失函数值。
从图像到标签分值的参数化映射 该方法的第一部分就是定义一个评分函数，这个函数将图像的像素值映射为各个分类类别的得分，得分高低代表图像属于该类别的可能性高低。下面会利用一个具体例子来展示该方法。现在假设有一个包含很多图像的训练集 ，每个图像都有一个对应的分类标签 。这里 并且 。这就是说，我们有N个图像样例，每个图像的维度是D，共有K种不同的分类。</description></item><item><title>tensorflow slim 源码分析</title><link>https://111qqz.com/2017/07/tensorflow-slim-code-notes/</link><pubDate>Sun, 16 Jul 2017 13:10:04 +0000</pubDate><guid>https://111qqz.com/2017/07/tensorflow-slim-code-notes/</guid><description>
py的源码看起来还是很愉快的。。。（虽然熟练成程度完全不如cpp。。。。
datasets里是数据集相关
deployment是部署相关
nets里给了很多网络结构
preprocessing给了几种预处理的方式
这些都和slim没有太大关系，就不多废话了。
分析的部分见代码注释...
由于刚刚入门machine learning 一周...还有很多内容还没有从理论层面接触...所以源码的理解也十分有限...希望能以后有机会补充一波
# Copyright 2016 The TensorFlow Authors. All Rights Reserved. # # Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description></item><item><title>几种梯度下降(GD)法的比较（转载）</title><link>https://111qqz.com/2017/07/Gradient-descent-methods/</link><pubDate>Mon, 10 Jul 2017 01:49:04 +0000</pubDate><guid>https://111qqz.com/2017/07/Gradient-descent-methods/</guid><description>
参考资料
机器学习中梯度下降（Gradient Descent， GD）算法只需要计算损失函数的一阶导数，计算代价小，非常适合训练数据非常大的应用。
梯度下降法的物理意义很好理解，就是沿着当前点的梯度方向进行线搜索，找到下一个迭代点。但是，为什么有会派生出 batch、mini-batch、online这些GD算法呢？
原来，batch、mini-batch、SGD、online的区别在于训练数据的选择上：
** ** **batch** **mini-batch** **Stochastic** **Online** **训练集** 固定 固定 固定 实时更新 **单次迭代样本数** 整个训练集 训练集的子集 单个样本 根据具体算法定 **算法复杂度** 高 一般 低 低 **时效性** 低 一般（delta 模型） 一般（delta 模型） 高 **收敛性** 稳定 较稳定 不稳定 不稳定 1.</description></item><item><title>Deep Learning Tutorial - PCA and Whitening</title><link>https://111qqz.com/2017/07/deep-learning-tutorial-pca-and-whitening/</link><pubDate>Thu, 06 Jul 2017 08:35:51 +0000</pubDate><guid>https://111qqz.com/2017/07/deep-learning-tutorial-pca-and-whitening/</guid><description>
说下我自己的理解
PCA：主成分分析，是一种预处理手段。对于n维的数据，通过一些手段，把变化显著的k个维度保留，舍弃另外n-k个维度。对于一些非监督学习算法，降低维度可以有效加快运算速度。而n-k个最次要方向的丢失带来的误差不会很大。
PCA的思想是将n维特征映射到k维上（k&amp;lt;n），这k维是全新的正交特征。这k维特征称为主成分，是重新构造出来的k维特征，而不是简单地从n维特征中去除其余n-k维特征。
whitening:是一种预处理手段，为了解决数据的冗余问题。比如如果数据是一个16_16的图像，raw data 有16_16=256维度，但是实际上这256个维度不是相互独立的，相邻的像素位置实际上有大关联！
Principal Component Analysis PCA is a method for reducing the number of dimensions in the vectors in a dataset. Essentially, you’re compressing the data by exploiting correlations between some of the dimensions.
Covariance Matrix PCA starts with computing the covariance matrix. I found this tutorial helpful for getting a basic understanding of covariance matrices (I only read a little bit of it to get the basic idea).</description></item><item><title>archlinux/manjaro 下 安装 qq/tim</title><link>https://111qqz.com/2017/06/install-qq-on-manjaro/</link><pubDate>Mon, 26 Jun 2017 16:09:19 +0000</pubDate><guid>https://111qqz.com/2017/06/install-qq-on-manjaro/</guid><description>
参考资料：install qq/tim on linux with wine
wine运行qq不能输入账号
This tutorial introduces how to install QQ/TIM in Linux with Wine, which had been tested on ArchLinux with Wine 2.4.
Prerequisites Before start, you need to get the latest Wine. I'm not sure whether QQ/TIM can run on lower version of Wine. In ArchLinux, you can easily get the latest Wine using following command:
?
pacman -S wine However, in Debian, you need to install Wine with some more steps.</description></item><item><title>libgfortran.so.4 missing under archlinux</title><link>https://111qqz.com/2017/06/libgfortran-so-4-missing-under-archlinux/</link><pubDate>Fri, 09 Jun 2017 20:12:41 +0000</pubDate><guid>https://111qqz.com/2017/06/libgfortran-so-4-missing-under-archlinux/</guid><description>
。。。哭了哦。。终于解决了这个bug
参考资料：
libgfortran broken?
libgfortran=3.0 should not be install with numpy &amp;lt;= 1.9
[SOLVED] libgfortran.so.3:cannot open shared object file: No such file
[Replacing gcc-libs-libs with gcc-multilib arch
conflict with gcc-libs and gcc-libs-multilib on latest update
一开始以为是anaconda相关。。。搞了半天。。。
然后又按照第一个资料里。。。试图把libgfortran用libgcc替代。。
发现删掉libgfortran会同时删掉scripy...
然后又觉得。。或许是scripy有什么问题？
查了一会也没发现什么。。。
后来又想也许是dlib的问题？
看了下dlib的github,说是pip 的安装方式可能存在问题，我又用源码安装了一边，问题依旧....
然后本来打算睡觉了。。。
突然梦到。。。也许是arch的问题呢。。。
一搜果然是。。。MGJ。。。这bug出现的时间。。。貌似是2017年5月30号以后。。。（具体参照最后一个资料的日期。。。
而且这。。。谁能想到是arch的锅啊。。。更别说是这么新鲜的bug...
所以说arch是不是不适合跑深度学习，做科学计算之类的啊orz....
最后说下解决办法：
:: gcc-libs 与 gcc-libs-multilib 有冲突。删除 gcc-libs-multilib 吗？ [y/N] y 错误：无法准备事务处理 (无法满足依赖关系) :: gcc-multilib：移除 gcc-libs-multilib 将破坏依赖关系 'gcc-libs-multilib=6.3.1-2' (tensorflow) [coder@111qqz-pc github]$ sudo pacman -S gcc-libs --force 正在解决依赖关系.</description></item><item><title>manjaro installation guide</title><link>https://111qqz.com/2017/06/manjaro-installation-guide/</link><pubDate>Thu, 08 Jun 2017 18:26:14 +0000</pubDate><guid>https://111qqz.com/2017/06/manjaro-installation-guide/</guid><description>
20180214 update:
第一个版本已经比较久了，于是更新一下，顺便写了个脚本orz
pacman-mirrors -c China echo &amp;quot; [archlinuxcn] &amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot; SigLevel = Optional TrustedOnly &amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot; Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot;[arch4edu]&amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot;SigLevel = Never&amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot;Server = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/\$arch &amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf pacman -Syyu pacman -S archlinuxcn-keyring pacman -S yakuake fish gvim pacman -S google-chrome chromium pacman -S wget aria2 remarkable netease-cloud-music pacman -S fcitx fcitx-configtool fcitx-sogoupinyin fcitx-im kcm-fcitx pacman -S shadowsocks-qt5 pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts cat &amp;gt;&amp;gt; ~/.</description></item><item><title>conda升级anaconda　ValueError的解决办法</title><link>https://111qqz.com/2017/06/how-to-fix-conda-upgrade-valueerror/</link><pubDate>Thu, 08 Jun 2017 13:03:51 +0000</pubDate><guid>https://111qqz.com/2017/06/how-to-fix-conda-upgrade-valueerror/</guid><description>
conda update anaconda　后提示
ValueError: unsupported format character ')' (0x29) at index 49 查到了这个：anaconda update issue
I have narrowed this down to the following packages: package build psutil-1.2.1 py27_0 hard-link pycparser-2.10 py27_0 hard-link pykit-0.1.0 np18py27_2 hard-link pyparsing-2.0.1 py27_0 hard-link by calling "</description></item><item><title>数字图像处理大作业(初步）</title><link>https://111qqz.com/2017/06/digital-image-processing-course-final-project/</link><pubDate>Wed, 07 Jun 2017 06:53:36 +0000</pubDate><guid>https://111qqz.com/2017/06/digital-image-processing-course-final-project/</guid><description>
...先随便记录一下好了。。。
* 神经网络识别数字或者字母？ * 识别车牌号？ * not hot dog? 安装python pandas pandas
发现之前装caffe的时候...装了这个东西。。。
但是就是检测不到？于是卸载重装。。。。
需要注意的是，如果是python2,要用pip2 install pandas,如果是python3,要用pip3 install pandas.
安装tensorflow...直接sudo pacman -Syu python-tensorflow 即可。。。
然后装好之后检测不到orz...感觉还是pip的安装方式比较靠谱。。。
pip2 install tensorflow
tensorflow_pip安装
我的环境是python2.7
# Ubuntu/Linux 64-bit, CPU only, Python 2.7 $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.10.0-cp27-none-linux_x86_64.whl sudo pip install --upgrade $TF_BINARY_URL 安装成功。。然后发现。。numpy挂了（？？？？？
SO上给出的建议 感觉之后还会各种遇到不同python版本导致的问题。。。。那就上anaconda好了。。。
试了anaconda...想法挺好。。但是貌似还不成熟.。。比如用anaconda安装numpy会报错orz..
最后解决办法是。。。卸载了python-numpy以及所有依赖python-numpy的a包；卸载了python2-numpy以及所有a依赖python２-numpy的包
然后重新安装了python2-numpy
以及发现。。。还有些坑是shellaa相关的.。。y所以暂时不要用fish了。。。
然后提示Missing required dependencies ['dateutil']
解决办法是安装python2-datautil
以及各种pip安装。。都记得要pip2而不是pip
中间缺少一堆库。。。大部分直接安装就好了。。。记得要安装python2对应的版本。。。
然后对于ImportError: No module named tensorboard.plugins
解决办法　是将tensorflow升级到1.</description></item><item><title>vim下python 的配置</title><link>https://111qqz.com/2017/06/vimrc-for-python/</link><pubDate>Wed, 07 Jun 2017 06:21:12 +0000</pubDate><guid>https://111qqz.com/2017/06/vimrc-for-python/</guid><description>
由于最近要做数字图像处理的大作业，以及之后一段时间，估计写python多一些，所以打算花些时间配置下vim. 1. 一键执行 其实之前一直有的。。不过没有效果，就没有管。发现问题是，python对应的filetype为&amp;quot;python&amp;quot;，而不是&amp;quot;py&amp;quot; func! CompileRunGcc() exec &amp;quot;w&amp;quot; if &amp;amp;filetype == 'c' exec &amp;quot;!g++ % -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'cpp' exec &amp;quot;!g++ % -std=gnu++11 -Wall -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'java' exec &amp;quot;!javac %&amp;quot; exec &amp;quot;!java %&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'sh' :!./% elseif &amp;amp;filetype == 'python' &amp;quot; exec &amp;quot;!python %&amp;quot; &amp;quot; exec &amp;quot;!python %&amp;lt;&amp;quot; exec &amp;quot;!python2.7 %&amp;quot; endif endfunc 2.代码补全 不想折腾了。。既然ycm也支持python,就先用用看好了。。不行再换别的。 放一段ycm　for python的配置文件 &amp;quot;默认配置文件路径&amp;quot; let g:ycm_global_ycm_extra_conf = '~/.</description></item><item><title>vundle error detected while processing function</title><link>https://111qqz.com/2017/06/vundle-error-detected-while-processing-function/</link><pubDate>Wed, 07 Jun 2017 05:50:27 +0000</pubDate><guid>https://111qqz.com/2017/06/vundle-error-detected-while-processing-function/</guid><description>
好久没装新插件了，最新要配下python,发现安装时候满屏的错误。。。 最后发现是shell的锅，因为我用的是fish,在.vimrc文件中添加 set shell=/bin/bash 即可。 以及说下可能的其他原因，虽然我没遇到 * 对于arch系，可能从aur中安装的版本out ot data * 可能没有把.vimrc中vundle的配置从set rtp+=~/.vim/bundle/vundle更新成set rtp+=~/.vim/bundle/vundle.vim * 可能项目名称用了&amp;quot; 而不是' 以及顺手查了下bundle和Plugin的区别。。。 简单来说。。Plugin是新写法，bundle是正在被淘汰的写法，不过由于兼容性的原因，仍然在使用。。。 以后使用plugin的写法就好。 参考资料</description></item><item><title>边界的链码，归一化链码，差分玛，形状数</title><link>https://111qqz.com/2017/06/digital-image-processing-course-review/</link><pubDate>Tue, 06 Jun 2017 11:42:37 +0000</pubDate><guid>https://111qqz.com/2017/06/digital-image-processing-course-review/</guid><description>
复习一下数字图像处理。 按照我自己的理解简单来说： 原链码：按照任意起点走边界一周，方向按照上图对应的表示，得到的数字序列就是原链码。 归一化链码：为了解决原链码中起点不唯一而产生的序列不唯一的问题，规定，对于所有起点得到的原链码中，字典序最小的即为归一化链码（由于序列都是自然数，因此字典序最小也可以理解成，把该序列看成有前导０的自然数之后的数值之后的数值最小。 差分码：为了解决图形旋转之后，原链码和归一化链码都会发生变化，引入差分码。n位原链码（或归一化链码，由于归一化链码只是一种特殊的原链码，之后不再单独强调）可以得到n-1位差分码。具体来说，对于原链码ai，可以得到差分码b[i],_b[i] = ((a[i+1] - a[i])+mod)%mod(i属于1..n-1)，_mod根据实际有几个方向决定，通常为４或者８。 形状数：需要强调的是，形状数也是一个序列，而不是一个数。其实形状数就是把差分码按照字典序排序之后，最小的序列。形状数的阶数是该序列的长度。 Freeman链码（弗雷曼链码）是指用曲线起始点的坐标和边界点方向代码来描述曲线或边界的方法，常被用来在图像处理、计算机图形学、模式识别等领域中表示曲线和区域边界。它是一种边界的编码表示法，用边界方向作为编码依据，为简化边界的描述，一般描述的是边界点集。
常用的链码按照中心像素点邻接方向个数的不同，分为4连通链码和8连通链码。4连通链码的邻接点有4个，分别在中心点的上、下、左和右。8连通链码比4连通链码增加了4个斜方向，因为任意一个像素周围均有8个邻接点，而8连通链码正好与像素点的实际情况相符，能够准确地描述中心像素点与其邻接点的信息。因此，8连通链码的使用相对较多。
(a)四方向链码的方向符； （b）八方向链码的方向符。
八链码如下：
链码的定义 按照水平、垂直和两条对角线方向，可以为相邻的两个像素点定义4个方向符：0、1、2、3，分别表示0°、90°、180°和270°四个方向。同样，也可以定义8个方向符：0、1、2、3、4、5、6、7。链码就是用线段的起点加上由这几个方向符所构成的一组数列，通常称之为Freeman链码。用Freeman链码表示曲线时需要曲线的起点，对8链码而言，奇数码和偶数码的对应线段长度不等，规定偶数码单位长度为1，奇数码的单位长度为1.414。
2. 曲线的链码表示
（1）原链码 从边界（曲线）起点S开始，按顺时针方向观察每一线段走向，并用相应的指向符表示，结果就形成表示该边界（曲线）的数码序列，称为原链码，表示为
其中，S表示边界（曲线）的起点坐标，N=4或8时分别表示四链码和八链码。当边界（曲线）闭合时，会回到起点，S可省略。
（2）归一化链码
原链码具有平移不变性（平移时不改变指向符），但当改变起点S时，会得到不同的链码表示，即不具备唯一性。为此可引入归一化链码，其方法是：
对于闭合边界，任选一起点S得到原链码，将链码看作由各方向数构成的n位自然数，将该码按一个方向循环，使其构成的n位自然数最小，此时就形成起点唯一的链码，称为归一化链码，也称为规格化链码。我们将这样转换后所对应的链码起点作为这个边界的归—化链码的起点。
（3）链码的旋转归一化
用链码表示给定目标的边界时，如果目标平移，链码不会发生变化。
但是，如果目标旋转则链码会发生变化。为了得到具有旋转不变性的链码，我们可定义所谓的差分码。链码对应的差分码定义为：
对差分码进行（起点）归一化，就可得到归一化（唯一）的差分码，它具有平移和旋转不变性，也具有唯一性。
3. 边界的形状数表示
由于归一化的差分码既具有唯一性，也具有目标物平移和旋转不变性，因此可用来表示边界，称为形状数。形状数序列的长度(位数)称为形状数的阶,它可作为闭合边界的周长。
如上图所示的目标边界，其
原链码为：42120606454 ，
差分码为 ： 6716626617 ，
形状数: 1662661767 ，
形状数的阶为10 。
参考资料：
图像形状特征（三）--链码及形状数
中南大学_第7章 目标表达和描述技术</description></item><item><title>qt 5.x　初探　(5)　</title><link>https://111qqz.com/2017/06/qt-5-notes-5/</link><pubDate>Sun, 04 Jun 2017 17:14:39 +0000</pubDate><guid>https://111qqz.com/2017/06/qt-5-notes-5/</guid><description>
qt_5.9_ui_doc
还是比直接写代码方便点。。。所以不妨学习一个！
以及。。。qt在2017年6月１号发布了5.9。。。所以之前是5.8。。。现在变成5.9了。。。
遇到了修改了ui文件却没有生效的问题。。。
解决办法：
到项目目录下去执行：uic mainwindow.ui &amp;gt; ui_mainwindow.h 时间测试的qt方法。。。
头文件#include &amp;lt;QTime&amp;gt; QTime time; time.start(); // do something qDebug()&amp;lt;&amp;lt;time.elapsed()&amp;lt;&amp;lt;&amp;quot;ms&amp;quot;; （注意单位。。。</description></item><item><title>qt 5.x初探　（４）　qt 在win下打包成exe</title><link>https://111qqz.com/2017/06/qt-5-notes-4/</link><pubDate>Sun, 04 Jun 2017 12:54:51 +0000</pubDate><guid>https://111qqz.com/2017/06/qt-5-notes-4/</guid><description>
des的基本搞定了。。。打包。。。
在linux下打包成exe。。。。实在是。。没什么好办法的样子。。。
嘛。转念一想。老师说是打包成可执行文件。。。没说一定是exe啊。。。
然后也许我就零分了呢2333
des1.0
好了。。我又跑到windows下装了个qt...安装包2.3G,记得要安装编译器...
装好以后。。。开始打包。。。
注意区分：
Qt Widgets Application 和 Qt Quick Application
我的是后者。。。打包方式略有不同。。。
下面引用了详细步骤。。我来说下简略步骤好了。。。
* 将creator选到release的部署模式。。然后编译。。。 * 将exe文件单独拷贝出来，放到一个文件夹。。。 * **运行qt的命令行（不是系统的命令行！)** * **在qt的命令行中运行windeployqt helloqml.exe --qmldir C:\Qt\Qt5.4.0\5.4\mingw491_32\qml（其中qmldir后面换为qml的真实路径）** 顺便吐槽这工具有点智障。。。文件夹选项不显示后缀名就找不到helloqml　也是有毒。。。
Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll， 如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。 因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe。 以官方 Qt 5.4.0+MinGW 开发环境为例， 从开始菜单--》Qt 5.4.0--》5.4--》MinGW 4.9 (32-bit)--》Qt 5.4 for Desktop (MinGW 4.9 32 bit)，可以打开 Qt 命令行，从这里就可以执行 windeployqt 工具。 集成开发环境 QtCreator 目前生成图形界面程序 exe 大致可以分为两类： Qt Widgets Application 和 Qt Quick Application。 下面分别介绍这两类exe 的发布方式。</description></item><item><title>关于恋爱模式的一点思考</title><link>https://111qqz.com/2017/05/think-about-Love-relationship/</link><pubDate>Tue, 30 May 2017 06:03:09 +0000</pubDate><guid>https://111qqz.com/2017/05/think-about-Love-relationship/</guid><description>
最近和妹子闹了一点小矛盾，不过已经problem solved.
大概是因为，我聊到了妹子很不喜欢的话题，导致妹子情绪变得负面而我还没意识到...
我是感觉...就像写代码一样，代码没有bug(初始时）是不太现实的，关键是要debug?
所以人际关系，更具体的说是和妹子相处....也不可能没有矛盾吧...
尤其是两个人成长环境如果相差得比较多的情况下...接触的时间越长，暴露的矛盾应该就越多...
一个好的coder会惧怕代码中有bug吗？当然不会...
所以矛盾似乎也没什么可怕的...
不过一个熟练的coder大概可能写出的bug会越来越少吧。
所以我觉得，找到一种合适的机制，去解决矛盾是非常必要的....
这种机制不是说解决矛盾的方法本身，而是更通用的为解决矛盾提供的环境？
另外，其实有矛盾也不是什么坏事....如果矛盾是客观存在的，大概越早暴露越好...
越早暴露应该越好解决吧orz
所以大概....下次遇到，至少是这一类的问题，我们应该能解决的更好了吧...
用coding的思维考虑恋爱关系想想其实也没有那么奇怪啊...
我一直觉得，每一对情侣之间都有他们自己相处的模式吧....
所以其实使用这一类方法（不过不代表全部套用...就好像觉得某种语言的某个特性好不代表以后就只使用这种语言一样2333）
对于我们来说应该是种挺高效的模式吧。。。
其实这也可以归结成“见什么人说什么话”？
就想起那次和室友们打《优势物种》...解释规则的时候，“资源的实例”的说法软院的学生都会明白而又不会显得冗杂..
就好像某次和妹子去光谷浪，看到很多家烤串店纠结去哪一家的时候....“遍历一下”也比能想到的其他说法更加准确高效....</description></item><item><title>安装win10后导致grub 引导缺失的解决办法</title><link>https://111qqz.com/2017/05/missing-grub-after-install-windows10/</link><pubDate>Sun, 28 May 2017 04:10:35 +0000</pubDate><guid>https://111qqz.com/2017/05/missing-grub-after-install-windows10/</guid><description>
我之前是单系统manjaro，装了win10以后，grub menu直接消失不见...
ubuntu 的live cd进去，用神器boot-repair也没作用...
最后的解决办法是：
用随便一个什么linux的live cd,进入live模式
使用某种方法（fdisk?gparted?自己记得？）确认linux安装在哪个分区（如果有安装了多个，应该以最后一个为准）我的linux安装在了sda5
挂载linux分区:
sudo mount /dev/sda5 /mnt #Replace sda5 with your partition number
4.挂载其他必要的文件夹
for i in /sys /proc /run /dev; do sudo mount --bind &amp;quot;$i&amp;quot; &amp;quot;/mnt$i&amp;quot;; done 5:chroot进你的系统
sudo chroot /mnt 6.重装并更新grub引导
grub-install /dev/sda update-grub exit sudo reboot 完美解决！</description></item><item><title>archlinux安装记</title><link>https://111qqz.com/2017/05/install-archlinux-notes/</link><pubDate>Sun, 21 May 2017 18:41:27 +0000</pubDate><guid>https://111qqz.com/2017/05/install-archlinux-notes/</guid><description>
实在不忍心x1c吃灰。。。
打算装个arch玩。。。
第一次失败了，原因是忘记配置引导相关...
第二次就成功了...
教程满大街都是就不再写了....
似乎装好以后，和manjaro区别不大？
有空来更新下配置吧。。。
（越来越觉得折腾linux的时间还不如用来陪妹子...
所以不一定什么时候会更了2333</description></item><item><title>qt 5.x初探 （3）</title><link>https://111qqz.com/2017/05/qt-5-notes-3/</link><pubDate>Thu, 18 May 2017 12:47:20 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-3/</guid><description>
update3：
终于知道了正确的学习姿势...
用百度把要用的东西大概描述出来，然后总能找到一个是你要的。。。
然后再去搜关键词。。。
嗯。。百度还是很有用的啊2333
qt5.8_doc_Line Edits Example
所以现在要把之前写成dialog的几个改回Line edit
update2:
老师说要把输入框中的东西随时选中复制出来check...
QLabel默认好像不具有这种属性啊？
稍微查了下。。。
查到了一个叫setTextInteractionFlags的属性
以及连根拔出了。。
qt5.8 QGraphicsTextItem Class
找到了解决办法。。。
openFileNameLabel = new QLabel; openFileNameLabel-&amp;gt;setFrameStyle(frameStyle); openFileNameLabel-&amp;gt;setTextInteractionFlags(Qt::TextSelectableByMouse); //添加可选中可复制的交互属性。。。 记得要
#include &amp;lt;QGraphicsTextItem&amp;gt; update1:
扶起。。。QFile读中文路径文件毫无问题。。。
换成了cpp的 ifstream就一直报错。。。
由于我还改了其他部分。。。所以。。。
查了好久才发现是ifstream的锅。。。。
把des放了进去。。。
本来加密和解密想就用一个函数用参数调节的。。。
不过看了半天也没太懂。。。这种connnet怎么写。。。
不过对connect的理解更深了一些。。。
信号和槽果然是qt的精髓。。。看起来还算不那么无聊。。。
放一些关于信号和槽的资料好了。。。
信号与槽机制
ibm_qt的信号与槽机制
qt的信号槽
然后目前的进度是。。。
des放了进去。。。加密基本没啥问题。。。
但是有个小问题。。。
对于加密过程。。。我是用了一个全局的QString QTextSt来传递信息。。。
对于打开文件。。。过程是file-&amp;gt;QString
加密后得到密文文件。。过程是QString -&amp;gt; file
但是解密过程。。。。完全反过来了啊。。。？
在思考怎么写在一起能够不违和。。。。。</description></item><item><title>C++中头文件（.h）和源文件（.cpp）都应该写些什么（转载）</title><link>https://111qqz.com/2017/05/cpp-header-file-and-source-file/</link><pubDate>Tue, 16 May 2017 07:07:06 +0000</pubDate><guid>https://111qqz.com/2017/05/cpp-header-file-and-source-file/</guid><description>
感觉其实。。。更像是一种规范。。。？而不是一种具体要求吧。。。
转自 头文件(.h)： 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。
在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：
#ifndef CIRCLE_H #define CIRCLE_H //你的代码写在这里 #endif
这样做是为了防止重复编译，不这样做就有可能出错。
至于CIRCLE_H这个名字实际上是无所谓的，你叫什么都行，只要符合规范都行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。
源文件（.cpp）：
**源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。**那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。
下面举个最简单的例子来描述一下，咱就求个圆面积。
第1步，建立一个空工程（以在VS2003环境下为例）。
第2步，在头文件的文件夹里新建一个名为Circle.h的头文件，它的内容如下：
#ifndef CIRCLE_H #define CIRCLE_H class Circle { private: double r;//半径 public: Circle();//构造函数 Circle(double R);//构造函数 double Area();//求面积函数 }; #endif
注意到开头结尾的预编译语句。在头文件里，并不写出函数的具体实现。
第3步，要给出Circle类的具体实现，因此，在源文件夹里新建一个Circle.cpp的文件，它的内容如下：
#include &amp;quot;Circle.h&amp;quot; Circle::Circle() { this-&amp;gt;r=5.0; } Circle::Circle(double R) { this-&amp;gt;r=R; } double Circle:: Area() { return 3.</description></item><item><title>g++ 编译多个源文件（转载）</title><link>https://111qqz.com/2017/05/g++-compile-multi-file/</link><pubDate>Tue, 16 May 2017 06:40:03 +0000</pubDate><guid>https://111qqz.com/2017/05/g++-compile-multi-file/</guid><description>
参考资料
一. 常用编译命令选项 假设源程序文件名为test.c。
无选项编译链接 用法：#gcc test.c 作用：将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。
选项 -o 用法：#gcc test.c -o test 作用：将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。
选项 -E 用法：#gcc -E test.c -o test.i 作用：将test.c预处理输出test.i文件。
选项 -S 用法：#gcc -S test.i 作用：将预处理输出文件test.i汇编成test.s文件。
选项 -c 用法：#gcc -c test.s 作用：将汇编输出文件test.s编译输出test.o文件。
无选项链接 用法：#gcc test.o -o test 作用：将编译输出文件test.o链接成最终可执行文件test。
选项-O 用法：#gcc -O1 test.c -o test 作用：使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。
二. 多源文件的编译方法
如果有多个源文件，基本上有两种编译方法： [假设有两个源文件为test.c和testfun.c]
多个文件一起编译 **用法：#gcc testfun.</description></item><item><title>qt 5.x 学习笔记　(2)</title><link>https://111qqz.com/2017/05/qt-5-notes-2/</link><pubDate>Tue, 16 May 2017 03:14:19 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-2/</guid><description>
先来放一波过程中用到的资料和官方文档好了。
basic layout_qt5.8
QBoxLayout Class_qt5.8
QString Class 5.8
QChar Class qt 5.8
Standard Dialogs Example qt 5.8
更新的部分还是放在最前面好了。。。
convert from QString to char *的时候有个坑。。。
In order to convert a QString to a char*, then you first need to get a latin1 representation of the string by calling toLatin1() on it which will return a QByteArray. Then call data() on the QByteArray to get a pointer to the data stored in the byte array.</description></item><item><title>qt 5.x　初探(1)</title><link>https://111qqz.com/2017/05/qt-5-notes-1/</link><pubDate>Sun, 14 May 2017 12:21:56 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-1/</guid><description>
嘛。。为了系统安全课来学一波qt...
现在算是写出了一个可以打开文件，保存文件的记事本。。。
接下来要搞定的事情是。。。如何写一个自定义的事件。。。比如计算个开方之类的。。。
放一波代码好了。。。
#include &amp;lt;QAction&amp;gt; #include &amp;lt;QMenuBar&amp;gt; #include &amp;lt;QMessageBox&amp;gt; #include &amp;lt;QStatusBar&amp;gt; #include &amp;lt;QToolBar&amp;gt; #include &amp;lt;QDebug&amp;gt; #include &amp;lt;QTextEdit&amp;gt; #include &amp;lt;QFileDialog&amp;gt; #include &amp;quot;mainwindow.h&amp;quot; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { openAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Open...&amp;quot;), this); openAction-&amp;gt;setShortcuts(QKeySequence::Open); openAction-&amp;gt;setStatusTip(tr(&amp;quot;Open an existing file&amp;quot;)); saveAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Save...&amp;quot;), this); saveAction-&amp;gt;setShortcuts(QKeySequence::Save); saveAction-&amp;gt;setStatusTip(tr(&amp;quot;Save a new file&amp;quot;)); QMenu *file = menuBar()-&amp;gt;addMenu(tr(&amp;quot;&amp;amp;File&amp;quot;)); file-&amp;gt;addAction(openAction); file-&amp;gt;addAction(saveAction); QToolBar *toolBar = addToolBar(tr(&amp;quot;&amp;amp;File&amp;quot;)); toolBar-&amp;gt;addAction(openAction); toolBar-&amp;gt;addAction(saveAction); textEdit = new QTextEdit(this); setCentralWidget(textEdit); connect(openAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::openFile); connect(saveAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::saveFile); } MainWindow::~MainWindow() { } void MainWindow::openFile() { QString path = QFileDialog::getOpenFileName(this, tr(&amp;quot;Open File&amp;quot;), &amp;quot;.</description></item><item><title>codeforces #413 C. Fountains （BIT维护前缀max）</title><link>https://111qqz.com/2017/05/codeforces-div2-413c/</link><pubDate>Fri, 12 May 2017 13:27:36 +0000</pubDate><guid>https://111qqz.com/2017/05/codeforces-div2-413c/</guid><description>
题目链接
题意：有２种货币，分别为C和D.给出n种资源的代价和美丽度，每种资源只能用其中一种资源购买。现在拥有货币C的数量是c,拥有货币D的数量是d.然后恰好买２个资源，问最大美丽度，不能的话输出０．
思路：首先显然三种情况。。。CC，CD,DD.
CD直接扫一遍。。重点是CC和DD
一开始思路错掉了。。全程写two pointer wa4...一直调。。
最后恍然大悟。。发现two pointer非常错啊。。。
其实正解也很简单？
先去跑步了orz
只要想办法维护每个代价的最大美丽度就好了(更准确得说，是维护小于等于某代价的最大美丽度)
直接BIT搞。维护一个前缀max...好像很稳啊？
不过我竟然对于BIT能维护前缀max吃了一惊？
以往都是用线段树来做这个操作的...想想大概是。。我把BIT的函数起名叫&amp;quot;Sum&amp;quot;的锅。。。
看起来就只能求Sum。。。。233333
/* *********************************************** Author :111qqz Created Time :2017年05月12日 星期五 20时20分57秒 File Name :code/codeforces/413/CC.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,c,d; int t[N] ; //for BIT vector&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt;v[2]; //总的思路是，维护每个代价(或者小于该代价）所对的美丽度的最大值 //用bit维护一个前缀max // // int lowbit( int x) { return x&amp;amp;(-x); } void update( int x,int delta) { for ( int i = x ; i &amp;lt; N ; i+=lowbit(i)) t[i] = max(t[i],delta); } int query( int x) { int ret = 0 ; for ( int i = x ; i&amp;gt;=1 ; i-=lowbit(i)) ret = max(ret,t[i]); return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #413 B T-shirt buying (贪心)</title><link>https://111qqz.com/2017/05/codeforces-div2-413b/</link><pubDate>Fri, 12 May 2017 13:18:06 +0000</pubDate><guid>https://111qqz.com/2017/05/codeforces-div2-413b/</guid><description>
题目链接
题意：有n个Ｔ恤，每个价格都不同，有三种颜色，分别用1,2,3表示，每件Ｔ恤给出前xiong和后背的颜色。现在有m个顾客排成一队，对于每个顾客，给出他喜欢的颜色，只要一个Ｔ恤的前xiong或者后背的颜色之一满足该颜色即可。顾客总希望买符合他喜欢颜色的Ｔ恤中价格最低的。现在问每个顾客买到的Ｔ恤的价格，如果某个顾客没有买Ｔ恤，输出-1
思路：贪一下？
对于每个颜色，找到价格最低的。记录的时候顺便记录id，以标记某件有２个颜色的衣服是否卖出去了。
１A美滋滋
/* *********************************************** Author :111qqz Created Time :2017年05月11日 星期四 15时29分58秒 File Name :B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; bool vis[N]; //表示某个id的是否被卖出。 vector&amp;lt; pair&amp;lt;int,int&amp;gt;&amp;gt;v[4]; //pair&amp;lt;price,id&amp;gt;,id是为了标记是否卖出去了，卖出去就继续找下一个。 //虽然价格本身唯一，但是太大不适合做标记？ struct node { int p,a,b; int id; }A[N]; bool cmp(node x,node y) { return x.</description></item><item><title>codeforces #413 A. Carrot Cakes (模拟)</title><link>https://111qqz.com/2017/05/codeforces-div2-413a/</link><pubDate>Fri, 12 May 2017 13:12:30 +0000</pubDate><guid>https://111qqz.com/2017/05/codeforces-div2-413a/</guid><description>
题目链接
题意：初始有一个锅，每t分钟可以做好k个饼，现在需要N个饼。还可以另外建一个锅，花费d时间，建好以后两个锅可以并行烙饼。问是否应该建锅？（以期减少烙饼时间）
思路：求出两种情况下的总时间，比较一下。
只有一个锅的情况很好求。
两个锅的情况比较麻烦，不如模拟时间流逝？
反正最多也就1E6的时间。。。模拟一下。。。稳。。
/* *********************************************** Author :111qqz Created Time :2017年05月11日 星期四 15时29分43秒 File Name :A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>20170504近况</title><link>https://111qqz.com/2017/05/20170504/</link><pubDate>Thu, 04 May 2017 12:58:06 +0000</pubDate><guid>https://111qqz.com/2017/05/20170504/</guid><description>
啊。。在准备考试QAQ
明天约了鹅厂面试。。。然而从四月就开始一直考试考试考试....感觉药丸啊？
MS的结果貌似明天也要出了orz...
之前没收到positive以为是跪了，结果听说有人没收到positive也拿到了offer啊？
以及，被之前拿到的某厂追加了类似sp之类的东西....
虽然说实习工资什么的的确不是很重要，不过比初始的offer 多了60%的工资还是美滋滋的啊？
而且貌似是我们组的boss帮我争取到的T T
好感动啊。。。。
哦还有。。后半学期有门叫大数据与云计算的课。。。
大概是做一些，和hadoop,spark,caffe有关的实验orz
我本以为我虽然菜了一点。。。但是毕竟一直在linux环境下。。。
这些东西还是能应付的。。。
结果关键步骤几乎全靠妹子carry啊orz....我好菜.jpg
所以虽然我们因为课程太多没办法像其他情侣一样出去玩。。。
一起在写代码，一起debug也算是另一种浪漫吧（强行自我安慰）
增强了专业水平又促进了感情orz
哦还有校赛。。。
虽然是菜鸡。。。不过校赛帮忙出题我觉得是老年选手的义务吧。。。。
但是听说dp和数学题已经够多了。。。马丹这两个最好出了吧orz...
尤其我半年没写过题。。。。我当时的idea...早就过时了吧orz...
而且还是校赛...武汉高校都会来吧。。。
万一因为我出的题太差影响了hust的形象那可就。。。。太糟糕了啊。。。</description></item><item><title>ubuntu 包管理(apt-get)损坏的解决办法</title><link>https://111qqz.com/2017/04/fix-ubuntu-package-manager-broken-problem/</link><pubDate>Sun, 30 Apr 2017 06:58:27 +0000</pubDate><guid>https://111qqz.com/2017/04/fix-ubuntu-package-manager-broken-problem/</guid><description>
症状是不管安装什么，都会说有一大堆依赖无法安装。。。
大概是: a depends b[i],but b[i] is not be installed. (b==0..n)
最后会提示Unable to correct problems, you have held broken packages
解决办法：用synaptic工具，把可能存在问题的包都清除掉。
参考资料
顺便想吐槽。。。ubuntu的包管理工具好辣鸡啊。。
随便装点东西竟然就损坏了？
我刚才装chrome,然后出了错误，提示我apt-get -f install 解决问题。。。
然后包管理就挂了？
想起当年虽然装的第一个发行版是ubuntu,但是并不好用啊？
好好使用的第一个还是mint
所以其实ubuntu不是很适合新手吧。。。只不过知名度高。。。。资料多。。。
要我说 manjaro 或者 linux mint 都要比ubuntu新手友好的多啊orz</description></item><item><title>install galliumOS on chromebook with chrx</title><link>https://111qqz.com/2017/04/install-galliumos-with-chrx-on-chromebook/</link><pubDate>Sat, 29 Apr 2017 15:09:51 +0000</pubDate><guid>https://111qqz.com/2017/04/install-galliumos-with-chrx-on-chromebook/</guid><description>
我的chromebook 是　samsung 3
查阅Hardware Compatibility 可以知道我的cb支持　gallium,对应的cpu 是Intel Braswell
然后去galliumos　官网　下载相应版本。  (发现这种做法并不需要自己下载。。。)
安装　galliumOS大体有两种方法，一种是完全去掉chromeOS,这种方法需要需要拆机去除写保护。。。我嫌麻烦。。。于是打算另一种，使用chrx　
步骤如下：
1. Enable [Developer Mode](http://www.chromium.org/chromium-os/developer-information-for-chrome-os-devices) (process is model-specific; for Acer C720, press `ESC+F3(Refresh)+Power`), then reboot 2. Load ChromeOS by pressing `CTRL+D` at the white &amp;quot;OS verification is OFF&amp;quot; screen 3. Configure your Wi-Fi network if necessary, then log in (Guest account is fine) 4. Open the ChromeOS Terminal by pressing `CTRL+ALT+T`, and enter `shell` at the prompt 5.</description></item><item><title>为什么。。。为什么会变成这样呢。。。</title><link>https://111qqz.com/2017/04/why-is-it-like-this/</link><pubDate>Thu, 27 Apr 2017 07:53:22 +0000</pubDate><guid>https://111qqz.com/2017/04/why-is-it-like-this/</guid><description>
连着考试。。。
取消考试周这做法就是蠢。。。
白天上课晚上考试。。。
说得好像没有考试周大家就不会复习了一样。。。
结果就只能是在白天的课上复习。。。
又影响听新的课，又影响复习。。。。
然后昨天还推了鹅厂的面试。。。不知道会不会留下什么不好的印象T T
连着考试真心要死啊。。。
身体完全受不了。。。
这还只是期中。。。
想想我们前半学期学完了 文档+专业英语+信号+测试+uml+游戏+计网，7门课。。。。
那就意味着期末还有12门。。。。。。。。
感觉真的。。。。。。。为什么。。。要这么多课呢。。。。。。。</description></item><item><title>20140419</title><link>https://111qqz.com/2017/04/20140419/</link><pubDate>Wed, 19 Apr 2017 12:56:13 +0000</pubDate><guid>https://111qqz.com/2017/04/20140419/</guid><description>
最让你恶心痛苦的那些人，你必要从他们身上学到最重要和有用的东西。 所有的痛苦都不能白受，克我者必生我。 在知乎看到这句话，不禁在想
人无疑是zhangk，可是学到了什么呢？
好像什么都没学到T T
那我好亏啊~~~~(&amp;gt;_&amp;lt;)~~~~</description></item><item><title>leetcode162. Find Peak Element (O(lgn)复杂度寻找峰值)</title><link>https://111qqz.com/2017/04/leetcode-162/</link><pubDate>Fri, 14 Apr 2017 12:25:16 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-162/</guid><description>
A peak element is an element that is greater than its neighbors.
Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[-1] = num[n] = -∞.
For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</description></item><item><title>leetcode 152. Maximum Product Subarray (最大连续子序列乘积，dp)</title><link>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray/</link><pubDate>Fri, 14 Apr 2017 11:33:30 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray/</guid><description>
Find the contiguous subarray within an array (containing at least one number) which has the largest product.
For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.
思路：由于有正，有负，还有0.。。所以比最大子串之和要复杂一些。。。
dp[i].max表示到当前位置的最大乘积。
dp[i].min表示到当前位置的最小乘积。
dp[i].max = max{dp[i-1].maxa[i],dp[i-1].mina[i],a[i]};
dp[i].min同理
边界dp[i].max = dp[i].min = a[0]
/* *********************************************** Author :111qqz Created Time :2017年04月14日 星期五 18时57分13秒 File Name :152.cpp ************************************************ */ class Solution { public: //dp //dp[i]表示当前的最大乘积。 //用了滚动数组优化空间/ int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetcode 228. Summary Ranges</title><link>https://111qqz.com/2017/04/leetcode-228/</link><pubDate>Fri, 14 Apr 2017 10:51:39 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-228/</guid><description>
Given a sorted integer array without duplicates, return the summary of its ranges.
For example, given [0,1,2,4,5,7], return [&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;].
题意：把连续的数连续表示
思路：模拟。注意有负数，注意有-2147483648这种数据。
本来还想着，可能是leetcode加数据的审核机制太松，导致被人加了奇怪的数据。。。
结果发现出题人和加数据的人是一个人啊？
不给数据范围，加这种奇怪的数据很有意思？ 分分钟卡掉你的标程啊？
感觉像吃了苍蝇一样恶心。。一句话，出题人傻逼
/* *********************************************** Author :111qqz Created Time :2017年04月14日 星期五 16时26分01秒 File Name :228.cpp ************************************************ */ class Solution { public: string int2st(long long x) { if (x==0) return &amp;quot;0&amp;quot;; string ret = &amp;quot;&amp;quot;; int val; //md还有负数 long long sign = 1; if (x&amp;lt;0) sign = -1; x*=sign; while (x) { val = x % 10; ret = ret + char(val+'0'); x/=10; } if (sign==-1) ret +=&amp;quot;-&amp;quot;; reverse(ret.</description></item><item><title>leetcode 209. Minimum Size Subarray Sum (尺取法)</title><link>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum/</link><pubDate>Thu, 13 Apr 2017 13:50:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum/</guid><description>
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.
For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint
思路：尺取即可。。好久没写，竟然调了半天。。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 20时48分00秒 File Name :209.cpp ************************************************ */ class Solution { public: int ruler(vector&amp;lt;int&amp;gt;nums,int tar,int n) { int head = 0; int tail = 0; int sum = 0 ; int res = 0x3f3f3f3f; while (tail&amp;lt;n&amp;amp;&amp;amp;head&amp;lt;=tail) { sum = sum + nums[tail]; if (sum&amp;gt;=tar) { res = min(res,tail-head+1); while (sum&amp;gt;=tar&amp;amp;&amp;amp;head&amp;lt;tail) { sum-=nums[head]; head++; } if (sum&amp;gt;=tar) { res = min(res,tail-head+1); } else { head--; sum+=nums[head]; res = min(res,tail-head+1); } } tail++; } return res==0x3f3f3f3f?</description></item><item><title>leetcode 229. Majority Element II （O(1)空间找出现次数大于n/3的元素）</title><link>https://111qqz.com/2017/04/leetcode-229-majority-element-ii/</link><pubDate>Thu, 13 Apr 2017 12:41:33 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-229-majority-element-ii/</guid><description>
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.
题意：给你n个数，要求找出出现此处大于n/3的。。。
思路：之前做过一个找出n个数出现此处大于n/2的题目，思想是“非吾族类，其心必异”。。
这道题类似。。。容易知道题目要求的数最多有2个，最少有0个。。。
由于最多两个“族类”，在更新的时候，要判断是不是友军的人...毕竟朋友妻不可欺嘛（什么鬼
最后记得扫一遍，check一下，检查出现此处是否满足题意。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 20时05分53秒 File Name :229.cpp ************************************************ */ class Solution { public: //出现次数大于int(n/3)的元素，最少有0个，最多有两个 vector&amp;lt;int&amp;gt; majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt;res; int n = nums.size(); if (n==0) return res; int cnt1,cnt2,v1,v2; cnt1 = cnt2 = 0; v1 = v2 = -1; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = nums[i]; // printf(&amp;quot;i:%d nums[i]:%d v1:%d cnt1:%d v2:%d cnt2:%d\n&amp;quot;,i,nums[i],v1,cnt1,v2,cnt2); if (cnt1==0&amp;amp;&amp;amp;v2!</description></item><item><title>leetcode 75. Sort Colors</title><link>https://111qqz.com/2017/04/leetcode-75-sort-colors/</link><pubDate>Thu, 13 Apr 2017 12:02:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-75-sort-colors/</guid><description>
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
题意：一个数组，由0,1,2组成，现在要求升序排列
思路：无脑做法就是计数排序，扫两遍，时间复杂度O(n)，空间复杂度O(1)
如果只扫一遍呢？
一个容易想到的思路是两个指针：
需要注意 的是，交换2后要再次遍历到当前位置，或者说，只有当不交换2的时候，才执行cur++
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 18时24分25秒 File Name :75.cpp ************************************************ */ class Solution { public: //思路：把0往前仍，把2往后仍 void pr(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetcode 11. Container With Most Water (two pointer)</title><link>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</link><pubDate>Thu, 13 Apr 2017 10:13:01 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</guid><description>
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.
题意：n条竖直的线段 (i,0)-&amp;gt;(i,a[i]),从中选2条，和x轴共同组成一个开口的容器，问容器的最大面积。</description></item><item><title>leetcode 16. 3Sum Closest (k-sum问题，two pointer)</title><link>https://111qqz.com/2017/04/leetcode-16-3sum-closest/</link><pubDate>Thu, 13 Apr 2017 09:45:45 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-16-3sum-closest/</guid><description>
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
思路： 排序，然后two pointer,复杂度 O(n^2)
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 16时24分28秒 File Name :16.cpp ************************************************ */ class Solution { public: int n; int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { n = nums.</description></item><item><title>leetcode 18. 4Sum (k-sum问题，two pointer)</title><link>https://111qqz.com/2017/04/leetcode-18-4sum/</link><pubDate>Thu, 13 Apr 2017 09:34:15 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-18-4sum/</guid><description>
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
思路： O(n^2)枚举两个元素，变成2-sum问题，总体复杂度O(n^3)
hash的解法以后补
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 17时24分54秒 File Name :18.cpp ************************************************ */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; int n; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { n = nums.</description></item><item><title>leetcode 15. 3Sum (k-sum问题，two pointer)</title><link>https://111qqz.com/2017/04/leetcode-15-3sum/</link><pubDate>Thu, 13 Apr 2017 08:21:52 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-15-3sum/</guid><description>
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note: The solution set must not contain duplicate triplets.
思路：排序O(nlgn)，然后枚举一个元素O(n),对于每个元素，在剩下的区间中 two pointer O(n)
整体复杂度 O(n^2)。
hash的解法以后补。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 16时07分00秒 File Name :15.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.</description></item><item><title>leetcode 216. Combination Sum III Add to List (枚举子集，限定集合大小，和为定值）</title><link>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list/</link><pubDate>Thu, 13 Apr 2017 07:55:09 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list/</guid><description>
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
题意：1..9个数，从中选择k个，和为n，要求输出所有满足题意的集合。
思路：枚举子集，根据sum和集合元素个数剪枝即可。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时44分56秒 File Name :216.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; int B[1005]; void get_subset(int n,int *B,int cur,int cnt,int k,int sum,int tar) { if (cur==n) { if (cnt!</description></item><item><title>leetcode 77. Combinations (枚举子集，限定集合大小)</title><link>https://111qqz.com/2017/04/leetcode-77-combinations/</link><pubDate>Thu, 13 Apr 2017 07:43:43 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-77-combinations/</guid><description>
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
思路：就是枚举子集，根据集合的大小剪枝。。。最后只要集合大小为k的集合
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时25分37秒 File Name :77.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; int B[1005]; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; void get_subset(int n,int *B,int cur,int cnt,int k) { if (cur==n) { vector&amp;lt;int&amp;gt;tmp; for ( int i = 0 ; i &amp;lt; n ; i++) if (B[i]) tmp.push_back(i+1); if (tmp.</description></item><item><title>leetcode 60. Permutation Sequence (求第k个排列)</title><link>https://111qqz.com/2017/04/leetcode-60-permutation-sequence/</link><pubDate>Thu, 13 Apr 2017 07:24:41 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-60-permutation-sequence/</guid><description>
The set [1,2,3,…,_n_] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):
1. `&amp;quot;123&amp;quot;` 2. `&amp;quot;132&amp;quot;` 3. `&amp;quot;213&amp;quot;` 4. `&amp;quot;231&amp;quot;` 5. `&amp;quot;312&amp;quot;` 6. `&amp;quot;321&amp;quot;` Given n and k, return the _k_th permutation sequence.
Note: Given n will be between 1 and 9 inclusive.
思路：还是根据leetcode 31 解题报告 中的算法搞一下就好了。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时17分19秒 File Name :60.</description></item><item><title>leetcode 47. Permutations II (生成全排列，有重复元素)</title><link>https://111qqz.com/2017/04/leetcode-47-permutations-ii/</link><pubDate>Thu, 13 Apr 2017 07:14:03 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-47-permutations-ii/</guid><description>
Given a collection of numbers that might contain duplicates, return all possible unique permutations.__
思路：和leet code 46 类似，最后用set去个重即可。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时00分48秒 File Name :47.cpp ************************************************ */ class Solution { public: void solve( vector&amp;lt;int&amp;gt;&amp;amp;nums) { int n = nums.size(); if (n==0) return; int k = -1; for ( int i = n-2 ; i &amp;gt;= 0 ; i--) { if (nums[i]&amp;lt;nums[i+1]) { k = i; break; } } if (k==-1) { reverse(nums.</description></item><item><title>leetcode 46. Permutations (生成全排列，无重复元素)</title><link>https://111qqz.com/2017/04/leetcode-46-permutations/</link><pubDate>Thu, 13 Apr 2017 06:59:43 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-46-permutations/</guid><description>
Given a collection of distinct numbers, return all possible permutations.
思路：调用n-1次 leetcode 31 解题报告 中提到的算法即可。。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 14时49分34秒 File Name :46.cpp ************************************************ */ class Solution { public: void solve(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int n = nums.size(); if (n==0) return; int k = -1; for ( int i = n-2 ; i &amp;gt;= 0 ; i--) { if (nums[i]&amp;lt;nums[i+1]) { k = i ; break; } } if (k==-1) { reverse(nums.</description></item><item><title>leetcode 31. Next Permutation (in-place 生成下一个全排列)</title><link>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place/</link><pubDate>Thu, 13 Apr 2017 06:47:55 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place/</guid><description>
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
The replacement must be in-place, do not allocate extra memory.
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1</description></item><item><title>leetcode 33. Search in Rotated Sorted Array (无重复数的旋转数组找定值)</title><link>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array/</link><pubDate>Thu, 13 Apr 2017 06:29:37 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array/</guid><description>
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
思路：找规律。。。二分。。。
0 1 2 3 4 5 6 1 2 3 4 5 6 0 2 3 4 5 6 0 1 3 4 5 6 0 1 2 4 5 6 0 1 2 3 5 6 0 1 2 3 4 6 0 1 2 3 4 5 观察发现。。。a[mid]&amp;lt;a[r]的时候，后半段有序;</description></item><item><title>leetcode 34. Search for a Range (二分，找到一段值为tar的区间)</title><link>https://111qqz.com/2017/04/leetcode-34-search-for-a-range/</link><pubDate>Thu, 13 Apr 2017 05:34:45 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-34-search-for-a-range/</guid><description>
Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm's runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4].
思路：二分。。。
我好像根本不会二分啊？？？
二分查找
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 10时49分02秒 File Name :34.</description></item><item><title>leetcode 39. Combination Sum (dfs，求所有的组合，和为定值，每个数可以重复用)</title><link>https://111qqz.com/2017/04/leetcode-39-combination-sum/</link><pubDate>Thu, 13 Apr 2017 02:47:49 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-39-combination-sum/</guid><description>
Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
The same repeated number may be chosen from C unlimited number of times.
Note:
* All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations. 题意：给n个数，求所有的组合，和为定值，每个数可以重复用)
思路：。。。。一开始用顺着枚举子集的思路。。。发现。。并不好搞。。。？还不如直接dfs...
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 00时06分12秒 File Name :39.</description></item><item><title>leetcode 40. Combination Sum II (枚举子集，和为定值)</title><link>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii/</link><pubDate>Wed, 12 Apr 2017 16:23:29 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii/</guid><description>
* Total Accepted: **106670** * Total Submissions: **329718** * Difficulty: **Medium** * Contributor: **LeetCode** Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
Each number in C may only be used once in the combination.
Note:
* All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations.</description></item><item><title>leetcode 495. Teemo Attacking</title><link>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</link><pubDate>Wed, 12 Apr 2017 16:00:57 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</guid><description>
In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.
You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</description></item><item><title>leetcode 442. Find All Duplicates in an Array（找出出现两次的元素）</title><link>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</link><pubDate>Wed, 12 Apr 2017 15:21:23 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</guid><description>
Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements that appear twice in this array.
Could you do it without extra space and in O(n) runtime?
思路：还是一个映射，如果某个位置要映射的时候已经为负了，就说明之前映射过该位置，那么该位置对应的元素就是出现了两个的元素。
和leetcode 448是一对题目。
/* *********************************************** Author :111qqz Created Time :2017年04月12日 星期三 21时49分11秒 File Name :442.cpp ************************************************ */ class Solution { public: vector&amp;lt;int&amp;gt; findDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt;res; int n = nums.</description></item><item><title>leetcode 48. Rotate Image (旋转方阵(in place))</title><link>https://111qqz.com/2017/04/leetcode-48-rotate-image/</link><pubDate>Wed, 12 Apr 2017 13:22:33 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-48-rotate-image/</guid><description>
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Follow up: Could you do this in-place?
题意：给一个n*n的方阵，要求顺时针旋转90度。
思路：(x,y)-&amp;gt;(y,n-1-x);
要求in-place的做法的话，其实是若干长度为4的环，保护一个节点，然后顺次做就好了。
然后对于那些标记已经做过选旋转的问题，实际上没有必要进行标记。
对于偶数，只需要处理 左上角hf * hf个,奇数只需要处理左上角hf*(hf-1)个。
其中hf = (n+1)/2
1A
1 2 3 (0,0) -&amp;gt;(0,2) 4 5 6 7 8 9 7 4 1 8 5 2 9 6 3 0 1 2 3 0 1 2 3 4 (0,0)-&amp;gt;(0,3) (0,1)-&amp;gt;(1,3) (0,2)-&amp;gt;(2,3) (0,3)-&amp;gt;(3,3) 1 5 6 7 8 (1,1)-&amp;gt;(1,2) (1,2)-&amp;gt;(2,2) (2,2)-&amp;gt;(2,1) 2 9 A B C (1,0)-&amp;gt;(0,2) (2,0)-&amp;gt;(0,1) 3 D E F G //只搞四分之一角落 0 1 2 3 0 D 9 5 1 1 E A 6 2 2 F B 7 3 3 G C 8 4 1 2 3 4 3 1 4 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* *********************************************** Author :111qqz Created Time :2017年04月12日 星期三 19时56分40秒 File Name :48.</description></item><item><title>leetcode 54. Spiral Matrix (矩阵蛇形取数)</title><link>https://111qqz.com/2017/04/leetcode-54-spiral-matrix/</link><pubDate>Tue, 11 Apr 2017 12:07:54 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-54-spiral-matrix/</guid><description>
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
思路：。。。再次让我回想起高一的暑假。。。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时42分05秒 File Name :54.cpp ************************************************ */ class Solution { public: int n,m; //0右，1下，2左，3上 int cal( int &amp;amp;x,int &amp;amp;y,int dir,vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; &amp;amp; vis) { if (dir==0) { if (y&amp;lt;=n-2&amp;amp;&amp;amp;!vis[x][y+1]) y++; else { dir++; x++; } return dir; } if (dir==1) { if (x&amp;lt;=m-2&amp;amp;&amp;amp;!</description></item><item><title>leetcode 55. Jump Game (dp)</title><link>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</link><pubDate>Tue, 11 Apr 2017 11:39:15 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</guid><description>
Given a collection of intervals, merge all overlapping intervals.
For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].
思路:dp[i]表示能否到达位置i...无脑dp即可。。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时33分51秒 File Name :55.cpp ************************************************ */ class Solution { public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if (n==0) return false; vector&amp;lt;int&amp;gt;dp(n,false); dp[0] = true; for ( int i = 0 ; i &amp;lt; n ; i++) { if (dp[i]) { int r = min(i+nums[i],n-1); for ( int j = i+1 ; j &amp;lt;=r ; j++) dp[j] = true; } } return dp[n-1]; } };</description></item><item><title>leetcode 56. Merge Intervals (模拟，求相交区间)</title><link>https://111qqz.com/2017/04/leetcode-56-merge-intervals/</link><pubDate>Tue, 11 Apr 2017 11:30:32 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-56-merge-intervals/</guid><description>
Given a collection of intervals, merge all overlapping intervals.
For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].
思路：扫一遍即可。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时15分30秒 File Name :56.cpp ************************************************ */ /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public: int n; static bool cmp(Interval A,Interval B) { return A.</description></item><item><title>leetocde 59. Spiral Matrix II (模拟)</title><link>https://111qqz.com/2017/04/59-spiral-matrix-ii/</link><pubDate>Tue, 11 Apr 2017 11:07:52 +0000</pubDate><guid>https://111qqz.com/2017/04/59-spiral-matrix-ii/</guid><description>
Given an integer n, generate a square matrix filled with elements from 1 to _n_2 in spiral order.
思路：仿佛回到高一的那个暑假。。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时52分15秒 File Name :59.cpp ************************************************ */ class Solution { public: int ok (int dir, int &amp;amp;x,int &amp;amp;y,int n,vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp;res) // 0右，1下，2左，3上 { if (dir==0) { if (y&amp;lt;=n-2&amp;amp;&amp;amp;res[x][y+1]==0) y++; else { dir++; x++; } return dir; } if (dir==1) { if (x&amp;lt;=n-2&amp;amp;&amp;amp;res[x+1][y]==0) x++; else { dir++; y--; } return dir; } if (dir==2) { if (y&amp;gt;=1&amp;amp;&amp;amp;res[x][y-1]==0) y--; else { dir++; x--; } return dir; } if (dir==3) { if (x&amp;gt;=1&amp;amp;&amp;amp;res[x-1][y]==0) x--; else { dir = 0 ; y++; } return dir; } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n) { vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res(n,vector&amp;lt;int&amp;gt;(n,0)); int dir = 0; int x,y; x = y = 0 ; for ( int i = 0 ; i &amp;lt; n*n ; i++) { res[x][y] = i+1; // printf(&amp;quot; x:%d y: %d\n&amp;quot;,x,y); dir = ok (dir,x,y,n,res); } return res; } };</description></item><item><title>leetocde 63. Unique Paths II</title><link>https://111qqz.com/2017/04/63-unique-paths-ii/</link><pubDate>Tue, 11 Apr 2017 10:50:57 +0000</pubDate><guid>https://111qqz.com/2017/04/63-unique-paths-ii/</guid><description>
Follow up for &amp;quot;Unique Paths&amp;quot;:
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.
[ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2.
题意：从左上到右下的方案数，有些点不能走。
思路：简单dp...1A
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时37分47秒 File Name :63.</description></item><item><title>leetcode 64. Minimum Path Sum (二维dp)</title><link>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum/</link><pubDate>Mon, 10 Apr 2017 02:35:20 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum/</guid><description>
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
数字三角形。。。。从坐上到右下问最短路径。。每次只能向下或者向右。。。
wa了一次。。。是因为边界值赋值成了0.。。求最短路径显然因为赋值成inf才对orz..果然傻了。。
简单的dp我们简单的A.
顺便吐槽一下。。(100,100)的答案会溢出int...然而答案就是负的。。。就没人check一下吗，，，
/* *********************************************** Author :111qqz Created Time :2017年04月10日 星期一 10时11分26秒 File Name :64.cpp ************************************************ */ class Solution { public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int n = grid.</description></item><item><title>leetcode 73. Set Matrix Zeroes (矩阵置0，乱搞)</title><link>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes/</link><pubDate>Mon, 10 Apr 2017 01:16:43 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes/</guid><description>
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.
click to show follow up.
**Follow up:**Did you use extra space? A straight forward solution using O(m__n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?
直接放常数空间的做法。
这道题面hypereal的时候遇到过，基本思路就是用已经确定是0的位置来存储其他行和列的信息。
三点注意：</description></item><item><title>leetcode 238. Product of Array Except Self (乱搞)</title><link>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self/</link><pubDate>Sun, 09 Apr 2017 11:50:05 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self/</guid><description>
Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
Solve it without division and in O(n).
For example, given [1,2,3,4], return [24,12,8,6].
Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.</description></item><item><title>leetcode 79. Word Search (dfs)</title><link>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</link><pubDate>Fri, 07 Apr 2017 06:59:26 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</guid><description>
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;quot;adjacent&amp;quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
思路：dfs即可。记得要回溯一下...
/* *********************************************** Author :111qqz Created Time :2017年04月07日 星期五 14时32分54秒 File Name :79.cpp ************************************************ */ class Solution { public: int n,m; const int dx4[4]={1,-1,0,0}; const int dy4[4]={0,0,-1,1}; bool vis[1005][1005]; int len; bool yes( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;=n-1&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;=m-1) return true; return false; } bool dfs( int x,int y,int cur,vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt; &amp;amp; maze,string &amp;amp; st) { // printf(&amp;quot;x:%d y:%d cur : %d\n&amp;quot;,x,y,cur); if (cur&amp;gt;=len) return true; for ( int i = 0 ; i &amp;lt; 4 ; i++) { int nx = x + dx4[i]; int ny = y + dy4[i]; if (!</description></item><item><title>leetcode 80 Remove Duplicates from Sorted Array II （有序数组去除重复元素）</title><link>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</link><pubDate>Wed, 05 Apr 2017 13:36:44 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</guid><description>
Follow up for &amp;quot;Remove Duplicates&amp;quot;: What if duplicates are allowed at most twice?
For example, Given sorted array nums = [1,1,1,2,2,3],
Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.
Subscribe to see which companies asked this question.
题意：一个有序数组，每个元素最多出现两次，如果大于两次，把多的去掉，返回去掉后的数组长度len，以及要求数组前len是去掉那些元素之后的元素。//语死早。。看原题好了。。
思路：排序了还不是随便搞？ 没要求空间再开一个标记空间。。。O(1)空间的话。。就乱搞一下？
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 21时25分48秒 File Name :80.</description></item><item><title>leetcode 81. Search in Rotated Sorted Array II (有重复元素的旋转数组找给定值)</title><link>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii/</link><pubDate>Wed, 05 Apr 2017 13:17:51 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii/</guid><description>
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Write a function to determine if a given target is in the array.
The array may contain duplicates.
好像阿里一面的时候问过。。。
思路：肯定是二分。。。不过由于有重复元素。。。所以很恶心。。。
总的思路是。。。当发现重复元素。。并且该重复元素不是target的时候。。。缩小范围。。。
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 20时26分25秒 File Name :81.cpp ************************************************ */ class Solution { public: bool search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int siz = nums.</description></item><item><title>leetcode 289. Game of Life (模拟)</title><link>https://111qqz.com/2017/04/leetcode-289-game-of-life/</link><pubDate>Wed, 05 Apr 2017 12:03:28 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-289-game-of-life/</guid><description>
According to the Wikipedia's article: &amp;quot;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;quot;
Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.</description></item><item><title>leetcode 90. Subsets II (枚举子集)</title><link>https://111qqz.com/2017/04/leetcode%2090-subsets-ii/</link><pubDate>Wed, 05 Apr 2017 10:45:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode%2090-subsets-ii/</guid><description>
Given a collection of integers that might contain duplicates, nums, return all possible subsets.
Note: The solution set must not contain duplicate subsets.
For example, If nums = [1,2,2], a solution is:
[ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路：
复习（？）一下 枚举子集的三种写法
（还有种更飘逸的...先不写了orz
这道题我用位向量法A的。。
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 17时15分34秒 File Name :90.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; int B[1005]; vector &amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; void get_subset(int n,int *B,int cur,vector&amp;lt;int&amp;gt;&amp;amp; nums) { // cout&amp;lt;&amp;lt;&amp;quot;cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; if (cur==n) //from 0 { vector&amp;lt;int&amp;gt;tmp; for ( int i = 0 ; i &amp;lt; n ; i++) if (B[i]) tmp.</description></item><item><title>106. Construct Binary Tree from Inorder and Postorder Traversal(根据中序和后序遍历构建二叉树)</title><link>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Wed, 05 Apr 2017 08:59:41 +0000</pubDate><guid>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 16时49分57秒 File Name :106.cpp ************************************************ / /* * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; / class Solution { public: TreeNode buildTree(vector&amp;amp; inorder, vector&amp;amp; postorder) { int siz = inorder.size(); if (siz==0) return NULL; int rt = postorder[siz-1]; int pos = -1; for ( int i = 0 ; i &amp;lt; siz; i++) { if (inorder[i]==rt) { pos = i ; break; } } TreeNode *head = new TreeNode(rt); vectorin,post; for ( int i = 0 ; i &amp;lt; pos ; i++) { in.</description></item><item><title>leetcode 287. Find the Duplicate Number (floyd判圈算法找重复元素)</title><link>https://111qqz.com/2017/04/leetcode-287-find-the-duplicate-number-floyd/</link><pubDate>Wed, 05 Apr 2017 07:31:49 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-287-find-the-duplicate-number-floyd/</guid><description>
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Note:
1. You **must not** modify the array (assume the array is read only). 2. You must use only constant, _O_(1) extra space. 3. Your runtime complexity should be less than `O(n2)`.</description></item><item><title>leetcode 532. K-diff Pairs in an Array （找差为k的数对）</title><link>https://111qqz.com/2017/04/leetcode-532-k-diff-pairs-in-an-array/</link><pubDate>Wed, 05 Apr 2017 06:53:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-532-k-diff-pairs-in-an-array/</guid><description>
Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
Example 1:
Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description></item><item><title>leetcode 448. Find All Numbers Disappeared in an Array(寻找所有消失的元素）</title><link>https://111qqz.com/2017/04/leetcode-448-find-all-numbers-disappeared-in-an-array/</link><pubDate>Wed, 05 Apr 2017 06:19:06 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-448-find-all-numbers-disappeared-in-an-array/</guid><description>
Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1] Output: [5,6] 思路：由于元素大小有限制，是在1..n之间。
这个信息有两个作用。一个是元素都是正数，一个是元素大小（绝对值意义上的）有限。</description></item><item><title>BZOJ 2748: [HAOI2012]音量调节 (dp)</title><link>https://111qqz.com/2017/04/bzoj-2748-haoi2012-dp/</link><pubDate>Sun, 02 Apr 2017 06:50:50 +0000</pubDate><guid>https://111qqz.com/2017/04/bzoj-2748-haoi2012-dp/</guid><description>
2748: [HAOI2012]音量调节 Time Limit: 3 Sec Memory Limit: 128 MB Submit: 1814 Solved: 1148 [Submit][Status][Discuss]
Description 一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都要改变一次音量。在演出开始之前，他已经做好了一个列表，里面写着在每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。 音量用一个整数描述。输入文件中给定整数beginLevel，代表吉他刚开始的音量，以及整数maxLevel，代表吉他的最大音量。音量不能小于0也不能大于maxLevel。输入文件中还给定了n个整数c1,c2,c3…..cn，表示在第i首歌开始之前吉他手想要改变的音量是多少。 吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。
Input 第一行依次为三个整数：n, beginLevel, maxlevel。 第二行依次为n个整数：c1,c2,c3…..cn。
Output 输出演奏最后一首歌的最大音量。如果吉他手无法避免音量低于0或者高于maxLevel，输出-1。
Sample Input 3 5 10 5 3 7
Sample Output 10
HINT 1&amp;lt;=N&amp;lt;=50,1&amp;lt;=Ci&amp;lt;=Maxlevel 1&amp;lt;=maxlevel&amp;lt;=1000
0&amp;lt;=beginlevel&amp;lt;=maxlevel
思路:
一看数据范围...长着一张dp的脸...
dp[i][j]表示经过i次调整后能否达到音量j.
初始化dp[0][beginlevel] = true.
按顺序转移就好了.
复杂度O(n*MAXlevel)
/* *********************************************** Author :111qqz Created Time :2017年04月02日 星期日 14时36分58秒 File Name :code/bzoj/2748.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; bool dp[51][1005]; //dp[i][j]表示经过i次操作,能否达到音量j int n,L,R; int a[1005]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 2257: [Jsoi2009]瓶子和燃料 (裴蜀定理)</title><link>https://111qqz.com/2017/04/bzoj-2257/</link><pubDate>Sun, 02 Apr 2017 06:26:02 +0000</pubDate><guid>https://111qqz.com/2017/04/bzoj-2257/</guid><description>
2257: [Jsoi2009]瓶子和燃料 Time Limit: 10 Sec Memory Limit: 128 MB Submit: 1246 Solved: 756 [Submit][Status][Discuss]
Description jyy就一直想着尽快回地球，可惜他飞船的燃料不够了。 有一天他又去向火星人要燃料，这次火星人答应了，要jyy用飞船上的瓶子来换。jyy 的飞船上共有 N个瓶子(1&amp;lt;=N&amp;lt;=1000) ，经过协商，火星人只要其中的K 个 。 jyy 将 K个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只 在瓶口标注了容量，第i个瓶子的容量为Vi（Vi 为整数，并且满足1&amp;lt;=Vi&amp;lt;=1000000000 ） 。 火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料 库里鼓捣一通，弄出一小点燃料来交差。jyy当然知道他们会来这一手，于是事先了解了火 星人鼓捣的具体内容。火星人在燃料库里只会做如下的3种操作：1、将某个瓶子装满燃料； 2、将某个瓶子中的燃料全部倒回燃料库；3、将燃料从瓶子a倒向瓶子b，直到瓶子b满 或者瓶子a空。燃料倾倒过程中的损耗可以忽略。火星人拿出的燃料，当然是这些操作能 得到的最小正体积。 jyy知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy希望找 到最优的瓶子组合，使得火星人给出尽量多的燃料。
Input 第1行：2个整数N,K， 第2..N 行：每行1个整数，第i+1 行的整数为Vi
Output 仅1行，一个整数，表示火星人给出燃料的最大值。
Sample Input 3 2 3 4 4
Sample Output 4
HINT 选择第2 个瓶子和第 个瓶子，火星人被迫会给出4 体积的容量。
思路:
思路完全错掉了orz...想去贪心来着....
因为自己脑算的例子错掉了...容量3和容量7的瓶子,能得到的最小是1不是2(因为忘了可以从瓶子中倒回燃料库的操作)...
样例一错毁所有orz..
正确的思路是,容量为a,b的两个瓶子能鼓捣出的体积一定是ax+by的形式
根据裴蜀定理,ax+by能得到的最小正数解就是(a,b),也就是gcd(a,b)
由此可以推广到多个瓶子,容量分别为x1,x2,...xn,能得到的最小体积就是gcd(x1,x2..xn)
(能推广的原因还是多说一句吧,假设现在只有两个瓶子x1,x2,称出了gcd(x1,x2),那么其实和只有一个容量为gcd(x1,x2)的瓶子在效果上是等价的)
因为剩下我们要做的就是,统计每个容量的因子统计,找到最大的并且出现此处大于等于k次的...</description></item><item><title>BZOJ 1012: [JSOI2008]最大数maxnumber (线段树,,单点更新)</title><link>https://111qqz.com/2017/04/bzoj-1012/</link><pubDate>Sat, 01 Apr 2017 09:20:48 +0000</pubDate><guid>https://111qqz.com/2017/04/bzoj-1012/</guid><description>
1012: [JSOI2008]最大数maxnumber Time Limit: 3 Sec Memory Limit: 162 MB Submit: 9717 Solved: 4244 [Submit][Status][Discuss]
Description 　现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L 个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加 上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取 模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个 数。
Input 　第一行两个整数，M和D，其中M表示操作的个数(M &amp;lt;= 200,000)，D如上文中所述，满足D在longint内。接下来 M行，查询操作或者插入操作。
Output 　对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。
Sample Input 5 100 A 96 Q 1 A 97 Q 1 Q 2
Sample Output 96 93 96
思路:线段树即可....
只是为了回忆一下..发现线段树还是没有忘记的23333
/* *********************************************** Author :111qqz Created Time :2017年04月01日 星期六 16时37分55秒 File Name :code/bzoj/1012.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int N=2E5+7; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int m,D; int tree[N&amp;lt;&amp;lt;2]; //树最大为M个节点.</description></item><item><title>hihocoder 1197 Give My Text Back (模拟)</title><link>https://111qqz.com/2017/03/hihocoder-1197/</link><pubDate>Fri, 31 Mar 2017 08:36:23 +0000</pubDate><guid>https://111qqz.com/2017/03/hihocoder-1197/</guid><description>
#1197 : Give My Text Back 时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述 To prepare for the English exam Little Ho collected many digital reading materials. Unfortunately the materials are messed up by a malware.
It is known that the original text contains only English letters (a-zA-Z), spaces, commas, periods and newlines, conforming to the following format:
Each sentence contains at least one word, begins with a letter and ends with a period.</description></item><item><title>..........呜呜呜</title><link>https://111qqz.com/2017/03/cry/</link><pubDate>Fri, 31 Mar 2017 07:45:10 +0000</pubDate><guid>https://111qqz.com/2017/03/cry/</guid><description>
....拿到offer结果被人同情得问...&amp;quot;你怎么这么惨&amp;quot;...还不止被一个人这样说.........
......不找实习打算去考研吧结果被说&amp;quot;你基础辣么差,去考研好亏哦&amp;quot;....
窝能怎么办,窝也很绝望啊....</description></item><item><title>今日头条2017秋招笔试_1</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-04/</link><pubDate>Thu, 30 Mar 2017 05:53:33 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-04/</guid><description>
头条校招（今日头条2017秋招真题）
题目描述 头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队。每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来。在选题之前，我们对题目进行了盲审，并定出了每道题的难度系数。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a, b, c，我们希望这3道题能满足下列条件：
a＜= b＜= c b - a＜= 10 c - b＜= 10
所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求。然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？
输入输入的第一行包含一个整数n，表示目前已经出好的题目数量。
第二行给出每道题目的难度系数 d1, d2, …, dn。
样例输入4
20 35 23 40
输出输出只包括一行，即所求的答案。
样例输出2
时间限制C/C++语言：1000MS其它语言：3000MS
内存限制C/C++语言：65536KB其它语言：589824K
div2 A的难度...直接贪就好,不给数据范围的都是耍流氓...
/* *********************************************** Author :111qqz Created Time :2017年03月30日 星期四 12时55分21秒 File Name :code/toutiao/1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; vector&amp;lt;int&amp;gt;vec; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>今日头条笔试题_或与加(打表,构造)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-03/</link><pubDate>Thu, 30 Mar 2017 03:04:06 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-03/</guid><description>
给定 x, k ，求满足 x + y = x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。
比如当 x=5，k=1时返回 2，因为5+1=6 不等于 5|1=5，而 5+2=7 等于 5 | 2 = 7。
输入描述: 每组测试用例仅包含一组数据，每组数据为两个正整数 x , k。 满足 0 &amp;lt; x , k ≤ 2,000,000,000。
输出描述: 输出一个数y。
输入例子: 5 1 输出例子: 达标2 一看就是数学题...? 打表观察...
1 0000001 2 0000010 3 0000011 4 0000100 5 0000101 6 0000110 7 0000111 8 0001000 9 0001001 10 0001010 11 0001011 12 0001100 13 0001101 14 0001110 15 0001111 16 0010000 17 0010001 18 0010010 19 0010011 20 0010100 21 0010101 22 0010110 23 0010111 24 0011000 25 0011001 26 0011010 27 0011011 28 0011100 29 0011101 30 0011110 31 0011111 32 0100000 33 0100001 34 0100010 35 0100011 36 0100100 37 0100101 38 0100110 39 0100111 40 0101000 41 0101001 42 0101010 43 0101011 44 0101100 45 0101101 46 0101110 47 0101111 48 0110000 49 0110001 50 0110010 51 0110011 52 0110100 53 0110101 54 0110110 55 0110111 56 0111000 57 0111001 58 0111010 59 0111011 60 0111100 61 0111101 62 0111110 63 0111111 64 1000000 65 1000001 66 1000010 67 1000011 68 1000100 69 1000101 70 1000110 71 1000111 72 1001000 73 1001001 74 1001010 75 1001011 76 1001100 77 1001101 78 1001110 79 1001111 80 1010000 81 1010001 82 1010010 83 1010011 84 1010100 85 1010101 86 1010110 87 1010111 88 1011000 89 1011001 90 1011010 91 1011011 92 1011100 93 1011101 94 1011110 95 1011111 96 1100000 97 1100001 98 1100010 99 1100011 100 1100100 发现如果x的二进制表示中,如果某位为1,那么对应的y的位置上一定为0.</description></item><item><title>今日头条笔试题-木棒拼图(数学)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-02/</link><pubDate>Wed, 29 Mar 2017 13:27:24 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-02/</guid><description>
有一个由很多木棒构成的集合，每个木棒有对应的长度，请问能否用集合中的这些木棒以某个顺序首尾相连构成一个面积大于 0 的简单多边形且所有木棒都要用上，简单多边形即不会自交的多边形。
初始集合是空的，有两种操作，要么给集合添加一个长度为 L 的木棒，要么删去集合中已经有的某个木棒。每次操作结束后你都需要告知是否能用集合中的这些木棒构成一个简单多边形。
输入描述: 每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n 表示操作的数量(1 ≤ n ≤ 50000) ， 接下来有n行，每行第一个整数为操作类型 i (i ∈ {1,2})，第二个整数为一个长度 L(1 ≤ L ≤ 1,000,000,000)。如果 i=1 代表在集合内插入一个长度为 L 的木棒，如果 i=2 代表删去在集合内的一根长度为 L 的木棒。输入数据保证删除时集合中必定存在长度为 L 的木棒，且任意操作后集合都是非空的。
输出描述: 对于每一次操作结束有一次输出，如果集合内的木棒可以构成简单多边形，输出 &amp;quot;Yes&amp;quot; ，否则输出 &amp;quot;No&amp;quot;。
输入例子: 5 1 1 1 1 1 1 2 1 1 2 输出例子: No No Yes No No 能组成n边形的条件可以由三角形推广而来..(虽然只是猜想... 也就是n-1条较小边的和大于最大边...事实证明这结论是对的orz.. 然后就是multiset就好...
/* *********************************************** Author :111qqz Created Time :2017年03月29日 星期三 21时17分02秒 File Name :code/toutiao2.</description></item><item><title>今日头条笔试题-最大映射(贪心)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-01/</link><pubDate>Wed, 29 Mar 2017 12:47:29 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-01/</guid><description>
有 n 个字符串，每个字符串都是由 A-J 的大写字符构成。现在你将每个字符映射为一个 0-9 的数字，不同字符映射为不同的数字。这样每个字符串就可以看做一个整数，唯一的要求是这些整数必须是正整数且它们的字符串不能有前导零。现在问你怎样映射字符才能使得这些字符串表示的整数之和最大？ 输入描述:每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n ， 接下来有 n 行，每行一个长度不超过 12 且仅包含大写字母 A-J 的字符串。 n 不大于 50，且至少存在一个字符不是任何字符串的首字母。 输出描述:输出一个数，表示最大和是多少。 输入例子: 2 ABC BCA 输出例子: 1875 一开始看漏了首位不能映射到0的条件...直接贪了..结果发现不太对...
哦贪心的方法就是算每个字母的权值和...用pair 搞一下...
处理的办法是如果10个字母都出现,那么先把没有在首位出现过的字母中权重最小的那个映射到0,再搞剩下的...
一个trick是...map映射到0..和某个key没有被映射过..产生了二义性....
窝的做法就是整体+1,最后再减回来..
然后因为某处手残卡了1个小时...???.
哎我果然是个废k了.....傻逼贪心都写不对QAQ
/* *********************************************** Author :111qqz Created Time :2017年03月29日 星期三 16时28分18秒 File Name :toutiao1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n; string st[N]; pair &amp;lt;long long ,int &amp;gt; cnt[20]; LL ten[25]; map&amp;lt;char,int&amp;gt;mp; set&amp;lt;char&amp;gt;Nhead; bool head[25]; set&amp;lt;char&amp;gt;all; set&amp;lt;char&amp;gt;used; set&amp;lt; pair &amp;lt;long long ,char&amp;gt; &amp;gt; se; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>murmurhash源码分析</title><link>https://111qqz.com/2017/03/reading-murmurhash-code/</link><pubDate>Wed, 22 Mar 2017 12:20:37 +0000</pubDate><guid>https://111qqz.com/2017/03/reading-murmurhash-code/</guid><description>
分析levelDB源码的时候遇到的...发现是一个广泛应用的hash算法，而且是纯c写的，于是找来了源码看。
**MurmurHash** 是一种非[加密](https://zh.wikipedia.org/wiki/)型[哈希函数](https://zh.wikipedia.org/wiki/)，适用于一般的哈希检索操作。[[1]](https://zh.wikipedia.org/wiki/Murmur#cite_note-Hadoop-1)[[2]](https://zh.wikipedia.org/wiki/Murmur#cite_note-2)[[3]](https://zh.wikipedia.org/wiki/Murmur#cite_note-3)由Austin Appleby在2008年发明，[[4]](https://zh.wikipedia.org/wiki/Murmur#cite_note-4)[[5]](https://zh.wikipedia.org/wiki/Murmur#cite_note-5) 并出现了多个变种，[[6]](https://zh.wikipedia.org/wiki/Murmur#cite_note-Murmur160-6) 都已经发布到了[公有领域](https://zh.wikipedia.org/wiki/)(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。[[7]](https://zh.wikipedia.org/wiki/Murmur#cite_note-StackExchange-7) 最初的实现是C++的，但是被移植到了其他的流行语言上，包括 Python,[11]C,[12]C#,[9][13]Perl,[14]Ruby,[15]PHP,[16]Haskell,[17]、Scala[18]、Java[19][20]和JavaScript[21][22]等。
这个算法已经被若干开源计划所采纳，最重要的有libstdc++ (4.6版)、Perl[23]、nginx (不早于1.0.1版)[24]、Rubinius[25]、 libmemcached (Memcached的C语言客户端驱动)[26]、maatkit[27]、Hadoop[1]、Kyoto Cabinet[28]以及RaptorDB[29]。
虽然说破天就是一个hash函数。。似乎没什么好分析的？
不过由于是第一次分析有现实意义的代码，所以简单一点也不是罪过吧orz
以及这次分析代码的重点不在hash算法本身...而是算法之外的其他东西...
大概感受下有现实意义的工程代码的布局之类orz
hash函数本身没有分析...这个没什么好分析的吧...应该是类似一种构造，看懂每一步很容易，但是你还是想不出来啊？而且一堆&amp;quot;magic number&amp;quot;
代码很短，也就200行,分析见注释。
/** * `main.c' - murmurhash * * copyright (c) 2014 joseph werle &amp;lt;joseph.werle@gmail.com&amp;gt; */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;inttypes.h&amp;gt; #include &amp;quot;murmurhash.h&amp;quot; static void usage () { fprintf(stderr, &amp;quot;usage: murmur [-hV] [options]\n&amp;quot;); } static void //函数类型和函数名不一行写是什么风格orz... help () { fprintf(stderr, &amp;quot;\noptions:\n&amp;quot;); fprintf(stderr, &amp;quot;\n --seed=[seed] hash seed (optional)&amp;quot;); fprintf(stderr, &amp;quot;\n&amp;quot;); } static char * read_stdin () { size_t bsize = 1024; size_t size = 1; char buf[bsize]; char *res = (char *) malloc(sizeof(char) * bsize); char *tmp = NULL; // memory issue if (NULL == res) { return NULL; } //申请内存失败了.</description></item><item><title>内存屏障（Memory Barriers）</title><link>https://111qqz.com/2017/03/memory-barriers/</link><pubDate>Wed, 22 Mar 2017 05:16:53 +0000</pubDate><guid>https://111qqz.com/2017/03/memory-barriers/</guid><description>
起因是最近在看levelDB源码，其中port里的atomic_pointer.h文件用到了内存屏障。。
于是来学习一下。。
粗略得说下我自己的理解。
代码的顺序并不和执行的顺序完全对应，出于对效率的追求，cpu和编译器会对一些顺序指令重排，以期得到最大的执行效率。
比如下面这段代码：
// example 2 // void *ptr, v, _store; v = ptr; _store = v; somefunc(); v = _store; v的值是没有改变的，那么编译器可能会认为_store = v; v = _store; 是多余的，就直接把这一段给“优化”掉了。这段代码在单线程中确实是多余的，但是在多线程环境下，可能在somefunc()被调用的时候，另一个线程把v的值给改变了，而这种情况是编译器无法发现的。因此，为了避免这种情况。。。内存屏障登场！
摘自维基百科：
**内存屏障**，也称**内存栅栏**，**内存栅障**，**屏障指令**等，是一类[同步屏障](https://zh.wikipedia.org/wiki/)指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。 大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。
语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。
在多线程环境里需要使用某种技术来使程序结果尽快可见。。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为**内存屏障或内存栅栏**。 再看一个例子
// get start time for (int i = 0; i != 100000; i++) { MemoryBarrier() } // get end time 这段代码，是想知道for循环空转100000次的耗时，这里就需要加入一个MemoryBarrier，如果不加，那么编译器可能就会直接把这个无意义的for循环直接优化掉了。
除了编译器，cpu由于指令流水线或者超流水线等计数，也可能导致出现乱序执行的情况。
内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。
不过内存平展由于阻碍了cpu和编译器的部分优化。。。因此对性能的影响是不忽略的。
为了达到最佳性能，最好是把要解决的问题模块化，这样处理器可以按单元执行任务，然后在任务单元的边界放上所有需要的内存屏障。采用这个方法可以让处理器不受限的执行一个任务单元。合理的内存屏障组合还有一个好处是：缓冲区在第一次被刷后开销会减少，因为再填充改缓冲区不需要额外工作了。 内存屏障的实现不同平台差别很大。。。因为我们可以看到atomic_pointer.h文件中 一堆和平台相关的条件编译...
// Copyright (c) 2011 The LevelDB Authors.</description></item><item><title>Lock-free vs wait-free concurrency</title><link>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</link><pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate><guid>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</guid><description>
参考资料
看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？
There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free, and wait-free. Their meaning is often confused. In lock-free systems, while any particular computation may be blocked for some period of time, all CPUs are able to continue performing other computations. To put it differently, while a given thread might be blocked by other threads in a lock-free system, all CPUs can continue doing other useful work without stalls.</description></item><item><title>AWK 初探</title><link>https://111qqz.com/2017/03/awk-/</link><pubDate>Sun, 19 Mar 2017 10:02:58 +0000</pubDate><guid>https://111qqz.com/2017/03/awk-/</guid><description>
参考资料：
awk_维基百科
awk简明教程
awk是一门比较古老但是很好用的文本处理工具（语言?）
语法还是很好懂的。。。转载了一篇文章。。。算是简明手册？ 不过台词有点糟糕orz
有一些网友看了前两天的《[Linux下应该知道的技巧](http://coolshell.cn/articles/8883.html)》希望我能教教他们用awk和sed，所以，出现了这篇文章。我估计这些80后的年轻朋友可能对awk/sed这类上古神器有点陌生了，所以需要我这个老家伙来炒炒冷饭。**况且，AWK是贝尔实验室1977年搞出来的文本出现神器，今年是蛇年，是AWK的本命年，而且年纪和我相仿，所以非常有必要为他写篇文章**。 之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《The AWK Programming Language》，它在豆瓣上的评分是9.4分！在亚马逊上居然卖1022.30元。
我在这里的教程并不想面面俱到，本文和我之前的Go语言简介一样，全是示例，基本无废话。
我只想达到两个目的：
1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。
2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。
废话少说，我们开始脱吧（注：这里只是topless）。
起步上台 我从netstat命令中提取了如下信息作为用例：
$ cat netstat.txt Proto Recv-Q Send-Q Local-Address Foreign-Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN tcp 0 0 coolshell.cn:80 124.205.5.146:18245 TIME_WAIT tcp 0 0 coolshell.cn:80 61.140.101.185:37538 FIN_WAIT2 tcp 0 0 coolshell.</description></item><item><title>C++ const 用法总结（转载）</title><link>https://111qqz.com/2017/03/cpp-const/</link><pubDate>Sat, 18 Mar 2017 12:22:32 +0000</pubDate><guid>https://111qqz.com/2017/03/cpp-const/</guid><description>
基本全文照搬了：关于C++ const 的全面总结
总结全面还是要一点时间的orz..感谢原作者，暂时没发现有什么错误（?
其中对我而言比较陌生的是“const修饰成员函数”的用法。。已经加粗。
 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。 Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。
一、Const作用
** **如下表所示：
**No.** **作用** **说明** **参考代码** 1 可以定义const常量 const int Max = 100; 2 便于进行类型检查 const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误 void f(const int i) { .........} //对传入的参数进行类型检查，不匹配进行提示
3 可以保护被修饰的东西 防止意外的修改，增强程序的健壮性。 void f(const int i) { i=10;//error!</description></item><item><title>京东实习面试总结</title><link>https://111qqz.com/2017/03/jd-intern-interview/</link><pubDate>Sat, 18 Mar 2017 08:01:49 +0000</pubDate><guid>https://111qqz.com/2017/03/jd-intern-interview/</guid><description>
印象中是并没有看到jd，只是要求熟悉算法和数据结构+C艹...于是当时扔了份简历过去。
然后立刻就接到了一个电话，大概问了下一些基本情况。。以及。。你为什么不考研。。。
然后说之后会安排面试。。就杳无音信了。。然后突然有一天周末晚上11点接到短信说要安排面试orz...
【一面】 一面先是手写代码...都是面试套路题，就不说了...
哦其中一道题给出了优于面试官手中正解复杂度(nlgn）的复杂度的做法...
因为我说完我的做法给出了一点正确性的证明以后听他说了句“哦这题原来可以O(n)啊”
然后问了一点cpp基础。。。不记得问什么了。。反正也都很简单？
之后问了两个智力题吧。。。其中一个是7g+9g砝码称140g中的50g的问题...当时的确想了一下。。
再之后。。。开始问机器学习。。。。
这个时候我才意识到。。。这大概是算法岗啊。。。orz
然后我就全程装死。。。直言说不会orz...
然后面试官说，那我问问你微积分和概率论吧。。。。
我继续装死...
然后就结束了...结束的时候问了面试官有什么建议
他说。。建议我。。去读研。。。。。。去读研。。。。
心想一定gg了。。。于是就忘了这事。。。
【二面】 然后10天以后。。竟然接到电话。。自称是二面面试官。。。
还说看到一面面试官对我评价很高。。。
我：喵喵喵喵喵？
然后我当时直接就问了一句：但是我机器学习基本不会，怎么会评价高呢。。。。
面试官说：放心我不会问你这些。。。
之后约了面试，还是手写代码...
先是考了个尺取。。忘记题目了。。反正是那种被考烂的题。。。
然后第二个问题是手写快排。。。问了下快排相关的问题。。。
第三个问题是让我设计一个高效算法。。查询区间最大值。。。。。
我问查询次数多吗。。他说很多。。。我说可以用st表的rmq来做。。。
他说对，然后让我手写一下rmq的初始化函数...
再之后，问了一个top k问题...还好之前看群里的人讨论过orz...
最后一个问题问了蓄水池抽样...orz...
之前没看过这个算法，没有回答出来。。
第二天有一个貌似是部门负责人的人告诉我二面通过了。。。评价很高（我：？？？？？）
说是可能还会有个HR面。。。让我保持联系。。。
【HR面】 不知道能不能称之为HR面。。。感觉就是HR姐姐确认一些问题？
先是问我。。你一个武汉的学生。。。怎么想到北京来了呢。。。
之后问了。。。以后的打算啊。。。有没有拿到其他offer啊。。。
然后确认了下薪资问题。。。。
说是offer流程要一周左右。。。让我耐心等待。。
然后果然等了快一周2333
【总结】 其实接到二面通知的时候，jd是我当时面过的几家里面的最差的一家了（害怕。。。这里最差显然是说我很多没答上来的意思好么2333。。。京东很强啊orz...不要误会啊QAQ）....能接到二面也是很神奇...想了想也只可能那个复杂度O(n)的解法起了作用吧2333</description></item><item><title>2017年3月更新archlinux后没有声音问题的解决办法</title><link>https://111qqz.com/2017/03/20173archlinux/</link><pubDate>Thu, 16 Mar 2017 06:37:25 +0000</pubDate><guid>https://111qqz.com/2017/03/20173archlinux/</guid><description>
系统信息：
表现为不管外放还是耳机。。都没有声音。。。
解决办法：
pacmd set-card-profile alsa_card.pci-0000_00_1b.0 output:analog-stereo+input:analog-stereo 参考资料</description></item><item><title>一致性哈希初探</title><link>https://111qqz.com/2017/03/overview-of-Consistent-Hashing/</link><pubDate>Wed, 15 Mar 2017 07:58:05 +0000</pubDate><guid>https://111qqz.com/2017/03/overview-of-Consistent-Hashing/</guid><description>
原始论文：一致性哈希
本来不打算放的。。被批评说太不严谨orz..
说说自己的理解好了。。
大概就是。。。hash的时候。。一开始有n个桶。。你设计的函数是y=x%n...看起来美滋滋。。。
然后这时候突然一个桶不见了。。。如果按照之前设计的hash函数。。就变成了x%(n-1)...
这可能会造成大量的数据改变自己之前所在的桶。。。这是不可接受的。。。
或者是。。。当前的桶不够用了。。要增加一个桶。。。变成了x%(n+1)。。。也会出现类似情况。。。
我们的目的就是设计一种算法。。。使得当减少一个桶或者增加一个桶的时候。。。。变化尽可能小。。。
并且希望以后新放入的数据尽可能到新的桶中（？
桶是简化的模型。。。实际应用上。。。一致性哈希主要用在分布式系统中。。。每个桶就相当于一台服务器（？or something...不是很懂分布式的术语）
一致性哈希算法 tencent2012笔试题附加题
问题描述： 例如手机朋友网有n个服务器，为了方便用户的访问会在服务器上缓存数据，因此用户每次访问的时候最好能保持同一台服务器。
已有的做法是根据ServerIPIndex[QQNUM%n]得到请求的服务器，这种方法很方便将用户分到不同的服务器上去。但是如果一台服务器死掉了，那么n就变为了n-1，那么ServerIPIndex[QQNUM%n]与ServerIPIndex[QQNUM%（n-1）]基本上都不一样了，所以大多数用户的请求都会转到其他服务器，这样会发生大量访问错误。
问： 如何改进或者换一种方法，使得：
(1) 一台服务器死掉后，不会造成大面积的访问错误，
(2)原有的访问基本还是停留在同一台服务器上；
(3)尽量考虑负载均衡。（思路：往分布式一致哈希算法方面考虑。）
1. 最土的办法还是用模余方法：做法很简单，假设有N台服务器，现在完好的是M（M&amp;lt;=N),先用N求模，如果不落在完好的机器上，然后再用N-1求模，直到M.这种方式对于坏的机器不多的情况下，具有更好的稳定性。 2. 一致性哈希算法。 下面，本文剩下部分重点来讲讲这个一致性哈希算法。
应用场景 在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括： 轮循算法（Round Robin）、哈希算法（HASH）、最少连接算法（Least Connection）、响应速度算法（Response Time）、加权法（Weighted ）等。其中哈希算法是最为常用的算法.
典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。
常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？
在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。
Consistent Hashing算法描述 下面以Memcached中的Consisten Hashing算法为例说明。
consistent hashing 算法早在 1997 年就在论文 Consistent hashing and random trees 中被提出，目前在 cache 系统中应用越来越广泛；</description></item><item><title>Linux 下各个目录的作用及内容</title><link>https://111qqz.com/2017/03/common-linux-files/</link><pubDate>Wed, 15 Mar 2017 06:29:36 +0000</pubDate><guid>https://111qqz.com/2017/03/common-linux-files/</guid><description>
参考：[wiki_FHS](http://Filesystem Hierarchy Standard)
其实这东西。。。虽然有一个统一的标准。。。但是不同发行版。。。或者同一个发行版的不同版本。。。差异貌似都蛮大的。。。所以只是理论上各个目录的作用。。。可能和具体的发行版不符。。。
Linux 目录 在 Linux 下，我们看到的是文件夹（目录）： 在早期的 UNIX 系统中，各个厂家各自定义了自己的 UNIX 系统文件目录，比较混乱。Linux 面世不久后，对文件目录进行了标准化，于1994年对根文件目录做了统一的规范，推出 FHS ( Filesystem Hierarchy Standard ) 的 Linux 文件系统层次结构标准。FHS 标准规定了 Linux 根目录各文件夹的名称及作用，统一了Linux界命名混乱的局面。
无论何种版本的 Linux 发行版，桌面、应用是 Linux 的外衣，文件组织、目录结构才是Linux的内心。
FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。 FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。
第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。
FHS 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会维持更新，FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示：
/：根目录，一般根目录下只存放目录，不要存放件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中
/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</description></item><item><title>压缩算法初探（科普向，转载）</title><link>https://111qqz.com/2017/03/Overview-of-Compression-Algorithms/</link><pubDate>Wed, 15 Mar 2017 02:55:56 +0000</pubDate><guid>https://111qqz.com/2017/03/Overview-of-Compression-Algorithms/</guid><description>
参考链接
简要概述原理： 每个文件都由各种不同代码组成，比如01代码。这类文件只有数字0与1组合。 压缩原理就是 【通过寻找其中的规律，简化数字的排列】。 比如 00000110001111111111 可以简化成 5个0,2个1,3个0,10个1的排列 100000000000 可以简化成数学的 10^10
至于@yskin 说 没见过2G压缩到十几兆的。 实际上在极限压缩方式下其实28.1G压到25.8M都可以。 &amp;lt;img src=&amp;quot;https://pic1.zhimg.com/893534a767ddb047cc04dd66e2a43900_b.jpg&amp;quot; data-rawwidth=&amp;quot;773&amp;quot; data-rawheight=&amp;quot;235&amp;quot; class=&amp;quot;origin_image zh-lightbox-thumb&amp;quot; width=&amp;quot;773&amp;quot; data-original=&amp;quot;https://pic1.zhimg.com/893534a767ddb047cc04dd66e2a43900_r.jpg&amp;quot;&amp;gt;附下载 附下载 2^31-1 [AviSynth 16x16 60.000fps AVC-Lossless-yuv420p8]__
打开看后基本都能理解这个压缩的大概原理了。
下面是几种常见文件压缩算法原理介绍：
字典算法
字典算法是最为简单的压缩算法之一。它是把文本中出现频率比较多的单词或词汇组合做成一个对应的字典列表，并用特殊代码来表示这个单词或词汇。例如： 有字典列表： 00=Chinese 01=People 02=China 源文本：I am a Chinese people,I am from China 压缩后的编码为：I am a 00 01,I am from 02。压缩编码后的长度显著缩小，这样的编码在SLG游戏等专有名词比较多的游戏中比较容易出现，比如《SD高达》。 固定位长算法（Fixed Bit Length Packing）
这种算法是把文本用需要的最少的位来进行压缩编码。 比 如八个十六进制数：1，2，3，4，5，6，7，8。转换为二进制为：00000001，00000010，00000011，00000100， 00000101，00000110，00000111，00001000。每个数只用到了低4位，而高4位没有用到（全为0），因此对低4位进行压缩编 码后得到：0001，0010，0011，0100，0101，0110，0111，1000。然后补充为字节得到：00010010， 00110100，01010110，01111000。所以原来的八个十六进制数缩短了一半，得到4个十六进制数：12，34，56，78。 这也是比较常见的压缩算法之一。 RLE（Run Length Encoding）
是一个针对无损压缩的非常简单的算法。它用重复字节和重复的次数来简单描述来代替重复的字节。尽管简单并且对于通常的压缩非常低效，但它有的时候却非常有用（例如，JPEG就使用它）。 &amp;lt;img src=&amp;quot;https://pic3.</description></item><item><title>缓存淘汰算法之LRU（转载）</title><link>https://111qqz.com/2017/03/lru/</link><pubDate>Wed, 15 Mar 2017 00:34:50 +0000</pubDate><guid>https://111qqz.com/2017/03/lru/</guid><description>
参考博客
计组块忘光了呜呜呜。。。来复习一波。。
1. LRU 1.1. 原理
LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。
1.2. 实现 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：
1. 新数据插入到链表头部；
2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3. 当链表满的时候，将链表尾部的数据丢弃。
1.3. 分析 【命中率】
当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。
【复杂度】
实现简单。
【代价】
命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。
2. LRU-K 2.1. 原理 LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。
2.2. 实现 相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：
1. 数据第一次被访问，加入到访问历史列表；
2. 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；
3. 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；
4. 缓存数据队列中被再次访问后，重新排序；
5. 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。
LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。
2.3. 分析 【命中率】
LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。
【复杂度】
LRU-K队列是一个优先级队列，算法复杂度和代价比较高。
【代价】
由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。
LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。
3. Two queues（2Q） 3.1. 原理 Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。
3.2. 实现 当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：
1. 新访问的数据插入到FIFO队列；
2. 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</description></item><item><title>阿里面试算法题（转载）</title><link>https://111qqz.com/2017/03/</link><pubDate>Tue, 14 Mar 2017 06:28:42 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
I want to match those five numbers 3, 7, 8, 9, 87 through regular express.
Here is my thought: - match those four numbers `3 7 8 9` var `^[3|7|8|9]$` - match number `87` var `^87$` Then combine them together, `(^[3|7|8|9]$|^87$)`. With some test, it seems correct. Is there any way to do that more efficiently? ------------------------------- Q: 已知三个升序整数数组a[l], b[m]和c[n]。请在三个数组中各找一个元素，是的组成的三元组距离最小。 三元组的距离定义是：假设a[i]、b[j]和c[k]是一个三元组，那么距离为: Distance = max(|a[i] – b[j]|, |a[i] – c[k]|, |b[j] – c[k]|) 请设计一个求最小三元组距离的最优算法，并分析时间复杂度。 用三个指针分别指向a,b,c中最小的数，计算一次他们最大距离的Distance ，然后在移动三个数中较小的数组指针， 再计算一次，每次移动一个，直到其中一个数组结束为止，最慢(l+ m + n)次，复杂度为O(l+ m + n) --------------------------------------------------------------------------------------------------------------------- Q:设计一个最优算法来查找一n个元素数组中的最大值和最小值。 已知一种需要比较2n次的方法，请给一个更优的算法。情特别注意优化时间复杂度的常数。 把数组两两一对分组，如果数组元素个数为奇数，就最后单独分一个，然后分别对每一组的两个数比较， 把小的放在左边，大的放在右边，这样遍历下来，总共比较的次数是 N/2 次；在前面分组的基础上，那么可以得到结论， 最小值一定在每一组的左边部分找，最大值一定在数组的右边部分找，最大值和最小值的查找分别需要比较N/2 次和N/2 次； 这样就可以找到最大值和最小值了，比较的次数为 N/2 * 3 = (3N)/2 次 --------------------------------------------------------------------------------------------------------------------- Q:有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。 从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？ 用一个栈 从左向右处理数据 1)遇到向右的鱼，压栈； 2)遇到向左的鱼，若栈空，结果+1；否则，将该鱼和栈顶比较，若栈顶鱼较大，则该鱼被吃掉，栈不变，处理下一个数据； 若栈顶鱼小，则弹出栈顶，继续与下一个比较，直到遇到较大的鱼，该鱼被吃掉；或者栈里鱼都比该鱼小，栈清空，结果+1 3)加上最终栈中鱼的数目 -------------------------------------------------------------------------------------------------------------------- Q: Taxicab numbers.</description></item><item><title>大数据top K 问题总结（转载）</title><link>https://111qqz.com/2017/03/top-k-problems/</link><pubDate>Tue, 14 Mar 2017 06:21:24 +0000</pubDate><guid>https://111qqz.com/2017/03/top-k-problems/</guid><description>
转自：http://blog.csdn.net/v_july_v/article/details/6279498
第一部分、十道海量数据处理面试题
1、海量日志数据，提取出某日访问百度次数最多的那个IP。
首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。
或者如下阐述（雪域之鹰）： 算法思想：分而治之+Hash
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)24值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；
**2、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。 ** 假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。
典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。
文中，给出的最终算法是： 第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）； 第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。
或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
方案：顺序读文件中，对于每个词x，取hash(x)00，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。
如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。
还是典型的TOP K算法，解决方案如下： 方案1： 顺序读取10个文件，按照hash(query)的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。
对这10个文件进行归并排序（内排序与外排序相结合）。
方案2： 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。
方案3： 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
遍历文件a，对每个url求取hash(url)00，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。
遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。
方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。
Bloom filter日后会在本BLOG内详细阐述。 6、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。
方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。
方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。 7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法： **方案1：**oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。
dizengrong： **方案2：**这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。
然后将这40亿个数分成两类: 1.</description></item><item><title>O(1)得到最小值的栈</title><link>https://111qqz.com/2017/03/o1/</link><pubDate>Sun, 12 Mar 2017 14:12:08 +0000</pubDate><guid>https://111qqz.com/2017/03/o1/</guid><description>
题意：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数，要求时间复杂度为O(1)
思路：标题党去死一死好么。。。真是无趣。。。就是用两个栈封装成一个。。。一个栈s1正常搞。。。一个是辅助栈s2。。每次去存min(value,s2.top());
。。。我还以为什么黑科技。。。
class Solution { public: stack&amp;lt;int&amp;gt;s1,s2; void push(int value) { s1.push(value); if (s2.empty()||value&amp;lt;s2.top()) s2.push(value); else s2.push(s2.top()); } void pop() { s1.pop(); s2.pop(); } int top() { return s1.top(); } int min() { return s2.top(); } };</description></item><item><title>求旋转数组最小值（二分）</title><link>https://111qqz.com/2017/03/</link><pubDate>Sun, 12 Mar 2017 13:19:16 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
题意：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
思路：二分。。。注意有重复元素。。。
class Solution { public: int minNumberInRotateArray(vector&amp;lt;int&amp;gt; a) { int siz = a.size(); int l = 0 ; int r = siz-1; while (r-l&amp;gt;1) { int mid = (l+r)&amp;gt;&amp;gt;1; if (a[mid]&amp;gt;a[r]) l = mid; else r = mid; } return min(a[l],a[r]); } };</description></item><item><title>预言向：大概还是要再打一年的</title><link>https://111qqz.com/2017/03/I-love-icpc-forever/</link><pubDate>Sat, 11 Mar 2017 19:36:57 +0000</pubDate><guid>https://111qqz.com/2017/03/I-love-icpc-forever/</guid><description>
虽然说感觉这届学弟蛮厉害...不知道能不能拿到校内资格。。。
以及没有太多时间训练...
不过只要假期实习的地方。。。加班不是很多的话。。。
大概。。。晚上+周末。。。还是可以补补多校的。。。？
其实有的时候。。。只是自以为自己不在意了。。。
到真正重要的时候。。。便会毫不犹豫得去再干一年吧。。。
只求顺利拿个银牌。。。
去年沈阳真的太可惜了。。。。。。。太气了。。。。
但愿一切顺利。。。让我拿个银牌吧orz</description></item><item><title>用两个栈实现队列</title><link>https://111qqz.com/2017/03/</link><pubDate>Sat, 11 Mar 2017 12:52:58 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
思路：
一个元素入队的时候直接插入到stack1中。。。
一个元素出队的时候。。。如果stack2不为空。。stack2顶的元素就是要出队的。。
如果stakc2为空。。。就将stack1清空，按照元素出栈的顺序依次入栈到stack2
class Solution { public: void push(int node) { stack1.push(node); } int pop() { if (stack2.size()!=0) { int ret = stack2.top(); stack2.pop(); return ret; } while (!stack1.empty()) { int val = stack1.top(); stack1.pop(); stack2.push(val); } if (stack2.size()!=0) { int ret = stack2.top(); stack2.pop(); return ret; } return -1; } private: stack&amp;lt;int&amp;gt; stack1; stack&amp;lt;int&amp;gt; stack2; };</description></item><item><title>leetcode 105 根据前序遍历和中序遍历重构二叉树</title><link>https://111qqz.com/2017/03/</link><pubDate>Sat, 11 Mar 2017 11:34:40 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
思路：
分治搞之。
实际上两个vector就够了。。。4个会MLE(在leetcode上。。。
/** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* res; TreeNode* reConstructBinaryTree(vector&amp;lt;int&amp;gt; pre,vector&amp;lt;int&amp;gt; vin) { int siz = pre.size(); if (siz==0) return NULL; int rt = pre[0]; int pos=-1; for ( int i = 0 ; i &amp;lt; siz; i++) if (vin[i]==rt) { pos = i; break; } vector&amp;lt;int&amp;gt;preL,preR,vinL,vinR; for ( int i = 0 ; i &amp;lt; pos ; i++) { preL.</description></item><item><title>hash学习笔记</title><link>https://111qqz.com/2017/03/hash/</link><pubDate>Sat, 11 Mar 2017 08:15:26 +0000</pubDate><guid>https://111qqz.com/2017/03/hash/</guid><description>
前言： hash这种东西人人都会用的东西还有必要说？
起因是...本问了hash中的一个细节...然后...我知道怎么做... 结果描述的不够清楚？如果知道那个做法的名字也许就不用费劲描述了呢。。。所以来复习一下吧2333
hash函数_维基百科
说起来其实哈希只有两个东西比较重要吧。。。
一个是哈希函数的构造：
构造散列函数 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。
1. [直接定址法](https://zh.wikipedia.org/w/index.php?title=&amp;amp;action=edit&amp;amp;redlink=1)：取关键字或关键字的某个线性函数值为散列地址。即{\displaystyle hash(k)=k}![hash(k)=k](https://wikimedia.org/api/rest_v1/media/math/render/svg/92632e59ab25c8f6d526ea9fb9cf4e014912afe3) 或{ ，其中 为常数（这种散列函数叫做自身函数） 2. 数字分析法：假设关键字是以_r_为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。 3. 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 4. 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。 5. 随机数法 6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即{\displaystyle hash(k)=k,{\bmod {,}}p} , {\displaystyle p\leq m} 。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。
还有一个就是冲突的处理。。。?
为了知道冲突产生的相同散列函数地址所对应的关键字，必须选用另外的散列函数，或者对冲突结果进行处理。而不发生冲突的可能性是非常之小的，所以通常对冲突进行处理。常用方法有以下几种： * [开放定址法](https://zh.wikipedia.org/w/index.php?title=&amp;amp;action=edit&amp;amp;redlink=1)（open addressing）：{\displaystyle hash_{i}=(hash(key)+d_{i})\,{\bmod {\,}}m}![hash_{i}=(hash(key)+d_{i})\,{\bmod \,}m](https://wikimedia.org/api/rest_v1/media/math/render/svg/e9f569136022671abb3e623da1828b31313fd254) , {\displaystyle i=1,2...k,(k\leq m-1)} ，其中{\displaystyle hash(key)} 为散列函数，{\displaystyle m} 为散列表长，{\displaystyle d_{i}} 为增量序列，{\displaystyle i} 为已发生冲突的次数。增量序列可有下列取法：
{\displaystyle d_{i}=1,2,3...(m-1)}![d_{i}=1,2,3...(m-1)](https://wikimedia.org/api/rest_v1/media/math/render/svg/7164de5dc3e5febaa66956083e959797e265f91c) 称为 线性探测(Linear Probing)；即{\displaystyle d_{i}=i} ，或者为其他线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。</description></item><item><title>局部敏感哈希算法(Locality Sensitive Hashing)初探</title><link>https://111qqz.com/2017/03/locality-sensitive-hashing/</link><pubDate>Sat, 11 Mar 2017 07:59:00 +0000</pubDate><guid>https://111qqz.com/2017/03/locality-sensitive-hashing/</guid><description>
前言： 其实有了前文simhash算法的基础，局部敏感hash算法已经不存在理解上的问题了吧。。。毕竟simhash算法应该是局部敏感哈希算法的一种。。所以我就直接转载几篇我认为比较好的文档结合一下好了。。。会把比较重要的概念或者定义标记重点。
局部敏感哈希(Locality Sensitive Hashing，LSH)算法是我在前一段时间找工作时接触到的一种衡量文本相似度的算法。局部敏感哈希是近似最近邻搜索算法中最流行的一种，它有坚实的理论依据并且在高维数据空间中表现优异。它的主要作用就是从海量的数据中挖掘出相似的数据，可以具体应用到文本相似度检测、网页搜索等领域。 1. 基本思想 局部敏感哈希的基本思想类似于一种空间域转换思想，LSH算法基于一个假设，如果两个文本在原有的数据空间是相似的，那么分别经过哈希函数转换以后的****它们也具有很高的相似度；相反，如果它们本身是不相似的，那么经过转换后它们应仍不具有相似性。
哈希函数，大家一定都很熟悉，那么什么样的哈希函数可以具有上述的功能呢，可以保持数据转化前后的相似性？当然，答案就是局部敏感哈希。
回到顶部
2. 局部敏感哈希LSH 局部敏感哈希的最大特点就在于保持数据的相似性，我们通过一个反例来具体介绍一下。
假设一个哈希函数为Hash(x) = x%8，那么我们现在有三个数据分别为255、257和1023，我们知道255和257本身在数值上具有很小的差距，也就是说它们在三者中比较相似。我们将上述的三个数据通过Hash函数转换：
Hash(255) = 255%8 = 7;
Hash(257) = 257%8 = 1;
Hash(1023) = 1023%8 = 7;
我们通过上述的转换结果可以看出，本身很相似的255和257在转换以后变得差距很大，而在数值上差很多的255和1023却对应相同的转换结果。从这个例子我们可以看出，上述的Hash函数从数值相似度角度来看，它不是一个局部敏感哈希，因为经过它转换后的数据的相似性丧失了。
我们说局部敏感哈希要求能够保持数据的相似性，那么很多人怀疑这样的哈希函数是否真的存在。我们这样去思考这样一个极端的条件，假设一个局部敏感哈希函数具有10个不同的输出值，而现在我们具有11个完全没有相似度的数据，那么它们经过这个哈希函数必然至少存在两个不相似的数据变为了相似数据。从这个假设中，我们应该意识到局部敏感哈希是相对的，而且我们所说的保持数据的相似度不是说保持100%的相似度，而是保持最大可能的相似度。
对于局部敏感哈希“保持最大可能的相似度”的这一点，我们也可以从数据降维的角度去考虑。数据对应的维度越高，信息量也就越大，相反，如果数据进行了降维，那么毫无疑问数据所反映的信息必然会有损失。哈希函数从本质上来看就是一直在扮演数据降维的角色。
回到顶部
3. 文档相似度计算 我们通过利用LSH来实现文档的相似度计算这个实例来介绍一下LSH的具体用法。
3.1 Shingling 假设现在有4个网页，我们将它们分别进行Shingling（将待查询的字符串集进行映射，映射到一个集合里，如字符串“abcdeeee&amp;quot;, 映射到集合”(a,b,c,d,e)&amp;quot;, 注意集合中元素是无重复的，这一步骤就叫做Shingling, 意即构建文档中的短字符串集合，即shingle集合。），得到如下的特征矩阵：
其中“1”代表对应位置的Shingles在文档中出现过，“0”则代表没有出现过。
在衡量文档的相似度中，我们有很多的方法去完成，比如利用欧式距离、编辑距离、余弦距离、Jaccard距离等来进行相似度的度量。在这里我们运用Jaccard相似度。接下来我们就要去找一种哈希函数，使得在hash后尽量还能保持这些文档之间的Jaccard相似度，即：
我们的目标就是找到这样一种哈希函数，如果原来文档的Jaccard相似度高，那么它们的hash值相同的概率高，如果原来文档的Jaccard相似度低，那么它们的hash值不相同的概率高，我们称之为Min-hashing(最小哈希)。
3.2 Min-hashing Min-hashing定义为：特征矩阵按行进行一个随机的排列后，第一个列值为1的行的行号。举例说明如下，假设之前的特征矩阵按行进行的一个随机排列如下：
元素 S1 S2 S3 S4 他 0 0 1 0 成功 0 0 1 1 我 1 0 0 0 减肥 1 0 1 1 要 0 1 0 1 最小哈希值：h(S1)=3，h(S2)=5，h(S3)=1，h(S4)=2.</description></item><item><title>文本相似度判断-simhash算法学习笔记</title><link>https://111qqz.com/2017/03/simhash/</link><pubDate>Fri, 10 Mar 2017 03:33:08 +0000</pubDate><guid>https://111qqz.com/2017/03/simhash/</guid><description>
先放原始论文。。。以此表达对这个算法的敬意orz
论文链接
问题引出： 那天百度一面，frog学姐问了我如何判断两篇新闻稿的相似度的问题....我满篇口胡...也只是回答了一些诸如从图片上考虑。。或者去掉stop word之后得到特征向量然后计算余弦值之类得到传统想法。。。
今天看到了google在用的网页去重的算法（？。。。感觉好神奇。。。准备面试到现在，第一个让我感到惊异而不是套路的算法orz
对于处理**大规模文本（500字以上吧）**的时候效果很好。。。但是算法思想却又非常简单。
这才是算法的美丽之处吧。。。。leetcode上的那些纱布技巧也好意思叫算法。。。？
网页去重，其实本质还是网页相似度的计算....首先是两篇，之后还可以推广到海量数据。
算法初探： simhash算法。。。字面上也可以看出。。是一种hash算法。。。那么它和一般的hash有什么不同呢？
最大的问题在于。。。传统hash的设计目的之一是使得映射后的值的分布尽可能均匀...对于同样的key会有同样的value,但是每当key有轻微的变化的时候，value就会千差万别。
举个例子：
“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 通过simhash计算结果为：
1000010010101101111111100000101011010001001111100001001011001011
1000010010101101011111100000101011010001001111100001101010001011
通过 hashcode计算为：
1111111111111111111111111111111110001000001100110100111011011110
1010010001111111110010110011101
也就是说。。。没办法通过hash之后得到的值的差异，去分析key的相似程度。
而simhash就是通过某种方法进行hash，使得hash之后得到的value可以反应key的相似度。
流程 simhash算法分为5个步骤：分词、hash、加权、合并、降维，具体过程如下所述： * 分词 * 给定一段语句，进行分词，得到有效的特征向量，然后为每一个特征向量设置1-5等5个级别的权重（如果是给定一个文本，那么特征向量可以是文本中的词，其权重可以是这个词出现的次数）。例如给定一段语句：“CSDN博客结构之法算法之道的作者July”，分词后为：“CSDN 博客 结构 之 法 算法 之 道 的 作者 July”，然后为每个特征向量赋予权值：CSDN(4) 博客(5) 结构(3) 之(1) 法(2) 算法(3) 之(1) 道(2) 的(1) 作者(5) July(5)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。 * hash * 通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“CSDN”的hash值Hash(CSDN)为100101，“博客”的hash值Hash(博客)为“101011”。就这样，字符串就变成了一系列数字。 * 加权 * 在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“CSDN”的hash值“100101”加权得到：W(CSDN) = 100101 _4 = 4 -4 -4 4 -4 4，给“博客”的hash值“101011”加权得到：W(博客)=101011 _5 = 5 -5 5 -5 5 5，其余特征向量类似此般操作。 * 合并 * 将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“CSDN”的“4 -4 -4 4 -4 4”和“博客”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。 * 降维 * 对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 0 1 0 1 1”，从而形成它们的simhash签名。 每篇文档得到SimHash签名值后，接着计算两个签名的海明距离即可。根据经验值，对64位的 SimHash值，海明距离在3以内的可认为相似度比较高。</description></item><item><title>蓄水池抽样算法概述(Reservoir Sampling Algorithm)[转载]</title><link>https://111qqz.com/2017/03/reservoir-sampling-algorithm/</link><pubDate>Thu, 09 Mar 2017 12:14:11 +0000</pubDate><guid>https://111qqz.com/2017/03/reservoir-sampling-algorithm/</guid><description>
面京东被这个问题卡了QAQ，来补补这方面的课。
转自：链接
蓄水池抽样算法随机算法的一种，用来从 N 个样本中随机选择 K 个样本，其中 N 非常大（以至于 N 个样本不能同时放入内存）或者 N 是一个未知数。其时间复杂度为 O(N),包含下列步骤 (假设有一维数组 S, 长度未知，需要从中随机选择 k 个元素, 数组下标从 1 开始), 伪代码如下:
array R[k]; // result integer i, j; // fill the reservoir array for each i in 1 to k do R[i] := S[i] done; // replace elements with gradually decreasing probability for each i in k+1 to length(S) do j := random(1, i); // important: inclusive range if j &amp;lt;= k then R[j] := S[i] fi done 算法首先创建一个长度为 k 的数组（蓄水池）用来存放结果，初始化为 S 的前 k 个元素。然后从 k+1 个元素开始迭代直到数组结束，在 S 的第 i 个元素，算法生成一个随机数 j∈[1,i]j∈[1,i]， 如果 j &amp;lt;= k， 那么蓄水池的第 j 个元素被替换为 S 的第 i 个元素。</description></item><item><title>leetcode 74. Search a 2D Matrix</title><link>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</link><pubDate>Thu, 09 Mar 2017 11:14:05 +0000</pubDate><guid>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</guid><description>
题目链接
题意：给一个二维数组。。。每一行每一列都分别递增。。问某个value是否出现过。。。
思路：单调。。显然二分。。。唯一的技巧是从右上角开始搜。
/* *********************************************** Author :111qqz Created Time :2017年03月09日 星期四 19时03分07秒 File Name :74.cpp ************************************************ */ class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int n = matrix.size(); if (n==0) return false; int m = matrix[0].size(); if (m==0) return false; int row = 0 ; int col = m-1; while (col&amp;gt;=0&amp;amp;&amp;amp;row&amp;lt;n) { if (matrix[row][col]==target) return true; else if (matrix[row][col]&amp;gt;target) col--; else row++; } return false; } };</description></item><item><title>阿里一面.</title><link>https://111qqz.com/2017/03/intern-interview-of-alibaba/</link><pubDate>Sun, 05 Mar 2017 12:51:42 +0000</pubDate><guid>https://111qqz.com/2017/03/intern-interview-of-alibaba/</guid><description>
一开始是晚上七点半，直接一个电话过来就开始面试》。。
窝说不方便，又约了周末下午或者晚上，然后周六上午来了电话....。。。。于是又约了周天下午。。。
然后窝从两点开始等。。。等到六点半。。。决定去教室写报告。。。然后刚到教室电话就来了orz...
先是常规的简单自我介绍。。
然后先是问了一些cpp的问题。。
问了一些cpp的问题：
先是问了c和cppneicu内存的区别。。。我：？？？？？ 内存区别什么鬼。。
然后就回答了malloc,free,delete,new的区别。。。好像就是这个问题。。。
第二个问题是什么时候会内存泄露。。
我说申请了内存没释放blablabla...
第三个问题是cpp哪些函数不能为虚函数：
我说构造函数。。。面试官姐姐问还有呢。。。。窝说不知道了orz...
第四个问题问了指针和引用的区别。。。
我回答了三方面。。。初始化。。。赋值。。还有类型转化上。。。
面试官姐姐问还有呢。。。。我：喵喵喵喵喵？。。。不知道了。。。给点提示可？
面试官姐姐说在作为参数传递的时候。。。
我说传数组只能用指针。。不能用引用。。。
第五个问题问了栈和堆在xx方面的区别。。。（xx我不记得原词是什么了。。大概是说使用场合？）
我说一个是系统用。。一个是程序员用。。。（？？？
第六个问题是问我面向对象的特性。。。
我说是继承。。封装。。多态。。个人认为最核心的是多态blablabla...
然后面试官姐姐就问cpp多态的体现。。。
我说分动多态和静多态。。。。。。然后把模板，，，函数重载。。。虚函数什么的说了一下。。。
这大概是第一部分。。。第二部分问了我数据结构。。。
先问了我堆排。。。
给我一串无序数。。让我构造一个大根堆。。。。
我。。竟然。。。一脸智障。。。。。。
真的不记得了。。。。虽然记得这题数据结构考试还考过吧。。。
最后在面试官姐姐的提示下。。蒙出来了。。。人生污点啊。。。orz
然后问我复杂度。。。稳定性。。。
又问了快排。。让我给他讲一下快排。。。
我就说了取pivot的几种策略。。。然后复杂度的平均和最坏情况。。。以及避免最坏情况的方法。。。
然后面试官姐姐问我最坏情况的数据是怎么样的。。。
这个经典问题我竟然也。。。。（人生污点*2
答案是基本单调的。。。
然后问我一个有序的数组。。找index=value的值。。数组没有重复元素。。。
其实一开始没说单调。。。我问了一句她才说漏了个条件2333.
单调。。那就二分呗。然而我口头描述了下二分的代码。。。
就是l和r的值什么要注意一下吧。。。
然后问我有单调有重复怎么办。。。
一开始没过脑子。。。说了个两次二分出一个区间。。事实证明是错误的。。。
然而实际上只要稍微修改下二分代码就好了。。。。
之后问我一棵二叉树。。如何in-place 按照前序遍历转化成单项链表。。。想了一会。。。还是不会orz。。。
这大概是leetcode的套路题吧。。。由于觉得leetcode太恶心。。。刷了80+就没再刷了。。。QAQ
然后第三部分。。。问我我OS的东西。。。
问我了内核态和用户态的区别。。。
然后问我linux的blablabla....我说我不会QAQ 面试官姐姐就没再问这方面了。。。
后来面试官姐姐说这方面她也不太懂。。。
第四部分。。。问了我数据库。。？
就问了一个 事务的特性。。。
我就回答了acid...每个解释了一下。。。
然后就没了吧。。。</description></item><item><title>C++ sort学习笔记</title><link>https://111qqz.com/2017/03/c-sort/</link><pubDate>Wed, 01 Mar 2017 07:27:12 +0000</pubDate><guid>https://111qqz.com/2017/03/c-sort/</guid><description>
回想起大一的时候打cf...那个时候对C++还不怎么熟悉。。。用sort不会自定义排序方式。。
于是手写快排。。。直接取中间元素没加随机化。。。跪了。。。
后来知道sort怎么写以后。。发现sort是可以通过的。。。
于是我就一直以为sort是带随机化的快排。。。
然而实际上是：
sort在数据量比较大的时候用quick_sort...当分段后的数据量小于某个门槛，为了避免对此递归带来的额外负担。。采取插入排序的策略。。
以及。。。快排在最快情况下还是会到达平方的复杂度。。。
于是有人发明了introsort...中文翻译叫内省排序。。。？
维基百科_introsort
这个算法其实就是。。对于数据量大的时候。。。一开始还是快排。。。但是当递归深度过深时。。用堆排。。。
据说现在的STL一般都是用了introsort....</description></item><item><title>百度实习生面试总结</title><link>https://111qqz.com/2017/02/baidu-intern-interview/</link><pubDate>Tue, 28 Feb 2017 13:36:11 +0000</pubDate><guid>https://111qqz.com/2017/02/baidu-intern-interview/</guid><description>
啊。。。虽然结果还没出来。。。不过回想发现有些细节已经有些记不清了。。。
所以打算先记录一下？ 就算过不了。。。也算是积累一些经验。
一面： 先是简单自我介绍。。。
然后问了2-sum...?(。。。我之前真不知道这是套路题。。。花了较长时间。。。被面试官姐姐（or适牛？）吐槽不够smartQAQ
姐姐表示没听过。。我说就是two-pointer...之后要求我实现一下尺取做法的代码。。。
有点久没写尺取竟然写残了。。。？面试官姐姐看了之后说。。。你的two pointer 怎么head和tail都在一端啊。。。不应该在两端吗。。。我表示喵喵喵喵喵？ 我写了好多尺取都是在一端。。。不过这倒是提醒了我。。。改对了代码。。。一头一尾。。。难道说这不叫two pointer? 还是说。。。尺取和two pointer根本不是一个东西。。。
之后好像问了道有很多人买5元一瓶的饮料。。。但是有一半人手里是有5元钱的，有一半人手里只有10元。初始饮料店老板手里没钱。。问合法的方案数？
听懂题目以后直觉和母函数有关系。。。就试探性问了句面试官姐姐。。。
发现果然是对的。。。然后面试官姐姐直接就说出了关键字catalan数....说是本打算让我自己推倒一遍的。。。
嗯。。虽然当时啃《组合数学》的时候母函数这部分我看得很细。。catalan数也是ACM题目的常客。。。。以及16年以前网上能找到的普通型母函数和指数型母函数的题目我基本A光了。。。但是感觉真让我推一遍。。。在面试的紧张气氛里。。。说不定就gg了。。。。。
好像算法题就这两个？
之后好像问了一个。。。大概是说同一个新闻可能会被不同站点报道。。。怎么去判断两个新闻稿件的相似度。。。
我说新闻稿件一般都会有图片。。。一张图片某些关键信息可以作为该图片的特征值。。。一般会有多张图片。。。然后算个n维向量的余弦值。。。。
然后文字部分。。。首先stop word什么的肯定要去掉。。。然后同一个新闻的不同稿件。。。时间地点人物什么的都应该一样。。。没有意义。。。
不同稿件应该是观点不同？ 所以我觉得应该重点关注那些表示观点的词。。。由于中文表示观点的词应该还算相对有限？ 可以打个表把不同类别的词赋值成不同的值。。。然后hash一下。。。？
（感觉自己全程口胡。。。。
其实一面应该还问了其他问题。。。？ 我实在不记得了。。。这几个问题是印象比较深刻的。。。
然后挂了一面电话没几分钟。。。就接了二面电话。。。。上来就面试问问题。。。被效率吓到。。。以至于我以为是哪里搞错了。。。还问了句。。。请问这是什么面试2333.
二面： 一开始好像问了个。。将一个数组的奇数放在前半部分。。。偶数放在后半部分。。。要求 原地完成。。。
这个还好。。。就是两个指针一前一后搞一搞。。。
然后问了。。。搜索中的敏感词问题。。。
问怎么把正文中的敏感词全部替换成星号。。。
我问敏感词多吗?好像是说1000个？反正不多。。。
我就说AC自动机就好。。。敏感词建一个AC自动机。。。然后正文扔进去跑。。。
面试官问我复杂度。。。。啊。。我。。。真的不记得。。。想了下说应该是O((n+m)*L)吧。。。L是字符表的大小。。。。
面试官说这效率不够好。。。让我再想想。。。。
我想到了hash....说把敏感词hash一下。。。？ 面试官问我正文怎么办。。。要把每个词也都hash吗。。。
我当时绝逼脑子短路了。。。以为两个字的词是把n个字两两组合。。。。。我怎么这么傻。。。然后觉得这复杂度显然炸了啊。。。不行。。。
实际上就是O(n)好么。。。再加上敏感词一般都不长。。。
于是我就放弃hash的思路了。。。。
黔驴技穷。。。最后给出了个口胡的统计上的思路。。。
就说统计敏感词的那些字的出现概率。。。以及每个敏感词的字的前后都是那些字（因为这些字出现在一起才敏感）。。。
根据马尔科夫假设。。。每个字出现的概率只和其前面一个字有关blablabla....
然后面试官说。。可以。。但是做不到精确。。。有没有精确的做法。。。
我又想了下。。说除了AC自动机我想不出别的做法了。。。
然后就问下一道题了。。。
说是一个随机数发生器。。。得到0的概率是p，得到1的概率是1-p，问如何等概率生成0和1.。
我想了下说好像和之前遇到的一个问题有点像。。。那道题是给你rand5()的随机数发生器让你生成rand7()的随机数发生器。。。
然后面试官说那就先说说你这道题吧。。。
内心：呜呜呜让你多嘴。。。
然后。。。不知道是紧张还是什么原因。。。明明面hypereal完美回答的问题竟然突然忘记该怎么生成了。。。？
关键就是那个等概率函数怎么构造。。。。
完全不记得当时怎么构造的了。。情急之下。。。竟然又想出另一种？
大概是把每个生成的rand5()看成五进制数某一位数字。。。这样就是等概率的了。。。结果%7就好。。。
不过这个思路貌似对于等概率生成0,1的原始题目也有用？
我可以直接生成二进制数啊。。。00,01,10,11...然后扔掉00和11.。。岂不是美滋滋？
之后又给了我一段代码。。。问我有没有什么问题。。。当时没有看出来。。。。最后知道。。。是在考vector的底层实现。。。
于是最近打算稍微看下STL那些东西的原理。。。
然后。。。大概就是这些。。。每次面试都能暴露自己蛮多问题。。。蛮不错的。。。</description></item><item><title>cpp vector学习笔记</title><link>https://111qqz.com/2017/02/cpp-vector/</link><pubDate>Tue, 28 Feb 2017 07:21:49 +0000</pubDate><guid>https://111qqz.com/2017/02/cpp-vector/</guid><description>
起因是百度实习二面的时候被问了一道类似这样的题：
给我下面的代码，问有没有什么问题。
/* *********************************************** Author :111qqz Created Time :2017年02月28日 星期二 14时49分37秒 File Name :vector.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;ctime&amp;gt; using namespace std; int func( int x ) //此处函数的条件是不单调...这样才可以触发问题. { return (x-50)*(x-50)+1; } int main() { vector&amp;lt;int&amp;gt;vec; int *pint = NULL; for ( int i = 0 ; i &amp;lt; 100 ; i++) { int x = func(i); vec.push_back(x); if (x&amp;lt;500) { pint = &amp;amp; vec[0]; } } if (pint) *pint = 0 ; int siz = vec.</description></item><item><title>leetcode 437. Path Sum III</title><link>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</link><pubDate>Fri, 24 Feb 2017 03:45:38 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</guid><description>
题目链接
题意：求一棵二叉树中，所有一段连续路径之和等于给定值的路径数目。
思路：想了半天就只能想到暴力。。。复杂度大概O(n^2)。。。也不是不可以接受。。。但是感觉这也太暴力了。。就去看了题解。。。发现题解就还真是暴力orz。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { //思路：枚举每个起点？？？好暴力啊。。。卧槽。。正解就是这样。。。 public: int dfs(TreeNode* root,int sum) { int res = 0 ; if (root==NULL) return res; if (root-&amp;gt;val==sum) res++; res += dfs(root-&amp;gt;left,sum-root-&amp;gt;val)+dfs(root-&amp;gt;right,sum-root-&amp;gt;val); return res; } int pathSum(TreeNode* root, int sum) { if (root==NULL) return 0; return dfs(root,sum)+pathSum(root-&amp;gt;left,sum)+pathSum(root-&amp;gt;right,sum); } };</description></item><item><title>leetcode 101. Symmetric Tree Add to List（二叉树，判断镜像）</title><link>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</link><pubDate>Fri, 24 Feb 2017 02:57:19 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</guid><description>
题目链接
题意：判断一棵二叉树是否是自己的镜像。做法是做个copy，相当于两棵树做比较。注意逻辑不要漏掉就好
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } bool mirror(TreeNode* rt1,TreeNode* rt2) { if (rt1==NULL&amp;amp;&amp;amp;rt2==NULL) return true; if (rt1==NULL||rt2==NULL) return false; printf(&amp;quot;%d %d\n&amp;quot;,rt1-&amp;gt;val,rt2-&amp;gt;val); if (leaf(rt1)&amp;amp;&amp;amp;leaf(rt2)&amp;amp;&amp;amp;rt1-&amp;gt;val==rt2-&amp;gt;val) return true; if (leaf(rt1)||leaf(rt2)) return false; //包含了其中一个是叶子，或者两个都是叶子但是值不相等的情况。 if (rt1-&amp;gt;val!</description></item><item><title>leetcode 110. Balanced Binary Tree</title><link>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</link><pubDate>Fri, 24 Feb 2017 00:20:19 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</guid><description>
题目链接
题意：判断一颗二叉树是否平衡....
思路：直接搞就好了。。。神TM又忘记dfs的时候忘记返回子调用的值。。。。我这是药丸啊。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { //错误原因：左右子树都平衡的树未必平衡！！！！ public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } int dep(TreeNode* root) { if (root==NULL) return 0; return max(dep(root-&amp;gt;left),dep(root-&amp;gt;right))+1; } bool dfs(TreeNode* root) { bool res = true; if (abs(dep(root-&amp;gt;left)-dep(root-&amp;gt;right))&amp;gt;1) return false; if (root-&amp;gt;left!</description></item><item><title>leetcode 235. Lowest Common Ancestor of a Binary Search Tree（求一个BST中某两个节点LCA）</title><link>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</link><pubDate>Wed, 22 Feb 2017 13:22:08 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</guid><description>
题目链接
题意：求一个BST中某两个节点LCA....
思路：卧槽。。。竟然求LCA...直接想到的显然是Tarjan的方法或者。。。RMQ+DFS。。。但是感觉。。。leetcode怎么可能考算法。。。。于是想到。。。可以从BST下手。。。
两个节点的LCA的值一定在这两个节点之间。
可以根据这个条件做二分。。。
这道题的收获是。。。不要被已知的东西限制住思路。。。tarjan或者RMQ+DFS显然也能做。。。但是那样的相当于没有用到BST的条件。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode * Find(TreeNode* root,TreeNode* p,TreeNode *q) { if (root==NULL) return NULL; //实际上这应该不可能发生》。。。 int rt = root-&amp;gt;val; int a = p-&amp;gt;val; int b = q-&amp;gt;val; if (a&amp;lt;=rt&amp;amp;&amp;amp;rt&amp;lt;=b) return root; if (b&amp;lt;=rt&amp;amp;&amp;amp;rt&amp;lt;=a) return root; if (a&amp;lt;rt&amp;amp;&amp;amp;b&amp;lt;rt) return Find(root-&amp;gt;left,p,q); if (a&amp;gt;rt&amp;amp;&amp;amp;b&amp;gt;rt) return Find(root-&amp;gt;right,p,q); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root==NULL) return NULL; TreeNode* res = Find(root,p,q); return res; } };</description></item><item><title>leetcode 104. Maximum Depth of Binary Tree（求一棵树的深度）</title><link>https://111qqz.com/2017/02/leetcode-104-maximum-depth-of-binary-tree/</link><pubDate>Wed, 22 Feb 2017 12:41:34 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-104-maximum-depth-of-binary-tree/</guid><description>
题目链接
题意：求一棵树的深度。。。。
思路：。。。定义搞即可。。按照左右子树中大的算。。。因为据说是经典题（虽然并不觉得2333。。。所以记录下。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int dfs(TreeNode* root) { if (root==NULL) return 0; return max(dfs(root-&amp;gt;left),dfs(root-&amp;gt;right))+1; } int maxDepth(TreeNode* root){ if (root==NULL) return 0; int res = dfs(root); return res; } };</description></item><item><title>leetcode 226. Invert Binary Tree（反转二叉树）</title><link>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</link><pubDate>Wed, 22 Feb 2017 12:14:36 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</guid><description>
题目链接
题意：反转一棵二叉树。。。字面意思理解即可。。就是把每一棵子树的左右孩子交换。。。
思路：直接照着题意做就好了。。。没有坑。。记录的原因是听说这题比较经典（虽然毫无难度...
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } void dfs(TreeNode* root) { if (leaf(root)) return; TreeNode* tmp = root-&amp;gt;left; root-&amp;gt;left = root-&amp;gt;right; root-&amp;gt;right = tmp; if (root-&amp;gt;left!=NULL) dfs(root-&amp;gt;left); if (root-&amp;gt;right!</description></item><item><title>112. Path Sum</title><link>https://111qqz.com/2017/02/112-path-sum/</link><pubDate>Wed, 22 Feb 2017 11:40:23 +0000</pubDate><guid>https://111qqz.com/2017/02/112-path-sum/</guid><description>
题目链接
题意：给一棵树。。问是否存在一条从树根到叶子的路径，使得路径上每个点的val之和等于给定的sum。
思路：。。。直接搞就好。。。由于是比较经典的题目所以记录一下。。。注意递归的时候每一部分都要返回值orz..(我是多久没写代码了。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } int SUM; bool dfs(TreeNode* root,int cur) { // cout&amp;lt;&amp;lt;&amp;quot;val:&amp;quot;&amp;lt;&amp;lt;root-&amp;gt;val&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; bool ret=false; if (cur+root-&amp;gt;val==SUM&amp;amp;&amp;amp;leaf(root)) return true; if (root-&amp;gt;left!=NULL) ret = dfs(root-&amp;gt;left,cur+root-&amp;gt;val); if (ret) return true; if (root-&amp;gt;right!</description></item><item><title>leetcode 108. Convert Sorted Array to Binary Search Tree（有序数组转化成bst）</title><link>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</link><pubDate>Tue, 21 Feb 2017 11:14:48 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</guid><description>
leetcode108
题意：把有一个有序的数组转化成一课高度尽量小的bst(二叉搜索树)
思路：我竟然忘记了什么是bst........我好傻啊...不过想想可能是因为...最朴素的二叉搜索树几乎用不到...所以很容易忘记吧2333
bst是 binary search tree的缩写..
具体见 维基百科_二叉搜索树
想起来概念就好搞了...直接递归建树即可...类似线段树的build的过程
/* *********************************************** Author :111qqz Created Time :2017年02月21日 星期二 13时08分04秒 File Name :108.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* dfs( int l,int r,vector&amp;lt;int&amp;gt;&amp;amp;nums) { int n = r-l+1; if (n&amp;lt;=0) return NULL; int m = n/2; cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; TreeNode* rt = new TreeNode(nums[l+m]); rt-&amp;gt;left = dfs(l,l+m-1,nums); rt-&amp;gt;right = dfs(l+m+1,r,nums); return rt; } TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetcode 107 Binary Tree Level Order Traversal II(最底层往上依次输出二叉树每一个node的val)</title><link>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</link><pubDate>Mon, 20 Feb 2017 12:36:21 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</guid><description>
最近要准备面试...虽然leetcode的题目难度比较水..不过白板写代码还是要练下的。。。我所理解的白板写代码。。。大概就是。。。用记事本。。一遍写对代码的能力吧。。。所以我来记录一下。。思路想错的或者没有秒的题目。
（因为题目描述傻逼/数据范围故意坑人/leetcode抽风 / 我自己犯傻逼 等原因 没有一次通过的题目不在记录之列）
leetcode107
题意：给一棵二叉树，从最底层往上依次输出每一个node的val..
思路：一开始以为同一层的一定会在相邻时间内访问。。。后来发现的确是蠢了。。。
因此dfs的时候加了一个level域。。。每次dfs的时候先左后右就好了。。。
注意记得判断root为空的情况。。。
/* *********************************************** Author :111qqz Created Time :2017年02月20日 星期一 19时21分51秒 File Name :107.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;res; vector&amp;lt;int&amp;gt;tmp[1500]; int mx_level = 0 ; void dfs( TreeNode* root,int level) { // cout&amp;lt;&amp;lt;&amp;quot;level:&amp;quot;&amp;lt;&amp;lt;level&amp;lt;&amp;lt;endl; mx_level = max(mx_level,level); if (root-&amp;gt;left!</description></item><item><title>hypereal面小记</title><link>https://111qqz.com/2017/02/hypereal-interview/</link><pubDate>Fri, 17 Feb 2017 08:44:43 +0000</pubDate><guid>https://111qqz.com/2017/02/hypereal-interview/</guid><description>
第一次参加面试orz...所以还是有点期待+紧张的2333
题目比较多，30分钟做了一半吧，之后就是和面试官聊。
优先编程题。
由于题目不可能做完。。我基本上是跳着做的。。。
看到一道求斐波那契第n项的题。。。我随口问面试官n的数据范围。。。
他说越优越好。。我问能实现的n越大越好？他说时间空间复杂度越低越好。
因为题目显然做不完。。我又确认了下。。是尽可能多做。。还是尽可能把每道题做优。。。
面试官说是后者。。
我想了一下。。。写了个lgn的算法。。。
然后有一道求等比数列第n项的题。。。
想了一下。。。不知道怎么优化。。就写了暴力。。。用了pow函数。。
之后面试官问我pow的实现原理。。。
我说好像是。。。康托展开。。？啊呸。。泰勒展开。。。
又问我时间复杂度。。。 隐约想起无数次打cf被pow函数坑。。。我回答了个。。。O(n)吧。。。
我好傻啊。。被坑是精度跪了又不是TLE。。。
还有一道
之后问了我lowbit函数的含义。。。顺便问了BIT的思想。。。
然后就是些C++相关的东西。。。一些容易混淆的概念。。。一些容易踩的坑什么的。。。
啊。。刚刚面试官说要求我保密。。。所以没办法发出来了orz</description></item><item><title>BZOJ 1303: [CQOI2009]中位数图（前缀/后缀和乱搞）</title><link>https://111qqz.com/2017/01/bzoj-1303-cqoi2009/</link><pubDate>Mon, 30 Jan 2017 16:09:22 +0000</pubDate><guid>https://111qqz.com/2017/01/bzoj-1303-cqoi2009/</guid><description>
1303: [CQOI2009]中位数图 Time Limit: 1 Sec Memory Limit: 162 MB Submit: 2480 Solved: 1529 [Submit][Status][Discuss]
Description 给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。
Input 第一行为两个正整数n和b ，第二行为1~n 的排列。
Output 输出一个整数，即中位数为b的连续子序列个数。
Sample Input 7 4 5 7 2 4 3 1 6
Sample Output 4
HINT 第三个样例解释：{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6} N&amp;lt;=100000
思路：这道题的思路还是比较经典的...把大于b的数看成1，小于b的数看成-1..于是一段以b为中位数的连续的长度为奇数的数列的和为0.
那么从b往前做一个后缀和，往后做一个前缀和...然后统计每个前缀和/后缀和的值的个数..
然后枚举前缀和/后缀和可能的值（-n..n，由于负数不好处理，整体+n，变成0..2n)
具体见代码
/* *********************************************** Author :111qqz Created Time :2017年01月30日 星期一 20时13分11秒 File Name :code/bzoj/1303.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N]; int sum[N]; int l[N*2],r[N*2]; int n,b; int pos; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>再见2016</title><link>https://111qqz.com/2017/01/goodbye-2016/</link><pubDate>Fri, 27 Jan 2017 13:22:24 +0000</pubDate><guid>https://111qqz.com/2017/01/goodbye-2016/</guid><description>
所以还是稍微写写年终总结吧..
感觉...2016分成了两部分吧，前11个月是一部分，后1个月是另一部分。
前11个月似乎都在做同一件事。大概先是期末花了两周时间稍微应付了下考试...然后就开始写题了...当时是第一次寒假留校...冻成狗orz
然后二月..三月...四月...五月...六月...七月...八月...九月...十月...似乎都在做同样的事情...写代码，写代码...
最后大概有1200题的样子...？我也不知道...cf rating的话..倒是还是不高...BC好像上了1900...？记不太清了...
那一学期玩脱了两科。。。计组喝数学物理方法Orz...更有趣的是...假期过于投入竞赛...尤其快开学那段时间忙校内排位赛...错过了补考的申请时间（实际上是完全忘记了申请补考这回事.)结果去考试的时候...发现自己并没有考试资格orz。。。惨哦
十月沈阳被艹哭我是不想多说了... 被卡了一道暴力题卡了蛮久...只能说是自己实力不够。。。而且就算不卡，那道字符串上的dp题的套路貌似我们没有人会...所以是说什么也做不出银牌题的....铜牌和铁牌的话..其实没什么区别吧
然后十一月去hk。。。其实已经完全是玩的心态了吧...
之后回来大概就是...失恋的状态...或者说生无可恋？
心情低迷了好一阵...好在没有大一下和zk那时候那么颓废...至少还是一切看起来正常...
至少那种感觉就好像...内心的什么火苗熄灭了...
其实本来纠结了一下是不是要退役。。。或者叫滚粗。。。
但是发现。。其实这个纠结毫无意义。。。因为现实情况就是。。。我没什么太多时间用来训练了。。。
于是试图转移转移思路。。。没有代码的日子感觉格外的闲...所以找了之前没有看完的被g神推荐的书拿出来继续看...
然后看一些网课之类的打发时间....（说起来跟了一门compiler的课。。。赞哭）
至少努力让自己不那么闲吧....虽然后来发现...其实没什么作用...
后来...期末啊...加权...其实说实话我是第一次看自己的加权。。。以前从来看都没看过orz。。。
不过由于花了时间...所以还是比以前有更高的期望的。。。。
不过还是觉得....课内果然还是蛮easy啊...至少...至少从不玩脱的角度...或者再高一点...？
但是课内也很无趣...不是课程本身无趣...而是觉得...可能一门出原卷的考试...你复习很久... 不如拿到卷子的同学分数高。。。
又或者什么科目你明明一直认真听讲一直做笔记...然后发现可能遇到了个假老师...
所以感觉....真的有点无趣.....
其他的大概是。。。成功牵了次红绳。。。室友和学姐2333... 牵红绳其实蛮有成就感的....大概也算做善事吧嘿嘿
然后也不禁有些羡慕...
有一次和学姐聊起妹子...
学姐说了句“你们这不就是普通朋友吗？”
突然好sad。。。也许就是普通朋友吧.....QAQ
新年愿望的话...能活到明年吧.....不开玩笑...
也祝各位新年快乐。</description></item><item><title>BZOJ 1800: [Ahoi2009]fly 飞行棋 （尺取+数学）</title><link>https://111qqz.com/2017/01/bzoj-1800-ahoi2009fly--/</link><pubDate>Thu, 26 Jan 2017 15:42:07 +0000</pubDate><guid>https://111qqz.com/2017/01/bzoj-1800-ahoi2009fly--/</guid><description>
1800: [Ahoi2009]fly 飞行棋 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 1530 Solved: 1220 [Submit][Status][Discuss]
Description 给出圆周上的若干个点，已知点与点之间的弧长，其值均为正整数，并依圆周顺序排列。 请找出这些点中有没有可以围成矩形的，并希望在最短时间内找出所有不重复矩形。
Input 第一行为正整数N，表示点的个数，接下来N行分别为这N个点所分割的各个圆弧长度
Output 所构成不重复矩形的个数
Sample Input 8 1 2 2 3 1 1 3 3
Sample Output 3
HINT N&amp;lt;= 20 思路：一开始的想法是枚举四条边，如果a==c&amp;amp;&amp;amp;b==d，就认为是找到了一个矩形。
重点在于判重，非常不好判断。一开始想要根绝四条边的长度hash一下，但是设想一个所有弧长都相等，且弧长较多的情况。
此时所有矩形的边长长度都相同，但是显然是不同的矩形，因此这种判断方法是错误的。
比较棒的思路是：矩形的对角线一定是外接圆的直径。
因此只需要找有多少条执行，假设为c，那么答案就是c*(c-1)/2（因为任意两条对角线就可以构成一个矩形）
这种做法的好处很明显，不需要判重。
至于如何找直径，直径是把圆周等分的弦，所以尺取找一下就好了。
复杂度O(n)
/* *********************************************** Author :111qqz Created Time :2017年01月26日 星期四 18时43分21秒 File Name :code/bzoj/r1800.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=25; int n,m; int a[N]; int sum=0; LL ans=0; void ruler() { int head; int tail; int cur = 0 ; head = tail = 1; while (head&amp;lt;n) { cur+=a[head]; while (cur&amp;gt;sum) cur-=a[tail++]; if (cur==sum) { ans++; } head++; } } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1207: [HNOI2004]打鼹鼠 (LIS)</title><link>https://111qqz.com/2017/01/bzoj-1207-hnoi2004-lis/</link><pubDate>Thu, 26 Jan 2017 08:12:38 +0000</pubDate><guid>https://111qqz.com/2017/01/bzoj-1207-hnoi2004-lis/</guid><description>
1207: [HNOI2004]打鼹鼠 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 2854 Solved: 1390 [Submit][Status][Discuss]
Description 鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿Q编写了一个打鼹鼠的游戏：在一个nn的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果i时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为（i,j）的网格移向(i-1, j),(i+1, j),(i,j-1),(i,j+1)四个网格，机器人不能走出整个nn的网格。游戏开始时，你可以自由选定机器人的初始位置。现在你知道在一段时间内，鼹鼠出现的时间和地点，希望你编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。
Input 第一行为n（n&amp;lt;=1000）, m（m&amp;lt;=10000），其中m表示在这一段时间内出现的鼹鼠的个数，接下来的m行每行有三个数据time,x,y表示有一只鼹鼠在游戏开始后time个时刻，在第x行第y个网格里出现了一只鼹鼠。Time按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。
Output 仅包含一个正整数，表示被打死鼹鼠的最大数目
Sample Input 2 2 1 1 1 2 2 2
Sample Output 1
HINT Source 思路：很巧妙的题目。类比LIS，如果两只仓鼠的曼哈顿距离小于等于两只仓鼠出现的时间，那么就可以从一只仓鼠转移到另一只仓鼠。利用这个条件，做二维的LIS即可。
/* *********************************************** Author :111qqz Created Time :2017年01月26日 星期四 15时39分26秒 File Name :1207.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; int t[N],x[N],y[N]; int dp[N] ; //dp[i]表示第i只仓鼠出现的时候，最多能打死几只仓鼠。 int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>又是这种绝望的感觉...</title><link>https://111qqz.com/2017/01/this-Desperate-feeling-again/</link><pubDate>Sat, 07 Jan 2017 13:02:56 +0000</pubDate><guid>https://111qqz.com/2017/01/this-Desperate-feeling-again/</guid><description>
绝望什么的...
总要有个具体的事情吧...
可是又说不清...好像突然每件事都让我绝望...
思考人生的意义。。。？并没有啊。。。
其实现在脑子是一片空白的。
单纯的绝望。。。
这种绝望的感觉大概经历过那么几次吧
正常的时候...自己都不觉得会怎么样。。。
然而在这种状态的时候...还是很害怕...
所以说，是一种...恐惧？
对死亡的恐惧？
就好像睡觉时那种突然下坠的感觉...
.............
是因为太久没写代码了吗==</description></item><item><title>大概功课不忙才有资本谈恋爱吧2333</title><link>https://111qqz.com/2017/01/2333/</link><pubDate>Sat, 07 Jan 2017 06:18:04 +0000</pubDate><guid>https://111qqz.com/2017/01/2333/</guid><description>
“元旦打算干嘛？”
“复习啊，你微机接口复习好了？数据库复习好了？体系架构复习好了？编译原理复习好了？嵌入式复习好了？”
“......”</description></item><item><title>其实每个时代都有不同的诱惑</title><link>https://111qqz.com/2017/01/Every-age-has-a-different-temptation/</link><pubDate>Fri, 06 Jan 2017 10:45:55 +0000</pubDate><guid>https://111qqz.com/2017/01/Every-age-has-a-different-temptation/</guid><description>
人生大概就是同各种欲望，各种诱惑做斗争的过程吧。</description></item><item><title>软件体系结构复习笔记</title><link>https://111qqz.com/2017/01/Software-Architecture-course-review/</link><pubDate>Tue, 03 Jan 2017 03:26:39 +0000</pubDate><guid>https://111qqz.com/2017/01/Software-Architecture-course-review/</guid><description>
Cha1 软件架构概念： 是系统的一个或多个结构，它们由软件组件，组件的外部可见属性以及组件之间的关系组成。 组件的外部可见属性是指其他组件对该组件所做的假设。 软件架构的多个结构： 静态的角度： 模块结构 分析类结构 类结构 动态的角度： 进程结构 数据流 控制流 使用结构 调用结构 层次结构 部署的角度： 物理结构
架构不止是功能需求的结果 Ch2: 需求包含三要素:功能，质量，限制条件 质量属性：系统在其生命周期过程中所表现出来的各种特征 质量属性的关系： 一个质量属性的获取对其他质量属性可能产生正面或者负面的影响。 任何质量属性都不可能在不考虑其他属性情况下单独获取。 质量属性举例： 运行时可见属性：性能，可用性，安全性 维护时可见属性：可修改，可扩展，可移植 易用性： 可学习性 可记忆性 错误避免 错误处理 满意度 质量场景创建的参与人员： 最终用户 系统管理员 维护人员 客户 开发组织 构架本身的质量属性： 一致性 正确性和完整性 可构建性 生成质量属性场景的目的和意义： 帮助构架师生成有意义的质量属性需求 使质量属性需求的描述规范化 某一场景是一类场景的代表，系统将以完全相同的方式做出反应。 构架的商业属性（限制）： 上市时间 成本和收益 预期系统生命周期长短 目标市场 推出计划 与老系统的集成 第三章： 软件架构样式的种类： 以数据为中心 数据流 虚拟机 调用-返回 独立组件 C/S 构架的异质性： 局部异质 层次异质 并行异质 ISO/OSI七层参考模型： 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 软件框架： 提取特定领域软件的共性部分形成的体系结构。 框架和架构的关系： 框架不是构架。 构架确定了系统整体结构、层次划分、不同部分之间的协作等设计老驴。 框架比构架更具体，更偏重于技术。 一个框架对应一个架构，一个架构可以有多个框架。 第四章： 架构战术：影响质量属性的设计决策。 架构策略：架构中所采用的战术的集合。 可用性的战术： 错误检测的战术： 回声 心跳 异常 错误恢复的战术： 表决 主动冗余 被动冗余 备件 状态再同步 检查点/回滚 错误预防的战术： 进程监视器 从服务中删除 事物 可修改性的战术： 局部化修改的战术： 维持语义一致性 预期期望的变更 泛化模块 限制可能的选择 防止连锁反应的战术： 信息隐藏 维持现有的接口 添加结构 添加适配器 提供一个占位程序 推迟绑定时间的战术： 运行时注册 配置文件 多态 组件更换 遵守已定义的协议 实施性能的战术： 影响响应时间的两个基本因素： 资源消耗 阻塞时间： 资源争用 资源的可用性 对其他计算的依赖性 控制对资源需求的战术： 减少处理一个事件所需要的资源： 提高计算效率 减少计算开销 减少需要同时处理： 管理事件率 控制采样频率 控制系统的使用： 限制执行时间 限制队列的大小 资源管理的战术： 引入并发 维持数据或计算的多个副本 增加可用资源 资源仲裁常见的调度策略： 先进/先出 固定优先级：语义重要性；时限时间单调；速率单调 动态优先级调度：轮转；时限时间最早优先 静态调度 实施安全性的战术： 用于抵抗攻击的战术： 对用户进行身份验证 对用户进行授权 维护数据的机密性 维护完整性 限制暴露的信息 限制访问 检测攻击的战术： 从攻击中恢复的战术： 回复状态 识别攻击者 易用性的战术： 运行时战术： 维持任务的一个模型 维护用户的一个模型 维护系统的一个模型 设计时战术： 软件架构样式与战术的关系： 软件架构样式是从战略层面解决质量问题，战术是从具体部署上给猪解决质量问题的局部策略。 第五章：设计构架 基于构架的开发步骤： 为软件系统创建一个商业案例 弄清系统需求 构建构架 正确表述此构架，并与有关各方进行交流 对此构架进行分析和评价 实现基于构架的系统并保证与构架相一致 系统维护时，构架文档应同步维护 构架驱动的因素： 功能 质量 部分限制条件（限制条件的某个子集） 良好架构的评判原则（判断题常考）： 设计构架过程的建议: 架的设计应该由一门设计师来完成 设计师应该全面掌握对系统的技术需求，以及对各项定性指标的优先级清单。 构架的文档完备，并蚕蛹所有人员认可的文档形式。 构架设计文档应让各风险承担者积极评估。 通过对构架分析，得出明确的定性与定量指标。 构架设计应该有助于具体实现。 允许构架带来一定的资源争用，并给出可行的解决方案。 关于构架的结构的建议： 构架由定义良好的模块组成，各个模块的功能划分应该基于信息隐藏。 模块的划分应体现出相互独立的原则。 把计算机基础结构的特性封装在一定的模块 构架尽量不依赖某个特定版本的商品产品或工具。 产生数据的功能和使用数据的功能应分属于不同的模块。 对并发系统，构架应充分考虑进程与模块结构的不对应。 进程编写要考虑到与特定处理器的关系，并容易改变关系。 构架应尽量采用一些已知的设计模式。 ADD构架设计的步骤： 样本输入 选择要分解的模块 根据下列5个步骤对模块进行求精（重点）： 从具体的质量场景和功能需求集合中选择构架驱动因素。 选择满足构架驱动因素的构架模式。 实例化模块并根据用例分配功能，使用多个视图进行表示 定义子模块的接口 验证用例和质量场景并对其进行求精，使它们称为子模块的限制。 对需求进一步分解的每个模块重复上述步骤。 创建骨架系统： 思想：提供一种基本能力，以一种对项目有利的顺序实现系统的功能。 好处： 提高开发效率，鼓舞士气。 能更早发现复杂的依赖关系。 使开发人员更多关注最难实现的部分。 能够缩短系统集成时间，降低其成本，并使集成成本更明确。 便于评审和测试。 步骤： 实现处理构架组件交互的软件部分 选择组件逐步添加到系统中。 逐步进行测试。 架构师的职责： 了解所在组织的业务目标，使架构更好地支持业务目标。 规划产品的开发与严禁 规划和建设架构级的重用etc 分析软件构架的原因(重要): 它是风险承担者之间的交流平台，是早期设计决策的体现，是可传递的模型。 软件质量不可能在软件开发的最后阶段追加上去，必须在设计之初就考虑到。 第七章： 构架评审： 成本： 人员时间成本 构架评审部门的组织开销 构架评审部分要求高级设计人员参与的代价（不就是人员时间成本吗。。。 收益： 及早发现构架中存在的问题 构架的改进 财务收益 强制位评审做准备 捕获构架设计的基本思想 验证需求的有效性 评审实施： 按问题的重要性进行分类 强调那些与偶家相符或相悖的重要问题 必须记载评审中所提的每个问题 构架评审的主要指导原则： 把由独立部门实施的正规的构架评审作为项目开发周期规划的一部分。 选择评审的最佳时间，尽早预审一次。 选择恰当的评审技巧 签署评审合同 限制所要品神的质量属性的个数 要保证评审小组中有构架方面的专家，领域专家，资料员，后勤员。 一定要有系统设计师。 收集各种场景数据，并在此基础上形成评审清单。 第八章： 架构权衡分析法（ATAM)： 特点：不仅可以揭示出构架满足特定质量目标的情况，而且可以让我们更清楚地认识质量目标之间的联系。 输入：用场景集合捕获的质量要求。 输出： 简介的框架表述 表述清楚的业务目标 构架决策到质量需求的映射 所确定的敏感点和权衡点集合 有风险决策和无风险决策 风险主题的集合 阶段： 评估小组和项目决策者共同决定评估细节 评估小组收集信息和分析 风险承担着参与评估 评估小组自我检查和改进，提交书面报告 步骤（重点）： ATAM方法的表述 商业动机的表述 构架的表述 对构架方法进行分类 生成质量属性效用树 分析构架方法 集体讨论并确定场景优先级 再次分析构架方法 结果的表述 第九章： 文档： 目的与作用：让不同的风险承担者都能快速找到和理解他们需要的信息。 基本原则：从读者的角度出发。</description></item><item><title>manjaro安(zhe)装(teng)记</title><link>https://111qqz.com/2016/12/manjarozheteng/</link><pubDate>Tue, 27 Dec 2016 04:40:53 +0000</pubDate><guid>https://111qqz.com/2016/12/manjarozheteng/</guid><description>
噫。。之前x200上装的是win7+fedora25 gnome。。。
虽然感觉gnome对于09年的老电脑来说有点吃力...不过也懒得换..
结果硬盘挂了2333 于是换了块硬盘
以及被人安利了manjaro，一个基于arch的linux发行版
还有就是因为平安夜又没有代码可以写又没有妹子可以陪觉得人生寂寞如雪
官网下好镜像以后，一开始用dd命令做u盘，发现启动不了。
无奈到win下用了poweriso制作，成功。
安装很顺利...基本就是傻瓜操作...
装好以后...装了vim...shadowsocks...chrome...fish...搜狗输入法。。。
添加了archcn的源
发现不能切换输入法。。。
解决办法：
在~/.xprofile 文件中添加如下内容 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot; 其他都挺顺利的。。
结果今天用着用着发现renkz2011这账户无法登录了。。。提示密码错误。。。
root账户是可以登录的。。。
于是我跑到root下登录。。。是可以的。。。
于是改了下renkz2011的密码。。。发现依然提示错误。。。
但是呢。。。我在root下做需要renkz2011权限的事情。。。输入密码就是没有问题的。。
我新建了一个账户。。。发现登录也没有问题。。。
奇怪啊。。。回想一下。。。我改了什么。。。
添加了archcn的源。。。
应该没关系。。。
还有就是。。。remove了zsh..?
于是我尝试着重新装回zsh...
再登录。。发现可以了。。。
回想一下。。。我在renkz2011账户下曾经设置默认shell为zsh...
卸载以后好像忘记更改了orz
但是。。。为什么和shell有关呢。。。</description></item><item><title>discourse邮件服务无法使用的解决方案</title><link>https://111qqz.com/2016/12/discourse/</link><pubDate>Sun, 25 Dec 2016 07:27:48 +0000</pubDate><guid>https://111qqz.com/2016/12/discourse/</guid><description>
解决办法:https://blog.discourse.org/2016/03/switching-your-discourse-from-mandrill-to-mailgun/</description></item><item><title>这几年我只做对了一个选择</title><link>https://111qqz.com/2016/12/</link><pubDate>Sat, 17 Dec 2016 12:51:41 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
https://www.zhihu.com/question/35659528/answer/136064981
高考。。保送...选择一错再错。
唯一正确的选择大概就是远离东北了吧。
真是幸运。
东北衰落不衰落是另一回事。
我不喜欢东北的人，虽然我也有很多朋友，他们人也很nice
但是大环境就是，学习没用，要懂得人情世故
看了这个回答回想起了以前的种种。
东北，是我的家乡，但是我不会再回去了。</description></item><item><title>20161217。。。</title><link>https://111qqz.com/2016/12/20161217/</link><pubDate>Sat, 17 Dec 2016 10:21:32 +0000</pubDate><guid>https://111qqz.com/2016/12/20161217/</guid><description>
不知道什么时候会死。。。
中弹。。。是谁。。。。？
竟然是。。。小学的一个同学。。。
肩膀。。。我要死了吗。。。
醒来以后回忆。。这个同学好像的确是去当兵了。。。
浑身酸痛的梦...</description></item><item><title>编译原理实验：词法分析器</title><link>https://111qqz.com/2016/12/</link><pubDate>Mon, 12 Dec 2016 09:02:12 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
实验一　设计实现简单语言的词法分析器 1、实验目的
通过该实验,熟练应用编译原理关于词法分析的基本理论和方法；学会用C/C++高级程序设计语言设计一个词法分析器；加深对编译原理理论的分析理解，提高实际操作和解决具体问题的能力。
2、实验条件
计算机上安装C/C++编译处理软件。
3、实验内容及要求
对下述单词表定义的语言设计编制一个词法分析器。单词符号及种别表和词法分析器功能及基本要求如下：
（1）单词符号及种别表
单词符号 种别编码 单词值 main 1 int 2 float 3 double 4 char 5 if 6 else 7 do 8 while 9 l(l|d)* 10 内部字符串 ( +|-|ε ) dd*(.</description></item><item><title>一些计划。。。</title><link>https://111qqz.com/2016/12/</link><pubDate>Fri, 09 Dec 2016 09:51:40 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
感觉owncloud的确很赞的样子。。。
小电影什么的。。我倒是需求不大。。。
不过作为同步盘感觉蛮赞的。。。
然而现在手头的服务器。。。除了论坛的vultr...都不是辣么有名的公司貌似。。。（国内的阿里云就算了。。。
所以现在的计划是。。。
等明年８月班瓦工到期。。。以及。。。不知道什么时候说不定就会tj的论坛。。。
打算买一个好一点的服务器orz，ss,owncloud，博客也搬过去吧...</description></item><item><title>fedora/centos　服务器搭建shadowsocks超时的解决办法</title><link>https://111qqz.com/2016/12/fedoracentosshadowsocks/</link><pubDate>Thu, 08 Dec 2016 07:42:54 +0000</pubDate><guid>https://111qqz.com/2016/12/fedoracentosshadowsocks/</guid><description>
操作肯定没有错，就是连接不上，显示超时
发现是防火墙的锅
具体请看：github_shadowsocks_issues_477</description></item><item><title>搭建论坛历程</title><link>https://111qqz.com/2016/12/</link><pubDate>Mon, 05 Dec 2016 08:32:38 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
。。。由于一些不可描述的原因。。。
和某个华师计科的妹子一拍即合。。。打算搞一个论坛出来。。。
算是做一些微小的贡献2333
一开始打算尝试dz...毕竟社区比较丰富...服务器的话。。先拿个免费的搭起来再说https://www.hostinger.com.hk/
不过安装失败了...还是数据库的问题...
加上被gyz安利了discourse...稍微看了下，感觉还是挺不错的。。。
不过考虑到，社交登陆方面,discourse貌似对fb,google+,twitter之类的支持良好..但是对于国内的....
至少对于我来讲，我是不愿意再多注册一个账号的..
而且日后可能要加一些功能。。。要自己写的那种。。。discourse的技术链。。。我真是一点也不懂2333（虽然php我懂的也不多。。。。
基于以上原因。。我还是先打算继续搞dz...
20161207update:搭好了。。。免费的服务器太不稳定。。。于是买了日本某公司的服务器2333.一个月１０刀。。。暂时我们三个人平摊吧。。。
然后选择了discourese...其实还是不错的2333
接下来的问题。。就是如何吸引第一批成员加入。。。
这个就交给她们两个了。。。</description></item><item><title>承认吧，我就是不喜欢和人在一起</title><link>https://111qqz.com/2016/12/</link><pubDate>Fri, 02 Dec 2016 03:37:49 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
原因大概是觉得...我好无趣啊...你也好无趣啊....何必浪费口舌在这里客套呢....</description></item><item><title>codeforces #382 div 2 E. Ostap and Tree (树形dp)</title><link>https://111qqz.com/2016/12/codeforces-382-div-2-e-ostap-and-tree-dp/</link><pubDate>Thu, 01 Dec 2016 13:44:50 +0000</pubDate><guid>https://111qqz.com/2016/12/codeforces-382-div-2-e-ostap-and-tree-dp/</guid><description>
题目链接
题意：将一棵树的若干点染成黑色，要求满足对于任何一个点u,至少存在一个距离其k以内的点v被染成黑色，问染色方案数。
思路：还没完全搞懂。。。记录一些idea...
参考题解
以及：该题解中说的children指的是子树全体。。。坑死好吗。。。坑了一晚上。。气啊。
**定义状态f[i][j]:以i为根的子树中，能向上贡献j个单位/需要外界往内填补j个单位，方案数** 如果是贡献，j为负数
转移的话，考虑不断合并子树,假如说当前处理x为根的子树
不妨把它的儿子按照输入顺序从左往右编号1~N
**一开始到x的时候，初始状态f[x][-k] = f[x][1] = 1 **
然后不断把儿子的信息合并给x
做法是x与儿子枚举每一个可能的j值然后判断一下这样的状态转移后如何，添加到辅助数组里
最后把辅助数组的值copy给f[x]，，
/* *********************************************** Author :111qqz Created Time :2016年12月07日 星期三 02时10分34秒 File Name :code/cf/#382/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD = 1E9+7; const int N=105; int n,k,ans,f[N][50],g[50]; vector&amp;lt;int&amp;gt;edge[N]; int F( int x) { return x+k; } int Add(LL x,LL y) { return (x+y)%MOD; } int Mul(LL x,LL y) { return x*y%MOD; } void dfs( int u,int pre) { f[u][F(-k)]=f[u][F(1)] = 1; for ( auto v:edge[u]) { if (v==pre) continue; dfs(v,u); ms(g,0); for ( int i = -k ; i &amp;lt;= k ; i++) { if (!</description></item><item><title>hdu 1520 Anniversary party (树形dp模板题)</title><link>https://111qqz.com/2016/11/hdu-1520/</link><pubDate>Wed, 30 Nov 2016 12:55:30 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-1520/</guid><description>
题目链接 题意：一个舞会，每个人有一个val，给出n个人之间的领导和被领导关系，一个人不愿意与他的领导同时参加，问一种安排方案，使得参加的人的val和最大，问这个最大的和是多少。
思路：树形dp模板题。
dp1[v]表示包含v节点的子树的最大值。
dp2[v]表示，不包含v节点的子树的最大值。
下面讲得很清楚。。
Now, similar to array problem, we have to make a decision about including node _V_ in our subset or not. If we include node _V_, we can't include any of its children(say _v_1, _v_2, ..., _v__n_), but we can include any grand child of _V_. If we don't include _V_, we can include any child of _V_. So, we can write a recursion by defining maximum of two cases.</description></item><item><title>树形dp学习资料</title><link>https://111qqz.com/2016/11/dp/</link><pubDate>Wed, 30 Nov 2016 12:10:49 +0000</pubDate><guid>https://111qqz.com/2016/11/dp/</guid><description>
资料１</description></item><item><title>关于代码插件　crayon　无法高亮的解决方案</title><link>https://111qqz.com/2016/11/crayon/</link><pubDate>Wed, 30 Nov 2016 08:37:57 +0000</pubDate><guid>https://111qqz.com/2016/11/crayon/</guid><description>
在最后一个标签　加上两个
（空格的字符表示　＆　＋　nbsp） 就好了。。。。</description></item><item><title>poj 3274 Gold Balanced Lineup (抽屉原理？错题？)</title><link>https://111qqz.com/2016/11/poj-3274/</link><pubDate>Wed, 30 Nov 2016 08:10:23 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-3274/</guid><description>
poj 3274 题目链接
题意：给出n个数和k，每个数不超过k位二进制。现在问最长的一段区间，满足该区间中所有数相加，k个位置上的数相等。
思路：k个位置上的数都相等的话。。。那这个和应该是(k&amp;lt;&amp;lt;1)-1的整数倍。。。
于是抽屉原理搞了一发。。一直wa..
正解是数字hash。。。
不过我拍了一下。。。如果不是我理解错了题意的话。。。我是把一份ac代码　hack掉了。。。。。
用来对拍的ac代码：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAX 100005 #define mod 1000000 //此处mod定义为99997时，运行时间1000多MS int hash[MAX*10];//hash表储存下标 int sum[MAX][35];//第 1 头牛到第 i 头的对应属性的和 int c[MAX][35];//存放每头牛属性 j与第一个属性的差 int n,k; int Hash_key(int *cc) { int j,key=0; for(j=1;j&amp;lt;k;j++) key=key%mod+cc[j]&amp;lt;&amp;lt;2;//此处用 * 乘超时 key=abs(key)%mod;//此处得到的key可能会是负数，所以取绝对值 return key; } int main() { int i,j,x,maxlen=0;//maxlen为最大长度 scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k); int l,r; memset(hash,-1,sizeof(hash));//初始化哈希表 hash[0]=0;//hash表首位初始化 for(i=1;i&amp;lt;=n;i++) { scanf(&amp;quot;%d&amp;quot;,&amp;amp;x); for(j=0;j&amp;lt;k;j++) { sum[i][j]=sum[i-1][j]+x%2; c[i][j]=sum[i][j]-sum[i][0]; x&amp;gt;&amp;gt;=1; } int key=Hash_key(c[i]); while(hash[key]!</description></item><item><title>poj 3349 Snowflake Snow Snowflakes (利用hash分组)</title><link>https://111qqz.com/2016/11/poj-3349/</link><pubDate>Wed, 30 Nov 2016 06:30:56 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-3349/</guid><description>
题意：有n个雪花，每个雪花有６瓣，给出每一瓣的长度，问是否有两个雪花相同。（雪花相同的条件是：存在某个顺序使得两个雪花的每一瓣长度对应相等）
思路：一开始想到的是先最小表示法。。。然后hash。。。存set。。看set的大小。。。但是因为我是顺时针，逆时针都存了一次，那么如果有一个雪花顺时针和逆时针相同，就会出现错误的结果（虽然这个我应该判掉了。。。但是还是WA　orz）
归根结底我是没有搞定当hash相同的时候，如何判定这两个不是一组orz。
看了很多题解。。。（为什么大家这道题的代码都写得这么丑啊。。。。？
思路有：hash或者最小表示法，或者最小表示法＋hash
思路是，把六瓣的长度求和，作为hash的key值。。。
然后。。。只在key相同的里面找一样的。。。
其实是根据这个和分了组。。。
因为和相同的，未必雪花一样，但是雪花的一样的，和一定相同，极大的缩小了范围。
也让我对hash有了新的理解：
hash未必可以唯一确定某个值，但是可以帮助缩小范围。
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 19时29分11秒 File Name :code/poj/3349.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int N=1e5+7; const int inf = 0x3f3f3f3f; int n; int a[N][6]; const int prime = 19997; //素数 vector&amp;lt;int&amp;gt;block[prime]; void Hash( int val,int x) { val%=prime; block[val].</description></item><item><title>codeforces #382 div2 D. Taxes(哥德巴赫猜想)</title><link>https://111qqz.com/2016/11/cf375d-2/</link><pubDate>Tue, 29 Nov 2016 11:16:28 +0000</pubDate><guid>https://111qqz.com/2016/11/cf375d-2/</guid><description>
题目链接
题意：一个人有n元前，他要交的税是n的最大因子（除n外)，现在这个投机倒把者想把前分成k部分(k为大于等于１的任意值）每部分不能为１，分别交税，问最少交多少税。
思路：要说因子小。。很容易想到素数。。。然后就很容易想到了维基百科_哥德巴赫猜想
内容是：任何一个大于２的偶数可以写成两个素数的和。
（虽然是一个猜想没有被证明。。。但是1E9这种级别正确性还是很显然的２３３３
那么任何大于２的偶数，答案就是２
奇数可以分成一个３和一个偶数，答案为３．
不过这可能还不够优，这也是这道题的两个trick所在：
如果该数本身为素数，那么不用分（k取１），答案为１
如果该数减去２为素数，那么答案为２．
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 11时36分56秒 File Name :code/cf/#382/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; bool prime( LL x) { for ( LL i = 2 ; i*i &amp;lt;= x ; i++) { if (x%i==0) return false; } return true; } LL solve( LL x) { if (prime(x)) return 1; if (x%2==0) return 2; if (x%2==1) { if (prime(x-2)) return 2; else return 3; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #382 div2 C. Tennis Championship(打表找规律）</title><link>https://111qqz.com/2016/11/cf735d/</link><pubDate>Tue, 29 Nov 2016 11:07:25 +0000</pubDate><guid>https://111qqz.com/2016/11/cf735d/</guid><description>
题目链接
题意：n个人进行淘汰赛制的比赛，输的人直接被淘汰，不进行下一轮，现在要求两个人可以比赛当且仅当两个人的胜场数相差小于等于１，现在问赢得最多场的那个人，最多可能赢多少场。
思路：打表找规律。。。麻蛋。。手算错了n=8。。。结果达成了f[1] = 2,fib[2] =4 的奇怪的fib数列。。。卡了一个多小时。。。气哭了。。。
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 10时16分50秒 File Name :code/cf/#382/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned long long n; unsigned long long x,y,z; unsigned long long solve( unsigned long long xx) { if (xx&amp;lt;=2) return 1; if (xx&amp;lt;=4) return 2; x = 1; y = 2; int p; unsigned long long cur = 4; for ( int i = 3 ; ; i++) { z = x + y; x = y; y = z; cur = cur + z; if (cur&amp;gt;=xx) { p = i; break; } } //cout&amp;lt;&amp;lt;p&amp;lt;&amp;lt;endl; return p; } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1257: [CQOI2007]余数之和sum (数学)</title><link>https://111qqz.com/2016/11/bzoj-1257-cqoi2007sum-/</link><pubDate>Mon, 28 Nov 2016 14:03:30 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1257-cqoi2007sum-/</guid><description>
1257: [CQOI2007]余数之和sum Time Limit: 5 Sec Memory Limit: 162 MB Submit: 3724 Solved: 1711 [Submit][Status][Discuss]
Description 给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7
Input 输入仅一行，包含两个整数n, k。
Output 输出仅一行，即j(n, k)。
Sample Input 5 3
Sample Output 7
HINT 50%的数据满足：1&amp;lt;=n, k&amp;lt;=1000 100%的数据满足：1&amp;lt;=n ,k&amp;lt;=10^9</description></item><item><title>bzoj 1008: [HNOI2008]越狱(对立事件，组合数学)</title><link>https://111qqz.com/2016/11/bzoj-1008-hnoi2008/</link><pubDate>Mon, 28 Nov 2016 08:31:10 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1008-hnoi2008/</guid><description>
1008: [HNOI2008]越狱 Time Limit: 1 Sec Memory Limit: 162 MB Submit: 8165 Solved: 3486 [Submit][Status][Discuss]
Description 　监狱有连续编号为1...N的N个房间，每个房间关押一个犯人，有M种宗教，每个犯人可能信仰其中一种。如果 相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱
Input 　输入两个整数M，N.1&amp;lt;=M&amp;lt;=10^8,1&amp;lt;=N&amp;lt;=10^12
Output 　可能越狱的状态数，模100003取余
Sample Input 2 3
Sample Output 6
HINT 　6种状态为(000)(001)(011)(100)(110)(111)
思路：越狱的情况很多，考虑不越狱的情况。
答案为：m^n - m*(m-1)^(n-1)
/* *********************************************** Author :111qqz Created Time :2016年11月28日 星期一 16时23分38秒 File Name :code/bzoj/1008.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL mod =100003; LL ksm( LL a,LL b,LL k) { LL res = 1; while (b&amp;gt;0) { if (b&amp;amp;1) res = (res * a)%k; b = b &amp;gt;&amp;gt; 1LL; a = (a*a)%k; } return res; } LL n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1192: [HNOI2006]鬼谷子的钱袋</title><link>https://111qqz.com/2016/11/bzoj-1192/</link><pubDate>Mon, 28 Nov 2016 08:14:53 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1192/</guid><description>
1192: [HNOI2006]鬼谷子的钱袋 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 3192 Solved: 2313 [Submit][Status][Discuss]
Description 鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。但是，他的行程安排得很满，他他已经买好了去邯郸的长途马车标，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？
Input 包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。
Output 只有一个整数h，表示所用钱袋个数
Sample Input 3
Sample Output 2
思路：转化成二进制表示....还是蛮容易想到的吧。
/* *********************************************** Author :111qqz Created Time :2016年11月28日 星期一 15时31分21秒 File Name :code/bzoj/1192.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int two[60]; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces #381 div2 E. Alyona and towers (线段树 区间合并)</title><link>https://111qqz.com/2016/11/cf740e/</link><pubDate>Mon, 28 Nov 2016 07:16:52 +0000</pubDate><guid>https://111qqz.com/2016/11/cf740e/</guid><description>
e:题意：那个数，定义hill为一段连续的区间，满足该区间为严格单峰。现在有若干操作，每个操作是对某段区间的数同时增加一个数，问每次操作后，所有的hill中，宽度最大的（区间长度最大）的是多少。
思路：同时增加一个数很线段树。。。但是要维护什么呢。。。？
_猜测：肯定要维护一个区间中hill的最大宽度..._ 但是合并的时候要怎么办呢。。。
考虑两个方向的合并。。。
所以还要维护一个区间中，包含右端点的向左单调减延伸的长度，以及左端点的值。
同理，要维护一个区间中，包含左端点的向右单调增延伸的长度，以及右端点的值。
那么每次pushup的时候，就是两个区间hill的最大值，以及两个方向合并的最大值中取最大。。。
。。。上面是我口胡的。。。
upd:
口胡的还是有点靠谱的（并没有2333，还是漏了情况）
具体题解见代码注释
以及，为了过这道题先过了在岛老师空间题解中提到的两道题目：
hdu 3308 题目链接
hdu 5367题目链接
/* *********************************************** Author :111qqz Created Time :2016年11月27日 星期日 22时16分44秒 File Name :code/cf/#381/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int a[N]; int n,m; struct Tree { LL lm,rm;//左右端点值。 int ans,len,upL,upR,downL,downR,maxL,maxR; /* 分别为 * ans:区间最优解 * len:区间长度 * upL,downL,maxL：包含左端点的递增，递减，山型的长度 * upR,downR,maxR: 包含右端点的递增，递减，山型的长度 */ Tree() { ans = len = upL = upR = downL = downR = maxL = maxR = lm = rm = 0; } Tree( int x) { ans = len = upL = upR = downL = downR = maxL = maxR = 1; lm = rm = x; } }; Tree operator + ( Tree x,Tree y) //x为左子树所表示的区间，y为右子树所表示的区间 { Tree res; if (x.</description></item><item><title>codeforces 381 div 2 D. Alyona and a tree(二分+前缀和)</title><link>https://111qqz.com/2016/11/cf740d/</link><pubDate>Mon, 28 Nov 2016 07:07:00 +0000</pubDate><guid>https://111qqz.com/2016/11/cf740d/</guid><description>
题目链接
d:题意：一棵树，给出边权和点权，定义点v控制点u，当且仅当u是v的子树中的点，并且dis(u,v)&amp;lt;=a[u]，其中dis(u,v)为点u到点v路径上的边权和，a[u]为点u的点权，现在问对于每个节点v，其能控制的点有多少个。
思路：先写了个rmq+dfs的lca。。。那么任意两个点的距离都可以O(1)得到了。然后不会了233333.
upd:和lca没有什么关系，因为一个点能控制另一个点这两个点一定在一条通向根的链上，因此距离直接减一下就好了。
机智的做法：dfs的时候维护一个栈，对于栈中序列，后面一半是对当前点有贡献的。问题时求对于每个v统计其能控制多少个u，现在我们固定u，考虑能控制他的v。这些v在树上的形态时一条链 ，借助第二类前缀和的思想，对于u标记+1，对于u往上的离根最近的且能统治u的v上面的一个标记-1，然后dfs后序遍历（也就是链的起点时距离根远的那一边），距离处理的时候，只需要在递归之后更新ans就好了。
栈里面维护，到哪个节点，从根下来，边权和最大，找边权和&amp;gt;=当前边权和-a[u]的地方。
启示：由于两个存在统治关系的点在一条链上，边权都为正，边权和具有单调性，单调的东西，容易想到二分处理。
/* *********************************************** Author :111qqz Created Time :2016年11月24日 星期四 09时17分48秒 File Name :code/cf/#381/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int a[N]; LL dis[N]; vector&amp;lt; pair&amp;lt;int,LL&amp;gt; &amp;gt;edge[N]; vector&amp;lt; pair&amp;lt;LL,int&amp;gt; &amp;gt;path; int ans[N]; void dfs( int u,int pre) { ans[u]++; int idx = lower_bound(path.</description></item><item><title>codeforces #381 div 2 C. Alyona and mex (构造)</title><link>https://111qqz.com/2016/11/cf740c/</link><pubDate>Mon, 28 Nov 2016 07:03:51 +0000</pubDate><guid>https://111qqz.com/2016/11/cf740c/</guid><description>
题目链接
题意：
m个区间，要求构造一个长度为n的数组，满足m个区间中，每个区间的mex值中的最小值最大。
s思路：很容易想到的是...这个最大的mex 不可能超过每一组区间长度，假设最小的区间长度为mn
那么是否一定可以构造出mex为mn的数组呢？
是的。
只需要按照
0,1,2...mn-1,0,1....的方式构造即可。
/* *********************************************** Author :111qqz Created Time :2016年11月24日 星期四 09时00分04秒 File Name :code/cf/#381/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; struct node { int l,r; int len; bool operator &amp;lt; ( node b)const { if (r==b.</description></item><item><title>hdu 5367 digger(动态线段树，区间合并)</title><link>https://111qqz.com/2016/11/hdu-5367-digger/</link><pubDate>Sun, 27 Nov 2016 08:59:09 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-5367-digger/</guid><description>
题目链接
题意：
地主小花有n座山，这些山在地主家门前排成一条直线。这些山一开始均有相同的高度。 每一天，小花都会要求ZJiaQ开挖机把几座山挖掉一定高度，或者给一些山堆上一些高度。并且要求报告ZJiaQ报告现在有多少座山属于“高山脉” 当一排山的高度相等，并且比这排山左边和右边的山要高时，这排山被称为高山脉。 当然，最左边和最右边的山不可能是“高山脉”的一部分 思路：线段树，要维护的域蛮多的。
下面高山脉简称&amp;quot;HM&amp;quot;
sum:区间中HM的总长度。
lsum,rsum,区间中包含左端点，右端点的高度相同的山的长度。
lh,rh：区间中包含左端点，包含右端点的的高度相同的山的高度。
llh,rrh:从左端点向右，从有段点向左的，第一个高度不相同的山的高度。
由于这道题n有1E9，没办法像以前的办法build 线段树，因此我们采用动态线段树的技巧。
官方题解：
对于求“高山脉”长度，可以利用线段树。树节点中保存左高度连续长度，左高度连续区间的高度，左高度连续区间的状态（即是否高于第一个高度不同的山），右高度连续长度，右高度连续区间的高度，右高度连续区间的状态，每段区间内的“高山脉”数量。每次更新时更新高度即可，在pushup过程中去计算新产生的“高山脉”。写起来难度不是很大，然后对于n很大且必须在线做这个条件只需对于**线段树动态建立节点**去维护即可 关于动态线段树：
平时我们做的线段树，假设区间为[1,n]，那我们通常都是直接以 1 号点表示区间【1，n】，以 i2 号点表示 i 节点代表区间的左半区间，以 i2+1 号点表示 i 节点多代表区间的右半区间，一半空间长度都定义为4*n。
 在本题中，n比较大，直接将所有线段树中的所有节点定义出来不现实，那我们注意到，这道题实际上是对区间进行的一系列操作，那么就可能存在一个区间【l，r】，在所有处理过程中，该区间都可以被当做一个整体来看待。 如果是这样的话，我们定义出与该区间的子区间相对应的节点就没有意义了。
 动态生成线段树就是：假设对某一节点 p (代表区间【l，r】)进行处理时，并不是对整个区间[l，r]进行处理，而是对其某个子区间进行处理，那这个时候，该区间就不能一直被当做一个整体来看待，所以生成两个初始子节点lp、rp（节点之均为初始值），表示该区间的左半部分与右半部分，然后父节点 p 在对两个新生成的子节点进行更新。
/* *********************************************** Author :111qqz Created Time :2016年11月27日 星期日 14时45分27秒 File Name :code/hdu/5367.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int INF = 0x3f3f3f3f; const int N=5E4+7; int cur,root; int n,q,nnn; struct Tree { int sum;//高山脉的长度和 int child[2];//左右孩子的编号 int rsum,lsum;//从左端点，右端点其高度相同的连续的山有多少个。 int lh,rh;//左边连续，右边连续的山的高度。 int llh,rrh;//从左边往右第一个不连续，从右边往左第一个不连续的山的高度。 int lazy; void init(int l,int r) { sum = child[0] = child[1] = lh = rh = llh = rrh = lazy = 0; lsum = rsum = r-l+1; //初始所有高度相同，所以高度相同的连续的山的个数等于区间长度。 } }; struct SegmentTree{ Tree tree[N*60]; void check(int &amp;amp;rt,int l,int r) { //cout&amp;lt;&amp;lt;&amp;quot;rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; if (rt) return; rt=++cur; tree[rt].</description></item><item><title>hdu 3308 LCIS (线段树单点更新，区间合并)</title><link>https://111qqz.com/2016/11/hdu-3308/</link><pubDate>Sat, 26 Nov 2016 11:21:26 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-3308/</guid><description>
题目链接
题意：长度为n的序列，单点更新，或者询问某一个区间中最长连续严格递增序列的长度是多少。（此处的连续为位置连续，并非数值连续，也就是3,5,7,9，这样的就是满足题意的长度为4的序列）
思路：线段树区间合并。维护三个域。
mx:区间中最长连续严格递增序列的长度
lm:包含区间左端点的最长连续严格递增序列的长度。
rm:包含区间右端点的最长连续严格递增序列的长度。
PushUp的时候，一个区间的答案显然可以从左右两个子区间的最大值得到。
还有一种可能是左右区间各取一部分，此时必须满足左区间的右端点值严格小于右区间的左端点值。
需要注意的是，如果某区间的最长连续严格递增子序列的长度等于区间长度，那么该区间可以向相应方向延伸。
查询的时候也是如此，要记得查询的时候，某一段区间对答案贡献不会超过区间长度。。
hdu有点坑。。。函数名不能命名为update...update2也不行2333
/* *********************************************** Author :111qqz Created Time :2016年11月26日 星期六 18时12分49秒 File Name :code/hdu/3308.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int a[N]; struct Tree { int mx,lm,rm; }tree[N&amp;lt;&amp;lt;2]; void PushUp(int rt,int l,int r) { tree[rt].</description></item><item><title>codeforces #381 div2</title><link>https://111qqz.com/2016/11/codeforces-381-div2/</link><pubDate>Thu, 24 Nov 2016 02:09:13 +0000</pubDate><guid>https://111qqz.com/2016/11/codeforces-381-div2/</guid><description>
http://codeforces.com/contest/740
A:现在有n个某种物品，要买k个使得n+k是4的倍数，可以的购买方案为a元1个，b元2个，c元3个，每种方案都可以买无限多。
思路：需要注意买多个未必比买少个贵..
所以分情况讨论：n%4==0，输出0
n%4==1，需要买3+4k个，
可以的方案为，买1个c，或者3个a，或者1个a 1个b（此处用价钱指代方案，下同）
n%4==2时，需要买2+4k个
可以的方案为：2个a，或者1个b，或者2个c
n%4==3时，需要买4K+1个
可以的方案为：1个a,或者1个b+1个c，或者3个c
注意要开long long.
/* *********************************************** Author :111qqz Created Time :2016年11月24日 星期四 08时09分32秒 File Name :code/cf/#381/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1971 Parallelogram Counting</title><link>https://111qqz.com/2016/11/poj-1971/</link><pubDate>Tue, 22 Nov 2016 15:08:14 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-1971/</guid><description>
题目链接
题意：给出n（n&amp;lt;=1E3）个不同的点，问最多组成多少个平行四边形。
思路：这道题的关键是，对于平行四边形的判断条件，要利用平行四边形对角线的交点平分两条对角线的性质。
也就是说，如果两条线段的对角线重合，那么一定可以组成一个平行四边形。
因此统计中点的位置即可，复杂度nnlg(n*n)
/* *********************************************** Author :111qqz Created Time :2016年11月22日 星期二 22时43分26秒 File Name :code/poj/1971.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct point { int x,y; bool operator &amp;lt; (point b)const { if (x==b.</description></item><item><title>poj 1200 Crazy Search (字符串哈希)</title><link>https://111qqz.com/2016/11/poj-1200/</link><pubDate>Tue, 22 Nov 2016 14:02:41 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-1200/</guid><description>
题目链接
题意：一个字符串，其仅由nc种字符组成，问其所有长度为n的字串里，共用多少种不同的。
思路：一开始木有懂nc种字符有什么用...
然后写了hash，发现会TLE。。。因为用到了map，被卡了个log..
nc的作用是，可以把字符串看成一个nc进制的数，这样做的好处是，得到的hash值可以尽可能的小而且保证了不同的字符串对应了不同的hash值。
然后就可以不用map而是一个数组，就变成了O(1)赋值和判断了。。。
（然而没有数据范围其实还是有点耍流氓的嫌疑。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std; const int N=16000005; //题目给出子串的最大和不超过16M const int NUM=257; bool Hash[N]; int m[NUM]; char str[1000000]; int n,nc,i,j,sum,seed=0,ans=0; int main() { // freopen(&amp;quot;code/in.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); memset(Hash,false,sizeof(Hash)); memset(m,0,sizeof(m)); memset(str,'\0',sizeof(str)); cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;nc&amp;gt;&amp;gt;str; int len = strlen(str); for(int i = 0 ; i &amp;lt; len; ++i) { if(!m[str[i]]) //将每个字符赋值为相应进制的数 m[str[i]]=++seed; if(seed == nc) break; } for(i=0;i&amp;lt;=len-n;++i) { sum=0; for(j=0;j&amp;lt;n;++j) //将字符串str[i],..,str[i+n-1]变为一个nc进制的整数,来判断是否重复出现过 sum=sum*nc+m[str[i+j]]-1; if(!Hash[sum]) { Hash[sum]=true; ++ans; } } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>hdu 1800 Flying to the Mars (字符串hash)</title><link>https://111qqz.com/2016/11/hdu1800/</link><pubDate>Tue, 22 Nov 2016 11:41:34 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu1800/</guid><description>
题目链接
题意：n个人，每个人有一个level值，用一个最长30位的，可能带前缀0的数字串表示，如果i的level大于j的level，那么i可以教j飞行，每个人只能有一个老师，每个人也只能收一个徒弟。师生可以共用一把扫帚飞行。现在问最少需要多少扫帚。
思路：分析发现，影响扫帚多少的是相等的数有多少，因为只要不相等，就肯定可以构成师生关系....
更确切得说，是所有数出现次数的最大值。
有一个trick点，就是带前缀0和不带前缀0的两个level被认为是相等的，hash的时候要处理前缀0.
/* *********************************************** Author :111qqz Created Time :2016年11月22日 星期二 19时18分30秒 File Name :code/hdu/1800.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned int BKDHash(char *str) { unsigned int seed = 251; unsigned int hash = 0 ; while (*str=='0') str++; //带前缀0的和不带前缀0的认为是同一个数，因此要处理前缀0.</description></item><item><title>codeforces 4C. Registration system (字符串hash)</title><link>https://111qqz.com/2016/11/cf4c/</link><pubDate>Tue, 22 Nov 2016 11:11:26 +0000</pubDate><guid>https://111qqz.com/2016/11/cf4c/</guid><description>
题目链接
题意：网站的注册系统..处理用户要注册的用户名，如果数据库中没有重名输出OK，否则输出要注册的用户名的字符串+num,num的大小为之前一共有多少个用户试图用该用户名。
思路：hash一下。。。
/* *********************************************** Author :111qqz Created Time :2016年11月22日 星期二 19时00分58秒 File Name :code/cf/problem/4C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned int BKDHash(char *str) { unsigned int seed = 113; unsigned hash = 0 ; while (*str) hash = hash*seed+(*str++); return (hash&amp;amp;0x7fffffff); } map&amp;lt;int,int&amp;gt;mp; int n; const int N=1E5+7; char str[33]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2503 Babelfish (字符串hash +sscanf读入技巧)</title><link>https://111qqz.com/2016/11/poj-2503/</link><pubDate>Tue, 22 Nov 2016 10:59:16 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-2503/</guid><description>
题目链接
题意：给定一个两种语言的对照关系表...给出后一种语言中的单词，问对应的前一种语言的单词是什么。。。
思路：hash一下然后map存一下即可。。。。读入方式由于单词表和查询是根据空行分开的。。那么读入不能用scanf(因为会跳过空行），要用gets。。。然后再sscanf一下。。。
/* *********************************************** Author :111qqz Created Time :2016年11月20日 星期日 11时13分29秒 File Name :code/poj/2503.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char eng[N][12],fori[N][12]; char str[N]; map&amp;lt;int,int&amp;gt;mp; unsigned int BKDRHash(char *str) { unsigned int seed = 113; unsigned int hash = 0 ; while (*str) hash = hash*seed+(*str++); return (hash&amp;amp;0x7fffffff); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1880 魔咒词典 (字符串hash)</title><link>https://111qqz.com/2016/11/hdu-1880--hash/</link><pubDate>Sun, 20 Nov 2016 03:08:58 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-1880--hash/</guid><description>
题目链接
题意：给你一部魔咒词典。当哈利听到一个魔咒时，你的程序必须告诉他那个魔咒的功能；当哈利需要某个功能但不知道该用什么魔咒时，你的程序要替他找到相应的魔咒。如果他要的魔咒不在词典中，就输出“what?”
思路：hash裸题。。。然而怎么感觉是第一次写hash呢。。。。
/* *********************************************** Author :111qqz Created Time :2016年11月20日 星期日 10时27分05秒 File Name :code/hdu/1880.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char magic[N][25],fun[N][81]; int cnt; int n; map&amp;lt;int,int&amp;gt;mp1,mp2; unsigned int BKDRHash(char *str) { unsigned int seed = 131; unsigned int hash = 0 ; while (*str) hash = hash*seed+(*str++); return (hash&amp;amp;0x7fffffff); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 2456: mode (O(1)找到出现次数大于n/2的数)</title><link>https://111qqz.com/2016/11/bzoj-2456-mode-o1n2/</link><pubDate>Sun, 20 Nov 2016 01:22:28 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-2456-mode-o1n2/</guid><description>
2456: mode Time Limit: 1 Sec Memory Limit: 1 MB Submit: 3887 Solved: 1636 [Submit][Status][Discuss]
Description 给你一个n个数的数列，其中某个数出现了超过n div 2次即众数，请你找出那个数。
Input 第1行一个正整数n。 第2行n个正整数用空格隔开。
Output  一行一个正整数表示那个众数。
Sample Input 5 3 2 3 1 3
Sample Output 3
HINT 100%的数据，n&amp;lt;=500000，数列中每个数&amp;lt;=maxlongint。
zju2132 The Most Frequent Number
思路：一开始没注意空间限制...不过为毛是TLE。。。以至于最后什么都不干也TLE，我才意识到问题并没有辣么简单。。。
感觉这道题好神奇。
用到了抵消的思想，对于众数来说，不是众数的数是“非我族类其心必异”
因为众数出现大于n/2次，所以最后剩下的数一定是众数。
具体见代码。
/* *********************************************** Author :111qqz Created Time :2016年11月18日 星期五 21时52分27秒 File Name :code/bzoj/2456.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; int n; int main() { scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); int cnt = 0 ; int val; int x; for ( int i = 1 ;i &amp;lt;= n ; i++){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;x); if (cnt==0) { cnt++; val = x; continue; } if (x==val) cnt++; else cnt--; } printf(&amp;quot;%d\n&amp;quot;,val); return 0; }</description></item><item><title>Mutual Training for Wannafly Union #1</title><link>https://111qqz.com/2016/11/mutual-training-for-wannafly-union-1/</link><pubDate>Sat, 19 Nov 2016 16:50:11 +0000</pubDate><guid>https://111qqz.com/2016/11/mutual-training-for-wannafly-union-1/</guid><description>
比赛链接
题外话：
wannafly union:可能有的学校不能很好得传承……可能某一时间可以进过两三次final ……但是final队过后，这个学校就退出了历史的舞台…… 说实话我依然记得我入学那年，也就是14年，看到了华科又一次进final，然后15年仿佛已经开始走下坡路，到了16年，icpc连快银都没有....见证了hust的衰落，我的内心是格外凄凉的。
而又不仅仅是见证...内心是有些愧疚的....总觉得自己没能把某些传统传承下去。。。。
曾经我以为学校的荣誉轮不到我去争取，毕竟我实力很弱，高中noip虽然有全省第二...但是大弱省....其实我当年只有275分...
14级的一队...pyy+zk+tm，三个人都是初一就开始参加比赛了....而且湖南+广东+安徽....
其他人，也至少比我发展均衡....
所以之前想着...弱鸡如我好好提高学校的下限就好了....
但是现在发现并不是那么一回事...
其实每个人...都是和学校相关的....
即使最后轮不到我...但是应该仍然有这个想法才对吧....
好了正题：
这次比赛只做出了三道题，A题之前遇到过，当时不会，忘记补了。目测E题也可以补，不过明天约了妹子自习估计要早睡，所以考完试再说吧。
A：
题意：有一个3*n的maze，一个人初始在最左边的某个格子里（3个中的一个，用s表示），然后有若干由大写字母组成的火车...
每一次运动中：人先向右移动一个格子，然后选择不动，或者向上或者向下（具体取决于现在处在3行中的哪一行），之后每列火车向左移动2个格子。如果某个时刻人和火车位于同一个格子，那么人就狗带了。人的获胜条件是到达最右边。
思路：比赛的时候脑抽。。。竟然觉得是指数模型。。。。然后就觉得想错了orz
这道题可以考虑物理的相对运动，我们可以认为火车是不动的，而人时先向右一个格子，然后换行（或者不换）,然后再向右两个
这样直接bfs搞一下就好咯。。。。果然是水题。。。。
/* *********************************************** Author :111qqz Created Time :2016年11月19日 星期六 18时56分06秒 File Name :code/wfly/#1/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E3+15; int n,k; char maze[4][N]; struct node { int x,y; void out() { printf(&amp;quot;x:%d y : %d\n&amp;quot;,x,y); } }s; int a[3][N]; bool vis[3][N]; bool ok; void bfs() { ms(vis,false); queue&amp;lt;node&amp;gt;q; while (!</description></item><item><title>反思</title><link>https://111qqz.com/2016/11/Reflection/</link><pubDate>Sat, 19 Nov 2016 10:59:39 +0000</pubDate><guid>https://111qqz.com/2016/11/Reflection/</guid><description>
我的问题。。。大概在于。。。
太容易中途弃疗。。以及。。。没有成为队伍carry的觉悟。。。或者说信心。。。</description></item><item><title>bzoj 1968: [Ahoi2005]COMMON 约数研究 (思维题)</title><link>https://111qqz.com/2016/11/bzoj-1968-ahoi2005common--/</link><pubDate>Fri, 18 Nov 2016 13:50:26 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1968-ahoi2005common--/</guid><description>
1968: [Ahoi2005]COMMON 约数研究 Time Limit: 1 Sec Memory Limit: 64 MB Submit: 1997 Solved: 1508 [Submit][Status][Discuss]
Description Input 只有一行一个整数 N（0 &amp;lt; N &amp;lt; 1000000）。
Output 只有一行输出，为整数M，即f(1)到f(N)的累加和。
Sample Input 3
Sample Output 5
HINT Source Day2
思路：如果跟着题目的意思走。。。求每个数的约束个数。。。复杂度是不资瓷的。。。
然而因为是求和，我们可以直接考虑，每个因子对答案的贡献。
容易知道，因子x对答案的贡献为n/x
x的范围为1..n
/* *********************************************** Author :111qqz Created Time :2016年11月18日 星期五 21时46分37秒 File Name :code/bzoj/1968.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 2463: [中山市选2009]谁能赢呢？ (博弈论)</title><link>https://111qqz.com/2016/11/bzoj-2463-2009-/</link><pubDate>Fri, 18 Nov 2016 13:33:01 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-2463-2009-/</guid><description>
2463: [中山市选2009]谁能赢呢？ Time Limit: 10 Sec Memory Limit: 128 MB Submit: 1826 Solved: 1347 [Submit][Status][Discuss]
Description 小明和小红经常玩一个博弈游戏。给定一个n×n的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？
Input 输入文件有多组数据。
输入第一行包含一个整数n，表示棋盘的规模。
当输入n为0时，表示输入结束。
Output 对于每组数据，如果小明最后能赢，则输出”Alice”, 否则输出”Bob”, 每一组答案独占一行。
Sample Input 2 0
Sample Output Alice
HINT 对于所有的数据，保证1&amp;lt;=n&amp;lt;=10000。
思路：手写了下几组猜是奇偶性..写了下就过了。
证明：
**首先对于n是偶数，一定能被1*2的骨牌覆盖！所以从起点开始，先手一定走的是骨牌的另一端，后手一定走的是骨牌的前一端，因此无论何时，先手总是可以走。因此先手必胜。** 如果n是奇数，那么去掉一格后一定能被1*2的骨牌覆盖，但是先手从左上角走，就进入了这个S态（必胜态），那么和上边的分析一样了，因此先手必败。
/* *********************************************** Author :111qqz Created Time :2016年11月18日 星期五 21时28分43秒 File Name :code/bzoj/2463.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>sigh</title><link>https://111qqz.com/2016/11/sigh/</link><pubDate>Fri, 18 Nov 2016 09:27:05 +0000</pubDate><guid>https://111qqz.com/2016/11/sigh/</guid><description>
上编译原理课 写题...被老师干了QAQ
还好他的提问我没回答错Orz，不然更惨
吓傻了2333</description></item><item><title>。。。。。。。。</title><link>https://111qqz.com/2016/11/depression/</link><pubDate>Thu, 17 Nov 2016 16:04:28 +0000</pubDate><guid>https://111qqz.com/2016/11/depression/</guid><description>
这样下去迟早抑郁....</description></item><item><title>【叉姐的魔法训练第一课_初级魔法练习】poj 3244 Difference between Triplets （数学）</title><link>https://111qqz.com/2016/11/poj-3244/</link><pubDate>Thu, 17 Nov 2016 13:22:47 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-3244/</guid><description>
题目链接
题意： For every pair of triplets, Ta = (Ia, Ja, Ka) and T__b = (Ib, Jb, Kb), we define the difference value between Ta and_T__b_ as follows:
D(Ta,_ Tb_) = max {Ia − Ib, Ja − Jb, Ka − Kb} − min {Ia − Ib, Ja − Jb, Ka − Kb}
Now you are given N triplets, could you write a program to calculate the sum of the difference values between every unordered pair of triplets?</description></item><item><title>【叉姐的魔法训练第一课_初级魔法练习】poj 2443 Set Operation ( bitset加速)</title><link>https://111qqz.com/2016/11/poj2443/</link><pubDate>Thu, 17 Nov 2016 02:29:19 +0000</pubDate><guid>https://111qqz.com/2016/11/poj2443/</guid><description>
poj 2443题目链接
题意：给出n个可重集...以及集合中的元素。。。现在若干查询，每个查询给出一对数x,y，询问是否存在某个集合，同时拥有x,y两个元素（x,y可以相同）
思路：由于x,y最大时10000，容易想到对每一个元素开一个集合，记录这个元素出现的集合的标号，然后用 set_intersection 来做...
就是询问的时候交一下两个集合，看是否为空，结果Tle了。。。
正解其实也是这个思路，不过用到了bitset加速一下。因为我求集合相交的时候，并不需要知道交了以后的结果，只需要知道是否为空，那么我们不妨用bitset
对每个元素开一个bitset,每个bitset上，第i位为1表示，该元素在第i个集中中出现了。
求相交的时候，只需要两个bitset 位与一下，然后看结果中是否有1出现就好了。
/* *********************************************** Author :111qqz Created Time :2016年11月17日 星期四 09时31分16秒 File Name :code/poj/2442.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; set&amp;lt;int&amp;gt;se[N]; bitset&amp;lt;1005&amp;gt;bse[N],tmp; set&amp;lt;int&amp;gt;myset; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>(dp专题006)hdu 2602 Bone Collector（01背包）</title><link>https://111qqz.com/2016/11/hdu2602/</link><pubDate>Wed, 16 Nov 2016 07:28:33 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu2602/</guid><description>
题目链接
题意:容量为V的背包，n个骨头，给出价值和体积，问最多能装多少价值的背包。
思路：01背包裸体。
/* *********************************************** Author :111qqz Created Time :2016年11月16日 星期三 15时14分36秒 File Name :code/hdu/2602.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int dp[N],value[N],cost[N]; int n,V; void solve(int v,int c) { for ( int i = V; i &amp;gt;= c; i --) dp[i] = max(dp[i],dp[i-c]+v); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>[dp专题005]hdu 1864最大报销额（01背包，垃圾题）</title><link>https://111qqz.com/2016/11/hdu1864/</link><pubDate>Wed, 16 Nov 2016 07:04:20 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu1864/</guid><description>
hdu1864题目链接
题意：中文题目，不多说了。
思路：正解是01背包，呵呵呵。
出题人是傻逼吗？
不给数据范围？
以及，正解的01背包基于所有的发票额度的只有2位小数。这是让人猜？
本来看到这题这么恶心时不打算写的...
写了的原因纯粹是为了吐槽傻逼出题人..
简直是我做得最垃圾的题目之一。
/* *********************************************** Author :111qqz Created Time :2016年11月16日 星期三 14时13分28秒 File Name :code/hdu/1864.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E6+7; double P; int n; int dp[N], value[35]; void solve( int value,int cost ) { for ( int i = int(P) ; i &amp;gt;= cost ; i--) dp[i] = max(dp[i],dp[i-cost]+value); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>(dp专题004)hdu 2955Robberies（01背包变形）</title><link>https://111qqz.com/2016/11/hdu2955/</link><pubDate>Tue, 15 Nov 2016 11:19:56 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu2955/</guid><description>
题目链接
题意： 给出n个银行 ，以及抢劫每个银行可以得到的价值和被抓的概率，不同银行之间被抓的概率是相互独立的，现在给出安全概率p，只有当概率从小于安全概率时才是安全的，问最多能抢劫多少价值。
思路：一开始很直接就想到把概率算成容量，
于是就成了经典的01背包，然后发现概率是double型。。。想当然得以为最多是2位小数，于是都*100转化成了整数做01背包。
然而正确思路是，把银行价值看成背包容量，而背包价值是概率！
将危险的概率转化成安全概率（1-危险概率=安全概率)
然后做01背包。
然后从大到小扫一遍价值，第一个大于安全概率的就是答案。
注意精度。
/* *********************************************** Author :111qqz Created Time :Tue 15 Nov 2016 06:53:53 PM CST File Name :code/hdu/2955.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; double dp[N]; double p; int n,V; int value[N]; double cost[N]; void solve(double Cost,int Value) { for ( int i = V ; i &amp;gt;= Value ; i--) dp[i] = max(dp[i],dp[i-Value]*Cost); } int dblcmp( double d) { return d&amp;lt;-eps?</description></item><item><title>对deepin失望至极</title><link>https://111qqz.com/2016/11/deepin-is-so-poor/</link><pubDate>Mon, 14 Nov 2016 16:08:21 +0000</pubDate><guid>https://111qqz.com/2016/11/deepin-is-so-poor/</guid><description>
前几天忘记什么原因，把gnome的什么东西搞坏了，干脆就换了kde.
然后发现kde太多细节，而且换了kde之后，关机键是失灵的.....我也不知道为什么，总之是各种难用。
本打算就换回gnome好了。。不过想起gnome下的那个（kde下也有）不定时键盘卡死，以至于出现了好几次代码写到一半，没法保存的情况.....
于是想了想...
ubuntu反人类还是算了....
mint可以应该可以（如果驱动没问题...）不过我印象里mint的内核才3+...? 好菜啊。。。。
其实另一台本上的fedora22用起来没啥问题....无奈2016款的x1c无法安装...
于是想到了deepin...
看了下评价还不错...而且我也快过了爱折腾的年龄了。。。开箱即用也蛮好的。。。。省心。
于是官网下载镜像。。。用官方工具制作启动盘。
制作成功。。。。然而...卡死在引导界面。。。（表现为光标一直闪烁）
。。。。官方的工具都这么不靠谱？ 那我换个U盘。。。。还是不行。。。
那好。。我换个引导工具试试吧。。。
换了poweriso,ultraiso,win32 disk image，还有一个不记得名字了，还有linux下的dd命令...
全都会出现一样的问题呵呵呵。
然后看到官网还有一种【体验安装】的方式...
大概就是加了一层东西...可以不分区而是在原有的分区里运行一个新的系统之类的技术....?
然后依然不行2333。卡死在启动界面。
去论坛反馈几个小时过去了，还没审核通过，呵呵呵
辣鸡deepin</description></item><item><title>辣鸡kde</title><link>https://111qqz.com/2016/11/kde/</link><pubDate>Mon, 14 Nov 2016 03:02:41 +0000</pubDate><guid>https://111qqz.com/2016/11/kde/</guid><description>
kde好难用啊....
换回了gnome.</description></item><item><title>(dp专题003)hdu 4055 Number String(dp)</title><link>https://111qqz.com/2016/11/hdu-4055/</link><pubDate>Sun, 13 Nov 2016 14:38:06 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-4055/</guid><description>
题目链接
题意：给出n(n&amp;lt;=1E3)个字符，字符可能为'D','I','?'，第i位对应的字符分别表示，第i位大于第i+1位，第i位小于第i+1位，或者不确定。
现在问满足该字符串的 1..n的排列的方案数。结果9+7
思路：没有太多思路，参考了题解
主要是状态表示没有想到，后面的状态转移方程倒是不难。
思路是，dp[i][j]表示长度为i，最后一位的相对大小为j的方案数。
考虑转移：如果第i-1个位置的字符为‘I’，那么所有比j小的都可以转移到j，也就是dp[i][j] = dp[i-1][1] + dp[i-1][2] + ... + dp[i-1][j-2] + dp[i-1][j-1];
如果第i-1个位置的字符是'D'，此时是这道题的重点。
有这个一个有趣的性质，比如对于一个排列{1，3，2}，现在我们在递推得到dp[4][2]，也就是要把2添加到这个排列的最后面，现在把当前排列即{1，3，2}中大于等于2的全部加上一得到{1，4，3}，这样是仍然不会改变题目给出的关系的，然后我们再把2添加到最后，{1，4，3，2}，就可以得到dp[4][2]了 此时的复杂度是n3,可以用前缀和优化掉一个n，复杂度n方。
最后答案就是sum[len+1][len+1]
/*************************************************** Author :111qqz ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; const int mod = 1000000007; char st[N]; int dp[N][N],sum[N][N];//dp[i][j]表示长度为i，最后结尾的字符的相对大小为j的方案数。 int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;D:\code\in.</description></item><item><title>【dp专题002】hdu 4489 The King’s Ups and Downs (dp)</title><link>https://111qqz.com/2016/11/dp002hdu-4489-the-kings-ups-and-downs-dp/</link><pubDate>Sun, 13 Nov 2016 11:33:20 +0000</pubDate><guid>https://111qqz.com/2016/11/dp002hdu-4489-the-kings-ups-and-downs-dp/</guid><description>
题目链接
题意：问长度为n的“波浪”型排列（即1..n每个数出现一次）有多少。波浪型的含义是，“高低高”或者“低高低”
思路：我们考虑当前已经知道i-1个数的波浪型的排列的方案数，那么当第i个数到来时，第i个数一定是最大的。
那么将i插入到某个位置，必须满足该位置前面必须以“高低”结尾，该位置后面必须以“低高”结尾才合法。（特别地，允许前面或者后面为空，这点体现在初始化上）
因此我们分别考虑，用dp[i][0]表示有i位且最后结尾为“高低”的方案数，dp[i][1]表示有i位且最后结尾为“低高”的方案数。
此时我们的情况是，已经有i-1个数，我要把第i个数插在某个位置。
这个位置是不确定的，因为我们需要枚举插入的位置（表现为，枚举插入的第i个数前面有j个数，后面剩余i-1-j个数）
那么第i个数前面是选择哪j个数呢？ 组合数为C[i-1][j] (i-1个数选择j个放在前面)
因此长度为i的答案为**sum[i] = sigma{dp[j][0]dp[i-j-1][1]C[i-1][j]} (0=&amp;lt;j&amp;lt;i)
dp[i][0]和dp[i][1]对称，显然相等，都等于sum[i]/2.
我们只需要再预处理一个组合数就好了。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL C[30][30]; LL dp[30][2]; LL sum[25]; void cal() { for ( int i = 1 ; i &amp;lt;= 20 ; i++) { C[i][0] = 1; C[i][i] = 1; } for ( int i = 2; i &amp;lt;= 20 ; i++) for ( int j = 1 ; j &amp;lt; i ; j++) C[i][j] = C[i-1][j] + C[i-1][j-1]; } int main() { cal(); /* for ( int i = 2 ;i &amp;lt;= 10 ; i++) { for ( int j = 0 ; j &amp;lt;= i ; j++) printf(&amp;quot;%d &amp;quot;,C[i][j]); printf(&amp;quot;\n&amp;quot;); } */ ms(sum,0); sum[1] = 1; dp[0][0]=dp[0][1]=dp[1][0]=dp[1][1] = 1; for ( int i = 2 ; i &amp;lt;= 20 ; i++) { for ( int j = 0 ; j &amp;lt; i ; j++) //枚举第i个位置前有几个。 { sum[i] += dp[j][0]*dp[i-1-j][1]*C[i-1][j]; } dp[i][0] = dp[i][1] = sum[i]/2; } // for ( int i = 1; i &amp;lt;= 20 ; i++) printf(&amp;quot;%lld\n&amp;quot;,sum[i]); int T; cin&amp;gt;&amp;gt;T; while (T--) { int cas,n; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;cas,&amp;amp;n); printf(&amp;quot;%d %lld\n&amp;quot;,cas,sum[n]); } return 0; }</description></item><item><title>hdu 4747 Mex （线段树lazy标记）</title><link>https://111qqz.com/2016/11/hdu-4747-mex-lazy/</link><pubDate>Sun, 13 Nov 2016 10:10:47 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-4747-mex-lazy/</guid><description>
题目连接
题意：给出n(n&amp;lt;=200000)个数，问所有区间[l,r]中mex的和。 （一个区间mex的定义为，这个区间中没有出现的最小的非负数）
思路：我们观察到mex(1,i)随着i增大，是不减的。(单调是线段树查询区间的时候非常好用的东西,这也是次题的突破口)
mex(1,i)可以O(n)维护出
现在我们考虑左端点向右移动对答案的影响。
当i移动到i+1时，此时序列中少了a[i]，设r为最小的x，满足a[x]=a[i]，那么当右断点在区间[r+1,n]，mex值是没有改变的。
当右端点属于[i+1,r-1]时，mex大于a[i]的会变成a[i]。
由于我们知道从1到某区间的mex值是单调的，那么mex大于a[i]的点必然是连续的一段。
我们可以知道最左边的q，满足mex(1,q)大于a[i]，然后将区间[q,r-1]成段更新为a[i]
因此整理思路，我们需要做两件事。
一个是每次区间求和，一个是找到最左边的q满足mex(1,q)大于a[i].
线段树维护三个域，max域，表示该区间中mex(1,i)的最大值；
sum域，表示该区间中mex(1,i)的和
lazy域，表示延迟标记。
可以预处理出nxt数组，表示位置i上的数下次出现最近是在nxt[i]
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; const int N=2E5+7; #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 typedef long long LL; int n; int a[N]; bool vis[N]; int Mex[N]; pair &amp;lt; int , int &amp;gt; b[N]; int nxt[N]; struct Tree { LL lazy; LL sum; LL mx; }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>20161113</title><link>https://111qqz.com/2016/11/20161113/</link><pubDate>Sun, 13 Nov 2016 08:11:45 +0000</pubDate><guid>https://111qqz.com/2016/11/20161113/</guid><description>
感冒也好得差不多了。
纠结也纠结够了吧。
退役个毛线啊。
寒假还要去叉姐的camp呢..
好了，继续。</description></item><item><title>【dp专题001】bzoj 1009: [HNOI2008]GT考试 (字符串上dp+kmp+矩阵加速线性递推式)</title><link>https://111qqz.com/2016/11/bzoj-1009/</link><pubDate>Sun, 13 Nov 2016 07:21:02 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1009/</guid><description>
1009: [HNOI2008]GT考试 Time Limit: 1 Sec Memory Limit: 162 MB Submit: 3127 Solved: 1926 [Submit][Status][Discuss]
Description 　阿申准备报名参加GT考试，准考证号为N位数X1X2....Xn(0&amp;lt;=Xi&amp;lt;=9),他不希望准考证号上出现不吉利的数字。 他的不吉利数学A1A2...Am(0&amp;lt;=Ai&amp;lt;=9)有M位，不出现是指X1X2...Xn中没有恰好一段等于A1A2...Am. A1和X1可以为 0
Input 　第一行输入N,M,K.接下来一行输入M位的数。 N&amp;lt;=10^9,M&amp;lt;=20,K&amp;lt;=1000
Output 　阿申想知道不出现不吉利数字的号码有多少种，输出模K取余的结果.
Sample Input 4 3 100 111
Sample Output 81
思路： 这次总算想对了状态表示：dp[i][j] 表示当前处理到第i位，最后j位与不吉利串相同的方案数。 然后此时考虑转移，也就是观察第i+1位。 根据第i+1位字符的不同，转移到的 位置也不相同。 从dp[i][j] 可以转移到dp[i+1][k]，这种转移表现为dp[i+1][k] += dp[i][j] (k取决于第i+1位字符) *我们可以用f[i+1][k]+=f[i][j]trans[j][k]，trans[j][k]表示串s后j位与不吉利串前j位相同， 添加一个字符后后k位与不吉利串前k位相同的方案数。
就是说中间的那一部式子可以化简成矩阵的形式。。因此整个递推式就成了矩阵乘法的形式。 tran数组可以用kmp预处理出来。 重点是注意体会在字符串上dp的思想。
/* *********************************************** Author :111qqz Created Time :2016年11月13日 星期日 13时54分33秒 File Name :code/bzoj/1009.</description></item><item><title>[dp专题000]uva 10328 Coin Toss (java 大数+dp)（Unsolved）</title><link>https://111qqz.com/2016/11/uva10328/</link><pubDate>Sat, 12 Nov 2016 12:39:25 +0000</pubDate><guid>https://111qqz.com/2016/11/uva10328/</guid><description>
题目链接
题意：问长度为n，每个位置由且仅有‘H’和'T'组成的序列中，至少有连续k个‘H’出现的方案数。
思路：不会做，参考了题解 不过没有完全搞懂。
根据题解，正面考虑比较麻烦，所以反面考虑。[j]
dp[i][j]表示长度为i，前面最后连续的‘H’的个数不超过j个的方案数。
考虑转移方程为：
总的情况为：dp[i][j] = dp[i-1][j] * 2;
但是其中有多考虑的情况，就是第i位是'H'，且i位之前的最后j个位置都是'H'（即从i-j位到第i-1位都是‘H’，此时第i-j-1位必然是'T'）
有i个硬币时，如果i 如果i &amp;gt; j + 1，dp[ i ] [ j ] = dp [ i - 1 ] [ j ] * 2 - x（不满足条件的部分）
然后我们来考虑这个x怎么求，既然是不满足条件，那么肯定是第i的位置放了H，前面的都是H，从而这些连续的H大于j。那么就考虑dp[ i - 1 - j - 1 ]（中间这 j - 1 个（kk:疑似作者笔误。应该位j个）全为H，加上第i个H，就不满足条件了），所以：
dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * 2 - dp [ i - j - 2 ] [ j ]（kk:仍然不是很懂这个式子.</description></item><item><title>20161111</title><link>https://111qqz.com/2016/11/20161111/</link><pubDate>Fri, 11 Nov 2016 10:46:32 +0000</pubDate><guid>https://111qqz.com/2016/11/20161111/</guid><description>
明明一直都穿着而很厚的衣服...还是被冻感冒了。
感冒了还是要吃药的吧...那种利用身体的免疫系统来对抗病毒的做法....还是算了，因为我只是放着没管一天，现在感觉眼睛都烫得厉害，身体发软...
不知道为什么人在特别虚弱的时候，好像很容易想家？
可能是因为身体虚弱的时候特别缺乏安全感...本能的想回到妈妈身边orz，因此想家吧....
以及，约了同(mei)学(zi)去看12月上映 的《你的名字》......期待.......
武汉这鬼地方咯....冻成狗....还好等毕业就离开这里了。
这周有4个队去比赛，预祝各位比赛顺利，拿到想拿的牌子，尤其是@Pacedect (毕竟还是有感情的......）</description></item><item><title>大纠结</title><link>https://111qqz.com/2016/11/</link><pubDate>Tue, 08 Nov 2016 05:09:13 +0000</pubDate><guid>https://111qqz.com/2016/11/</guid><description>
rt</description></item><item><title>acdream oj 1124 喵喵的遗憾 (斐波那契数列循环节)</title><link>https://111qqz.com/2016/11/acdream-oj-1124--/</link><pubDate>Thu, 03 Nov 2016 00:39:54 +0000</pubDate><guid>https://111qqz.com/2016/11/acdream-oj-1124--/</guid><description>
题目链接
题意：
F0 = 1 , F1 = 1 , F2 = 2 , Fn = Fn-1+Fn-2
求：
FFFn Mod P
( 也就是 F[ F[ F[n] ] ] % P )
思路：原来这是适牛出的题2333.
需要注意的是p可能为1，因此n==0或者1的时候，特判要输出1%p而不是1.
其他的没了。就是求斐波那契数列循环节的经典做法。
/* *********************************************** Author :111qqz Created Time :Thu 03 Nov 2016 08:09:26 AM CST File Name :1124.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } }M,M1; Mat mul (Mat a,Mat b,LL mod) { Mat c; c.</description></item><item><title>hdu 3978 Evil teacher's Final Problem (斐波那契数列的循环节)</title><link>https://111qqz.com/2016/11/hdu-3978/</link><pubDate>Wed, 02 Nov 2016 10:08:16 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-3978/</guid><description>
题意：now he let you calculate G(n,k) .Here G(n,0) = f(n) , G(n,i) = f( G(n,i-1) ) (k &amp;gt;= i &amp;gt;= 1).其中f是斐波那契数列。
思路：其实就是hdu 4291的加强版：hdu 4291 解题报告
开一个1E4的数组存一下每一层的循环节就好了。
http://vjudge.net/contest/139429#overview 告一段落，完结撒花！
/* *********************************************** Author :111qqz Created Time :Tue 01 Nov 2016 08:31:22 PM CST File Name :code/hdu/3978.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } }M,M1; Mat mul (Mat a,Mat b,LL mod) { Mat c; c.</description></item><item><title>hdu 2522 A simple problem (模拟，求小数循环节)</title><link>https://111qqz.com/2016/11/hdu-2522/</link><pubDate>Tue, 01 Nov 2016 12:21:12 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-2522/</guid><description>
题目链接
题意：求一个小数的循环节...
思路：其实直接模拟就好...
模拟竖式计算...
这里用到一个小技巧。
由于多组数据，每次都memset一个bool会很慢，导致超时。
我们可以用一个人int数组来代替每次重置的bool数组,
/* *********************************************** Author :111qqz Created Time :Tue 01 Nov 2016 08:00:49 PM CST File Name :code/hdu/2522.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int vis[N]; int n; int cnt = 0; void solve( int n) { if (n&amp;lt;0) { printf(&amp;quot;-&amp;quot;); n = -n; } if (n==1) { printf(&amp;quot;1&amp;quot;); return; } int x; printf(&amp;quot;0.</description></item><item><title>对acm圈现风气的感受</title><link>https://111qqz.com/2016/11/acm/</link><pubDate>Tue, 01 Nov 2016 10:40:18 +0000</pubDate><guid>https://111qqz.com/2016/11/acm/</guid><description>
这种东西我也没什么资格评论，只是随便说说自己的感受。
之前在知乎上看到有人批判说，OI/ACM圈子的戾气，大致有两点。
一个是（装）弱，一个是膜。
第一点其实，至少我认识的大多数人，包括我在内，并不是装弱，而是真的觉得自己弱。
我觉得这也是竞赛带给我的财富之一吧，就是一个比较开阔的眼界。
更具体得说，大概就是，虽然竞赛是一个小圈子，但是我基本清楚，这个圈子里，世界最强的那批人是什么水平。
因此我也很清楚自己有多么弱小，而不会像有些人一样或者像包括我在内的许多人的小时候一样...在一个小的圈子（地理意义上）
一旦做到很高，就容易自满。
但是听到有的人批判说，这种“我好菜啊”的态度会让人没办法做好事情。
说实话，我对于这个逻辑是无法理解的，感觉是在搞笑。
难道我认为自己弱就不去努力做好一件事了吗？就自怨自艾了？
难道我觉得自己弱就要自卑吗？
弱与强是客观事实，而自卑与否确是一种心态。
那些批判这点的人，难道非要做什么事情之前先给自己打一波鸡汤，让自己相信自己不弱，亦或者本来就觉得自己很强以后，才能做好事情吗？
感觉有些可悲。
我是弱啊，但是我今天比昨天又有了不少进步，所以很开心啊。
我是弱啊，但是让我做的事情，如果我知道自己做不到，我就会说做不到，但是如果确定要做，难道就因为我自己觉得自己弱，我就不去努力了？
两码事啊。
第二点，膜的风气，其实之前也觉得没什么。
不过我今天算是见识到了。
最开始应该是蒟蒻%神犇，这我觉得没什么啊，真心敬佩（还有人批判说膜拜别人会让自己不努力。。。又是一种我无法理解的逻辑）
然后菜鸡之间互相膜...虽然好像挺无聊的....不过也不是什么大事情。
但是神犇%菜鸡是什么心态啊？
也许没那么夸张。
比如今天,
我一个cf现在1400+，刚刚打了块铁的人....
你们喊“宽神是我们心中的红太阳”真是让我....
我知道你们没恶意，不过这让我感到很不舒服。
我只是希望大家可以一起讨论问题，一起进步，不要“膜来膜去”的。
嘛，反正也是马上就退役的人了，这些很快也与我无关了。</description></item><item><title>20161101</title><link>https://111qqz.com/2016/11/20161101/</link><pubDate>Mon, 31 Oct 2016 18:14:35 +0000</pubDate><guid>https://111qqz.com/2016/11/20161101/</guid><description>
软院的妹子，简称软妹。
[audio mp3=&amp;quot;https://111qqz.com/wordpress/wp-content/uploads/2016/08/桜華月想-3L.mp3&amp;quot;][/audio]</description></item><item><title>hdu 4291 A Short problem (矩阵快速幂+广义斐波那契循环节||暴力找循环节)</title><link>https://111qqz.com/2016/10/hdu-4291/</link><pubDate>Mon, 31 Oct 2016 08:59:53 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-4291/</guid><description>
题目链接
题意：
Given n (1 &amp;lt;= n &amp;lt;= 1018), You should solve for
g(g(g(n))) mod 109 + 7 where
g(n) = 3g(n - 1) + g(n - 2)
g(1) = 1
g(0) = 0思路：找循环节。首先由于模数固定，可以暴力一下找到循环节。
得到1E9+7的循环节是222222224,222222224的循环节是183120.
然后三次矩阵快速幂就行了。
需要注意每次都要判断那一层的n是否为0和1。
暴力解法：
/* *********************************************** Author :111qqz Created Time :Mon 31 Oct 2016 02:47:01 PM CST File Name :code/hdu/4291.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL loop0 = 1E9+7; const LL loop1=222222224,loop2=183120; //暴力得到每一层的循环节。 /* LL find_loop(LL mod) { LL a,b,c; a = 0 ; b = 1 ; for ( int i = 2 ; ; i++) { c = (a+3*b%mod)% mod; a = b; b = c; // cout&amp;lt;&amp;lt;&amp;quot;a:&amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; b:&amp;quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; if (a==0&amp;amp;&amp;amp;b==1) { return i-1; // i的时候得到第i项，判断循环的时候是判断g[i-1]==g[0]&amp;amp;&amp;amp;g[i]==g[1]，所以循环节长度是i-1; } } }*/ LL n; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } void out() { cout&amp;lt;&amp;lt;mat[0][0]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;mat[0][1]&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;mat[1][0]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;mat[1][1]&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;endl; } }M,M1; Mat mul(Mat a,Mat b,LL MOD) { Mat c; c.</description></item><item><title>hdu 1005 Number Sequence (矩阵快速幂加速线性递推式)</title><link>https://111qqz.com/2016/10/hdu-1005/</link><pubDate>Sun, 30 Oct 2016 21:18:36 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-1005/</guid><description>
题目链接
题意：A number sequence is defined as follows:
f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.
Given A, B, and n, you are to calculate the value of f(n).
思路：矩阵加速线性递推式。
这题第一次看是2012年11月2333，当时用pascal写的
/* *********************************************** Author :111qqz Created Time :Mon 31 Oct 2016 05:03:40 AM CST File Name :code/hdu/1005.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } }M,M1; Mat operator * ( Mat a,Mat b) { Mat c; c.</description></item><item><title>hdu 3977 Evil teacher (斐波那契数列循环节)</title><link>https://111qqz.com/2016/10/hdu-3977/</link><pubDate>Sun, 30 Oct 2016 21:01:37 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-3977/</guid><description>
题目链接
题意：f[0] = 1,f[1] = 1,f[i] = f[i-1] + f[i-2] (i&amp;gt;=2)，问最小的m满足f[n]%p==f[n+m]%p
思路：求斐波那契数列循环节。
参考了Acdreamer的博客_Fib数模n的循环节
对于一个正整数n，我们求Fib数模n的循环节的长度的方法如下： （1）把n素因子分解，即 （2）分别计算Fib数模每个 的循环节长度，假设长度分别是 （3）那么Fib模n的循环节长度 从上面三个步骤看来，貌似最困难的是第二步，那么我们如何求Fib模 的循环节长度呢？
 这里有一个优美的定理：Fib数模 的最小循环节长度等于 ，其中 表示Fib数模素数 的最小循环节长度。可以看出我们现在最重要的就是求 对于求 我们利用如下定理：
 如果5是模 的二次剩余，那么循环节的的长度是 的因子，否则，循环节的长度是 的因子。
顺便说一句，对于小于等于5的素数，我们直接特殊判断，loop(2)=3,loop(3)=8,loop(5)=20。
那么我们可以先求出所有的因子，然后用矩阵快速幂来一个一个判断，这样时间复杂度不会很大。
这道题是模板题。博客中的模板代码很好理解...
换成了自己比较熟悉的矩阵构造方式，以及代码风格。
需要注意的是下标是从0开始的，当验证k是否为循环节的时候，应该验证f[k]和f[k+1]
/* *********************************************** Author :111qqz Created Time :Mon 31 Oct 2016 03:54:15 AM CST File Name :code/hdu/3977.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL P; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } }M,M1; Mat mul (Mat a,Mat b,LL mod) { Mat c; c.</description></item><item><title>hdu 3221 Brute-force Algorithm (矩阵快速幂+指数循环节)</title><link>https://111qqz.com/2016/10/hdu-3221/</link><pubDate>Sun, 30 Oct 2016 16:45:32 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-3221/</guid><description>
题目链接
题意：给出了一段伪代码。分析得知其实就是f[1]= a,f[2] = b,f[n]=f[n-1] * f[n-2]
思路：一眼题，和hdu4549很类似hdu4549解题报告
不同的是这道题中p不一定是质数（其实不是也无所谓啊...hdu4549只不过是因为1E9+7是指数，又用费马小定理化简了一下,这道理%phi(p)即可）
还有这道题让我知道了
首先我们知道指数循环节公式，也就是所谓的降幂公式为：**a^x = a^(x mod phi(c)+phi(c)) (mod c) x=phi(c)，（ps:后面的限制条件，在x** 括号里的话是错误的。只有当x&amp;lt;phi(c)的时候，这个公式才成立。
这道题就是反例，不加判断会wa。
/* *********************************************** Author :111qqz Created Time :Sun 30 Oct 2016 11:46:33 PM CST File Name :code/hdu/3221.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,p,n; LL mod; LL euler( LL x) { LL ret = 1; for ( LL i = 2 ; i*i &amp;lt;= x; i++) { if (x%i==0) { x/=i; ret*=(i-1); while (x%i==0) { x/=i; ret*=i; } } } if (x&amp;gt;1) ret*=(x-1); return ret; } struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } }M,M1; Mat operator * (Mat a,Mat b) { Mat res; res.</description></item><item><title>hdu 2837 Calculation (指数循环节+欧拉函数)</title><link>https://111qqz.com/2016/10/hdu-2837/</link><pubDate>Sun, 30 Oct 2016 15:29:59 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-2837/</guid><description>
题目链接
题意：
Assume that f(0) = 1 and 0^0=1. f(n) = (n)^f(n/10) for all n bigger than zero. Please calculate f(n)%m. (2 ≤ n , m ≤ 10^9, x^y means the y th power of x).
思路：指数循环节。
trick点在于0^0=1这点。
比较容易想到的一层是ksm的时候特判。
比较不容易想到的一层是，0作为底数的时候，可能出现0^a在用降幂公式加速后，出现0^0。
举个例子：
680 80
phi(80)=32,恰好是8^6的因子
而0^(8^6)答案应该为0，用降幂公式加速后变成了0^0，答案变成了1，结果错误
究其原因，是因为这道题中底数可能有0以及0^0是题目中定义的运算。
解决办法是ksm的结果判断一下，如果是0就加mod。
/* *********************************************** Author :111qqz Created Time :Sun 30 Oct 2016 07:19:02 PM CST File Name :code/hdu/2837.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n,m; LL digit[20]; int cnt; LL ksm( LL a,LL b,LL mod) { // cout&amp;lt;&amp;lt;&amp;quot;a:&amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; b:&amp;quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&amp;quot; mod:&amp;quot;&amp;lt;&amp;lt;mod&amp;lt;&amp;lt;&amp;quot; &amp;quot;; if (b==0) return 1; if (a==0) return 0; //任何数的0次方都为1，0的任何除0外次方等于0.</description></item><item><title>hdu 4335 What is N? （指数循环节+欧拉函数)</title><link>https://111qqz.com/2016/10/hdu-4335/</link><pubDate>Thu, 27 Oct 2016 12:18:20 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-4335/</guid><description>
题目链接
题意：给出b,p,m（( 0&amp;lt;=b&amp;lt;P, 1&amp;lt;=P&amp;lt;=10^5, 1 &amp;lt;= M &amp;lt;=2^64 – 1 )）,问满足图中条件的n有多少个。
思路：这题由于对p没有限制，所以细节多一些，需要讨论。
首先我们知道指数循环节公式，也就是所谓的降幂公式为：a^x = a^(x mod phi(c)+phi(c)) (mod c) x&amp;gt;=phi(c)，（ps:后面的限制条件，在x&amp;lt;phi(c)的时候，该式子依然正确，只不过增加了运算复杂度。。。？ 存疑）
然后我们只需要对n分两种情况讨论。
第一种是n&amp;lt;t ,第二种是n&amp;gt;=t (t = min{x| x! % phi(P)==0})
由于t不会很大。。前一种直接暴力。。。
后一种用降幂公式搞之。。。
/* *********************************************** Author :111qqz Created Time :Thu 27 Oct 2016 03:43:05 AM CST File Name :code/hdu/4335.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair typedef unsigned long long ULL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =2E5+7; LL b,p; LL a[N]; unsigned long long M; LL euler( LL x) { LL ret = 1; for ( LL i = 2 ; i * i &amp;lt;= x ; i++) { if (x%i==0) { x/=i; ret*=(i-1); while (x%i==0) { x/=i; ret*=i; } } } if (x&amp;gt;1) ret*=(x-1); return ret; } LL ksm( LL a,LL b,LL k) { LL res = 1; while (b&amp;gt;0) { if (b&amp;amp;1) res = (res * a) % k; b = b &amp;gt;&amp;gt; 1LL; a = (a*a) % k; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10692 Huge Mods (欧拉函数，指数循环节)</title><link>https://111qqz.com/2016/10/uva-10692/</link><pubDate>Wed, 26 Oct 2016 12:24:10 +0000</pubDate><guid>https://111qqz.com/2016/10/uva-10692/</guid><description>
题目链接
题意：求一个楼梯数%m的大小。
思路：指数循环节。
需要注意的是，模数只有最外层是m，每往里一层，模数都变成m=phi(m)
所以可以写个dfs或者先预处理出每一层m存一下。
记得考虑n=1的特殊情况。
/* *********************************************** Author :111qqz Created Time :Wed 26 Oct 2016 07:07:27 PM CST File Name :code/uva/10692.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char st[20]; LL n,m; LL a[15]; LL ksm( LL a,LL b,LL k) { LL res = 1; while (b&amp;gt;0) { if (b&amp;amp;1) res = (res * a )% k; b = b &amp;gt;&amp;gt; 1; a = ( a * a) % k; } return res; } LL euler( LL x) { LL ret = 1 ; for ( LL i = 2 ; i*i &amp;lt;= x ; i++) { if (x%i==0) { x/=i; ret*=(i-1); while (x%i==0) { x/=i; ret*=i; } } } if (x&amp;gt;1) ret*=(x-1); return ret; } LL phi[20]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4704 Sum (隔板法，指数循环节，费马小定理)</title><link>https://111qqz.com/2016/10/hdu-4704-sum-/</link><pubDate>Wed, 26 Oct 2016 10:42:21 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-4704-sum-/</guid><description>
题目链接
题意：定义s(k)为将n分成k个正整数的划分数，给出n，问s(1) + s(2) + ... + s(n-1) + s(n)是多少，结果9+7，其中n&amp;lt;=10^100000。
思路：首先化简要求的式子。
根据隔板法_维基百科
现在有10个球，要放进3个盒子里 ●●●●●●●●●● 隔2个板子，把10个球被隔开成3个部分
●|●|●●●●●●●●、●|●●|●●●●●●●、●|●●●|●●●●●●、●|●●●●|●●●●●、●|●●●●●|●●●●、●|●●●●●●|●●●、...... 如此类推，10个球放进3个盒子的方法总数为{ n个球放进k个盒子的方法总数为{ 问题等价于求{ 的可行解数，其中 为正整数。
于是问题转化成：
n个木棍，n-1个缝， 分成1份则是C(n-1,0);
分成2份则是C(n-1,1);
分成3份则是C(n-1,2);
...
分成n份则是C(n-1,n-1);
ans = sum( C(n-1,i) ) (0&amp;lt;=i&amp;lt;=n-1)
=2^(n-1);
这是我能理解的得到2^(n-1)的方式。。。
看到有好多人说这个结论是显然的。。。求指教（说这是个结论记住就好的就算了23333）
接下来，就是求A=2^(n-1)9+7的问题了。。。
根据指数循环节公式A=2^((n-1)%(mod-1))*2^(mod-1)%mod (其中mod=1E9+7)
由于gcd(2,1E9+7)=1,根据费马小定理2^(mod-1)%mod=1，因此A=2^((n-1)%(mod-1))
然后快速幂搞之。
/* *********************************************** Author :111qqz Created Time :Wed 26 Oct 2016 06:22:39 PM CST File Name :code/hdu/4704.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const LL mod = 1E9+7; char st[N]; int len; LL n; LL ksm(LL a,LL b) { LL res = 1LL; while (b&amp;gt;0) { if (b&amp;amp;1) res = (res * a) % mod; b = b &amp;gt;&amp;gt; 1LL; a = ( a*a ) % mod; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4549 M斐波那契数列 (矩阵快速幂+费马小定理+指数循环节)</title><link>https://111qqz.com/2016/10/hdu4549/</link><pubDate>Wed, 26 Oct 2016 09:12:43 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu4549/</guid><description>
题意：M斐波那契数列F[n]是一种整数数列，它的定义如下：
F[0] = a F[1] = b F[n] = F[n-1] * F[n-2] ( n &amp;gt; 1 )
现在给出a, b, n，你能求出F[n]的值吗？
思路：观察发现。。。F[n] = a^(fib(n-1)) * b ^ (fib(n))
此处要用到指数循环节的知识：
111qqz_指数循环节学习笔记
a^n ≡ a^(n % Phi(M) + Phi(M)) (mod M) (n &amp;gt;= Phi(M))
然后 因为1000000007是质数，对于任意的x,有gcd(x,1000000007) = 1，所以可以结合费马小定理化简上式：
a^n ≡ a^(n%(m-1)) * a^(m-1)≡ a^(n%(m-1)) (mod m)
记得特判一下n为0和1的情况。
xiaodingli
/* *********************************************** Author :111qqz Created Time :Wed 26 Oct 2016 09:16:22 AM CST File Name :code/hdu/4549.</description></item><item><title>指数循环节学习笔记</title><link>https://111qqz.com/2016/10/</link><pubDate>Wed, 26 Oct 2016 08:59:48 +0000</pubDate><guid>https://111qqz.com/2016/10/</guid><description>
资料先行：
指数循环节证明
指数循环节2
对指数循环节的一些理解
挂了一点题目，写完来写总结。
vjudge_不会指数循环节的111qqz
写完了。
首先要注意的是：
首先我们知道指数循环节公式，也就是所谓的降幂公式为：**a^x = a^(x mod phi(c)+phi(c)) (mod c) x=phi(c)，（ps:后面的限制条件，在x）** 括号里的话是错误的。当x&amp;lt;phi(c)时，该式子是错误的。
之前一直没出问题是因为数据水。
参考题目：hdu3221解题报告</description></item><item><title>BZOJ 4547: Hdu5171 小奇的集合 (矩阵快速幂)</title><link>https://111qqz.com/2016/10/bzoj-4547-hdu5171--/</link><pubDate>Wed, 26 Oct 2016 01:09:38 +0000</pubDate><guid>https://111qqz.com/2016/10/bzoj-4547-hdu5171--/</guid><description>
4547: Hdu5171 小奇的集合 Time Limit: 2 Sec Memory Limit: 256 MB Submit: 263 Solved: 113 [Submit][Status][Discuss]
Description  有一个大小为n的可重集S，小奇每次操作可以加入一个数a+b(a,b均属于S)，求k次操作后它可获得的S的和的最大
值。（数据保证这个值为非负数）
Input 第一行有两个整数n,k表示初始元素数量和操作数，第二行包含n个整数表示初始时可重集的元素。
对于100%的数据，有 n&amp;lt;=10^5，k&amp;lt;=10^9，|ai|&amp;lt;=10^5
Output 输出一个整数，表示和的最大值。答案对10000007取模。
Sample Input 2 2 3 6
Sample Output 33
HINT Source By Hzwer
思路：同hdu 5171的区别在于，a可能为负数。
同样是设a0为次大值，a1为最大值。
根据a0,a1的正负分类讨论。
如果a1&amp;lt;0（此时a0一定也小于0）那么每次操作都是a0+a1,因为越加越小。
如果a0&amp;lt;0，需要计算需要几次运算，使得a0&amp;gt;=0。设需要num次。
原因是，类斐波那契数列的性质可以对于正数，也可以对于负数，但是如果有正数有负数，性质是不满足的。
因此如果num&amp;gt;k，说明一直都是负数，直接运算即可，如果num&amp;lt;=k，就需要先把负数部分用等差数列的方法处理掉。
然后再用矩阵快速幂的方法计算剩下的k-num次。
/* *********************************************** Author :111qqz Created Time :Tue 25 Oct 2016 07:00:23 PM CST File Name :code/bzoj/4547.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL mod = 1E7+7; const int N=1E5+7; int n,k; LL a[N]; LL a0,a1; LL sum; struct Mat { LL mat[2][2]; void clear() { ms(mat,0); } }M,M1; Mat operator*(Mat a,Mat b) { Mat res; res.</description></item><item><title>hdu 5171 GTY's birthday gift (矩阵快速幂)</title><link>https://111qqz.com/2016/10/hdu-5171-gtys-birthday-gift-/</link><pubDate>Tue, 25 Oct 2016 10:56:10 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-5171-gtys-birthday-gift-/</guid><description>
题目链接
题意：给出n,k，以及n个正数，把n个数放在一个集合里，进行k次操作，每次操作取最大的数和次大的数放进集合。问k次操作结束后，集合中所有数的和。
思路：假设初始时刻，次大和最大分别为a0,a1，那么得到的就是一个类斐波那契数列。初始为a0,a1,fn = fn-1 + fn
最后求和。
利用这个性质。。。
我们直接构造完矩阵。。。求出F(n+2)即可。。
需要注意。。。矩阵中每一项是小于1E7+7的。。。矩乘的时候会爆int...
所以mat要用LL存。。我好傻啊。。。
/* *********************************************** Author :111qqz Created Time :Thu 20 Oct 2016 10:40:39 AM CST File Name :code/hdu/5171.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =1E5+7; const LL mod = 1E7+7; int n; LL k; LL a[N]; LL sum; LL a0,a1; struct Mat { LL mat[3][3]; void clear() { ms(mat,0); } Mat operator*(const Mat &amp;amp;b)const { Mat ans; ans.</description></item><item><title>近况。。。</title><link>https://111qqz.com/2016/10/get-iron-medal-on-icpc-shenyang-regional/</link><pubDate>Mon, 24 Oct 2016 04:20:30 +0000</pubDate><guid>https://111qqz.com/2016/10/get-iron-medal-on-icpc-shenyang-regional/</guid><description>
沈阳打铁了。。。。
具体不多说了。。。总之现在格外消沉，心情也很差。
可能需要一段时间缓一缓...
能缓过来就继续干...
缓不过来大概就退役了把2333
哦，没拿牌应该叫滚粗。。。
希望自己可以缓过来。
毕竟还没拿金，还有几个妹子没有面2333
各位有缘再见。</description></item><item><title>2016 沈阳</title><link>https://111qqz.com/2016/10/2016-icpc-shenyang-reigonal-onsite/</link><pubDate>Sat, 22 Oct 2016 14:34:01 +0000</pubDate><guid>https://111qqz.com/2016/10/2016-icpc-shenyang-reigonal-onsite/</guid><description>
这两天一直睡不醒。。。
今天热身赛几乎睡了全场。
还是没能把自己的博客过一遍。。。
记得去年比赛前好像什么都没看呀？
大概是因为去年什么都不会所以没什么可看的吧233333
为啥有一种准备的考试的即视感。。。。
看自己博客的感受是：我竟然会这么多东西&amp;amp;&amp;amp;这些东西真是我写的？
然后晚上一只困成狗。。。又不敢喝咖啡。。。好困啊orz
关于今天呢。。。大概想说。。。。礼仪队妹子好漂亮嘿嘿嘿
志愿者服务态度很棒。。。也很周到。。。
餐厅非常好吃。。。就是量太少了。。。。后来的同学就没有饭吃了orz
jry的发言很亮。。。
明天比赛，rp++
kkkkk?kkkkk！</description></item><item><title>hdu 4965 Fast Matrix Calculation (矩阵快速幂，2014多校#9)</title><link>https://111qqz.com/2016/10/hdu-4965-fast-matrix-calculation-20149/</link><pubDate>Wed, 19 Oct 2016 20:54:11 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-4965-fast-matrix-calculation-20149/</guid><description>
题目链接
题意：Step 1: Calculate a new NN matrix C = AB. Step 2: Calculate M = C^(N*N). Step 3: For each element x in M, calculate x % 6. All the remainders form a new matrix M’. Step 4: Calculate the sum of all the elements in M’.
思路： 水题。。就一个trick...
朴素的矩阵乘法的复杂度是n^3的。。。按照题目的顺序求的话。。。。求M矩阵时会超时。。。（而且1000*1000的数组也不能放到结构体里...?
我们可以根据矩阵乘法的结合律。
M = (AB)^(NN) = A * (BA)^(NN-1) * B
然后就可以搞了。
/* *********************************************** Author :111qqz Created Time :Wed 19 Oct 2016 08:39:49 PM CST File Name :code/hdu/4965.</description></item><item><title>hdu 2157 How many ways?? (矩阵快速幂经典题目)</title><link>https://111qqz.com/2016/10/hdu-2157/</link><pubDate>Wed, 19 Oct 2016 12:36:20 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-2157/</guid><description>
题意：给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值
思路： ** 把给定的图转为邻接矩阵，即A(i,j)=1当且仅当存在一条边i-&amp;gt;j。令C=A*A，那么C(i,j)=ΣA(i,k)A(k,j)，实际上就等于从点i到点j恰好经过2条边的路径数（枚举k为中转点）。类似地，CA的第i行第j列就表示从i到j经过3条边的路径数。同理，如果要求经过k步的路径数，我们只需要快速幂求出A^k即可。**
M67_十个利用矩阵乘法解决的经典题目
这个转化好美啊。。。
/* *********************************************** Author :111qqz Created Time :Wed 19 Oct 2016 08:14:56 PM CST File Name :code/hdu/2157.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=25; const int mod = 1000; int n,m; struct Mat { int mat[N][N]; void clear() { ms(mat,0); } }M; Mat operator * (Mat a,Mat b) { Mat ans; ans.</description></item><item><title>hdu 1211 RSA (扩展欧几里得算法求逆元 +快速幂)</title><link>https://111qqz.com/2016/10/hdu-1211-rsa--/</link><pubDate>Wed, 19 Oct 2016 10:03:52 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-1211-rsa--/</guid><description>
题目链接
题意：给出p, q, e, l,令n = p * q, fn = (p-1) * (q-1)
给出l个c,计算m = D(c) = c**d** mod n,其中m为要输入的明文对应的ascii编码，d的计算方法：&amp;gt; calculate d, making d × e mod F(n) = 1 mod F(n), and d will be the private key。
问明文。
思路：
出题人JGShining（极光炫影）傻逼。
题意都说不清？
大小写字母一个意思？
脑袋有坑的出题人。
出题人傻逼。 出题人傻逼。 出题人傻逼。 好了。这道题需要用到扩展欧几里得算法求逆元。。。ksm(a,mod-2)的方法是基于费马小定理，必须mod为质数才可以用。扩展偶记里算法没有这个限制。
用欧几里德算法求模的逆元：
同余方程ax≡b (mod n)，如果 gcd(a,n)== 1，则方程只有唯一解。
在这种情况下，如果 b== 1，同余方程就是 ax=1 (mod n ),gcd(a,n)= 1。
这时称求出的 x 为 a 的对模 n 乘法的逆元。</description></item><item><title>逆元学习笔记</title><link>https://111qqz.com/2016/10/</link><pubDate>Wed, 19 Oct 2016 09:17:15 +0000</pubDate><guid>https://111qqz.com/2016/10/</guid><description>
acdreamer_逆元学习笔记
摘重点：
ksm(a,mod-2)的方法求逆元只适用于mod为质数且 gcd(a,mod)==1
扩展欧几里得算法求逆元只适用于gcd(a,mod)==1
扩展欧几里得算法求逆元
acdreamer的博客里提到一种通用的方法，正确性未知。（然而有b|a的前提呵呵呵呵呵）
但是你会发现费马小定理和扩展欧几里得算法求逆元是有局限性的，它们都会要求![](http://img.blog.csdn.net/20140613102654328) 与![](http://img.blog.csdn.net/20140613102712781) 互素。实际上我们还有一 种通用的求逆元方法，适合所有情况。公式如下
O(n)求逆元：
其实有些题需要用到![](http://img.blog.csdn.net/20140613122746828) 模![](http://img.blog.csdn.net/20140613122821000) 的所有逆元，这里![](http://img.blog.csdn.net/20140613122821000) 为奇质数。那么如果用快速幂求时间复杂度为![](http://img.blog.csdn.net/20140613123226296) ， 如果对于一个1000000级别的素数 ，这样做的时间复杂度是很高了。实际上有 的算法，有一个递推式如下
它的推导过程如下，设 ，那么
对上式两边同时除 ，进一步得到
再把 和 替换掉，最终得到
初始化 ，这样就可以通过递推法求出 模奇素数 的所有逆元了。
另外 模 的所有逆元值对应 中所有的数，比如 ，那么 对应的逆元是 。</description></item><item><title>poj 3233 Matrix Power Series （矩阵快速幂+分治）</title><link>https://111qqz.com/2016/10/poj-3233/</link><pubDate>Wed, 19 Oct 2016 08:17:04 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-3233/</guid><description>
题目链接
题意：
Given a n × n matrix A and a positive integer k, find the sum S = A + _A_2 + _A_3 + … + Ak.
思路： 对k进行二分。
比如，当k=6时，有： A + A^2 + A^3 + A^4 + A^5 + A^6 =(A + A^2 + A^3) + A^3*(A + A^2 + A^3) 应用这个式子后，规模k减小了一半。我们二分求出A^3后再递归地计算A + A^2 + A^3，即可得到原问题的答案。
以及错误的递归方式：
无形中增加了多少次。。。。。。怎么像小学生呢。。。
正确的写法。。。
/* *********************************************** Author :111qqz Created Time :Tue 18 Oct 2016 05:10:53 PM CST File Name :code/poj/3233.</description></item><item><title>20161019梦境记录</title><link>https://111qqz.com/2016/10/20161019-dream/</link><pubDate>Wed, 19 Oct 2016 04:42:11 +0000</pubDate><guid>https://111qqz.com/2016/10/20161019-dream/</guid><description>
梦。。。。 设定大概是我身上有某种可以产生军用价值的变异... 所以要杀掉我做研究。。。？ 但是我不同意2333 于是把我抓了起来。。。判了10年有期徒刑的样子。。。 罪名好想是不支持社会主义建设。。。。？？？ 我还记得很清楚。。。。有人和我讲什么“好好改造，早日回归社会” 鬼啊。当时第一个念头是，我今年的比赛还没打。。。。10年出来以后就不能参加比赛了orz。。。
第二个设定是。。。。kk想杀我。。。 然后全世界的人。。。都想让我死。。。。。。。大概是有奖金吧，我不知道。 全世界的人都想让你死是什么感觉呢。。。。。 心好累啊。。。 最近每天都是这种。。。一不小心就会死。。。或者要拼死拼活才能活命的梦。。。。 前一天是梦到在一个只能上升不会下降的电梯。。。。。无法控制。。。。（这个设定大概是最近的某道题2333）
sigh...</description></item><item><title>test latex</title><link>https://111qqz.com/2016/10/test-latex/</link><pubDate>Mon, 17 Oct 2016 18:49:27 +0000</pubDate><guid>https://111qqz.com/2016/10/test-latex/</guid><description>
(\alpha+\beta\geq\frac12)
20180101_test:
(\alpha+\beta\geq\frac12)
$$\left[ \begin{matrix}a&amp;amp;b\c&amp;amp;\alpha\end{matrix} \right]$$
\left( \begin{matrix}a&amp;amp;b\c&amp;amp;\alpha\end{matrix} \right)</description></item><item><title>poj 3070 Fibonacci (矩阵加速线性递推式)</title><link>https://111qqz.com/2016/10/poj-3070-fibonacci/</link><pubDate>Mon, 17 Oct 2016 18:36:15 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-3070-fibonacci/</guid><description>
题目链接
题意：求f[n] % 10000,f为斐波那契数。
思路：按照题目给出的公式，或者按照加速线性递推式的方法都可以。。。
因为把模数的1E4手滑写成1E4+7结果调了半天也是没谁了呵呵呵呵。
/* *********************************************** Author :111qqz Created Time :Tue 18 Oct 2016 01:18:40 AM CST File Name :code/poj/3070.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD = 1E4; int n; struct Mat { int mat[5][5]; void clear() { ms(mat,0); } }M,M1; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>矩阵加速线性递推式（转载）</title><link>https://111qqz.com/2016/10/</link><pubDate>Mon, 17 Oct 2016 17:38:36 +0000</pubDate><guid>https://111qqz.com/2016/10/</guid><description>
找到了篇四年前空间中的旧文，也是有点感动2333.
快速求解多项递推式 问题描述:
已知 F(n) = AF(n-1) + BF(n-2) + CF(n-3)+.....
求解 F(n)%P
分析:
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
如果n的值不大,一般来说在1000000之内,则可以考虑直接递推求解,只要预先花O(n)时间复杂度,可打出一张表,运行时直接查表就可以了.
另一方面,如果n值可能很大,如10^9,用这种方法无论是在内存还是时间上开销都太大,根本无法满足.本文将介绍一种与矩阵相关的高效通用算法.
举个例子:
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
如果我们已知一个序列的前两项为a0,a1,递推关系为:F(n) = AF(n-1)+BF(n-2)
令矩阵 M = | 0 1 | M(1) = | a0 |
| B A | | a1 |
N = M * M(1) = | a1 |
| Aa1+Ba0 |
而 Aa1+Ba0 刚好就是 a2 !
设 M(n) = | a(n-1) |
| an |
N = M * M(n) = | an |</description></item><item><title>矩阵学习笔记</title><link>https://111qqz.com/2016/10/</link><pubDate>Mon, 17 Oct 2016 17:03:16 +0000</pubDate><guid>https://111qqz.com/2016/10/</guid><description>
参考资料：
十个利用矩阵乘法解决的经典题目</description></item><item><title>hdu 1573 X问题 (exgcd求解一般线性同余方程组解的个数)</title><link>https://111qqz.com/2016/10/hdu-1573/</link><pubDate>Sat, 15 Oct 2016 09:00:14 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-1573/</guid><description>
题目链接
题意：求在小于等于N的正整数中有多少个X满足：X mod a[0] = b[0], X mod a[1] = b[1], X mod a[2] = b[2], …, X mod a[i] = b[i], … (0 &amp;lt; a[i] &amp;lt;= 10)。
思路：先用扩展欧几里得算法（excrt）解一般同余方程求出一个特解R,然后通解R' = R + k * LCM(a1..am)
注意一些特殊情况，如果无解输出0，如果n小于最小的正整数的R也输出0，
否则答案为(n-R)/M + 1
/* *********************************************** Author :111qqz Created Time :Sat 15 Oct 2016 03:31:09 PM CST File Name :code/hdu/1573.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =15; LL a[N],r[N]; LL nn; int m; LL exgcd(LL a,LL b,LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1; y = 0 ; return a; } LL ret = exgcd( b, a%b,y,x); y-=x*(a/b); return ret; } LL ex_crt(LL *m,LL *r,int n) { LL M = m[1] , R = r[1],x,y,gcd; for ( int i = 2 ; i &amp;lt;= n ; i++) { gcd = exgcd(M,m[i],x,y); if ((r[i]-R)%gcd) return 0; LL gx = m[i]/gcd; x = x*(r[i]-R)/gcd; x %=gx; R += x*M; M = M / gcd * m[i]; R%=M; } if (R&amp;lt;=0) R+=M; if (nn&amp;lt;R) return 0; return (nn-R)/M + 1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2891 Strange Way to Express Integers (扩展欧几里得算法解一般线性同余方程组)</title><link>https://111qqz.com/2016/10/poj-2891/</link><pubDate>Fri, 14 Oct 2016 19:16:55 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-2891/</guid><description>
题目链接
题意：给出k个方程，形式为 x==r1,求最小的正数x，无解输出-1.
思路：首先很容易让人联想到crt.
然而crt的使用条件是，所有的m(也就是这道题中的a)两两互质，这道题并不满足，因此不能使用crt.
X mod m1=r1 X mod m2=r2 ... ... ... X mod mn=rn 首先，我们看两个式子的情况 X mod m1=r1……………………………………………………………(1) X mod m2=r2……………………………………………………………(2) 则有 X=m1k1+r1………………………………………………………………() X=m2k2+r2 那么 m1k1+r1=m2k2+r2 整理，得 m1k1-m2*k2=r2-r1 令(a,b,x,y,m)=(m1,m2,k1,k2,r2-r1)，原式变成 ax+by=m 熟悉吧？此时，因为GCD(a,b)=1不一定成立，GCD(a,b) | m 也就不一定成立。所以应该先判 若 GCD(a,b) | m 不成立，则方程无解。（理论依据：裴蜀定理） 否则，继续往下。
解出(x,y)，将k1=x反代回（），得到X。 于是X就是这两个方程的一个特解，通解就是 X'=X+kLCM(m1,m2) 这个式子再一变形，得 X' mod LCM(m1,m2)=X 这个方程一出来，说明我们实现了(1)(2)两个方程的合并。 令 M=LCM(m1,m2)，R=r2-r1  （注意这里原博客写错了，应该为R=x*m1+r1） 就可将合并后的方程记为 X mod M = R。
然后，扩展到n个方程。 用合并后的方程再来和其他的方程按这样的方式进行合并，最后就能只剩下一个方程 X mod M=R，其中 M=LCM(m1,m2,...,mn)。 那么，X便是原模线性方程组的一个特解，通解为 X'=X+k*M。
如果，要得到X的最小正整数解，就还是原来那个方法：</description></item><item><title>poj 1006 Biorhythms (中国剩余定理模板题)</title><link>https://111qqz.com/2016/10/poj-1006-biorhythms-/</link><pubDate>Thu, 13 Oct 2016 12:39:27 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-1006-biorhythms-/</guid><description>
题目链接：
**题意：**人自出生起就有体力，情感和智力三个生理周期，分别为23，28和33天。一个周期内有一天为峰值，在这一
天，人在对应的方面（体力，情感或智力）表现最好。通常这三个周期的峰值不会是同一天。现在给出三个日
期，分别对应于体力，情感，智力出现峰值的日期。然后再给出一个起始日期，要求从这一天开始，算出最少
再过多少天后三个峰值同时出现。
思路：解一个线性同余方程。crt的模板题。
关于crt的讲解：中国剩余定理学习笔记
几年前就A过了，现在重新写题解复习一下。
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 08:00:04 PM CST File Name :code/poj/1006.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int p,e,i,d; int a[5],m[5]; void exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y) { if (b==0) { x = 1; y = 0; return; } exgcd(b,a%b,x,y); int tmp = x; x = y; y = tmp - a/b*y; } int crt(int a[],int m[],int n) { int M = 1; int ans = 0 ; for ( int i = 1 ; i &amp;lt;= n; i++) M*=m[i]; for ( int i = 1 ; i &amp;lt;= n ; i++) { int x,y; int Mi = M/m[i]; exgcd(Mi,m[i],x,y); ans = ( ans + Mi * x * a[i])%M; } if (ans&amp;lt;0) ans+=M; return ans; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2142 The Balance (扩展欧几里得算法)</title><link>https://111qqz.com/2016/10/poj-2142/</link><pubDate>Thu, 13 Oct 2016 11:34:08 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-2142/</guid><description>
题目链接
题意：给出a,b,d，分别表示a,b两种刻度的砝码，以及要称量的物体重量为d.现在保证能称量出给定重量的物体，问两种砝码个数的和最小的时候，两种砝码分别有多少。如果有多组解，那么要求weight of(ax + by) 最小。
思路：求特解直接扩展欧几里得...
关键是怎么找到绝对值和最小的。。
我就是两个方向跑了下。。。
一开始因为把weight of (ax+by) （求得还是绝对值最小）理解成了 ax+by最小。。导致WA了半天。。。。sigh....
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 04:23:13 PM CST File Name :code/poj/2142.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,d; LL exgcd( LL a,LL b,LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1; y = 0; return a; } LL ret = exgcd(b,a%b,x,y); LL tmp = x; x = y; y = tmp - a/b*y; return ret; } LL num ( LL x) { if (x&amp;lt;0) return -x; return x; } LL cal( LL x,LL y) { return a*num(x)+b*num(y); } bool ok( LL x,LL y,LL gx,LL gy) { if (num(x)+num(y)&amp;gt;num(x+gx)+num(y-gy)) return true; if (num(x)+num(y)==num(x+gx)+num(y-gy)&amp;amp;&amp;amp;cal(x,y)&amp;gt;cal(x+gx,y-gy)) return true; return false; } bool ok2( LL x,LL y,LL gx,LL gy) { if (num(x) + num(y) &amp;gt; num(x-gx) + num(y+gy)) return true; if (num(x) + num(y) ==num (x-gx) + num(y+gy)&amp;amp;&amp;amp;cal(x,y)&amp;gt;cal(x-gx,y+gy)) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2115 C Looooops (扩展欧几里得算法)</title><link>https://111qqz.com/2016/10/poj-2115-c-looooops-/</link><pubDate>Thu, 13 Oct 2016 08:11:17 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-2115-c-looooops-/</guid><description>
题目链接
题意： 问 循环for ( int i = a ; i !=b; i+=c)在% （2^k）的意义下循环了多少次。
思路：
一般的思路是：
列方程...
化成扩展欧几里得算法的形式。。。
根据裴蜀定理判断解是否存在...
然后用对用扩展欧几里得算法求出的X,Y按照题目要求调整。
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 03:57:06 PM CST File Name :code/poj/2115.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,c,k; LL exgcd(LL a,LL b,LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1; y = 0; return a; } LL ret = exgcd(b,a%b,x,y); LL tmp = x; x = y; y = tmp - a/b*y; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1061 青蛙的约会 （扩展欧几里得算法（负数的处理））</title><link>https://111qqz.com/2016/10/poj-1061--/</link><pubDate>Thu, 13 Oct 2016 07:48:35 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-1061--/</guid><description>
题目链接
题意：两只青蛙初始在数轴的x,y点，单位时间内分别可以向右跳m米和n米，数轴是环型的，长度为L，问两只青蛙能否相遇，以及相遇时跳的次数。
思路：相遇就是同一时间在同一地点。
 那么有方程 x+ Cm = y + Cn + k*L 其中C为跳的次数，k为之间差了L的个数（可以理解为被套圈的圈数）
化简得到 C(m-n) + K*L = y-x.
根据裴蜀定理，该方程有解，当且仅当y-x是gcd(m-n,L)的倍数。
然后根据扩展欧几里得算法，需要注意的是其中可能有负数。
如果a是负数，可以把问题转化成
![\left|a\right|(-x)+by=\gcd(|a|,b)](https://wikimedia.org/api/rest_v1/media/math/render/svg/8f297adf01fb91ae218da2cd1dd5d45c1a0f4f4f) （![\left|a\right|](https://wikimedia.org/api/rest_v1/media/math/render/svg/bc1989313eab6e17a909a3491eacf2b7a6c16e59) 为a的[绝对值](https://zh.wikipedia.org/wiki/)），然后令![x'=(-x)](https://wikimedia.org/api/rest_v1/media/math/render/svg/0b6d28243b84ac1fc55d2b43250c71f3ae98c510) 。 第二个需要注意的是，扩展欧几里得算法求出的是ax+by=gcd(a,b)的解，x,y还要乘对应的倍数才能得到正确的解。
第三个需要注意的是，跳的次数一定为正，这是隐含条件。
用了上道题用的while去得到第一个大于0的X会TLE
所以其实** X = ( X % gx + gx) %gx**就好。。。？ （其中gx = b/gcd(a,b)）
/* *********************************************** Author :111qqz Created Time :Wed 12 Oct 2016 08:43:02 PM CST File Name :code/poj/1061.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL x,y,m,n,L; LL exgcd( LL a,LL b, LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1LL; y = 0LL; return a; } LL ret = exgcd(b,a%b,x,y); LL tmp = x; x = y; y = tmp - a/b*y; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2669 Romantic (扩展欧几里得模板题)</title><link>https://111qqz.com/2016/10/hdu-2669/</link><pubDate>Wed, 12 Oct 2016 12:30:21 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-2669/</guid><description>
题目链接
题意：问ax+by=1的一组x&amp;gt;0的解，如果无解输出sorry.
思路：根据裴蜀定理， ax+by=1有解当且gcd(a,b)=1。
然后根据扩展欧几里得算法，我们可以得到一组x,y。需要注意的是，这只是其中一组解。
x,y的通解为：**(x+kgx , y-kgy ） 其中：gx= b/gcd(a,b),gy = a/gcd(a,b),k为任意整数 **
/* *********************************************** Author :111qqz Created Time :Wed 12 Oct 2016 07:30:20 PM CST File Name :code/hdu/2669.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int exgcd( int a,int b,int &amp;amp;x,int &amp;amp;y) { if (b==0) { x = 1; y = 0; return a; } int ret = exgcd(b,a%b,x,y); int tmp = x; x = y; y = tmp - a/b*y; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>20161011</title><link>https://111qqz.com/2016/10/20161011/</link><pubDate>Tue, 11 Oct 2016 15:07:15 +0000</pubDate><guid>https://111qqz.com/2016/10/20161011/</guid><description>
我信任学姐。</description></item><item><title>中国剩余定理(crt)学习笔记</title><link>https://111qqz.com/2016/10/crt/</link><pubDate>Tue, 11 Oct 2016 13:04:54 +0000</pubDate><guid>https://111qqz.com/2016/10/crt/</guid><description>
前置技能点：
维基百科_裴蜀定理（贝祖等式）
对任何[整数](https://zh.wikipedia.org/wiki/)![a](https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc) ， ![b](https://wikimedia.org/api/rest_v1/media/math/render/svg/f11423fbb2e967f986e36804a8ae4271734917c3) 和它们的[最大公约数](https://zh.wikipedia.org/wiki/)![d](https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab) ，关于未知数![x](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4) 和![y](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) 的[线性](https://zh.wikipedia.org/wiki/)[丢番图方程](https://zh.wikipedia.org/wiki/)（称为**裴蜀等式**）：![ax+by=m](https://wikimedia.org/api/rest_v1/media/math/render/svg/a3386cf2b30d74a8dc65ec168ef326cf2ece3de0) 有整数解时当且仅当_m_是_d_的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解 、 都称为裴蜀数，可用扩展欧几里得算法求得。
特别地，方程 有整数解当且仅当整数_a_和_b_互素。（kk:因为1(m=1)只可能是1(d=1)的倍数，也就是说gcd(a,b)=1，即a,b互质）
维基百科_扩展欧几里得算法
已知整数a、b，扩展欧几里得算法**可以在求得a、b的[最大公约数](https://zh.wikipedia.org/wiki/)的同时，能找到整数x、y**（其中一个很可能是负数），使它们满足[贝祖等式](https://zh.wikipedia.org/wiki/) ![ax + by = \gcd(a, b).](https://wikimedia.org/api/rest_v1/media/math/render/svg/72fe07a990a7ce59a499626f59b1ce588c8f6cda) 通常谈到[最大公约数](https://zh.wikipedia.org/wiki/)时，我们都会提到一个非常基本的事实：**给予二整数a、b，必存在有整数x、y使得ax + by = gcd(a,b)**[[1]](https://zh.wikipedia.org/wiki/#cite_note-1)。 有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。
例子：
求二元一次不定方程 的整数解。
* 47 = 30 * 1 + 17 * 30 = 17 * 1 + 13 * 17 = 13 * 1 + 4 * 13 = 4 * 3 + 1 然后把它们改写成“余数等于”的形式</description></item><item><title>二次剩余（Cipolla's algorithm）学习笔记</title><link>https://111qqz.com/2016/10/cipollas-algorithm/</link><pubDate>Mon, 10 Oct 2016 12:08:41 +0000</pubDate><guid>https://111qqz.com/2016/10/cipollas-algorithm/</guid><description>
先放资料。
前置技能点： 剩余系
剩余系**:设模为m,则根据余数可将所有的整数分成m类，分别记成[0],[1],[2],…[m-1]****，**
这m个数**{0,1,2,****…****m-1}**称为一个完全剩余系，
每个数称为相应类的代表元。
当m=10（偶数）时候，则{0,1,2,3,4,5,6,7,8,9}是最小非负完全剩余系
{-5,-4,-3,-2,-1,0,1,2,3,4,5} 是绝对值最小完全剩余系
{-4,-3,-2,-1,0,1,2,3,4,5} 绝对值最小
{1,2,3,4,5,6,7,8,9,10}是最小正完全剩余系
简化剩余系:在每个剩余类选取至1个与m互素代表元构成简化剩余系。
当m=10则,{0,1,2,3,4,5,6,7,8,9} 完全剩余系
{1,3,7,9}是简化剩余系(x,10)=1
当m=5则，{0,1,2,3,4}为完全剩余系,
{1,2,3,4}是简化剩余系，因为除去余0(正好是倍数)外，其它都互素。
f(m)=欧拉函数=|{t|0&amp;lt;t&amp;lt;m, (t, m)=1}|
=简化剩余系的元素个数
维基百科_高斯引理
设_p_为奇[质数](https://zh.wikipedia.org/wiki/)，_a_是一个与_p_[互质](https://zh.wikipedia.org/wiki/)的整数。考虑以下数组：![{\displaystyle a,2a,3a,\dots ,{\frac {p-1}{2}}a}](https://wikimedia.org/api/rest_v1/media/math/render/svg/82941c63fd5e49cf0b57612ee5e895d1e1c9096c) 以及它们对_p_的[最小非负剩余](https://zh.wikipedia.org/w/index.php?title=&amp;action=edit&amp;redlink=1)。这些剩余两两不等（**kk:这些剩余两两不等的证明：可以考虑反证，假设两个不同的数x,y对于p同余， 那么x-y和0关于p同余，而x-y同时关于a同余，a与p互质，矛盾。因此这些剩余两两不等**），因此我们共有![\frac{p-1}{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a733b8495b0d55ed5bc9d795b7b6821efb1d858b) 个两两不等的介于1和_p（_**kk:这里似乎有问题，如果剩余是在1..p之间，那么前面应该是说最小正剩余而不是最小非负剩余，最小非负剩余应该是在0..p-1之间**_）_之间的整数：![{\displaystyle t_{1},t_{2},t_{3},\dots ,t_{\frac {p-1}{2}}}](https://wikimedia.</description></item><item><title>database connection error 的解决方案</title><link>https://111qqz.com/2016/10/database-connection-error-/</link><pubDate>Mon, 10 Oct 2016 10:37:14 +0000</pubDate><guid>https://111qqz.com/2016/10/database-connection-error-/</guid><description>
其实 东西之前出现过...不过好像重启一下服务器就可以了？
这次比较麻烦。
一开始我是直接google 了这条错误信息，结果答案五花八门，或者说...可能的原因非常多。
排查了几个。。。还是没有搞定。。。
突然想到。。。。为何不直接看log....我好傻啊。
2016-10-10 10:36:54 3755 [Note] IPv6 is not available. 2016-10-10 10:36:54 3755 [Note] - '0.0.0.0' resolves to '0.0.0.0'; 2016-10-10 10:36:54 3755 [Note] Server socket created on IP: '0.0.0.0'. 2016-10-10 10:36:54 3755 [ERROR] /alidata/server/mysql/bin/mysqld: Table './mysql/user' is marked as crashed and last (automatic?) repair failed 2016-10-10 10:36:54 3755 [ERROR] Fatal error: Can't open and lock privilege tables: Table './mysql/user' is marked as crashed and last (automatic?</description></item><item><title>codeforces 240 F. TorCoder (线段树)</title><link>https://111qqz.com/2016/10/cf240f/</link><pubDate>Wed, 05 Oct 2016 12:05:16 +0000</pubDate><guid>https://111qqz.com/2016/10/cf240f/</guid><description>
题目链接
题意：给一个仅由小写字母组成的字符串，然后m个操作，每个操作一个区间，要求把区间中排列成字典序最小的回文串，如果不能形成回文串，就忽略该操作。
思路：和上一道线段树优化计数排序的题目很像，几乎是一样的。
同样的，26棵线段树，每种字母对应一棵。
每次统计询问区间中每种字母的个数。
然后先判断是否能形成回文（奇数长度只有一个个数为奇数的，偶数长度不能出现个数为奇数的）
能的话重置区间，然后前后分别覆盖。
注意如果是奇数长度的话，记得先覆盖中间点。
需要注意这道题的输入输出方式不是标准的。。。而是要加文件。。。不然会MLE 1
然而Tle 19....Tle了好久。。。
最后换了种线段树的写法就过了。。。
然而后面这种写法就一定好么。。。。好像也不是。。。
总之是个挺玄学的东西。。。。不管了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月05日 星期三 04时00分51秒 File Name :code/cf/problem/240F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #include &amp;lt;bits/stdc++.h&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+1; int tree[26][N*4]; int lazy[26][N*4]; int n,m; char st[N]; int cnt[26]; int L,R; inline bool scan_d(int &amp;amp;num) { char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!</description></item><item><title>codeforces 558 E. A Simple Task (线段树优化计数排序)</title><link>https://111qqz.com/2016/10/cf558e/</link><pubDate>Tue, 04 Oct 2016 18:41:12 +0000</pubDate><guid>https://111qqz.com/2016/10/cf558e/</guid><description>
题目链接
题意：给出一个字符串，仅由小写字母组成。现在给出q个操作，每个操作l,r,k三个参数，k=1表示把区间[l,r]变为升序排列，k=0表示把区间[l,r]变为降序排列。
思路：首先，最重要的一点是，由于只有26个字母，联想到计数排序。
对于字符集数目比较小情况，一定要想到计数排序。
对于字符集数目比较小情况，一定要想到计数排序。
对于字符集数目比较小情况，一定要想到计数排序。
那么我们回顾计数排序，不妨考虑升序排列的情况，是怎么做的呢？
做法是统计该区间中每种字符的个数，然后按照字符的大小，从小到大在区间上从左到右得放置每种字符。
大概是这样子：
for(int j=x;j&amp;lt;=y;j++) cnt[s[j] - 'a']++; ind = 0; for(int j=x;j&amp;lt;=y;j++) { while(cnt[ind] == 0) ind++; s[j] = ind + 'a'; cnt[ind]--; } 然而这个复杂度每次是o(n)的。。。
我们需要用线段树来优化计数排序的过程。。。
思考计数排序其实分为两个过程：
一是统计某区间中每个字符的个数。
二是将字符按照字符的大小顺序重新放回区间。
我们可以建26棵线段树，一种字母对应一棵。
对于过程一，我们可以直接query.
对于过程2，由于相同的字母总是相邻在一起的，因此可以用线段树成段更新来优化，也就是lazy标记。
tree[id][rt]表示第id棵线段树对应的区间中字母id+'a'-1的个数。
lazy[id][rt]三种值，-1表示没有标记，0表示重置标记，1表示被某种字母覆盖的标记。（重置的意思是，该区间被排序了，但是还不确定该区间上字母是哪些）
输出的时候，对于某个位置，只要query到26个字母中值不为0的那个输出就好了。
总的复杂度：O(26qlgn)
代码注释中还有部分细节和理解
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 23时59分11秒 File Name :code/cf/problem/558E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int tree[27][N&amp;lt;&amp;lt;2];//26棵线段树，表示26个字母在对应区间中的个数。 int lazy[27][N&amp;lt;&amp;lt;2];//lazy存储的是某段区间是否被某个字母覆盖.</description></item><item><title>codeforces 605 A. Sorting Railway Cars (dp)</title><link>https://111qqz.com/2016/10/cf605a/</link><pubDate>Tue, 04 Oct 2016 12:59:16 +0000</pubDate><guid>https://111qqz.com/2016/10/cf605a/</guid><description>
题目链接
题意：给出一个n个数的排列，每次可以把一个数放到最前面或者最后面的位置，问至少要进行多少次操作才能使得数列升序。
思路：考虑不被移动的那些数，当把所有一定的数去掉以后，这些剩下的数一定是一段数值连续，位置递增的数。如果想要移动的数最少，俺么这串递增的数就尽可能长。
dp[a[i]] = dp[a[i]-1] + 1
那么ans = n - max{dp[i]}
另外：对于要移动的数，我们可以按照一定顺序（放在前面的数按照递减顺序，放在最长序列后面的数按照递增顺序）移动，可以保证每个数只需要移动一次。
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 20时10分00秒 File Name :code/cf/problem/605A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 496 C Removing Columns (构造)</title><link>https://111qqz.com/2016/10/cf496c/</link><pubDate>Tue, 04 Oct 2016 11:37:22 +0000</pubDate><guid>https://111qqz.com/2016/10/cf496c/</guid><description>
题目链接
题意：给一个n*m的由小写字母组成的table.要求从上往下每一行字典序不严格递增。问最少删除几列才能满足。
思路：一开始想的是用一个left数组维护每次删除后某一列左边是哪一列，目的是为了下次的判断。
再想了下，发现没必要。我们只需要知道，两行之间的关系是否确定就好了。over[i][j]为真表示第i行和第j行的胜负已分，对于胜负已分的行，大小无所谓。
对于胜负未分的行，如果table[i][j]&amp;gt;table[i+1][j]，就必须要删掉这一列了。。。。
需要注意的是，某一列最多删一次，记得打上标记。
以及ove标记的时候，要在最后确定这一列没有被删以后再标记。。。用一个set存下可能的胜负已分的行的下标即可。
1A
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 19时10分39秒 File Name :code/cf/problem/496C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; char table[N][N]; int n,m; bool mark[N]; bool over[N][N]; int left[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 509 B. Painting Pebbles （构造）</title><link>https://111qqz.com/2016/10/cf509b/</link><pubDate>Mon, 03 Oct 2016 19:09:23 +0000</pubDate><guid>https://111qqz.com/2016/10/cf509b/</guid><description>
题目链接
题意：n堆石子，每堆a[i]个，k种颜色。给每个石子涂色，要求对于每种颜色，任意两堆中该颜色石子的个数最多差一个。问是否有解，有解输出一组方案。
思路：我们发现有解与否只和最大值最小值有关。
设mn为最小值,mx为最大值。
当mx&amp;gt;mn+k时无解，否则有解。
如果有解。。。输出方案就好了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 02时40分20秒 File Name :code/cf/problem/509B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,k; int a[105]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #375 D. Lakes in Berland (dfs)</title><link>https://111qqz.com/2016/10/cf375d/</link><pubDate>Mon, 03 Oct 2016 18:03:37 +0000</pubDate><guid>https://111qqz.com/2016/10/cf375d/</guid><description>
题目链接
题意：nm个格子，有和.两种类型。定义一个湖为边相邻的只有.组成的最大点集合，且任何一个.不在边界上。现在给出一个nm的图保证至少有k个湖。问填多少个.成，才能使得恰好有k个湖。
思路：贪心，先处理出所有的湖的大小，然后从小往大填。
注意dfs的时候如果某个“可能”的湖遇到了边界，要把之前打的标记撤销掉。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 21时18分03秒 File Name :code/cf/#375/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0};tanxin const int inf = 0x3f3f3f3f; const int N=55; char maze[N][N]; int n,m,k; int vis[N][N]; int lake_cnt=0; int siz; struct node { int id; int val; bool operator &amp;lt; (node b)const { return val&amp;lt;b.</description></item><item><title>codeforces #375 C. Polycarp at the Radio (贪心)</title><link>https://111qqz.com/2016/10/cf375c/</link><pubDate>Mon, 03 Oct 2016 17:57:53 +0000</pubDate><guid>https://111qqz.com/2016/10/cf375c/</guid><description>
题目链接
题意：给出n,m，n个数，对其中的一些数进行修改，要求1..m中出现次数最少的数最大，输出这个最少的数最大是多少，以及修改的次数。
思路：最小的数最多出现n/m次。
竟然因为排序后下标变乱不知所措40分钟。。。我也是醉了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 19时29分52秒 File Name :code/cf/#375/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2005; int n,m; int a[N]; struct node { int id; int val; bool operator &amp;lt; (node b)const { return val&amp;lt;b.</description></item><item><title>弱校连萌 2016 10.3</title><link>https://111qqz.com/2016/10/-2016-10-3/</link><pubDate>Mon, 03 Oct 2016 08:59:37 +0000</pubDate><guid>https://111qqz.com/2016/10/-2016-10-3/</guid><description>
题目链接
。。。sad.....
果然没睡够&amp;amp;起来就写题脑子完全就是不清醒的状态。。。
这个不清醒。。。主要体现在。。。。10+次。。。忘记删条件编译。。。
改着改着。。。就忘记这件事了。。。好烦啊。。。本来早就A了。。。结果又接着去改。。。
题目链接：jag2016
就水了三道题。。。。
A是个暴力。。直接O(n2)算乘积，然后再check一下合法性就好。。。尼玛wa到我怀疑人生。。。过了好久才考虑也许是不支持条件编译的问题。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 12时37分27秒 File Name :code/weakteam/20161003/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; int a[N]; int ans = -1; int digit[20]; void check(int x) { ms(digit,0); int len = 0 ; int xx = x; while (x) { digit[++len] = x; x/=10; } for ( int i = len-1 ; i&amp;gt;=1 ; i--) { if (digit[i+1]-digit[i]!</description></item><item><title>codeforces 468 A. 24 Game (构造)</title><link>https://111qqz.com/2016/10/cf468a/</link><pubDate>Sun, 02 Oct 2016 17:14:48 +0000</pubDate><guid>https://111qqz.com/2016/10/cf468a/</guid><description>
题目链接
题意：给出n，有1..n n个数，可以选择两个数进行加，减，乘，三种操作，操做完得到一个数放回。 n-1次操作后只剩下一个数。现在要求剩下的数为24.问方法。
思路：我们发现。。。两个数相减可以为1.。那么只要找到4个数的方案和5个数的方案就好了。。。
4个数：123*4
5个数：4*5+3+2-1
然而窝一开始以为必须前面减后面。。。
所以是按照4K,4K+1,4K+2,4K+3分的类。。。每4个数得到两个-1，再相乘。。。。麻烦了一点。。代码写了一半的时候意识到了按2K,2K+1分类就行。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 00时50分18秒 File Name :code/cf/problem/468A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;code/in.</description></item><item><title>codeforces 679A A. Bear and Prime 100 (交互题，构造)</title><link>https://111qqz.com/2016/10/cf679a/</link><pubDate>Sun, 02 Oct 2016 12:58:24 +0000</pubDate><guid>https://111qqz.com/2016/10/cf679a/</guid><description>
题目链接
题意：存在一个[2..100]之间的数，每次可以询问一个数是否是该数的因子，返回yes或者no,最多询问20次。每次要输出询问的数，以及最后要输出这个数是否是质数。
思路：第一次做交互题。。。发现完全不能按照以前的思路。。。
更像是相反的。。。把output看做某种输入。。。input里是某种结果。。。我要根据input里的东西来确定一些东西。
就是先有output，再有input。。。output是选手的输入（最后一个除外），input是返回结果(不是你写的代码的返回结果）
对于这道题。。我们要尽可能少得猜一个数的因子，以确定该数是否为质数。
一个数不是质数的话，就有至少两个大于1的因子。。。
很容易想到。。。判素因子。。。
由于至少有2个非1的因子才不是素数。。。最小为2，因此另一个因子不会大于50.。。
此外。。。有可能有两个相同质因数组成的因子。。。。
因此还要判一下22,35,55,77
/* *********************************************** Author :111qqz Created Time :Sun 02 Oct 2016 08:22:44 PM CST File Name :code/cf/problem/679A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int prime[19]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49}; string st; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bestcoder #88 || hdu 5908 Abelian Period(暴力)</title><link>https://111qqz.com/2016/10/hdu-5908/</link><pubDate>Sat, 01 Oct 2016 16:11:33 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-5908/</guid><description>
题目链接
题意：一段数字串，如果一个数字k满足，将该串分成若干个长度为K的子串，这些子串两两满足每个字符出现的次数一样多，那么称为k是一个阿贝尔周期。现在问所有合法的阿贝尔周期。
思路：
* 首先我们发现，所有的阿贝尔周期一定是数字串长度（设为n)的因数。 * 然后我们还发现。。。如果某个因子是阿贝尔周期，那么该因子的整数倍中恰好也是n的因子的也一定是阿贝尔周期，类似筛法。 * 然后我们还发现。。。最小的阿贝尔周期一定比数字串中的元素个数大。。。
然而其实后面两个不管也可以过吧。。。因为有点忘了n的约数个数的上界了。。。。
还是太保守了。。。
不过hack了四发哈哈哈。。。要是大号的话今天就紫了呜呜呜
/* *********************************************** Author :111qqz Created Time :2016年10月01日 星期六 18时58分00秒 File Name :code/bc/#88/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; vector &amp;lt;int&amp;gt;factor; int cnt[N]; set&amp;lt;int&amp;gt;se; bool vis[N]; int a[N]; set&amp;lt;int&amp;gt;ans; bool solve(int st,int en) { bool ret = true; for ( int i = st ; i &amp;lt;= en ; i++) { cnt[a[i]]--; if (cnt[a[i]]&amp;lt;0) ret = false; } for ( int i = st ; i &amp;lt;= en ; i++) cnt[a[i]]++; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>20160929好虚啊</title><link>https://111qqz.com/2016/09/20160929/</link><pubDate>Thu, 29 Sep 2016 14:47:10 +0000</pubDate><guid>https://111qqz.com/2016/09/20160929/</guid><description>
好虚啊。。。
线段树勉强写完了单点更新的一组题。。。。16道题写了20天。。。
后面的带lazy标记的简直难度上天啊orz...刷不动==
然后想回头复习下数位dp吧。。。发现也是各种被卡。。。
突然想起去年北京的那个银牌题。。。又看了下。。。发现卡在了数位dp之前的地方。。。。。？
啊啊啊啊 啊啊，要打铁了要打铁了要打铁了。。。</description></item><item><title>hdu 3967 Zero's Number (不允许前导0（新写法）的数位dp)</title><link>https://111qqz.com/2016/09/hdu-3967/</link><pubDate>Thu, 29 Sep 2016 08:46:11 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-3967/</guid><description>
题目链接
题意：给出l,r,k，定义f(n,k)为将数n分成左右两个非空的部分，再求和之后能被k整除的方案数。
现在问区间[l,r]中所有f(i,k)的和。
思路：数位dp...
枚举一下分点即可。。想到这个这题就A了。。。
然后相当于做分点个数个数位dp...求和即可。
dp[i][j][k][p]表示第i位，前半部分%k的结果，后半部分%k的结果，是否有前导0.
然后关于前导0这个。。。换了一种写法。。。加了一个状态在dp数组里。。。
不然每次都要一个if。。。感觉有点丑。。。。这样写简介了一点。。。
以及。。因为每次k是不同的。。。我dp状态记录的时候又没有记录k...所以记得每次初始化成-1。。。
因为忘记这个结果第二个样例调了好久一直是31。。。。
/* *********************************************** Author :111qqz Created Time :Thu 29 Sep 2016 02:49:50 PM CST File Name :code/hdu/3967.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int k; LL l,r; int digit[20]; LL dp[20][20][20][20][2]; LL dfs( int pos,LL sum1,LL sum2,bool limit,int cut,int prehasnonzero) { if (pos==0) return (sum1+sum2)%k==0; if (!</description></item><item><title>FZU 2113 Jason的特殊爱好 (数位dp)</title><link>https://111qqz.com/2016/09/fzu-2113/</link><pubDate>Wed, 28 Sep 2016 19:07:09 +0000</pubDate><guid>https://111qqz.com/2016/09/fzu-2113/</guid><description>
题目链接
题意：统计区间[a,b]里数字1出现的次数。
思路：数位dp。
收获是，dfs传递的参数可能是为了判断符合条件的答案（比如不要62中的preis6等）
但是也可能是在统计答案信息。。。pos等于0的时候返回值未必是1和0.。。
然后傻逼fzu。。。long long 必须交 I64d..因为这个wa到死。
傻逼fzu，毁我青春。
/* *********************************************** Author :111qqz Created Time :Thu 29 Sep 2016 02:20:09 AM CST File Name :code/fzu/2113.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL l,r; int digit[30]; LL dp[30][30]; LL dfs( int pos,int cnt,bool limit) { if (pos==0) return cnt; if (!</description></item><item><title>codeforces 145 E. Lucky Queries (线段树lazy标记)</title><link>https://111qqz.com/2016/09/cf145e/</link><pubDate>Tue, 27 Sep 2016 11:15:53 +0000</pubDate><guid>https://111qqz.com/2016/09/cf145e/</guid><description>
题目链接
题意：给出一串只由数字'4'和'7'组成的串。两种操作，一种是询问整个串中最长非下降子序列的长度，另一种给出区间[l,r]，将区间中的没个数反转，反转的定义为，4变成7,7变成4.
思路：线段树lazy标记。
线段树的域记录5个信息，c4,c7,c47,c74，flip,a分别表示4的个数,7的个数，非下降子序列的个数，非上升的子序列的个数，以及该区间是否被翻转。
纠结了很久PushUp操作。。。。
c4和c7倒是没什么疑问。。。。
一开始觉得c47是由三部分的最大值更新得到的。。。
left.c4+right.c47,left.c4+right.c7,left.c47+right.c7...
但是样例过不了。。。
纠结了半天发现。。。
比如4774,4444是左右两个区间的时候。。。。
c47最大是5.。。但是left.c4 + right.c7=6，比正确答案大。
原因是。。一个区间中4的位置可能是分散的。。。这样只有某段连续出现的4对答案的贡献是正确的。。。
所以只有区间长度为1的时候c4+c7的更新方式才是合法的。。。
我们不妨在初始化的时候。。。。在线段树的叶子节点直接设置c47为1（当然相应地c74也要为1）
另外一个收获是。。。线段树对于区间的操作（对于点的操作也是同样）
不一定是某种常见的定义过的操作（求和啊，最大值最小值啊之类的）
也可能是某种自定义的操作。。。
比如这道题中的flip操作。。。
就是对区间的一个自定义的操作。。。
/* *********************************************** Author :111qqz Created Time :Tue 27 Sep 2016 09:14:22 AM CST File Name :code/cf/problem/145E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 1E6+7; int n,m; char st[N]; struct node { int c7,c4,c47,c74; bool flip; void out() { printf(&amp;quot;c4:%d c7: %d c47 :%d c74 : %d\n&amp;quot;,c4,c7,c47,c74); } }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 52 C. Circular RMQ (线段树区间更新，区间询问)</title><link>https://111qqz.com/2016/09/cf52c/</link><pubDate>Sun, 25 Sep 2016 22:43:40 +0000</pubDate><guid>https://111qqz.com/2016/09/cf52c/</guid><description>
题目链接
题意：一个循环数列，两种操作，一种是把某段区间中加上v，另一种是询问某区间的最小值。对于每个询问，输出答案。
思路：区间更新+区间询问的模板题....
注意体会pushdown以及update的时候。。。
要同时更新tree数组和lazy数组。。。
读入的时候可以用sscanf判断操作类型。。。
/* *********************************************** Author :111qqz Created Time :Mon 26 Sep 2016 05:30:21 AM CST File Name :code/cf/problem/52C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; LL a[N]; LL tree[N&amp;lt;&amp;lt;2]; LL lazy[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt] = min(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void PushDown( int rt) { if (lazy[rt]) { lazy[rt&amp;lt;&amp;lt;1] += lazy[rt]; lazy[rt&amp;lt;&amp;lt;1|1] +=lazy[rt]; tree[rt&amp;lt;&amp;lt;1] +=lazy[rt]; tree[rt&amp;lt;&amp;lt;1|1] +=lazy[rt]; lazy[rt] = 0; } } void build( int l,int r,int rt) { if (rt) if (l==r) { tree[rt] = a[l] ; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } void update(int L,int R,LL sc,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) { lazy[rt] +=sc; tree[rt] +=sc; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,sc,lson); if (R&amp;gt;=m+1) update(L,R,sc,rson); PushUp(rt); } LL query( int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; LL ret = 1LL&amp;lt;&amp;lt;60; if (L&amp;lt;=m) ret = min(ret,query(L,R,lson)); if (R&amp;gt;=m+1) ret = min(ret,query(L,R,rson)); return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>重要的事情</title><link>https://111qqz.com/2016/09/</link><pubDate>Sun, 25 Sep 2016 20:43:02 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
我学不会dp不是因为我智商低，而是因为没有足够好的资料。 ** 我学不会dp不是因为我智商低，而是因为没有足够好的资料。** ** 我学不会dp不是因为我智商低，而是因为没有足够好的资料。**</description></item><item><title>hdu 5904 LCIS (dp)</title><link>https://111qqz.com/2016/09/hdu-5904-lcis-dp/</link><pubDate>Sun, 25 Sep 2016 20:13:38 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-5904-lcis-dp/</guid><description>
题目链接
题意： 给定两个序列，求它们的最长公共递增子序列的长度, 并且这个子序列的值是连续的 思路：以值为连续做入手点。
很显然个鬼咯 dp[a[i]]表示以a[i]结尾的最大长度。 dp[a[i]] = dp[a[i-1]] + 1 对于b序列一样。
答案为 MAX(min(dp[i],dp2[i])) ( 1=&amp;lt;i &amp;lt;= 1E6)
/* *********************************************** Author :111qqz Created Time :Mon 26 Sep 2016 04:02:24 AM CST File Name :code/hdu/5904.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int dp[N],dp2[N]; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 455 E. Function (斜率优化，线段树套凸包)</title><link>https://111qqz.com/2016/09/cf455e/</link><pubDate>Sun, 25 Sep 2016 16:10:49 +0000</pubDate><guid>https://111qqz.com/2016/09/cf455e/</guid><description>
题目链接 题意：已知 f(1, j) = a[j] f[i][j] = min (f[i-1][j],f[i-1][j-1]) 然后给出 n n≤1E5​​ 个数（a[i] a​i​​≤1E4​​)，给出 m组查询（m&amp;lt;=1E5），每组两个数 x,y 问 f(x,y) 是多少。
参考题解：茶姐的回答（下标好像搞错了，领会意思即可
官方题解
以及前置技能点是：斜率优化+线段树
思路：考虑一排数a[1]到a[n]，原问题可以转化成从a[y]走x-1步，每一步原地不动或者向左移动一个格子后的总的代价。
Function is calculated as follows: , k__i — how many times we visited the i th element of the array a.
这个式子感觉不是很明确。。。。
窝来解释一下。。。l=y-x+1是可能走到的最左边的点。。。。
终点在【L,Y】区间内都是合法的。。。。
然后考虑代价最小的情况。。。
一定是在最小的格子上尽可能多得停留，在其他格子上只停留一次。。。
对于终点为l的情况，走到y要花费y-l步,一共要走x-1步，那么多出来x-1-(y-l)步，这些步停留在最小的点上是最优的，最小的点上之前停留了一次，现在再多停留x-1-(y-l)次，也就是停留了x-(y-l)次。
那么，另一个结论是，区间[l,y]中，当a[l]为最小的时候才是最优的。。。
为什么呢？
假设a[k] (k&amp;gt;l)是最小，那么以a[k]为终点的情况一定比以a[l]为终点的情况优秀（因为多走了【l,k-1】之间的点。。。走这些点比停留在a[k]的代价大）
因此对于l是终点的情况，一定在a[l]是最小值的时候是最优的。
此时代价为：
sum[y] - sum[l] + a[l]·(x - (y - l))
我们变形得到：
sum[y] - sum[l] + a[l]·(x - (y - l)) = sum[y] - sum[l] + a[l]·(x - y + l) = sum[y] - sum[l] + a[l]·l + a[l]·(x - y) = sum[y] + (a[l]·(x - y) + a[l]·l - sum[l])</description></item><item><title>hdu 3507 Print Article (斜率优化dp)</title><link>https://111qqz.com/2016/09/hdu3507/</link><pubDate>Sat, 24 Sep 2016 16:10:18 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu3507/</guid><description>
题目链接
题意：n个数，分成若干段，每段的代价为 ，求最小代价。
思路：dp。
状态方程很显然个鬼。。。
dp[i] 表示处理完前面i个数的最小代价。
dp[0] = 0 ;
dp[i] = min(dp[j]+(sum[i]-sum[j])^2) ( 0&amp;lt;j &amp;lt;i),sum[i]为a[i]的前缀和。
这复杂度是n^2的。。。然而n最大5E5.....boom....
斜率优化登场！
这篇博客讲得非常好
我们假设k两边移项一下，得到：(dp[j]+num[j]^2-(dp[k]+num[k]^2))/(2*(num[j]-num[k]))&amp;lt;sum[i]。我们把dp[j]-num[j]^2看做是yj，把2*num[j]看成是xj。
那么不就是yj-yk/xj-xk&amp;lt;sum[i]么？ 左边是不是斜率的表示？
那么yj-yk/xj-xk&amp;lt;sum[i]说明了什么呢？ 我们前面是不是假设j的决策比k的决策要好才得到这个表示的？ 如果是的话，那么就说明g[j,k]=yj-jk/xj-xk&amp;lt;sum[i]代表这j的决策比k的决策要更优。
关键的来了：现在从左到右，还是设k&amp;lt;j&amp;lt;i，如果g[i,j]&amp;lt;g[j,k]，那么j点便永远不可能成为最优解，可以直接将它踢出我们的最优解集。为什么呢？
我们假设g[i,j]&amp;lt;sum[i]，那么就是说i点要比j点优，排除j点。
如果g[i,j]&amp;gt;=sum[i]，那么j点此时是比i点要更优，但是同时g[j,k]&amp;gt;g[i,j]&amp;gt;sum[i]。这说明还有k点会比j点更优，同样排除j点。
排除多余的点，这便是一种优化！
接下来看看如何找最优解。
设k&amp;lt;j&amp;lt;i。
由于我们排除了g[i,j]&amp;lt;g[j,k]的情况，所以整个有效点集呈现一种上凸性质，即k j的斜率要大于j i的斜率。
这样，从左到右，斜率之间就是单调递减的了。当我们的最优解取得在j点的时候，那么k点不可能再取得比j点更优的解了，于是k点也可以排除。换句话说，j点之前的点全部不可能再比j点更优了，可以全部从解集中排除。
于是对于这题我们对于斜率优化做法可以总结如下：
1，用一个单调队列来维护解集。
2，假设队列中从头到尾已经有元素a b c。那么当d要入队的时候，我们维护队列的上凸性质，即如果g[d,c]&amp;lt;g[c,b]，那么就将c点删除。直到找到g[d,x]&amp;gt;=g[x,y]为止，并将d点加入在该位置中。
3，求解时候，从队头开始，如果已有元素a b c，当i点要求解时，如果g[b,a]&amp;lt;sum[i]，那么说明b点比a点更优，a点可以排除，于是a出队。最后dp[i]=getDp(q[head])。
代码：
/* *********************************************** Author :111qqz Created Time :Sat 24 Sep 2016 02:16:33 PM CST File Name :code/hdu/3507.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int a[N],sum[N]; int dp[N]; int n,m; int q[N]; int head,tail; int calDp( int i,int j) { return dp[j] + m + ( sum[i] - sum[j] ) * ( sum[i] - sum[j] ); } int calUp(int j,int k) { return dp[j] + sum[j] * sum[j] - (dp[k] + sum[k] * sum[k]); } int calDown(int j,int k) { return 2*(sum[j] - sum[k]); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>斜率优化学习笔记</title><link>https://111qqz.com/2016/09/</link><pubDate>Sat, 24 Sep 2016 15:38:00 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
浅谈数形结合思想在信息学竞赛中的应用
参考博客
这个东西英文好像叫做：convex hull trick
Convex_hull_trick_wiki codeforces convex hull trick
简单说说我的理解：斜率优化是一种数形结合的思想。。。
对于一个dp的若干状态。。。有些状态是不会对答案有贡献的。。。这些我们就可以不考虑。。。
简单地说。。。如果把状态的下标和状态对应成二维平面的点。。。
凸起来的点一定不会影响答案。。。
具体证明参考论文。。。。。
也就是维护一个&amp;quot;下凸折线&amp;quot;
具体维护的办法是用单调队列来维护。。。
感觉还是挺简单的。。。。</description></item><item><title>2017 小米 软件工程师 校招 笔试题 (模拟)</title><link>https://111qqz.com/2016/09/2017-----/</link><pubDate>Fri, 23 Sep 2016 15:51:41 +0000</pubDate><guid>https://111qqz.com/2016/09/2017-----/</guid><description>
题意：一串电话号码，每个数字+8取各位后，把每个数字写成对应的大写英文，从&amp;quot;ZERO&amp;quot;和“NINE”，然后打乱字母的顺序。现在给出打乱的字母顺序，问可能的字典序最小的电话号码是是多少（可能有前导0）
思路：分析0..9 每个数字的英文组成。。。然后大概类似解方程。。可以根据字母的个数确定每个数字的个数。。。
然后-8。。。存一下排个序就好了。。。1A
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char st[N]; int len; int a[30]; int cnt[15]; //0.</description></item><item><title>codeforces 380 C. Sereja and Brackets (线段树区间合并)</title><link>https://111qqz.com/2016/09/cf380c/</link><pubDate>Fri, 23 Sep 2016 10:38:51 +0000</pubDate><guid>https://111qqz.com/2016/09/cf380c/</guid><description>
题目链接 题意：给出一个由‘(’和‘）’组成的字符串。。。然后给出若干查询。。。每个查询一个区间，问区间中能匹配的括号数。。。
思路：考虑某一个区间中的括号匹配。。。其实是一个不断寻找'()'然后删去的过程。。。
因此对于某个区间的括号匹配数。。。等于左边区间和右边区间和合法匹配数之和，再加上左区间和右区间新的能匹配到一起的括号数。
（说“因此”是因为。。。只要左边有没匹配的左括号。。。右边有没匹配的右括号。。。因为他们中间有的都是匹配好的括号，会被删除。。。所以两边的括号总能匹配在一起）
具体做法是：
线段树的节点中有三个域，分别表示，合法的括号匹配数，没有被匹配的左括号数，和没有被匹配的右括号数。
query的时候要合并左右两个区间。。。不过可能某一区间中为空。。。这里合理得初始化为node(0,0,0)，就不用分情况讨论了。。。
一个和node(0,0,0)合并对原来的答案没有影响。。。。
以及，凡是需要在query的时候合并区间的问题。。。（不是那种简单的sum,min/max合并）
返回一个node会方便很多。。。。。
/* *********************************************** Author :111qqz Created Time :Fri 23 Sep 2016 05:32:22 PM CST File Name :code/cf/problem//380C.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; struct node { int left,right,sum; node (){} node ( int x,int y,int z): left(x),right(y),sum(z){}; }tree[N&amp;lt;&amp;lt;2]; char st[N]; int n; void PushUp( int rt) { int add = min(tree[rt&amp;lt;&amp;lt;1].</description></item><item><title>挫败感++</title><link>https://111qqz.com/2016/09/too-sad-to-live/</link><pubDate>Thu, 22 Sep 2016 10:57:06 +0000</pubDate><guid>https://111qqz.com/2016/09/too-sad-to-live/</guid><description>
。。。。。
代码不会写。。。成绩又烂。。。又不会勾搭妹子。。。。
。。。。。。
对比一下。。。。。算了还是不对比了。。。。。
啊。。。人生啊。。。活得好失败T T</description></item><item><title>【施工中】回文自动机学习笔记</title><link>https://111qqz.com/2016/09/</link><pubDate>Thu, 22 Sep 2016 09:36:22 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
是14年才被提出来的算法... 先%一下该算法的作者：作者的codeforces页
接下来，老规矩，放一波资料：
参考博客1 codeforces上的讲解
20171115 update:
emmmm，这篇是学习笔记是１６年９月写的。。。。一转眼13个月过去了啊。。
回文树，也叫回文自动机，简称PAM
学了SAM之后PAM简直是傻逼算法...
该算法时间和空间复杂度都是O(n)
这样的复杂度基于以下结论：
长度为n的字符串的本质不同的回文串的数目不超过n
因此状态数开到和字符串长度一样就可以了orz
len表示某个状态所表示的回文串的长度
cnt表示某个状态所表示的回文串的数量
构建PAM的算法仍然是增量算法，在某一时刻，本质不同的回文串的数量是sz-1 (sz标号从０开始，出去标号为０和标号为１的２个根)
唯一需要特别注意的是
在构建完PAM之后，沿着回文链（类比后缀链)从底向上跑一遍得到的cnt，才是真正的cnt
在构建完PAM之后，沿着回文链（类比后缀链)从底向上跑一遍得到的cnt，才是真正的cnt
在构建完PAM之后，沿着回文链（类比后缀链)从底向上跑一遍得到的cnt，才是真正的cnt
我的模板：
/* *********************************************** Author :111qqz Created Time :2017年11月15日 星期三 20时31分58秒 File Name :PAM.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct PAM { //cnt表示某个节点的回文串的数量 //len表示的是该状态所表示的回文串的长度 //PAM有２个根，分别为状态０和状态１ //初２个根外，其余每个状态表示一个本质不同的回文串,总数为sz-1 struct state { int fail,cnt,len; int nxt[26]; }st[N]; char S[N],RS[N]; int n,now,sz; int Right[N];//Right[i]表示以i结尾的最长回文串的长度 int Left[N]; //Left[i]表示以i开头的最长回文串的长度.</description></item><item><title>codeforces 594 D. REQ (树状数组+欧拉函数+逆元)</title><link>https://111qqz.com/2016/09/cf594d/</link><pubDate>Thu, 22 Sep 2016 07:48:00 +0000</pubDate><guid>https://111qqz.com/2016/09/cf594d/</guid><description>
题目链接
题意：给出n个数,q个查询，每组一个区间，询问区间中所有数的乘积的欧拉函数9+7的答案是多少。
思路：这道题需要一点欧拉函数的知识。
phi(n)是欧拉函数，意义为小于等于n并且与n互质的数的个数。
To calculate the answer on every query let's use the formula , where _p_1, p_2, ..., p__k — all prime numbers which divided_n.
如果知道欧拉函数的这个公式。。。那么这道题就成了水题。。。。
考虑两个数a,b的欧拉函数。
一开始考虑也许有什么性质。。。查了下欧拉函数的wiki 欧拉函数_维基百科 欧拉函数是积性函数（但不是完全积性函数。。因此必须phi(ab) =phi(a)*phi(b)成立当且仅当gcd(a,b)==1)
然而这里并不一定满足互质的条件。。。
再想一下。。。发现完全没必要由phi(a)和phi(b)得到phi(a*b)
直接把a*b看成一个数就好了。。。。
后面质因子乘积部分只需要把两部分的并在一起就好了。。。
所以根据上面欧拉函数的公式。。。答案分为两部分。。。
一部分是区间中所有数的乘积。。。
一部分是区间中所有数的不相同的素因子的p-1/p形式的乘积。。。
第一部分预处理前缀积即可。。。由于有%运算。。。所以除的时候需要计算逆元。。。
第二部分的做法同spoj_dquery解题报告
也是离线处理，把询问按照区间右端点排序升序排列，然后lst数组记录上次该数出现的位置。。。用bit维护一个从1到某个数的乘积。。。在撤销的时候同样需要逆元。。。
还要注意。。。太长的式子一定要分开写。。。。
因为写错括号顺序调了半天orz...
/* *********************************************** Author :111qqz Created Time :Thu 22 Sep 2016 02:07:39 PM CST File Name :code/cf/problem/594D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; const int M=1E6+7; const LL MOD = 1E9+7; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { return r&amp;lt;b.</description></item><item><title>poj 2886 Who Gets the Most Candies? （线段树模拟加强版约瑟夫问题+反素数)</title><link>https://111qqz.com/2016/09/poj-2886/</link><pubDate>Wed, 21 Sep 2016 17:03:08 +0000</pubDate><guid>https://111qqz.com/2016/09/poj-2886/</guid><description>
poj 2886 题目链接
题意：n个人围成一圈，每个人身上由一个数，可正可负。从第k个人开始出圈，如果第k个人身上的数是X,X&amp;gt;0，就左边第x个没有出圈的人出圈，否则右边第-X个人出圈。 第k个人出圈得到的糖果数目为f(k)，f(x)表示x的因子个数。现在问谁能拿到最多的糖果，并且拿到了多少糖果。
思路：看起来好像很麻烦。。其实可以分解成两个问题。
第一个子问题就是约瑟夫问题的加强版。。。每次间隔不是定数，而取决与上一次出队的人。。。
终点是数据有5E5.。。模拟的话会炸掉。。。所以用线段树来模拟这个过程。。。
类似于那道插队的问题。。。线段树的域存的是某区间中空位置的数量。。初始为1.。。
然后每次update的时候优先查看左子树。。。
第二个子问题就是。。。到底第几个出去的人那道的糖果最多。。。。
其实也就是求1..n中。。。因子数最大的那个。。。
利用反素数表。。。每次upper_bound一下即可。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 09:19:11 PM CST File Name :code/poj/2886.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int tree[N&amp;lt;&amp;lt;2]; int n,k; char nam[N][11]; int val[N]; int s[40] = {1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,500001}; int b[40] = {1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200}; void PushUp( int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void build( int l,int r,int rt) { if (l==r) { tree[rt] = 1; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } int update( int p,int l,int r,int rt) { if (l==r) { tree[rt]--; return l; } int m = (l+r)&amp;gt;&amp;gt;1; int ret; if (p&amp;lt;=tree[rt&amp;lt;&amp;lt;1]) ret = update(p,lson); else ret = update(p-tree[rt&amp;lt;&amp;lt;1],rson); PushUp(rt); return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1053: [HAOI2007]反素数ant</title><link>https://111qqz.com/2016/09/bzoj-1053/</link><pubDate>Wed, 21 Sep 2016 12:31:01 +0000</pubDate><guid>https://111qqz.com/2016/09/bzoj-1053/</guid><description>
1053: [HAOI2007]反素数ant Time Limit: 10 Sec Memory Limit: 162 MB Submit: 2750 Solved: 1559 [Submit][Status][Discuss]
Description 　对于任何正整数x，其约数的个数记作g(x)。例如g(1)=1、g(6)=4。如果某个正整数x满足：g(x)&amp;gt;g(i) 0&amp;lt;i&amp;lt;x
，则称x为反质数。例如，整数1，2，4，6等都是反质数。现在给定一个数N，你能求出不超过N的最大的反质数么
？
Input 　一个数N（1&amp;lt;=N&amp;lt;=2,000,000,000）。
Output 　不超过N的最大的反质数。
Sample Input 1000
Sample Output 840
HINT Source 思路：dfs然后剪一下。。。和ural 1748同样的做法。。。。
还可以。。。打表。。。。
有表不打和咸鱼有什么区别呢
（oi赛制不可以带纸质材料，所以打表大概算是恶习...不过acm不一样啊orz。。。反素数表1..1E18也才167个。。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 08:15:41 PM CST File Name :code/bzoj/1053.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL anti_prime[]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2095133040,2205403200,2327925600,2793510720,3491888400,4655851200,5587021440,6983776800,10475665200,13967553600,20951330400,27935107200,41902660800,48886437600,64250746560,73329656400,80313433200,97772875200,128501493120,146659312800,160626866400,240940299600,293318625600,321253732800,481880599200,642507465600,963761198400,1124388064800,1606268664000,1686582097200,1927522396800,2248776129600,3212537328000,3373164194400,4497552259200,6746328388800,8995104518400,9316358251200,13492656777600,18632716502400,26985313555200,27949074753600,32607253879200,46581791256000,48910880818800,55898149507200,65214507758400,93163582512000,97821761637600,130429015516800,195643523275200,260858031033600,288807105787200,391287046550400,577614211574400,782574093100800,866421317361600,1010824870255200,1444035528936000,1516237305382800,1732842634723200,2021649740510400,2888071057872000,3032474610765600,4043299481020800,6064949221531200,8086598962041600,10108248702552000,12129898443062400,18194847664593600,20216497405104000,24259796886124800,30324746107656000,36389695329187200,48519593772249600,60649492215312000,72779390658374400,74801040398884800,106858629141264000,112201560598327200,149602080797769600,224403121196654400,299204161595539200,374005201994424000,448806242393308800,673209363589963200,748010403988848000,897612484786617600,1122015605983272000,1346418727179926400,1795224969573235200,2244031211966544000,2692837454359852800,3066842656354276800,4381203794791824000,4488062423933088000,6133685312708553600,8976124847866176000,9200527969062830400}; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 27 E. Number With The Given Amount Of Divisors (dfs，反素数（假）)</title><link>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</link><pubDate>Wed, 21 Sep 2016 09:02:26 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</guid><description>
题目链接
题意：求约数个数恰好为n个的最小的x
思路：这道题是作为反素数的例题出现在acdreamer的博客里的。
但是实际上，这道题应该和反素数没有关系。
如果题目问的是最小的约数个数大于等于n的x，那么答案一定是反素数...打表就行了。。。
但是问的是**恰好，**比如如果n为5，那么最小的x是16，但是x不是反素数。
所以其实就是个dfs啦。
理论依据是：
一个数 A 可以分解成 p1k1 * p2k2 * …… * pnkn 其中p为素数。这样分解之后，A的因子个数
S = （k1+1） *（ k2+1） * …… *（ kn+1）
以及要找的是一个最小的x，满足约数个数等于n。
那么关于反素数的两个性质依然是满足的：
（1）一个反素数的所有质因子必然是从2开始的连续若干个质数，因为反素数是保证约数个数为![](http://img.blog.csdn.net/20140505150741093) 的这个数![](http://img.blog.csdn.net/20140505145329656) 尽量小 （2）同样的道理，如果 ，那么必有 /* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 04:48:42 PM CST File Name :code/cf/problem/27E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47}; int n; LL ans = 1LL&amp;lt;&amp;lt;60; void dfs( int depth,LL val,int num) { if (num&amp;gt;n) return; if (num==n&amp;amp;&amp;amp;val&amp;lt;ans) ans = val; for ( int i = 1 ; i &amp;lt;=63 ; i++) //最多63个质数。。。因为2^64&amp;gt;1E18 { if (val*prime[depth]&amp;gt;ans) break; dfs(depth+1,val*=prime[depth],num*(i+1)); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2521 反素数</title><link>https://111qqz.com/2016/09/hdu-2521/</link><pubDate>Wed, 21 Sep 2016 08:27:48 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-2521/</guid><description>
题目链接
题意：求区间[a,b]中约数最多的那个数，如果有多个，输出最小的。
思路：看起来好像和反素数没什么关系...只是打个约数个数的表...
但是实际上，所有的答案恰好都是反素数。。。
我们回顾反素数的定义：设f(x)为x的约数个数，那么如果f(n)&amp;gt;f(i) (0&amp;lt;i&amp;lt;n),n就被称为反素数.
换句话说，对于所有f(x)==k的x组成的集合，最小的那个x就是反素数。
需要注意的是，因数个数并不单调。。因此上面那句话并不准确。。。
举个例子，16虽然有5个因子，是第一个有5个因子的数，但是16不是反素数，因为比16小的12有6个因子。
那么这个东西有什么用呢。。。。
我们发现。。。反素数的分布很稀疏。。。因此。。。可以直接打表。。。
一张反素数的表(一共167个)：
{1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2095133040,2205403200,2327925600,2793510720,3491888400,4655851200,5587021440,6983776800,10475665200,13967553600,20951330400,27935107200,41902660800,48886437600,64250746560,73329656400,80313433200,97772875200,128501493120,146659312800,160626866400,240940299600,293318625600,321253732800,481880599200,642507465600,963761198400,1124388064800,1606268664000,1686582097200,1927522396800,2248776129600,3212537328000,3373164194400,4497552259200,6746328388800,8995104518400,9316358251200,13492656777600,18632716502400,26985313555200,27949074753600,32607253879200,46581791256000,48910880818800,55898149507200,65214507758400,93163582512000,97821761637600,130429015516800,195643523275200,260858031033600,288807105787200,391287046550400,577614211574400,782574093100800,866421317361600,1010824870255200,1444035528936000,1516237305382800,1732842634723200,2021649740510400,2888071057872000,3032474610765600,4043299481020800,6064949221531200,8086598962041600,10108248702552000,12129898443062400,18194847664593600,20216497405104000,24259796886124800,30324746107656000,36389695329187200,48519593772249600,60649492215312000,72779390658374400,74801040398884800,106858629141264000,112201560598327200,149602080797769600,224403121196654400,299204161595539200,374005201994424000,448806242393308800,673209363589963200,748010403988848000,897612484786617600,1122015605983272000,1346418727179926400,1795224969573235200,2244031211966544000,2692837454359852800,3066842656354276800,4381203794791824000,4488062423933088000,6133685312708553600,8976124847866176000,9200527969062830400}​ 当然这道题数据小可以直接打因数个数的表...
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 04:00:39 PM CST File Name :code/hdu/2521.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5005; int num[N]; int factor( int n) { if (n==1) return 1; int res = 2 ; int mx = n; for ( int i = 2 ; i &amp;lt; mx ; i++) if (n%i==0) res = n/i==i?</description></item><item><title>反素数学习笔记</title><link>https://111qqz.com/2016/09/</link><pubDate>Wed, 21 Sep 2016 07:24:41 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
acdreamer的博客
wiki上的反素数是什么鬼orz...完全不是一个东西吧。。。。
反素数直观得理解。。。就是一个约数特别多的数。。。因为素数的约数最少。。。所以约数多的数就叫反素数（？随便口胡的...
由于1E18之前的反素数大概只有167个。。。所以打表可以很方便。。。
反素数是第一个约数“增长”到某个数的数，必须是“增长”，而不是第一个约数个数为某个数的数。
因为16是第一个约数个数为5的个数，但是16不是反素数，因为比16小的12有6的约数。。。
反素数的两个性质非常好用。。。
一个是反素数分解的质因子一定是连续的。。。
另一个是反素数分解的质因子的指数一定不增。。。
这两个性质都很显然。。。。证明没啥必要。。。
这两个性质可以用来dfs的时候剪枝。。。</description></item><item><title>codeforces #609 F. Frogs and mosquitoes (线段树+二分)</title><link>https://111qqz.com/2016/09/codeforces-609-f-frogs-and-mosquitoes-/</link><pubDate>Tue, 20 Sep 2016 17:48:18 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-609-f-frogs-and-mosquitoes-/</guid><description>
题目链接
题意：n只青蛙，第i只位于x[i],舌头长度为t[i]。m只蚊子，第i只蚊子所在位置为p[i],蚊子的大小为b[i]。
蚊子按照出现顺序输入。
一只青蛙能吃到蚊子当且仅当蚊子和青蛙在同一个位置，或者蚊子在青蛙右边并且与青蛙的距离小于等于该青蛙舌头的长度。
当多只青蛙可以吃到同一只蚊子的时候，最左边的那只青蛙来吃。
当一只青蛙吃掉一只蚊子以后，青蛙的舌头增加蚊子的大小。
当一只青蛙吃掉一只蚊子后，因为舌头边长而又能吃到其他蚊子的时候，这只青蛙会继续吃，只到当前没有蚊子可以被任何一只青蛙吃到，在这个过程之后才会飞来下一只蚊子。
思路：问题的关键在于，对于某只蚊子，我们如何找到能吃到该蚊子的青蛙中最左边的那只。
可以抽象成寻找区间[1,r]中，最左边的那个&amp;gt;=x的元素。
联想到一个类似的问题：对于区间[1,n]，找到最左边的&amp;gt;=x的元素。做法是线段树维护最大值，只需要每次先query左子树，就可以保证找到额是最左边的。
但是如果是区间[1,r]呢。。。
我们发现。。。区间[1..k] (k&amp;lt;=r)的最大值是随着k的增大而不减的。。。。（最大值。。。肯定不减呀）
也就是说是单调的。。。因此我们可以考虑二分。。。这很重要。。。
寻找区间[1，r]中第一个大于等于x的元素，利用单调性来二分做是一个很经典的做法，复杂度(lgn)^2,注意体会。
因此具体做法是：
建树，存的是区间中x[i]+t[i]的最大值。
对于每一只飞来的蚊子，寻找能吃到它的最左边的青蛙的编号（具体做法是，先找到最后一个位置小于等于蚊子位置的青蛙的下标，作为青蛙的下标的上界，然后二分，每次query区间最大值，不断缩小区间。）
当蚊子被吃的时候记录答案，更新青蛙的各种信息（线段树要update)
并且由于青蛙的舌头变长了，可能吃到之前没有青蛙能吃到的蚊子，因此要把之前的没有能被青蛙吃到的蚊子存进一个multiset(因为蚊子可能落在同一个位置） 然后让当前的青蛙尽可能吃这些没有被吃到的蚊子，同时更新青蛙的各种信息，并在multiset中删除这只蚊子/
没被吃的时候就扔进multiset里。
需要注意multiset erase的时候要erase一个迭代器。。。不然会把所有相同的都删掉。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 12:30:16 AM CST File Name :code/cf/problem/609F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; LL ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; struct node { LL x,t; LL sum; int id; bool operator &amp;lt; (node b)const { return x&amp;lt;b.</description></item><item><title>codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)</title><link>https://111qqz.com/2016/09/cf540e/</link><pubDate>Tue, 20 Sep 2016 12:07:02 +0000</pubDate><guid>https://111qqz.com/2016/09/cf540e/</guid><description>
题目链接
题意：一个无穷数列，从1开始，初始第i个位置上为i，给出n个swap，每次交换两个位置的数。问交换n次以后得到的数列中，逆序对的数。
思路：
官方题解：
At first find the position of each element which is used in swap (using map). Now let's find the answer. It consists of the two parts. First part is the number of inversions formed by only whose elements which took part in the swaps. They can be counted by one of the standard ways: mergesort or Fenwick tree. The second part is the number of inversions formed by pairs of elements where one element has been swapped even once, and the other element stayed at his position.</description></item><item><title>poj 3579 Median (尺取法+二分)</title><link>https://111qqz.com/2016/09/poj-3579/</link><pubDate>Mon, 19 Sep 2016 16:54:21 +0000</pubDate><guid>https://111qqz.com/2016/09/poj-3579/</guid><description>
题意：给出n个数，两两做差的绝对值，共有m=n*(n-1)/2个，问其中的中位数是多少。特别地，当m为偶数的时候，中位数为第m/2个。
思路：二分中位数。
一开始还觉得由于中位数在整数意义上不连续不能二分。。。。
但是最后结果不可能是那样的答案啊。。。
check的条件是，以k为中位数的时候，绝对值小于k的数要小于(m+1)/2个（也就是中位数所在的位置）
check的时候尺取即可。
复杂度 排序O(nlgn) + 二分(lgn)*尺取O(n) ，整体O(nlgn)
/* *********************************************** Author :111qqz Created Time :Tue 20 Sep 2016 12:18:19 AM CST File Name :code/poj/3579.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL n,m; int x[N]; bool check( int k) { int cnt = 0 ; //cnt为绝对值小于k的对数,小于中位数的对数应该小于m个。 int head = 1; int tail = 1; while (head&amp;lt;=n) { while (x[tail]-x[head]&amp;lt;k&amp;amp;&amp;amp;tail&amp;lt;=n) tail++; tail--; cnt+=(tail-head); head++; } return cnt&amp;gt;=m; } int bin() { int l = 0 ; int r = x[n] - x[1]; while (l&amp;lt;=r) { int mid = (l+r)&amp;gt;&amp;gt;1; if (check(mid)) r = mid-1; else l = mid+1; } return l-1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2456 Aggressive cows (二分)</title><link>https://111qqz.com/2016/09/poj2456/</link><pubDate>Mon, 19 Sep 2016 15:15:57 +0000</pubDate><guid>https://111qqz.com/2016/09/poj2456/</guid><description>
题目链接
题意：给出n个x轴上的坐标点，选取其中c个，问c个之中任意两个点的最小距离最大是多少。
思路：二分距离check合法性。
大水题。。。因为想把三分艹掉。。。三分的题又多和二分挂在一起。。。顺便就写了。。。。
/* *********************************************** Author :111qqz Created Time :Mon 19 Sep 2016 10:57:54 PM CST File Name :code/poj/2456.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int x[N]; int n,c; bool check( int k) { int cnt = 1; int cur = x[1]; for ( int i = 2 ; i &amp;lt;= n ; i++) { if (x[i]-cur&amp;gt;=k) { cnt++; cur = x[i]; } } return cnt&amp;gt;=c; } int bin() { int l = 1; int r = x[n]-x[1]; while (l&amp;lt;=r) { int mid = (l+r)&amp;gt;&amp;gt;1; if (!</description></item><item><title>codeforces 515 E. Drazil and Park ( 线段树区间合并)</title><link>https://111qqz.com/2016/09/cf515e/</link><pubDate>Mon, 19 Sep 2016 10:54:47 +0000</pubDate><guid>https://111qqz.com/2016/09/cf515e/</guid><description>
题目链接
题意：圆上，询问任意一段弧中，任意两点的距离+两点的权值和的最大值。
思路：
1.环先拆成串，复制1..n到后面，变成1..2n。
化简公式：
2 * h[u] + 2 * h[v] + dist(u, v) = 2 * h[v] + d[1] + d[2] + ... + d[v-1] + 2 * h[u] - (d[1] + d[2] + ... + d[u-1]).
设A[v] = 2 * h[v] + d[1] + d[2] + ... + d[v-1], B[u] = 2 * h[u] - (d[1] + d[2] + ... + d[u-1]).
Another important thing is that L__u + R__v always bigger than L__v + R__u when u &amp;lt; v.</description></item><item><title>codeforces #351 D. Jeff and Removing Periods (线段树/树状数组判断位置成等差数列)</title><link>https://111qqz.com/2016/09/cf351d/</link><pubDate>Sun, 18 Sep 2016 13:53:39 +0000</pubDate><guid>https://111qqz.com/2016/09/cf351d/</guid><description>
题目链接 题意：有n个数，每次可以删除掉数值相同并且所在位置成等差数列（只删2个数或者只删1个数应该也是可以的），删掉这些数以后可以将剩下的数重新以任意顺序排列，称为一次操作。现在给出m个询问，每个询问一个区间[l,r]，问删光区间[l,r]中的数最少需要的操作次数。
思路/题解：由于第一次操作之后可以重排，那么把相同的数放在一起得到一个位置的公差为1的等差数列，之后的答案显然是元素个数。所以需要判断初始的时候，是否能一次删光某个数值的数，也就是需要判断初始时刻是否有某个数出现的所有位置组成一个等差数列。
(去icpc-camp的论坛问了一波。。。链接在这里)
之前刚刚学了判断一个区间中不同的数有多少个的姿势。。。
所以问题就在于如何判断这个等差数列。。。
参考叉姐的思路，我的思路如下：
就是从左往右扫的时候，对于当前的数，看该种数在当前位置左边且离当前位置最近的不能和当前位置构成等差数列的数的位置，然后用树状数组判断这个位置和当前查询区间的左端点的关系，如果左端点在这个位置左边，就不是等差，否则就是等差。 上面是判断一种数的情况。。。我要找到一种数满足题意即可。。
具体做法：
从左到右扫描每个元素，对于每种数字，肯定是有最长的一段后缀是等差数列，假设是 xx 个，那么左端点落在第 x + 1x+1 个后，这种数字就是全是等差数列。 我们可以拿一个树状数组把从第 (x + 1)(x+1) 个数往后全部 +1，询问时只要询问某个元素是不是 0 就可以了。 顺便说一句：叉姐人真的好nice啊。。本来昨天大概找了大半天题解。。看了代码也没看懂。。。
然后晚上去icpc-camp的论坛上问了一波。。。
然后茶姐的回复窝仍然看不懂。。。。。
感觉窝问的应该不是什么困难的问题（虽然我想了好久都想不出）。。。
所以纠结了好久要不要再问一下叉姐。。。。
最后还是问了。。。结果叉姐非常热心而又详细地回答了我。。。。
真是让我这种蒟蒻感动不已啊。。。。orz
怪不得人人爱叉姐。
/* *********************************************** Author :111qqz Created Time :Sun 18 Sep 2016 08:30:02 PM CST File Name :code/cf/problem/351D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N],pre[N],lst[N]; int n,m; int tree[N&amp;lt;&amp;lt;2]; int t[N]; int ans[N]; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (r==b.</description></item><item><title>2016 ShenYang regional online 1007||hdu 5898 odd-even number （数位dp）</title><link>https://111qqz.com/2016/09/hdu5898/</link><pubDate>Sun, 18 Sep 2016 11:15:08 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu5898/</guid><description>
题目链接
题意：题意说得一点页不清楚。。。意思在询问在区间[l,r]中满足某条件的数。该条件是，该数的任何一段数字是奇数组成的数串必须有偶数长度，任何一段数字是偶数组成的数串必须由奇数长度。
对于样例1，满足条件的29个数字分别是： 2,4,6,8,11,13,15,17,19,31,33,35,37,39,51,53,55,57,59,71,73,75,77,79,91,93,95,97,99.
对于样例2，满足条件的36的数字分别是：
110,112,114,116,118,
130,132,134,136,138
150,152,154,156,158
170,172,174,176,178
190,192,194,196,198
200,202,204,206,208,220
211,213,215,217,219
思路：数位dp.dp[i][j][k]表示长度为i，奇偶性相同的连续由j个，上一个的奇偶性为k.
注意不允许前导0.
其他就是细节了，太久没写数位dp调了好久啊QAQ
/* *********************************************** Author :111qqz Created Time :Sun 18 Sep 2016 01:11:37 PM CST File Name :code/net/2016/shenyang/1007.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int digit[40]; LL dp2[30][30][5]; LL dfs2(int pos,int cnt,int lst,bool limit,bool prehasnonzero) { if (pos==0) { if (lst==1&amp;amp;&amp;amp;cnt%2==0) return 1; if (lst==2&amp;amp;&amp;amp;cnt%2==1) return 1; return 0; } if (prehasnonzero&amp;amp;&amp;amp;!</description></item><item><title>spoj DQUERY - D-query (询问区间中不同数的个数，线段树(离线) or 莫队算法（离线） or 主席树（在线）)</title><link>https://111qqz.com/2016/09/spoj-dquery/</link><pubDate>Sat, 17 Sep 2016 12:01:43 +0000</pubDate><guid>https://111qqz.com/2016/09/spoj-dquery/</guid><description>
题目链接 题意：给出n个数，然后m个询问，每个询问一个区间[l,r],问该区间中不同的数有多少个。
思路：离线处理+线段树的做法不多说了：
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 11:34:32 PM CST File Name :code/spoj/dquery.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E4+7; const int M=2E5+7; int n,Q; int a[N]; int tree[N&amp;lt;&amp;lt;2]; map&amp;lt;int,int&amp;gt;mp; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (r==b.</description></item><item><title>codeforces 338 E. Optimize! (线段树维护最小前缀和）</title><link>https://111qqz.com/2016/09/codeforces-338-e-optimize/</link><pubDate>Fri, 16 Sep 2016 10:13:51 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-338-e-optimize/</guid><description>
题目链接
题意：题意是由伪代码给出的。。手算模拟了一下(noip初赛即视感），题意大概是说，给出两个数组a和b，a数组长度为n,b数组长度为len,然后从a中截取连续的len个元素，称为数组s，如果存在一种方法使得s中元素和b中的元素一一对应且每组和都大于等于h,则称这个s是合法的。现在问a中有多少个合法的s。 具体来说，对于样例 5 2 10 5 3 1 8 5 5 7
s={8,5}和s={5,7}是有解的。 因为对于前者8+3&amp;gt;=10并且5+5&amp;gt;=10,对于后者5+5&amp;gt;=10,7+3&amp;gt;=10,因此答案为2 思路：
最重要的一部是，我们先将b排序，然后维护一个函数f[i],在排序后的b中找到一个最小的j，满足a[i]+b[j]&amp;gt;=h,然后让f[i]=j?
f[i]直接二分就可以得到。。
因为f[i]的值是使得a[i]满足条件的最小的b值。
然后我们观察发现。
f[i]大于等于len的元素个数最多有1个，不然无解。
f[i]大于等于len-1的元素个数最多有2个，不然无解。
f[i]大于等于i的元素个数最多由len+1-i个，不然无解。
设g[i]=len+1-i-sum[i],sum[i]=y[i]+y[i+1]+...+y[len]。
如果某个s中，对于所有的i，都有g[i]&amp;gt;=0，那么这个s就是合法的。
实际上我们没有必要去查询每个g[i]，只要g[i]中最小的大于等于0，那么这个s就是合法的。
现在的问题就变成了动态维护一段长度为len的最小后缀和。
我的思路是整体覆盖，
当a数组的区间从[l,r]到[l+1,r+1]的时候，增加了a[r+1],假设f[r+1]=p,那么用线段树更新区间[1,p]，都增加1. 减少了a[l],假设f[l]=q,那么同样用线段树维护，使得区间[1,q]都减少1.
讲道理应该也可以做吧。。。
不过被羊神@sheep教育说其实单点更新就可以。。。
于是去学了下动态维护区间最大子段和的线段树做法： bzoj 1756解题报告hit oj 2687 解题报告
然后单点更新维护最大后缀和就很容易了。
类似的做法，我们也维护一个最小前缀和。初始化的时候把1..len赋值成-1.
然后每次移动区间，从【l,r】移动到[l+1,r+1]的时候，将f[r+1]添加1，将f[l]减少1.
这样如果某个s中的任意前缀和都是等于0的，那么这个s就是合法的。
因此我们只需要维护最小前缀和。
代码是维护的最小前缀和
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 05:13:38 PM CST File Name :code/cf/problem/338E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=150005; int n,len,h; int a[N],b[N],f[N]; struct Tree { int mn;//最小前缀和 int sum;//区间和 }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>BZOJ 1756: Vijos1083 小白逛公园　 （线段树维护单点修改区间查询最大子段和）</title><link>https://111qqz.com/2016/09/bzoj-1756/</link><pubDate>Thu, 15 Sep 2016 21:51:33 +0000</pubDate><guid>https://111qqz.com/2016/09/bzoj-1756/</guid><description>
1756: Vijos1083 小白逛公园 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 1078 Solved: 353 [Submit][Status][Discuss]
Description 小新经常陪小白去公园玩，也就是所谓的遛狗啦…在小新家附近有一条“公园路”，路的一边从南到北依次排着n个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。 一开始，小白就根据公园的风景给每个公园打了分-.-。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第a个和第b个公园之间（包括a、b两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。 那么，就请你来帮小白选择公园吧。
Input 第一行，两个整数N和M，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。 接下来N行，每行一个整数，依次给出小白 开始时对公园的打分。 接下来M行，每行三个整数。第一个整数K，1或2。K=1表示，小新要带小白出去玩，接下来的两个整数a和b给出了选择公园的范围（1≤a,b≤N）；K=2表示，小白改变了对某个公园的打分，接下来的两个整数p和s，表示小白对第p个公园的打分变成了s（1≤p≤N）。 其中，1≤N≤500 000，1≤M≤100 000，所有打分都是绝对值不超过1000的整数。
Output 小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。
Sample Input 5 3 1 2 -3 4 5 1 2 3 2 2 -1 1 2 3
Sample Output 2 -1
题意：中文题面，不多说。
思路：关于维护最大子段和的问题，做法同
hitoj2687题解
但是和上面这道题不同的是，每次询问的是某个区间的最大字段和，而不是整个区间的最大子段和。
我们的做法是，将查询的区间拆成若干个区间，然后按照pushup中的方法合并。
一个技巧是query的时候返回一个结构体，这样会比较好写。
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 03:15:50 AM CST File Name :code/bzoj/1756.</description></item><item><title>hit oj 2687 Candy (线段树动态维护最大连续子段)</title><link>https://111qqz.com/2016/09/hit-oj-2687-candy/</link><pubDate>Thu, 15 Sep 2016 21:04:48 +0000</pubDate><guid>https://111qqz.com/2016/09/hit-oj-2687-candy/</guid><description>
题目链接
题意：给出n个数,m个修改，每次修改后询问整个区间的最大连续子段。
思路：考虑一段区间，分成左右两个子区间，这段区间的最大子段有三种情况：只在左区间中，只在右区间中，既在左区间中又在右区间中。前两种很好维护，对于后一种，我们新增加线段树的两个域，mxl,mxr，分别表示一个区间中包含左端点在的最大字段和（也就是最大前缀和），和一个区间中包含右端点在的最大子段和（也就是最大后缀和），然后对于最大子段既在左区间又在右区间的情况，只需要合并【左区间的最大后缀和 】和【右区间的最大前缀和】就好。
关于一个区间最大前缀和的维护，取该区间的左区间的最大前缀和和【该区间的左区间和】+【该区间的右区间的最大前缀和】的最大值。
最大后缀和同理。
这是一种很经典的做法，注意体会。
1A
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 04:01:49 AM CST File Name :code/hitoj/2687.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; struct { int mx; int mxr; int mxl; int sum; }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 220 E. Little Elephant and Inversions (树状数组+尺取)</title><link>https://111qqz.com/2016/09/cf220e/</link><pubDate>Thu, 15 Sep 2016 08:13:56 +0000</pubDate><guid>https://111qqz.com/2016/09/cf220e/</guid><description>
题目链接
题意：
how many pairs of integers l and r are there, such that 1 ≤ l &amp;lt; r ≤ n and sequence b = _a_1_a_2... a__l__a__r__a__r + 1... a__n has no more than k inversions.
我花了两个小时才看懂题。。。。一直没懂b数列中a[l]和a[r]怎么就挨着了。。。
其实意思是。。。只保留a数列中1..l和r..n的。。。构成b数列。。。然后b数列的逆序对数小于等于k.问这样的l,r的对数。
思路：尺取+树状数组。
枚举l,每次找到最小的满足题意的r，对答案的贡献是n-r+1,然后用两个树状数组，分别维护增加或者减少一个树的时候，前半段和后半段对逆序数的影响。
/* *********************************************** Author :111qqz Created Time :Wed 14 Sep 2016 04:23:06 PM CST File Name :code/cf/problem/220E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int tree[2][N]; int a[N],p[N]; int n; LL k; int lowbit( int x) { return x&amp;amp;(-x); } void update (int o, int x,int delta) { if (!</description></item><item><title>codeforces 501 D Misha and Permutations Summation (康托展开+康托逆展开+factorial_number_system+线段树×2)</title><link>https://111qqz.com/2016/09/codeforces-501-d-misha-and-permutations-summation-factorial_number_systemx2/</link><pubDate>Wed, 14 Sep 2016 07:05:21 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-501-d-misha-and-permutations-summation-factorial_number_systemx2/</guid><description>
题目链接
题意：给出两个排列，定义ord(p)为排列p的顺序（字典顺从小到大），定义perm(x)为顺序为x的排列，现在要求 1 ≤ n ≤ 200 000
思路：首先去学了一下康托展开和逆展开。。。其实就是对于这种排列之类的问题。。。的一个比较省空间的hash函数。。。？
康托展开资料
然后由于n非常大。。康托展开中要查找当前位置后面有多少个比当前位置小的。。。
然而这复杂是n2。。。肯定gg。。。
因此里面那层我们用一课线段树维护。。。复杂度nlgn
在康托逆展开的过程中。。。我们要查询之前没有出现过的第k个元素。。。。
因为n很大这里也需要线段树来维护。。。
所以再建一棵线段树。。。某位置表示初始时刻是否为空，初始都为1，表示都没有出现。思想类似于poj 2828 poj 2828解题报告
然后还是由于n很大。。。在康托展开中的阶乘部分。。。完全存不下。。。
直接用高精度应该也能做？
不过比较推荐的做法是： The Factorial Number System wiki_Factorial number system
是一种和阶乘相关的进制表示法。
大概就是不同位置上的权值，不像一般的k进制数，是k^0,k^1,k^2....
而是0!,1!,2!。。。
这种表示合法的正确性基于：
1*1! + 2*2! + 3*3! + ... + k*k! = (k+1)! - 1 具体参见上面两个链接。
因为我们可以把所有康托展开都用 Factorial number system来表示。
/* *********************************************** Author :111qqz Created Time :Tue 13 Sep 2016 04:33:55 PM CST File Name :code/cf/problem/501D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n ; int tree[N&amp;lt;&amp;lt;2]; int fac[N]; int A[N],B[N]; int ans[N]; void PushUp(int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson); else update(p,rson); PushUp(rt); } int query(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0 ; if (L&amp;lt;=m) { int res = query(L,R,lson); ret +=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson); ret +=res; } return ret; } void Contor(int A[])//https://en.</description></item><item><title>light oj 1080 Binary Simulation (线段树lazy标记，区间更新，单点查询)</title><link>https://111qqz.com/2016/09/light-oj-1080-binary-simulation-lazy/</link><pubDate>Tue, 13 Sep 2016 17:41:49 +0000</pubDate><guid>https://111qqz.com/2016/09/light-oj-1080-binary-simulation-lazy/</guid><description>
题目链接
题意：给出一个长度为n的数列，每个位置是0或者1，给出q个操作，操作有两种类型，分别是将一段区间中反转，和询问当前某位置是0还是1
思路：lazy标记。lazy[i]记录以i节点为根节点的子树对应的区间中被翻转的次数，初始为0.然后查询的时候，根据被翻转次数的奇偶性确定答案。
wa了好多发。。。比较致命的是。。PushDown函数忘记改了。。。还按照染色的方法直接赋值的。。。然而这里是统计次数。。。所以是累加。。。。
/* *********************************************** Author :111qqz Created Time :Wed 14 Sep 2016 12:59:07 AM CST File Name :code/loj/1080.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int lazy[N&amp;lt;&amp;lt;2];//记录翻转次数 int n; string st; int a[N]; void PushDown( int rt) { if (lazy[rt]) { lazy[rt&amp;lt;&amp;lt;1] +=lazy[rt]; lazy[rt&amp;lt;&amp;lt;1|1]+=lazy[rt]; lazy[rt] = 0; } } void build(int l,int r,int rt) { if (l==r) { lazy[rt] = 0; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); } void update(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) { lazy[rt]++; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,lson); if (R&amp;gt;=m+1) update(L,R,rson); } int query( int p,int l,int r,int rt) { if (l==r) return lazy[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; //int res; if (p&amp;lt;=m) query(p,lson); else query(p,rson); // return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>light oj 1045 Digits of Factorial (k进制数的位数)</title><link>https://111qqz.com/2016/09/digits-of-factorial-k/</link><pubDate>Tue, 13 Sep 2016 09:41:38 +0000</pubDate><guid>https://111qqz.com/2016/09/digits-of-factorial-k/</guid><description>
题目链接 题意：求n！在k进制表示下有多少位。 思路：答案为[ log(1)+log(2)+...+log(N) ]+1 其中log的底数都是K
由于有多组数据，预处理一个log的前缀和。
/* *********************************************** Author :111qqz Created Time :Tue 13 Sep 2016 05:13:15 PM CST File Name :code/loj/1045.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt;-digits-of-factorial-k进制数的位 #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; int base; double sum[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>康托展开和康托逆展开</title><link>https://111qqz.com/2016/09/</link><pubDate>Tue, 13 Sep 2016 05:14:51 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
感觉就是为了记录排列。。。重复之类的。。。用到的一个hash函数。。。？
维基百科
讲解</description></item><item><title>20160910随笔</title><link>https://111qqz.com/2016/09/20160910/</link><pubDate>Fri, 09 Sep 2016 17:27:16 +0000</pubDate><guid>https://111qqz.com/2016/09/20160910/</guid><description>
被ex吐槽说。。。常年穿运动服。。。没有想看的欲望。。。。
已经是第二次被吐槽不会穿衣了Orz....
不禁陷入沉思。。。。？
所以大概要花些时间学习一下基本的穿衣技巧......？
而且。。。。之前觉得。。。。没有遇到合适的妹子。。。。。
现在觉得。。。。。如果不自己创造一些机会的话。。。。就永远不会有合适的。。。。？
不过。。。。。。我在这方面毫无信心和经验orz....
哎。。。怎么突然想起这些事。。。明天hk网赛，rp++</description></item><item><title>sad</title><link>https://111qqz.com/2016/09/sad/</link><pubDate>Tue, 06 Sep 2016 20:16:57 +0000</pubDate><guid>https://111qqz.com/2016/09/sad/</guid><description>
难得有聊得来的妹子邀请我出去玩。。。。。
我竟然。。。。。。。。
我。。。。。
。。。。。
。。。。。
。。。。。
我好菜啊。。。。。。。</description></item><item><title>codeforces 356 A. Knight Tournament (线段树lazy标记，倒序处理)</title><link>https://111qqz.com/2016/09/cf356a/</link><pubDate>Tue, 06 Sep 2016 19:19:11 +0000</pubDate><guid>https://111qqz.com/2016/09/cf356a/</guid><description>
[题目链接](http://codeforces.com/problemset/problem/356/A) 题意：现在有N个骑士进行M轮PK...现在告诉这M轮是谁站在台上...其将l~r所存在的骑士都打败..而若一个骑士被打败..就出局了..也就是不存在了...请输出每个骑士是被哪个骑士打败的(最后的胜利者输出0)...保证有解.. 思路：由于先前被打败的骑士直接就退场了。。。所以如果不做判断。。那么之后胜利的骑士会干扰之前的结果。。。
可以在pushdown的时候加判断。。。
不过我觉得比较好的做法是。。。倒序处理。。。。
倒序处理。。。后处理的直接覆盖先处理的结果。。。因为后处理的在之前。。优先级更高。。。被覆盖掉的骑士其实应该是退场的。。。
倒序处理就避免了判断的问题。。。完美。。。
/* *********************************************** Author :111qqz Created Time :Wed 07 Sep 2016 02:13:55 AM CST File Name :code/cf/problem/356A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int n,m; struct node { int l,r,x; }q[N]; int lazy[N&amp;lt;&amp;lt;2]; void PushDown( int rt) { if (lazy[rt]) lazy[rt&amp;lt;&amp;lt;1]=lazy[rt&amp;lt;&amp;lt;1|1]=lazy[rt]; lazy[rt] = 0; } void update(int L,int R,int sc,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) { lazy[rt] = sc; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,sc,lson); if (R&amp;gt;=m+1) update(L,R,sc,rson); } int query(int p,int l,int r,int rt) { if (l==r) return lazy[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) query(p,lson); else query(p,rson); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 292 E. Copying Data (染色问题，线段树lazy标记模板题)</title><link>https://111qqz.com/2016/09/cf292e/</link><pubDate>Tue, 06 Sep 2016 13:57:54 +0000</pubDate><guid>https://111qqz.com/2016/09/cf292e/</guid><description>
x题目链接
题意：给出两个数组，每个数组n个数，分别为a和b,给出m个操作，操作有两种类型，第一种是给出x,y,k,表示从a数组的x坐标开始复制k个数到b数组的y到y+k-1。
第二种操作是给出x，询问当前b[x]是多少。
对于每个第二种操作，输出结果。
思路：第一次写lazy标记的线段树。
今天突然就顿悟了。。。其实lazy标记的思想大概就是。。
对于某段区间的更新，如果没有查询到这段区间中任何一个数的时候。。。那么这个更新其实是无所谓的。。。
（让我想到了那个脑洞，就是整个世界都是一段程序，为了让你不察觉异常并且耗费尽量少的资源，所有场景只有在有人观测的时候才会被加载，不观测就用很少的资源随便处理一下233）
所以lazy标记，也叫延迟标记，就是只有当查询到某个节点的时候，才去把之前的修改更新，不然不更新（就好像有人观测的时候，上帝才把某个场景的代码写出来）
这道题除了延迟标记这个点外，还用到了染色问题的经典做法。
所谓染色问题，这里说的是一种区间覆盖问题，每次用一个颜色覆盖某段区间，最后询问某一点是什么颜色（大概是这样...?
回到这道题，具体做法是，记录每次覆盖操作的位移差，然后用线段树维护某个点最后被覆盖的时间（也可以形象得说被染成了什么颜色，染的颜色种类和时间对应）
这样，每次询问b[x]的时候，我们可以查询x位置最后是被染成了什么颜色，然后根据之前记录的位移差信息，就可以得到相应的答案。
这是一种经典做法，这类问题具有一定普遍性，注意体会。
以及，之前对lazy标记有一个错误得认识，以为lazy是基于线段树本身数组的一个辅助数组。。。但是做完这道题后感觉。。。
之前写的单点更新的线段树数组tree和现在的lazy标记的数组应该是同等地位。。。。PushDown和PushUp大概也是同等地位。。。就是说。。。可以只出现PushDown和lazy数组不出现PushUp和tree.
还有一些写法上的注意，见代码注释。
/* *********************************************** Author :111qqz Created Time :Tue 06 Sep 2016 08:41:03 PM CST File Name :code/cf/problem/292E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int lazy[N&amp;lt;&amp;lt;2];//lazy[i]记录的信息是以i节点为根节点的子树所表示的区间被覆盖的时间。 int n,m; int q[N]; //记录覆盖信息，q[i]表示第i个覆盖的位移差。 int a[N],b[N]; void PushDown( int rt) { if (lazy[rt]) lazy[rt&amp;lt;&amp;lt;1]=lazy[rt&amp;lt;&amp;lt;1|1]=lazy[rt]; lazy[rt] = 0; } void update(int L,int R,int sc,int l,int r,int rt) { if (L&amp;lt;=l &amp;amp;&amp;amp; r&amp;lt;=R) { lazy[rt] = sc; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,sc,lson); if (R&amp;gt;=m+1) update(L,R,sc,rson); //如果是区间查询或者修改，那么就需要分别两个if来判断。 } int query(int p,int l,int r,int rt) { if (l==r) return lazy[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) query(p,lson); //如果是单点查询或者修改，那么不在这个就一定在另一个，所以可以用else.</description></item><item><title>codeforces 474 F. Ant colony (线段树求gcd+统计区间中某数出现的次数的经典做法)</title><link>https://111qqz.com/2016/09/cf474f/</link><pubDate>Mon, 05 Sep 2016 13:42:23 +0000</pubDate><guid>https://111qqz.com/2016/09/cf474f/</guid><description>
题目链接
题意：给出n个数，m个查询，每组查询一个区间[l,r]，问[l,r]中会被吃掉多少个（区间[l,r]中的数只有当其是其他所有数的因数时才不会被吃掉,顺便问一句。。a divide b 是 a除b,也就是b除以a,b/a的意思嘛23333）
思路：我们知道，不会被吃掉的数其实就是区间[l,r]中所有数的gcd,求gcd可以很容易用线段树办到。。。关键是还要统计该区间中等于gcd的数有多少个。
并不会做。
大概有两种做法。。。？
一种是基哥@clq11111说的，将询问离线，然后从小到大排序插入，询问区间中等于x转化成询问区间中小于等于x的，和询问区间中小于等于x-1的，做差即为所求。
第二种办法是题解的讨论区部分的：
想了一下感觉很有道理。。。
这种做法是说：建一个val和该val对应下标的pair，然后排序（pair默认按照val第一关键字，pair第二关键字升序排）
排序之后，val相同的都在一起了，我们只需要找一段最大的区间，使得这段区间中的第二关键字在[l,r]范围内，然后这段区间的长度就是[l,r]区间中该数出现的次数.
找这段最大的区间，两次二分就好。说起来二分得到区间这个做法之前写过两次。。。之前都是手写的。。。这次用了STL。
具体写法参见代码
1A开心哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 08:37:57 PM CST File Name :code/cf/problem/474F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int tree[N&amp;lt;&amp;lt;2]; int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } void PushUp( int rt) { tree[rt] = gcd(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void build(int l,int r,int rt) { if (l==r) { tree[rt] = a[l].</description></item><item><title>codeforces 61 E. Enemy is weak (离散化+线段树求逆序三元组)</title><link>https://111qqz.com/2016/09/cf61e/</link><pubDate>Mon, 05 Sep 2016 08:35:49 +0000</pubDate><guid>https://111qqz.com/2016/09/cf61e/</guid><description>
题目链接 题意：给出n个数，求满足 i&amp;lt;j&amp;lt;k且a[i]&amp;gt;a[j]&amp;gt;a[k]的三元组有多少个。
思路：对于这种要求三个数满足条件的题目，老司机的经验是考虑中间那个数，这道题也不例外。
我们枚举j，通过求两次逆序对求出对于每个a[j]，满足a[i]&amp;gt;a[j]的i的个数，以及满足a[j]&amp;gt;a[k]的个数。
两个个数的乘积就是j作为中间数满足的三元组的个数，这样把所有的j累加就是答案。
其他的就是，要离散化，以及最后答案可能会爆long long?
1A，好爽啊哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 03:40:20 PM CST File Name :code/cf/problem/61E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int a[N]; int A[N]; int H[N]; int n; int m; int tree1[N&amp;lt;&amp;lt;2],tree2[N&amp;lt;&amp;lt;2]; pair&amp;lt;LL,LL&amp;gt;ans[N]; void PushUp(int rt,int *tree) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt,int *tree) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson,tree); else update(p,rson,tree); PushUp(rt,tree); } int query(int L,int R,int l,int r,int rt,int *tree) { // cout&amp;lt;&amp;lt;&amp;quot;L:&amp;quot;&amp;lt;&amp;lt;L&amp;lt;&amp;lt;&amp;quot; R:&amp;quot;&amp;lt;&amp;lt;R&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; if (L&amp;gt;R) return 0; if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0 ; if (L&amp;lt;=m) { int res = query(L,R,lson,tree); ret+=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson,tree); ret +=res; } return ret; } int Hash( int x) { return lower_bound(H,H+m,x)-H; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 459 D. Pashmak and Parmida's problem (离散化+线段树求逆序对数)</title><link>https://111qqz.com/2016/09/cf459d/</link><pubDate>Mon, 05 Sep 2016 07:23:18 +0000</pubDate><guid>https://111qqz.com/2016/09/cf459d/</guid><description>
题目链接 题意：定义_f_(l, r, x)为区间[l,r]中x出现的次数。现在要求calculate the number of pairs of indicies i, j (1 ≤ i &amp;lt; j ≤ n) such that_f_(1, i, a__i) &amp;gt; f(j, n, a__j).
思路：可以通过o(n)预处理出f(1,i,a[i])和f[j,n,a[j]]，其实预处理的过程就是离散化的过程呢。。。
分别得到
1 1 2 3 2 3 4
4 3 3 2 2 1 1
所以答案其实就是第一组数在第二组数中找逆序数的过程。。。
我们不妨倒序处理。
需要注意的是，线段树维护的区间是0..mx，我整体增加了1.
线段树求逆序对和树状数组求逆序对是同样的思想。。。注意体会。。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 02:06:05 PM CST File Name :code/cf/problem/459D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; map&amp;lt;int,int&amp;gt;mp; int n ; int a[N],b[N]; int tmp[N]; int tree[N&amp;lt;&amp;lt;2];//tree[i]表示的是以i节点为根节点的子树所代表的区间中数的个数。 void PushUp( int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson); else update(p,rson); PushUp(rt); } int query(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0; if (L&amp;lt;=m) { int res = query(L,R,lson); ret +=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson); ret +=res; } return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 339 D. Xenia and Bit Operations(线段树)</title><link>https://111qqz.com/2016/09/cf339d/</link><pubDate>Sun, 04 Sep 2016 17:48:11 +0000</pubDate><guid>https://111qqz.com/2016/09/cf339d/</guid><description>
题目链接
题意：给出n和m,初始给出1&amp;lt;&amp;lt;n个数，先相邻的两个数进行或操作（a[1]^a[2],a[3]^a[4]...），得到的新数列再相邻的两个数进行异或操作。
最后得到一个数，即为答案。现在给出m个操作，每个操作两个数p,b，表示令a[p]=b,每次变化后输出最终的结果。
思路：线段树。这道题让我学到了，线段树的数组tree[i]存储的信息可能不唯一，可以不同层存储的是不同的信息。
比如这道题中，距离叶子节点距离为奇数的点存储的是或操作的结果，距离叶子节点距离为偶数的点存储的是异或操作的结果。
还需要注意的是，build和update操作都是从顶向下，最后一个操作是异或还是或取决于n的奇偶性，记得判断。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 12:56:34 AM CST File Name :code/cf/problem/339D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1&amp;lt;&amp;lt;18; int tree[N&amp;lt;&amp;lt;2]; int n,m; void PushUp(int rt,int state) { if (state==-1) tree[rt] = tree[rt&amp;lt;&amp;lt;1]|tree[rt&amp;lt;&amp;lt;1|1]; else tree[rt] = tree[rt&amp;lt;&amp;lt;1]^tree[rt&amp;lt;&amp;lt;1|1]; } void build(int l,int r,int rt,int state) { if (l==r) { scanf(&amp;quot;%d&amp;quot;,&amp;amp;tree[rt]); return ; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson,-state); build(rson,-state); PushUp(rt,state); } void update( int p,int sc,int l,int r,int rt,int state) { if (l==r) { tree[rt] = sc; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,sc,lson,-state); else update(p,sc,rson,-state); PushUp(rt,state); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 19 D. Points (离散化+树套树（线段树+set）)</title><link>https://111qqz.com/2016/09/cf19d/</link><pubDate>Sun, 04 Sep 2016 13:47:07 +0000</pubDate><guid>https://111qqz.com/2016/09/cf19d/</guid><description>
题目链接
题意：
在二维坐标平面内进行_n_ (1 ≤ _n_ ≤ 2·105) 次操作。一共有三种类型操作。 1.add x,y 将点(x,y)加进坐标系。
2.remove x,y 将点(x,y)移除.
3.find x,y 找到点(x,y)右上角的点(xp&amp;gt;x,yp&amp;gt;y)。如果有多个输出x最小的。还是有多个输出y最小的。
x,y均为非负数。以上操作均合法。
思路：没有思路。。。不会啊。。。以为要二维线段树什么的。。。。总之是不会做。。。
大概从中午开始看题解。。。8个小时。。。。终于完全搞懂了orz
很巧妙得把二维问题转化成了一维问题。。。
我来说一下大概做法，具体的细节见代码注释：
在x轴方向维护一课线段树，线段树的数组tree[i]存储的信息是以i节点为根节点的子树所对应的区间能达到的最大的y值。线段树的叶子节点上是一个set，set[i]是横坐标为i时的纵坐标集合，也就是所谓的树套树。
由于x很大，但是n比较小，所以我们这里采用了stl+去重的办法离散化离散化的三种办法
对于添加和删除点的操作，我们更新完对应的set把相应的x（离散化后的）在线段树中更新就好（因为线段树的update操作是和set有关的）
对于find操作，我们首先从线段树中找到（下标大于x且最小且集合中存在大于y的元素的集合）的下标
这样我们确定了x，再upper_bound一下找到对应的集合中最小的y.
初始化由于没有插入y,所以tree可以初始化为-1，不用建树。。。（反正建了也都是-1）
/* *********************************************** Author :111qqz Created Time :Sun 04 Sep 2016 07:19:05 PM CST File Name :code/cf/problem/19D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; int tree[N&amp;lt;&amp;lt;2]; //记录线段树的信息，tree[i]表示的是以i节点为根节点的子树所代表的区间中的点的最大的y值。 set&amp;lt;int&amp;gt;se[N];//集合se[i]是横坐标为x的点的纵坐标的集合。 struct node //线段树套平衡树，在x轴的方向上建一棵线段树，线段树的每个叶子节点是一个set。 { int x,y; char cmd[15]; void input() { scanf(&amp;quot;%s%d%d&amp;quot;,cmd,&amp;amp;x,&amp;amp;y); } }q[N]; int H[N]; void PushUp(int rt) { tree[rt] = max(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void update( int p,int l,int r,int rt) { if (l==r) { if (se[l].</description></item><item><title>poj 2828 Buy Tickets (线段树单点更新，逆序插入)</title><link>https://111qqz.com/2016/09/poj-2828/</link><pubDate>Sat, 03 Sep 2016 13:26:54 +0000</pubDate><guid>https://111qqz.com/2016/09/poj-2828/</guid><description>
poj 2828 题目链接
题意：n个人，每个人有一个rp值（用来区分不同的人），还有一个pos[i]，表示当第i个人来排队的时候插入到第pos[i]个人的后面（也就是排在位置pos[i]+1)
现在问最后的序列，从1到n输出n个人的rp值
思路：第二道线段树，并不会做，看了题解。
比较关键的一点是：按照顺序的话，当后来的一个人插入到前面，那么之前很多人排好的位置将发生改变，这个代价是巨大的。
由于越后来的人越容易确定位置，因此正确的做法是倒序处理。
对于第i个人，我们把他放在从前往后数的第i个空的位置即可。
接下来需要做的就是线段树处理，线段树存储的信息是某一个区间中空位置的个数。
感觉是一道很好的题目，对于新手来说并不是很容易，不过理解了这道题目以后，感觉进一步理解线段树，有点开心。
/************************************************************************* &amp;gt; File Name: code/poj/2828.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年10月29日 星期四 09时00分08秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define yn hez111qqz #define j1 cute111qqz #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) using namespace std; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=2E5+7; int pos[N],val[N]; int n; int tree[N&amp;lt;&amp;lt;2]; //tree[i]存储的是以i为根节点的子树对应的区间中空位置的数量。 int ans[N]; void PushUp(int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1]+tree[rt&amp;lt;&amp;lt;1|1]; //一段区间空位置的数量等于两端子区间中空位置的数量的和。 } void build(int l,int r,int rt) { if (l==r) { tree[rt] = 1; //初始的空位置的数量为区间长度r-l+1 return ; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } void update (int p,int val,int l,int r,int rt) { if (l==r) //终于找到了该点的归属。。。 { ans[l] = val; tree[rt]--; return ; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=tree[rt&amp;lt;&amp;lt;1]) update(p,val,lson); //如果左子树所代表的区间中空位置的数目够的话就放左边 else update(p-tree[rt&amp;lt;&amp;lt;1],val,rson);//否则放右边，一共需要p个空位置，左边提供了tree[rt&amp;lt;&amp;lt;1]个，还需要右边提供p-tree[rt&amp;lt;&amp;lt;1]个。 PushUp(rt); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 687 A. NP-Hard Problem(交叉染色法)</title><link>https://111qqz.com/2016/09/cf687a/</link><pubDate>Fri, 02 Sep 2016 17:57:46 +0000</pubDate><guid>https://111qqz.com/2016/09/cf687a/</guid><description>
题目链接
题意：找两个不相交点集使得对于每一条边至少有一个顶点在点集中
思路：判断能否构成二分图。染色即可。
需要注意的是。。。答案有特判。。和样例不一样我还以为是自己做错了2333.
/* *********************************************** Author :111qqz Created Time :2016年09月03日 星期六 01时04分40秒 File Name :code/hdu/687A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M=2E5+7; int n,m; struct Edge { int v; int nxt; }edge[M]; int cnt = 0 ; int head[N]; int col[N]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>codeforces 623 A. Graph and String (构造)</title><link>https://111qqz.com/2016/09/cf623a/</link><pubDate>Fri, 02 Sep 2016 08:48:37 +0000</pubDate><guid>https://111qqz.com/2016/09/cf623a/</guid><description>
题目链接：题目链接
题意：给出一个无向图，该图是通过仅包含‘a’ 'b' 'c'三个字母，以规则“i,j之间有边，当且仅当s[i]和s[j]相同，或者s[i]和s[j]在字母表中相邻”（也就是只有'a'和'c'是没有边相连的）得到的，现在问能否还原这个字符串，如果能，输出任意一个解。
思路：其实就是简单构造。。。
构造的一个技巧是。。把能确定的地方先确定了。。。。
我们发现'b'比较特殊。。因为b和任意点都相连。。。
于是可以统计一下度。。。然后确定字符串中的b
然后对于某个没有确定的位置，我放置一个a,并且把所有和这个位置相连的都放成a
字符串中剩下的没有确定的位置就一定是c了。
这个时候我再判断是否满足题中图的条件。
/* *********************************************** Author :111qqz Created Time :2016年09月02日 星期五 15时56分14秒 File Name :code/cf/problem/623A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m; bool conc[N][N]; int degree[N]; char ans[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5285 wyh2000 and pupil (交叉染色法，二分图点集差最大)</title><link>https://111qqz.com/2016/09/hdu-5285/</link><pubDate>Fri, 02 Sep 2016 07:13:03 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-5285/</guid><description>
题目链接：hdu 5285 题目lianjie
题意：给定n个小朋友，以及小朋友之间的关系，要求将小朋友分成两组，**并且每组至少一个人，**现在问能否这样分组，如果有解，输出两组的人数，并保证第一组的人数尽可能地大。
思路：。。。一开始看到n的数据范围。。。想当然的以为会给认识的人的关系。。。尼玛。。。求个补图就够受的了。。。。不会做，卒。
结果发现。。竟然给的是两个人不认识的关系。。。2333
那么我们来交叉染色。。。
实际上交叉染色的过程中，颜色相同的点属于二分图中相同的点集合。
交叉染色其实是在模拟交错轨的过程...？
由于图不一定联通，可能由多个联通块。
我们在交叉染色的时候记录一下0,1的个数（也就是两个点集的大小）
然后每次把大的累加（因为没说不认识的就是默认认识了。。。）
无解的情况有：任何一个联通快无解或者n&amp;lt;=1
此外还需要注意，m可能为0.
特判一下，m为0或者为1，直接输出n-1和1.
以及！
n&amp;lt;=1的无解是在特判m之前的。。。。我好傻啊。
n&amp;lt;=1的无解是在特判m之前的。。。。我好傻啊。
n&amp;lt;=1的无解是在特判m之前的。。。。我好傻啊。
/* *********************************************** Author :111qqz Created Time :2016年09月02日 星期五 14时41分35秒 File Name :code/hdu/5285.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int M = 2E5+7; const int N = 1E5+7; int n,m; int head[N]; int col[N]; struct Edge { int v; int nxt; }edge[M]; int cnt; int cnt0,cnt1; void addedge(int u ,int v) { edge[cnt].</description></item><item><title>hdu 5215 Cycle(交叉染色法判断无向图的奇偶环)</title><link>https://111qqz.com/2016/09/hdu-5215/</link><pubDate>Fri, 02 Sep 2016 04:40:25 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-5215/</guid><description>
hdu 5215
思路:询问一个无向图，是否存在奇数环，以及是否存在偶数环。（不同的环之间可以由相同的点，不能有相同的边）
思路：一开始的想法是，根据染色的奇偶性，如果染色到某个之前染色过的点，和当前要染的颜色相同，说明存在奇数环，不同，说明存在偶数环。
感觉很有道理的做法。。。然而错了。。。发现是忽略了上面说的，不同的环之间由相同的点的情况。
比如这组数据：
5 6 1 2
2 3
3 1
1 4
4 5
5 1
两个三元环扣在一起。
实际上是既有奇数环，又有偶数环的。
但是按照我的做法，由于每次只去染没有染过的点，无法发现偶数环。
因此正解是增加一步回溯，这样使得之前存在与某个环中的点还可以出现在其他环中。
然而这样复杂度会炸。。。
于是我们根据，每条边只能走一次，对边加一个vis，使得每条边只走一次，从而保证复杂度。
好题！
这道题我看到了三种解法，第一种是官方解法，tarjan什么（没仔细看）。
第二种是交叉染色。
但是我们可以发现，在这样的情况下，偶环是否和奇环是有联系的，即能不能根据两个奇环的关系，来判断偶环是否存在。 做法：判断是否存在一个点，同时属于两个奇环，如果存在，那么这两个奇环一定可以构成偶环。
证明：令两个奇环分别有x1、x2条边，如果两个环存在一个公共点，令他们存在y条公共边，则它们合并成的环有x1+x2-2*y条边，一定是偶环。因为题目中限制的是边的通过次数，所以即使像下面这组数据一样y=0，偶环是交叉的，也是符合题意的。
第二种做法
但是代码略长，而且还要记录路径。
第三种做法就是我这里用到的做法。。。感觉很完美。。可以当模板23333
/* *********************************************** Author :111qqz Created Time :2016年09月01日 星期四 14时47分32秒 File Name :code/hdu/5215.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec secon #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M=3E5+7; int n,m; int col[N]; bool even,odd; bool vis[N]; int cnt ; int head[N]; struct Edge { int v; int nxt; bool vis; }edge[2*M]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>[solved ]fedora 24 "Tap to click" not working</title><link>https://111qqz.com/2016/09/solved-fedora-24-tap-to-click-not-working/</link><pubDate>Thu, 01 Sep 2016 08:16:07 +0000</pubDate><guid>https://111qqz.com/2016/09/solved-fedora-24-tap-to-click-not-working/</guid><description>
链接</description></item><item><title>using your computer without mouse</title><link>https://111qqz.com/2016/09/using-your-computer-without-mouse/</link><pubDate>Thu, 01 Sep 2016 07:44:31 +0000</pubDate><guid>https://111qqz.com/2016/09/using-your-computer-without-mouse/</guid><description>
键盘足够爽了以后。。。
鼠标明显降低效率。。。
学会逐步脱离鼠标吧orz.
首先是chrome插件vimium
vimium教程
Vimium 常用的按键功能解释： * **j：向下细微滚动窗口 k：向上细微滚动窗口** * J：(**Shift+j的意思，以下大写全部表示加Shift)** 下一个标签页 K：上一个标签页 * d：向下滚动半个屏幕 u：向上移动半个屏幕 * **g+g（连续按两下g）：回到顶部** * **G：到达页面底部** * H：后退 L： 前进 * f：将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框。如果按的是F，那么将在新窗口中打开页面（见上图） * g+i：将光标 定位到输入框，如果有多个可以按Tab键切换 * x：关闭当前页面 X：恢复刚刚关闭的页面 * o：相当于Chrome中的地址栏，可以匹配历史记录、收藏夹并在当前窗口打开，或者直接打开一个网址或者搜索一个关键字（Chrome在全屏的时候地址栏死都出不来，有了它就解决这个一直困扰我的问题了！～），如果按的是O，则可以在新窗口中打开，非常非常方便！ * g+s：查看网页的源代码 * r：重新载入当前网页（顺便提一句，这点上新浪微博和它是一样的，光标没有定位在发送框时，即便没有安装这个插件你也可以用j/k来控制页面上下滚动，用r在刷新，用f或者p来定位到发送框。而Gmail的快捷键如j,k上下移动光标也是类似，有兴趣大家可以再自己去了解一下一些常用web应用的快捷键）</description></item><item><title>hdu 2444 The Accomodation of Students (交叉染色法+匈牙利算法)</title><link>https://111qqz.com/2016/09/hdu-2444/</link><pubDate>Thu, 01 Sep 2016 06:39:23 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-2444/</guid><description>
hdu 2444题目链接
题意：判断一个有向图是否是二分图，是的话求最大匹配数。
思路：交叉染色判二分图，是的话跑遍匈牙利即可。1A.
/* *********************************************** Author :111qqz Created Time :2016年09月01日 星期四 14时24分36秒 File Name :code/hdu/2444.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n,m; vector&amp;lt;int&amp;gt;edge[N]; int col[N]; int link[N]; bool vis[N]; void init() { for ( int i = 0 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>hdu 4751 Divide Groups (反向建图，判断二分图，交叉染色法)</title><link>https://111qqz.com/2016/09/hdu-4751/</link><pubDate>Wed, 31 Aug 2016 18:26:37 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-4751/</guid><description>
hdu 4751 题目链接
题意：n个人，给出每个人认识的人的信息。问能否将这些人分成两组，保证每组至少1个人，并且两两互相认识。
思路：首先是反向建图。由于要求同组内两个人互相认识，那么两个人u,v，只要u不认识v或者v不认识有一个满足，就连接双向边u,v，表示u,v不能分到同一组。
由于图反向以后不保证联通，因此求补图以后可能会得到几个联通分量。
而合法的条件是，每个联通分量都合法。
不合法的条件是，只要由一个联通分量不合法。
以及：之前把交叉染色部分写错了。上道题可以通过纯粹是因为数据水。。？
/* *********************************************** Author :111qqz Created Time :2016年09月01日 星期四 01时13分04秒 File Name :code/hdu/4751.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n; bool know[N][N]; int col[N]; vector&amp;lt;int&amp;gt;edge[N]; bool dfs( int u,int x) { col[u] = x; int siz = edge[u].</description></item><item><title>uva 10004 Bicoloring （交叉染色法判断二分图模板题）</title><link>https://111qqz.com/2016/08/uva10004/</link><pubDate>Wed, 31 Aug 2016 14:03:50 +0000</pubDate><guid>https://111qqz.com/2016/08/uva10004/</guid><description>
uva10004题目链接
题意：给出一个无向图，问是否可以组成二分图。
思路：交叉染色法。
**首先任意取出一个顶点进行染色,和该节点相邻的点有三种情况:** **　1.未染色 那么继续染色此节点(染色为另一种颜色)**
**　2.已染色但和当前节点颜色不同 跳过该点**
**　3.已染色并且和当前节点颜色相同 返回失败(该图不是二分图)**
学习链接
upd:更正dfs中的一个错误。
把dfs(v,1-x)改成了 if (!dfs(v,1-x)) return false;
之前的写法中，当前层之后的层的没有起到任何作用。。。
而实际上应该是后面只要某一层不满足，整体就该为false.
写成这样这题还能过我也是醉了。。。。
/* *********************************************** Author :111qqz Created Time :2016年08月31日 星期三 21时50分16秒 File Name :code/uva/10004.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; vector &amp;lt;int&amp;gt;edge[N]; int n,m; int col[N]; bool dfs( int u,int x) { col[u] = x; int siz = edge[u].</description></item><item><title>BZOJ 3680: 吊打XXX (广义费马点，模拟退火+爬山)</title><link>https://111qqz.com/2016/08/bzoj-3680-xxx-/</link><pubDate>Wed, 31 Aug 2016 13:32:02 +0000</pubDate><guid>https://111qqz.com/2016/08/bzoj-3680-xxx-/</guid><description>
3680: 吊打XXX Time Limit: 10 Sec Memory Limit: 128 MBSec Special Judge Submit: 2043 Solved: 732 [Submit][Status][Discuss]
Description gty又虐了一场比赛，被虐的蒟蒻们决定吊打gty。gty见大势不好机智的分出了n个分身，但还是被人多势众的蒟蒻抓住了。蒟蒻们将 n个gty吊在n根绳子上，每根绳子穿过天台的一个洞。这n根绳子有一个公共的绳结x。吊好gty后蒟蒻们发现由于每个gty重力不同，绳 结x在移动。蒟蒻wangxz脑洞大开的决定计算出x最后停留处的坐标，由于他太弱了决定向你求助。 不计摩擦，不计能量损失，由于gty足够矮所以不会掉到地上。
Input 输入第一行为一个正整数n(1&amp;lt;=n&amp;lt;=10000)，表示gty的数目。 接下来n行,每行三个整数xi，yi，wi，表示第i个gty的横坐标，纵坐标和重力。 对于20%的数据，gty排列成一条直线。 对于50%的数据，1&amp;lt;=n&amp;lt;=1000。 对于100%的数据，1&amp;lt;=n&amp;lt;=10000,-100000&amp;lt;=xi,yi&amp;lt;=100000
Output 输出1行两个浮点数（保留到小数点后3位），表示最终x的横、纵坐标。
Sample Input 3 0 0 1 0 2 1 1 1 1
Sample Output 0.577 1.000
HINT Source By wangxz
思路：
看起来是物理题。。其实就是求广义非费马点。。
也就是带权费马点。
一般的费马点是说，所有点到这个点的距离之和最小。
带权的费马点就是每个点到这个点的距离*权值，和最小。
这道题用到的才是真正的模拟退火！
模拟退火很重要的一部分就是允许有一定概率向不优的方向走，之前写的所谓的“模拟退火”的题目，全都没有体现这一点。
所以那些，其实就是一个爬山法吧。。
而且看到主席如是说...
这道题真的很棒。
初始搜索范围很大的时候用模拟退火，快速得到一个大致范围。
但是由于精度不能很好的保证，于是在做完模拟退火后在答案附近爬山。
完美的分段思想！
一直调不对样例的原因是。。。
忘记把ans初始化成最大值23333
/* *********************************************** Author :111qqz Created Time :2016年08月31日 星期三 15时47分25秒 File Name :code/bzoj/3680.</description></item><item><title>hdu 5017 Ellipsoid (模拟退火，计算椭球到定点的最小距离)</title><link>https://111qqz.com/2016/08/hdu-5017-ellipsoid-/</link><pubDate>Wed, 31 Aug 2016 06:51:29 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5017-ellipsoid-/</guid><description>
hdu 5017 题目链接
题意：给出椭球方程的6的参数 a,b,c,d,e,f 问椭球上的点到原点(0,0,,0)的最小距离是多少。
思路：感觉难点在于，如何保证搜到的点一直在椭球上。
一开始我考虑到了用椭球的参数方程。。。。然后发现不记得是什么了2333
然后看了题解，发现比较巧妙的做法是，只搜索x,y，然后从椭球方程中解出z。
x,y确定以后，椭球方程就变成了一个关于z的一元二次方程，可解。
由于是要求距离原点的最小距离，而现在可能得到的两个解是关于xoy平面对称的，只有z坐标不同，因此我们取距离原点近的那个z。
以及，感觉在平面上搜4个方向就好。。。没必要8个方向。。？
wa到死是因为。。。计算距离。。忘记开根号。。。。。呵呵呵呵呵呵呵呵呵我是傻逼。。。
/* *********************************************** Author :111qqz Created Time :2016年08月30日 星期二 20时46分05秒 File Name :code/poj/5017.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair #define INF 1E20 #define MAX 1 using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double a,b,c,d,e,f; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>poj 2069 Super Star (模拟退火)</title><link>https://111qqz.com/2016/08/poj-2069/</link><pubDate>Tue, 30 Aug 2016 12:12:29 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2069/</guid><description>
poj 2069 题目链接
题意：给出n个点，找出包含这n个点的最小半径的外接球。求球的半径。
思路：模拟退火。不过在走的时候，不是随机上下左右前后6个方向走，而是每次往距离当前球心最远的点的方向走。这样才能通过（随机6个方向的写法样例也是可以通过的）
所以模拟退火的精髓大概是“概率减小” 而不是“随机”？
以及，我看到的资料中，对于模拟退火的介绍，都有一部分是“允许一定概率向着不优的方向移动，但是这个概率会越来越小（因此叫退火）”
但是做了几道所谓的“模拟退火”的题目，发现并没有这部分。。。？
那样的话应该是爬山法？
以及看到说模拟退火适合并行计算。。。
是不是体现在我可以放k个初始解，然后每次最优的答案是在k个答案中取最优？
/* *********************************************** Author :111qqz Created Time :2016年08月30日 星期二 14时31分15秒 File Name :code/poj/2069.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair #define INF 1E20 #define MAX 1E6 using namespace std; const double eps = 1E-7; const int dx6[6]={1,0,0,-1,0,0}; const int dy6[6]={0,1,0,0,-1,0}; const int dz6[6]={0,0,1,0,0,-1}; const int inf = 0x3f3f3f3f; int n; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>2016 ACM ICPC Asia Hong Kong Regional rules</title><link>https://111qqz.com/2016/08/2016-acm-icpc-asia-hong-kong-regional-rules/</link><pubDate>Tue, 30 Aug 2016 11:38:36 +0000</pubDate><guid>https://111qqz.com/2016/08/2016-acm-icpc-asia-hong-kong-regional-rules/</guid><description>
貌似香港赛区的规则和大陆有所不同？
来整理一波。
**D. ****中国大陆赛站及境外赛站的关系。** (a)** **中国大陆各赛站及香港，北朝鲜赛站同为亚洲East Continent子赛区的一部分。
(b)** **中国大陆队伍，可在香港及北朝鲜赛站竞争WF参赛名额。
(c)** **蒙古，北朝鲜，及香港队伍，亦可在中国大陆各赛站竞争WF参赛名额。如果要在CHINA-Final赛站争取WF名额时，需经CHINA-Final组委会同意。
(d) 中国大陆各赛站的参与名额是把East Continent子赛区的总名额减掉香港赛站及北朝鲜赛站的名额而得（亚洲各赛站的参与名额是由亚洲区主席根据2016亚洲规则而定。）
(e) 2016年亚洲规则规定，所有亚洲队伍都可以去亚洲任何赛场参加比赛，但是一个队伍必须从自己的子赛区出线。
来源：西杰阿雄的博客
关于香港网络赛的规则：
* Additional rules specific to this Online Preliminary are as follows: 1. [Accepted teams](https://icpc.baylor.edu/regionals/finder/hong-kong-prelim-2016/teams) are allowed to attempt this online contest from anywhere with internet access. 2. Each coach (a faculty member of that team's University) will supervise his/her team(s) during the 5-hour online contest so that ICPC rules are respected, especially on these three important points: 1.</description></item><item><title>2016暑假总结</title><link>https://111qqz.com/2016/08/2016-summer-holiday/</link><pubDate>Mon, 29 Aug 2016 10:34:57 +0000</pubDate><guid>https://111qqz.com/2016/08/2016-summer-holiday/</guid><description>
开学了orz。。。。。。
随手写个总结（好像团队老师也要个人写报告的样子。。。？
大概一开始随便刷了点图论题，干掉了树的直径。。。次小生成树。。。这些算是在辣鸡比赛cccc之前把。。。
然后大概就是。。学了。。。博弈论。。。主要是sg函数。。。其实是个很容易理解但是会经常和其他算法一起考察的工具。。。？
然后大概花了几天时间。。。学习了后缀数组。。。完成了论文题中的一部分。。。
然后顺手学了kmp。。。。真的不明白kmp这种&amp;quot;傻逼算法&amp;quot;（语出某菊苣）我竟然五年时间才搞懂（雾
然后顺手学了ac自动机。。。。之前先学了trie树。。。
然后。。。好像终于完全理解了单调栈和单调队列。。。。？
感觉之前总是不会写八成是因为我之前看到的代码太丑了2333.
然后好像领悟到了模拟退火的本质。。。。？（也可能并没有2333
所以说其实大概就这些。。。。？
果然是又颓了一个假期啊。。。。哎。。。
线段树还是没来得及搞。。。。
今年大概会去沈阳。。。。？
所以还有大概一个半月的时间。。。。
干！</description></item><item><title>poj 1385 Lifting the Stone (多边形的重心)</title><link>https://111qqz.com/2016/08/poj-1385/</link><pubDate>Mon, 29 Aug 2016 03:31:15 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1385/</guid><description>
poj 1385 题目链接
题意：求多边形的重心。
思路：
抄模板（逃
嘛。。三角形的重心是三个点坐标的平均数。。。
多边形的重心其实就是先求三角形的重心然后再加权平均一下就好了。。。权值是面积比。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int dblcmp(double d) { return d &amp;lt; -eps ?</description></item><item><title>poj 2420 A Star not a Tree? (模拟退火模板题求多边形费马点)</title><link>https://111qqz.com/2016/08/poj-2420/</link><pubDate>Mon, 29 Aug 2016 03:23:27 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2420/</guid><description>
poj 2420
题意：求多边形费马点，也就是距离所有点的距离之和最小的点。
思路：模拟退火裸题。
关于模拟退火的学习： 模拟退火讲解
我就记住了一句话2333：
**爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。** **　模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。**
等写一波题再来总结
以及：感觉适牛的版好简洁嘿嘿嘿。
/* *********************************************** Author :111qqz Created Time :2016年05月30日 星期一 17时04分06秒 File Name :code/poj/2420.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair #define MAX 1000000 #define INF 999999999 using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>poj 1380 Equipment Box （简单几何）</title><link>https://111qqz.com/2016/08/poj-1380/</link><pubDate>Sun, 28 Aug 2016 13:03:22 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1380/</guid><description>
题目链接
题意：问一个小矩形能否放在一个大矩形中，给定两个矩形的尺寸。
思路：主要是斜着放比较难判断。学弟貌似写了离散化角度旋转。。。我的做法是。。直接考虑对角线。。。因为我认为对角线是最有可能放进去的位置。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int dblcmp(double d) {return d&amp;lt;-eps?</description></item><item><title>poj 1386 Play on Words (欧拉路)</title><link>https://111qqz.com/2016/08/poj-1386/</link><pubDate>Sun, 28 Aug 2016 12:53:13 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1386/</guid><description>
poj 1386
题意：n个单词，问能否形成一个串（单词接龙，收尾相连，当且仅当前一个单词的末尾字母和后一个单词的首字母相同）
思路：欧拉路。
关于欧拉路：
(1)**有向图G为欧拉图(存在欧拉回路)，当且仅当G的基图连通（弱联通，），且所有顶点的入度等于出度。** (2)有向图G为半欧拉图(存在欧拉路)，当且仅当G的基图连通（弱联通），且存在顶点u的入度比出度大1、v的入度比出度小1，其它所有顶点的入度等于出度。
（3） 无向图存在欧拉回路: 图连通，所有点都是偶数度，
（4）无向图存在欧拉路：图联通，只有两个点的度数为奇数。
有向图判断联通性判断的弱联通，因此可以用并查集实现。
具体办法是，判断根的个数，个数为大于1表示不联通。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=26; int in[N]; int out[N]; int f[N]; int root ( int x) { if (x!</description></item><item><title>poj 1383 Labyrinth (树的直径裸题)</title><link>https://111qqz.com/2016/08/poj-1383/</link><pubDate>Sun, 28 Aug 2016 12:04:15 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1383/</guid><description>
poj 1383题目链接
题意：一个迷宫图，求最远两点的距离是多少，保证每两个点都是联通的。
思路：树的直径。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; char maze[N][N]; bool vis[N][N]; int ans; int n,m; struct Point { int x,y; int d; bool ok () { if (x&amp;lt;0||y&amp;lt;0||x&amp;gt;=n||y&amp;gt;=m) return false; if (maze[x][y]=='#') return false; if (vis[x][y]) return false; return true; } void out() { cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; } }S,lst; void bfs(Point S) { queue&amp;lt;Point&amp;gt;q; S.</description></item><item><title>poj 1379 Run Away (模拟退火)</title><link>https://111qqz.com/2016/08/poj-1379/</link><pubDate>Sun, 28 Aug 2016 11:49:57 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1379/</guid><description>
poj 1379题目链接
题意：给出一个矩形区域的长宽，给出区域中若干点，问距离所有点的最近距离的最大值是多少。
思路：很容易想到模拟退火。
比赛的时候因为忘记判断矩形边界导致答案错得离谱2333
加上之后1A
/* *********************************************** Author :111qqz Created Time :2016年08月28日 星期一 19时10分47秒 File Name :code/poj/1379.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define INF 1e8 #define MAX 1e6 #define MAXN 1005 double X,Y; int n; struct Point { double x, y; double d; Point() {} Point(double _x, double _y) : x(_x), y(_y) {} Point operator +(const Point &amp;amp;p) const { return Point(x + p.</description></item><item><title>seerc 2014 Circle of digits (二分+后缀数组)</title><link>https://111qqz.com/2016/08/seerc-2014-circle-of-digits-/</link><pubDate>Sat, 27 Aug 2016 07:37:23 +0000</pubDate><guid>https://111qqz.com/2016/08/seerc-2014-circle-of-digits-/</guid><description>
题目链接
题意：把一个长度为n的只由数字构成的串分成k个不为空的字串，使得最大的串最小（大小是说串所对应的十进制数的大小）
思路：由于长度为x的串肯定大于长度为x-1的串，因此很容易想到，我们要尽可能使得k组串的长度尽可能平均（避免出现某一个串的长度非常大的情况）
我们可以知道，最大值的串的长度一定为 LEN=(n+k-1)/k;
而每一组的长度，只可能是LEN或者LEN-1。
然后build_sa
注意循环串的几个地方记得%n
接下来二分sa数组的下标。
二分check的时候，先枚举断点，断环为链。
由于每部分最长的长度为LEN，所以0..LEN-1中一定存在一个断点。
然后贪心，尽可能取LEN
根据rk值来决定某一段的长度是LEN还是LEN-1（如果rk值比当前的大，那么就只能取LEN-1，否则取LEN）
如果此时k段的长度之和超过了n，说明此时的最大值还可能更小。
于是继续二分区间的前一半。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char s[N]; int sa[N],t[N],t2[N],c[N]; int rk[N],height[N]; int L; int n,k; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[(a+l)%n]==r[(b+l)%n];} void build_sa(int n,int m) { int *x = t; int *y = t2; //ms(cnt,0); ms(c,0); for ( int i = 0 ; i &amp;lt; n ; i++) c[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) c[i]+=c[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--c[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k &amp;lt;&amp;lt;=1) { int p = 0; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; else y[p++] = n+(sa[i]-k)%n; ms(c,0); for ( int i = 0 ; i &amp;lt; n ; i++) c[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) c[i]+=c[i-1]; for ( int i = n-1 ; i &amp;gt;=0 ; i--) sa[--c[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>seerc 2014 D - Frame (傻逼题)</title><link>https://111qqz.com/2016/08/seerc-2014-d-frame-/</link><pubDate>Sat, 27 Aug 2016 06:52:38 +0000</pubDate><guid>https://111qqz.com/2016/08/seerc-2014-d-frame-/</guid><description>
题目链接
思路：注意xy-(x-2)*(y-2)=2x+2y-4，一定被2整除。因此siz为2的也是合法的。这个比较容易忘掉。
其他的判定条件都很好想。具体见代码；
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int X,Y; bool ok( int a) { if (a==2) return true; if (X%a==0&amp;amp;&amp;amp;(Y-2)%a==0) return true; if (Y%a==0&amp;amp;&amp;amp;(X-2)%a==0) return true; if (X%a==1&amp;amp;&amp;amp;Y%a==1) return true; return false; } int main() { // freopen(&amp;quot;in.</description></item><item><title>seerc 2014 A Banks (暴力)</title><link>https://111qqz.com/2016/08/seerc-2014-a-banks-/</link><pubDate>Sat, 27 Aug 2016 06:42:17 +0000</pubDate><guid>https://111qqz.com/2016/08/seerc-2014-a-banks-/</guid><description>
题目链接
题意：n个数围成一圈，对于负数可以进行magic操作，也就是取反，但是会影响到左右相邻的，加上这个负数。问最少进行多少次magic操作，使得所有数都是非负。
思路：我们知道，如果一个负数想变成整数的话，只能通过magic 操作。唯一可能影响次数的就是顺序。
不过手动写了几个发现顺序好像无关紧要？
于是大胆猜测，写了发暴力2333。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int maxn = 1e4+10; int n,a[maxn]; void work(){ queue&amp;lt;int&amp;gt; Q; int cnt = 0; while(!</description></item><item><title>fedora 24 cannot modify keyboard delay and rate</title><link>https://111qqz.com/2016/08/fedora-24-cannot-modify-keyboard-delay-and-rate/</link><pubDate>Thu, 25 Aug 2016 08:58:50 +0000</pubDate><guid>https://111qqz.com/2016/08/fedora-24-cannot-modify-keyboard-delay-and-rate/</guid><description>
最近入手了x1 c
然后发现没办法支持 f22.....
没办法，只好上f24了。。。虽然明知道一堆bug...
最近发现。。之前在系统设置-&amp;gt;键盘-&amp;gt;打字 中的调整键盘延迟和速率的选项。。。不见了。。。
找了好久终于找到了解决办法：
/××××××××××××××××××××××××××××××××××××××××××××××××/ xset r rate 250 30
链接：参考</description></item><item><title>累了</title><link>https://111qqz.com/2016/08/</link><pubDate>Wed, 24 Aug 2016 08:44:18 +0000</pubDate><guid>https://111qqz.com/2016/08/</guid><description>
想家了。
破游戏，不玩了。
上次绝望的想哭，还是那场校内选拔赛
我真的在努力了啊，我真的在认真了啊...
可是一年过去，我还是这么菜。
真的想哭，真的不想玩了
cf rating永远也超不过小可了吧...
那些没有学会的算法，再也没机会学了吧....
感觉已经完全没有力气了。
sad max.</description></item><item><title>hdu 5036 Explosion||2014 北京区域赛网络赛 (概率+bitset优化的状态压缩+floyd传递闭包)</title><link>https://111qqz.com/2016/08/hdu-5036/</link><pubDate>Sun, 21 Aug 2016 11:18:49 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5036/</guid><description>
题目链接
题意：有n扇门，n种钥匙，一一对应。每扇门打开后可能得到k把钥匙（k可能为0）。一扇门还可以用一颗炸弹炸开。现在问要开所有门，使用炸弹的期望个数。
思路：状态压缩。用一个二进制串表示每扇门能打开的门的信息，对应的位上为1表示能打开，为0表示不能打开。
状态是可以传递的。。
如果第i扇门能打开门k，那么能打开第i扇门的第j扇门也可以打开门k。
状态压缩以及传递的过程可以很容易用bitset来维护，这才是bitset的正确打开姿势
相当于用floyd做了一个传递闭包。(floyd的有一层循环隐藏在了bitset中，复杂度没有改变，但是常数小)
最后对于期望的计算方法：统计能打开第i扇门的方案数计为cnt,这cnt的方案中，只有一种是用炸弹炸掉，因此用的炸弹数的期望数为1/cnt
由于期望的独立性，因此打开所有门所有的炸弹数的期望就是每个门的期望累加。
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 18时43分56秒 File Name :code/hdu/5036.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; bitset&amp;lt;N&amp;gt;b[N]; //b[i]表示第i扇门可以打开的门 int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #368 div 2 C. Pythagorean Triples (构造，数学)</title><link>https://111qqz.com/2016/08/cf707c/</link><pubDate>Sun, 21 Aug 2016 10:45:59 +0000</pubDate><guid>https://111qqz.com/2016/08/cf707c/</guid><description>
题目链接
题意：给出一个数，问包含这个数三个数组成的勾股数，输出另外两个数。
思路：
所谓勾股数,就是当组成一个直角三角形的三边长都为正整数时,我们就称这一组数为勾股数. 那么,组成一组勾股数的三个正整数之间,是否具有一定的规律可寻呢?下面我们一起来观察几组勾股数： 规律一：在勾股数（3,4,5）、（5,12,13）、（7,24,25）（9,40,41）中,我们发现 由（3,4,5）有：32=9=4+5 由（5,12,13）有：52=25=12+13 由（7,24,25）有：72=49=24+25 由（9,40,41）有：92=81=40+41. 即在一组勾股数中,当最小边为奇数时,它的平方刚好等于另外两个连续的正整数之和.因此,我们把它推广到一般,从而可得出以下公式： ∵（2n+1)²=4n²+4n+1=（2n²+2n）+（2n²+2n+1） ∴（2n+1)**²**+（2n²+2n)²=（2n²+2n+1)²（n为正整数） 证明（略） **勾股数公式一：（2n+1,2n²+2n,2n²+2n+1）（n为正整数）** 规律二：在勾股数（6,8,10）、（8,15,17）、（10,24,26）中,我们发现 由（6,8,10）有：62=36+2×（8+10） 由（8,15,17）有：82=64=2×（15+17） 由（10,24,26）有：102=100=2×（24+26） 即在一组勾股数中,当最小边为偶数时,它的平方刚好等于两个连续整数之和的二倍,推广到一般,从而可得出另一公式： ∵（2n）2=4n2=2[（n2-1）+（n2+1）] ∴（2n）2+（n2-1）2=（n2+1）2（n≥2且n为正整数） 证明（略） **勾股数公式二：（2n,n²-1,n²+1）（n≥2且n为正整数）** 利用以上两个公式,我们可以快速写出各组勾股数. 结论是： n&amp;lt;=2无解。
n为奇数用公式1构造。
n为偶数用公式2构造。
** **
 /* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时02分26秒 File Name :code/cf/#368/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;code/in.</description></item><item><title>hdu 2051 bitset (水)</title><link>https://111qqz.com/2016/08/hdu-2051/</link><pubDate>Sun, 21 Aug 2016 08:32:08 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2051/</guid><description>
题目链接
题意：把一个数n(n&amp;lt;1000)转化成二进制输出。。。
思路：。。。搜acm bitset 搜到这题。。。所以其实这并不是“bitset”优化的题。。。只是题目名字交这个了2333。
还是用bitset过掉了。。。不过不知道怎么处理高位0.。。
所以这是一次bitset的错误示范(逃
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 16时10分50秒 File Name :code/hdu/2051.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1};Explosion const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned long long n ; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>acm 奇技淫巧 bitset</title><link>https://111qqz.com/2016/08/acm--bitset/</link><pubDate>Sun, 21 Aug 2016 07:39:56 +0000</pubDate><guid>https://111qqz.com/2016/08/acm--bitset/</guid><description>
1.定义与初始化 在定义 bitset 时，要明确 bitset 有多少位，这个位数是整形常量
(tips:如果长度和输入的数m有关，在做翻转操作以后再统计时候会多算，一个可以的做法是设置一个长度为m，所有位上都是1的位串，然后翻转之后先与一下。类似的技巧还有很多。)
（） bitset b; //b 有 n 位，每位都是 0 bitset b(u); //b 是 unsigned long 型 u 的一个副本 bitset b(s); //b 是 string 对象 s 中含有的位串的副本，这个s 必须是位串，也就是二进制码串 bitset b(s, pos, n); //b 是 s 中 从位置 pos 开始的 n 个位的副本
2.bitset 的操作 b.any() //b 中是否存在置为 1 的二进制位？ b.none() // 和b.any() 效果一样 b.count() //b 中不存在置为 1 的二进制位吗？
b.any() //b中存在置为1的二进制位吗？ b.size() //b 中置为 1 的二进制位的个数 b[pos] //访问 b 中在 pos 处二进制位 b.</description></item><item><title>codeforces #368 div 2 B. Bakery (暴力)</title><link>https://111qqz.com/2016/08/707b/</link><pubDate>Sun, 21 Aug 2016 06:17:59 +0000</pubDate><guid>https://111qqz.com/2016/08/707b/</guid><description>
题目链接
题意：n个城市，m条双向路，要从k条中选择一个，使得到其他n-k个城市中的某个城市的距离最短。
思路：直接暴力 枚举。1A
/* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时02分14秒 File Name :code/cf/#368/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =1E5+7; int n,m,k; vector &amp;lt;pair &amp;lt;int,LL&amp;gt; &amp;gt;edge[N]; int b[N]; bool cangku[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #368 div 2 A. Brain's Photos (暴力)</title><link>https://111qqz.com/2016/08/cf707a/</link><pubDate>Sun, 21 Aug 2016 06:10:35 +0000</pubDate><guid>https://111qqz.com/2016/08/cf707a/</guid><description>
题目链接
。。。这题也能成hack题。。。。有毒啊。。然后我room里所有人都写对了。。。是我看这道题看得太早了？
/* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时01分57秒 File Name :code/cf/#368/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>0821随笔</title><link>https://111qqz.com/2016/08/0821/</link><pubDate>Sat, 20 Aug 2016 17:53:58 +0000</pubDate><guid>https://111qqz.com/2016/08/0821/</guid><description>
。。第一场组队赛。。。罚时爆炸。。。pacedect不在。。。没rk1好不开心啊。。。我的锅我的锅。。。
晚上cf听从适牛的写题策略。。先从c开始。。。终于蓝了。。。也是感动。。。
然后看到一些学长的cf号。。发现都好高啊。。。。
但是区域赛并没有取得什么好的成绩。。。甚至打铁。。。
而我们去年拿牌的几个队的所有人。。。rating最高的不过1700+?
随便一个毕业学长都有1800.。。三个这样的学长组在一起结果打了铁。。。？
我也不是很懂。。。是区域赛变简单了。。。还是cf变难了。。。。
说起来。。。8月21.。。今天好像是小可的生日呢。。。。。。
嘛，还是要说句生日快乐的，嗯。</description></item><item><title>the way so far</title><link>https://111qqz.com/2016/08/the-way-so-far/</link><pubDate>Thu, 18 Aug 2016 14:34:08 +0000</pubDate><guid>https://111qqz.com/2016/08/the-way-so-far/</guid><description/></item><item><title>hdu 1754 I Hate It (线段树模板题，炒鸡详细注释版)</title><link>https://111qqz.com/2016/08/hdu-1754/</link><pubDate>Thu, 18 Aug 2016 11:47:41 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1754/</guid><description>
hdu 1754 题目链接 题意：单点更新，区间查询最大值。 思路：线段树。 一开始借鉴了clj的pointer写法。。wjmzbmr's code 直接MLE。。。看来也许只能在cf上用。。。 下面是MLE的代码：
/* *********************************************** Author :111qqz Created Time :2016年08月18日 星期四 18时40分24秒 File Name :code/hdu/1754.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N],n,m; int _max( int x,int y) { if (x==-1||y==-1) return x==-1?</description></item><item><title>线段树学习笔记</title><link>https://111qqz.com/2016/08/</link><pubDate>Thu, 18 Aug 2016 09:19:31 +0000</pubDate><guid>https://111qqz.com/2016/08/</guid><description>
嘛，终于下定决心搞定线段树了。
之前几次都是被lazy标记卡住，这次大概不会了吧2333
放一些学习资料，最后比较zkw线段树和普通线段树的区别。
codeforces上非递归线段树讲解 （其实就是zkw吧）
线段树进阶（各种花式技巧）
找到了一篇非常赞的tutorial（含lazy标记） 链接</description></item><item><title>c++11 学习笔记</title><link>https://111qqz.com/2016/08/c11-/</link><pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate><guid>https://111qqz.com/2016/08/c11-/</guid><description>
昨天终于搞定了ycm对c++11的支持....
嘛，17都快出来了，我竟然连11都不会用。
不过突然把所有的11特性给我也没办法全部吸收。
所以在这里记录下用过的c++11的用法。
auto可以代替stl的一些容器中的iterator: /****************************************************************** ******************************************************************* ******************************************************************/ set&amp;lt;int&amp;gt;se; //之前的写法遍历要这样写： for (set&amp;lt;int&amp;gt;::iterator it = se.begin() ;it!=se.end() ;it++) //用auto可以简化成这样子 for ( auto it = se.begin(); it!=se.end() ;it++)</description></item><item><title>hdu 3065 病毒侵袭持续中 (ac自动机)</title><link>https://111qqz.com/2016/08/hdu-3065/</link><pubDate>Wed, 17 Aug 2016 19:36:33 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3065/</guid><description>
题目链接
题意：给出n个病毒的模式串，问每个病毒串在文本串中出现了多少次。
思路：ac自动机。模式串只由大写字母组成。文本串是所有可视字符。 如果动态128会MLE.做法是换成静态数组写法，或者对于每次Search的时候，出现非大写字母的字符特判一下。
/* *********************************************** Author :111qqz Created Time :2016年08月18日 星期四 00时17分38秒 File Name :code/hdu/3065.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int sizTrie = 26; map&amp;lt;int,int&amp;gt;mp; char ill[1005][50]; struct Trie { struct Node { Node *nxt[sizTrie]; Node *fail; int cnt; int id; Node() { for ( int i = 0 ; i &amp;lt; sizTrie; i++) nxt[i]=NULL; cnt = 0 ; id = 0 ; fail = NULL; } }; Node *root; void init() { root = new Node(); } void Insert(char *s,int x) { int len = strlen(s); Node *u = root; for ( int i = 0 ; i &amp;lt; len ; i++ ) { int v = s[i]-'A'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; } u-&amp;gt;cnt++; u-&amp;gt;id = x; // cout&amp;lt;&amp;lt;&amp;quot;s:&amp;quot;&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&amp;quot; cnt:&amp;quot;&amp;lt;&amp;lt; u-&amp;gt;cnt &amp;lt;&amp;lt;endl; } void getFail() { root-&amp;gt;fail = root; queue&amp;lt;Node*&amp;gt;Q; for ( int i = 0 ; i &amp;lt; sizTrie ; i++) { if (root-&amp;gt;nxt[i]==NULL) root-&amp;gt;nxt[i] = root; else { root-&amp;gt;nxt[i]-&amp;gt;fail = root; Q.</description></item><item><title>hdu 2896 病毒侵袭 (ac自动机)</title><link>https://111qqz.com/2016/08/hdu-2896/</link><pubDate>Wed, 17 Aug 2016 13:17:02 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2896/</guid><description>
hdu 2896 题目链接
题意：给出n个病毒，然后给出m个网站，然后问每个网站中有哪些病毒，以及有病毒的网站的个数。
需要注意病毒和网站都需要按从小到达排列输出。
思路：ac自动机，需要记录病毒id...然后。。因为病毒的id忘记排序wa了好多发。。智力减2.
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 19时53分24秒 File Name :code/hdu/2896.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; vector &amp;lt;int&amp;gt;ans; struct Trie { struct Node { Node *nxt[128]; Node *fail; int val; Node() { for ( int i = 0 ; i &amp;lt; 128 ; i++) nxt[i] = NULL; val = 0; fail = NULL; } }; Node *root; void init() { root = new Node(); } void Insert(char *s,int num) { int len = strlen(s); Node *u = root; for ( int i = 0 ; i &amp;lt; len ;i++) { int v = s[i]-32; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; } u-&amp;gt;val = num; } void getFail() { root-&amp;gt;fail = root; queue&amp;lt;Node*&amp;gt;Q; for ( int i = 0 ; i &amp;lt; 128 ; i++) { if (root-&amp;gt;nxt[i]==NULL) root-&amp;gt;nxt[i] = root; else { root-&amp;gt;nxt[i]-&amp;gt;fail = root; Q.</description></item><item><title>ac自动机模板by Lalatina （hdu 2222）</title><link>https://111qqz.com/2016/08/acby-lalatina-hdu-2222/</link><pubDate>Tue, 16 Aug 2016 08:54:53 +0000</pubDate><guid>https://111qqz.com/2016/08/acby-lalatina-hdu-2222/</guid><description>
orzorz 日常%学弟 华科的未来orz
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; struct tnode { int s; tnode *f, *w, *c[26]; } T[5000000], *Q[5000000]; int C; inline tnode *tnew() { memset(T + C, 0, sizeof(tnode)); return T + C++; } inline void AcaInsert(tnode *p, const char *s) { while (*s) { int u = *s - 'a'; if (!p-&amp;gt;c[u]) p-&amp;gt;c[u] = tnew(); p = p-&amp;gt;c[u]; ++s; } ++p-&amp;gt;s; } inline void AcaBuild(tnode *p) { p-&amp;gt;f = p-&amp;gt;w = p; int ql = 0; for (int i = 0; i &amp;lt; 26; ++i) if (p-&amp;gt;c[i]) { p-&amp;gt;c[i]-&amp;gt;f = p-&amp;gt;c[i]-&amp;gt;w = p; Q[ql++] = p-&amp;gt;c[i]; } for (int qf = 0; qf &amp;lt; ql; ++qf) for (int i = 0; i &amp;lt; 26; ++i) if (Q[qf]-&amp;gt;c[i]) { tnode *f = Q[qf]-&amp;gt;f; while (f !</description></item><item><title>hdu 2222 Keywords Search (ac自动机模板题（静态数组写法+动态指针写法）)</title><link>https://111qqz.com/2016/08/hdu-2222/</link><pubDate>Tue, 16 Aug 2016 07:12:36 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2222/</guid><description>
hdu 2222 题目链接
题意：给出n个模式串，一个文本串，问文本串中出现了多少各模式串。
思路：ac自动机裸题。代码风格来自bin神。静态数组的写法。
需要理解 在build fail的时候，先单独处理root的必要性。
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 06时00分48秒 File Name :code/hdu/2222.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 5E5+7; int n; struct Trie { int nxt[N][26],fail[N],end[N]; int root,L; int newnode() { for ( int i = 0 ; i &amp;lt; 26 ; i++) nxt[L][i]=-1; end[L++] = 0 ; return L-1; } void init() { L = 0 ; root = newnode(); } void Insert(char *s) { int len = strlen(s); int u = root; for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (nxt[u][v]==-1) nxt[u][v] = newnode(); u = nxt[u][v]; } end[u]++; } void Getfail() { queue&amp;lt;int&amp;gt;Q; fail[root] = root; for ( int i = 0 ; i &amp;lt; 26 ; i++) if (nxt[root][i]==-1) nxt[root][i] = root; else { fail[nxt[root][i]] = root; Q.</description></item><item><title>20160816随笔</title><link>https://111qqz.com/2016/08/20160816/</link><pubDate>Mon, 15 Aug 2016 21:51:09 +0000</pubDate><guid>https://111qqz.com/2016/08/20160816/</guid><description>
突然感觉。。。
我这种几乎没有恋爱经验的人。。。
感觉被妹子随便用点手段就能收了啊orz
想想真是可怕。。。
别问我为什么突然有这种的感慨。。。
吓傻了。。。。
还是好好写代码比较靠谱。</description></item><item><title>ac自动机学习笔记</title><link>https://111qqz.com/2016/08/ac/</link><pubDate>Mon, 15 Aug 2016 21:43:49 +0000</pubDate><guid>https://111qqz.com/2016/08/ac/</guid><description>
老规矩，先放资料： 参考资料1 参考资料2 参考资料3
（其实这些资料我都没怎么看。。。。因为感觉。。。理解起来非常容易的样子orz）
我的理解：感觉这东西如果明白了kmp和trie，理解起来就完全没难度。。。
感觉就是在trie上做kmp...？
nxt数组换个名字叫fail。。。。其实是一样的东西吧。。。？
来来来，先干一波题再回来总结。。。
感觉暴力匹配相对于kmp（都是线性单模式串），就好像trie相对于ac自动机（都是树上多模式串）
另一个方向：暴力相对于trie，（都是暴力）就好像kmp相对于ac自动机（都是经过失配优化）
ac自动机的题目里这么多和dp结合在一起让我怎么做啊orz...
以及感觉。。。ac自动机的水平可以通过多写trie来提高2333。
区域赛之前再刷一波trie...
是时候干掉线段树了。。。</description></item><item><title>poj 2001 Shortest Prefixes (trie树)</title><link>https://111qqz.com/2016/08/poj-2001/</link><pubDate>Mon, 15 Aug 2016 19:22:36 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2001/</guid><description>
poj 2001 题目链接
题意：给出n个字符串的表，问每个字符串的简化表示。简化表示的要求是，以该字符串的最短的而且不能产生歧义的前缀来表示。
思路：字典树，多一个cnt属性，每次insert的时候，路过的每个节点的cnt++
find的时候从root往下扫。。遇到的cnt为1的节点结尾的字符串。。就是该单词的唯一表示。。。
按照这个思路写了一发。。。1A好开心哈哈哈
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 02时55分22秒 File Name :code/poj/2001.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; char s[N][25]; int n; struct Trie { struct Node { Node *nxt[26]; int cnt; Node() { for ( int i = 0 ; i &amp;lt; 26; i++) nxt[i] = NULL; cnt = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; u-&amp;gt;cnt++; } } string Find(char *s) { Node *u = root; string res=&amp;quot;&amp;quot;; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; res = res + s[i]; u = u-&amp;gt;nxt[v]; if (u-&amp;gt;cnt==1) return res; //cnt为1表示应该就唯一了吧。。。 } } }trie; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3630 Phone List (带删除操作的静态trie树模板题)</title><link>https://111qqz.com/2016/08/poj-3630/</link><pubDate>Mon, 15 Aug 2016 18:52:16 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3630/</guid><description>
poj 3630 题目链接
题意：给出n个字符串，问是否满足所有的字符串都不以其他的字符串为前缀。
思路：字典树，先建树，然后每次查找的之前先删掉自己，找完以后再加回来。
以及这题动态建艹不过。。。学习了一下静态建树的写法。。。第一次写静态的写法。。。可以当做模板用。。。
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 00时46分23秒 File Name :code/poj/3630.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; char s[N][12]; int tot; struct Trie { int nxt[10]; int cnt; void init() { ms(nxt,0); cnt = 0; } }trie[N]; int add() { memset(&amp;amp;trie[tot],0,sizeof(Trie)); return tot++; } void Insert(char *s) { int rt = 0 ; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (!</description></item><item><title>hdu 1247 Hat’s Words (trie树)</title><link>https://111qqz.com/2016/08/hdu-1247/</link><pubDate>Mon, 15 Aug 2016 16:36:29 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1247/</guid><description>
hdu 1247 题目链接
题意：给出n个字符串的单词表，输出所有的字符串a，满足字符串a是由n中另外两个字符串拼接成的。
思路：字典树。。其实我一开始想出了正解。。。。就是分割一个单词然后分别在trie上查找。。。但是由于题目坑爹得没给单词的长度这个数据范围。。并不是很敢写2333。。。看了下题解发现就是这么做。。。然后写了下1A。。。
不给数据范围玩个鸟啊。。。
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 00时08分01秒 File Name :code/hdu/1247.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 5E4+7; char s[N][200]; int n ; struct Trie { struct Node { Node *nxt[26]; bool ok; //标记单词的结尾 Node() { for ( int i = 0 ; i &amp;lt; 26 ; i++) nxt[i] = NULL; ok = false; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; } u-&amp;gt;ok = true; } bool Find(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) return 0; u=u-&amp;gt;nxt[v]; } return u-&amp;gt;ok; } }trie; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5536 || 2015 长春区域赛 J Chip Factory (带删除操作的trie树)</title><link>https://111qqz.com/2016/08/hdu-5536/</link><pubDate>Mon, 15 Aug 2016 15:54:40 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5536/</guid><description>
hdu 5536 题目链接
题意：给出n个数，然后问最大的(a[i]+a[j])^a[k] (i,j,k互不相同)
思路：异或和最大很容易想到字典树。。但是如何保证i,j,k互不相同这里没有想明白。。。。。我的想法是加一个标记代表之前的id，但是我加的标记是只有在叶子节点上才有的。。。也就是会出现走到了最后一步才发现这个节点是不能走的情况。。。
正确的做法是，加一个cnt标记。
每次插入的时候，这个数从根节点到叶子节点每个节点的cnt都+1
删除的时候做就是每个节点的cnt都-1.
这样子每次Find的时候只走cnt&amp;gt;0的点。。
这种做法的正确性基与：
两个不同的数。。一定有至少一位的二进制数不同。。。保证了当只出现过一次的数x被删掉以后，其他的数y的存在不会导致经过x的路径
** 两个相同的数，每一位二进制数位都是相同搞的。 **保证了id不同的相同的数。。即使一个被删掉。。另外的也可以继续访问。。。因为cnt仍然是大于0的。。。
/* *********************************************** Author :111qqz Created Time :2016年08月15日 星期一 22时54分03秒 File Name :code/hdu/5536.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int LEN=32; const int N=1005; int n; char str[35]; int a[N]; struct Trie { struct Node { Node *nxt[2]; int val; int cnt; Node() { for (int i = 0 ; i &amp;lt; 2 ; i++) nxt[i] = NULL; cnt = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s,int num) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u=u-&amp;gt;nxt[v]; u-&amp;gt;cnt++; } u-&amp;gt;val = num; } void Delete(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (u-&amp;gt;nxt[v]!</description></item><item><title>hdu 4828 Xor Sum (trie 树模板题，经典应用)</title><link>https://111qqz.com/2016/08/hdu-4828-xor-sum-trie-/</link><pubDate>Mon, 15 Aug 2016 13:09:28 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-4828-xor-sum-trie-/</guid><description>
hdu 4825 题目链接
题意：给定n个数，然后给出m个询问，每组询问一个数x，问n中的数y使得x和y的异或和最大。
思路：字典树。。把每个数转化成二进制，注意补全前导0，使得所有数都有相同的位数。
如果想要异或和最大，那么每一位尽可能都是1.
所以做法是，先构建字典树，然后每次find的时候，尽可能按照和当前寻找的数的位相反的位的方向走（如果有的话）
比如当前位是1，那我就往0的方向走。
需要注意的是，多组数据，每次要重新初始化一遍。
做法是 在struct 中重新 root = new Node() 一下。。这样就重新调用了Node中初始化用的构造函数。
/* *********************************************** Author :111qqz Created Time :2016年08月15日 星期一 20时03分05秒 File Name :code/hdu/4825.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int LEN = 32; int n,m; char str[35]; struct Trie { struct Node { Node *nxt[2]; int val; Node() { for ( int i = 0 ; i &amp;lt; 2 ; i++) nxt[i]=NULL; val = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s,int num) { Node *u =root; int len = strlen(s); // cout&amp;lt;&amp;lt;&amp;quot; len :&amp;quot;&amp;lt;&amp;lt;len&amp;lt;&amp;lt;endl; for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; } u-&amp;gt;val = num; } int Find(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int x = s[i]-'0'; int y = !</description></item><item><title>hdu 1251 统计难题 (trie树模板题)</title><link>https://111qqz.com/2016/08/hdu-1251/</link><pubDate>Sun, 14 Aug 2016 16:06:02 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1251/</guid><description>
hdu 1251 题目链接
题意：先给一个单词表，然后给出若干查询，每个查询一个单词，问单词表中以这个单词为前缀的单词的个数。
思路：trie树裸题。第一次写trie树。。感觉要注意的是trie树是一个比较耗费空间的数据结构。。？ 以及动态开辟内存记得free...？
/* *********************************************** Author :111qqz Created Time :2016年08月14日 星期日 19时58分41秒 File Name :code/hdu/1251.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char s[20]; struct Trie { struct Node { Node *nxt[26]; int cnt; Node() { for ( int i = 0 ; i &amp;lt; 26; i++) nxt[i]=NULL; cnt = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v]=new Node(); u = u-&amp;gt;nxt[v]; u-&amp;gt;cnt++; } } int Find(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) return 0; u = u-&amp;gt;nxt[v]; } return u-&amp;gt;cnt; } }trie; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5833 || ccpc 2016 网络赛 1002 Zhu and 772002 （高斯消元）</title><link>https://111qqz.com/2016/08/hdu-5833/</link><pubDate>Sun, 14 Aug 2016 11:33:25 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5833/</guid><description>
hdu 5833 题目链接
题意：n个数，保证每个数的素因子不超过2000，从中取若干个，问乘积是完全平方数的方案数。
思路： 完全平方数就是要求每个质因子的指数是偶数次。
列方程组，a1,a2,a3……am分别表示bi是否在集合中。对于每一个素因子，建立异或方程组，要求因子个数为偶数，即异或为0
然后得到自由元的个数为num,答案为2^num-1 (减去空集)
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std; typedef long long LL ; #define pi acos(-1.0) const int mod=1e9+7; const int INF=1e9; const double eqs=1e-9; const int N=310; LL mat[N][N], a[N], equ, var, prime[N]; LL c[N]; LL gauss() { LL i, j, k, h, max_r, tmp; for(i=0,j=0;i&amp;lt;equ&amp;amp;&amp;amp;j&amp;lt;var;i++,j++){ max_r=i; for(k=i+1;k&amp;lt;equ;k++){ if(mat[k][j]&amp;gt;mat[max_r][j]) max_r=k; } if(max_r!</description></item><item><title>hdu 5835 || ccpc 2016 网络赛 1004 Danganronpa (模拟)</title><link>https://111qqz.com/2016/08/hdu-5835/</link><pubDate>Sun, 14 Aug 2016 11:24:01 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5835/</guid><description>
hdu 5835 题目链接 题意：n种礼物，每种a[i]个。现在有无穷个小朋友排成一排，分给每个人一个“普通”的礼物，一个“昂贵”的礼物（哪个普通哪个昂贵是自己定的，或者说，任意的） 要求是相邻的小朋友的普通的礼物不能是同一种。现在问最多能给多少小朋友分礼物。。。
思路：容易知道，因为昂贵的礼物是没有限制的。。所以没什么用。。考虑礼物总数sum..那么最多只可能分给sum/2个小朋友。。。然后再两个指针模拟一下。。记得特判n=1的情况。1A
/* *********************************************** Author :111qqz Created Time :2016年08月14日 星期日 12时46分56秒 File Name :code/ccpc2016/1004.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=11; int n; int a[N]; int total; bool bian[N]; bool cmp(int a,int b) { return a&amp;gt;b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5842 || 2016 ccpc 网络赛 1011 Lweb and String（set）</title><link>https://111qqz.com/2016/08/hdu-5842/</link><pubDate>Sun, 14 Aug 2016 11:17:22 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5842/</guid><description>
hdu 5842题目链接
题意：给一个只由小写字母组成的字符串，每个字符映射到一个数字，问映射之后的最长上升子序列的长度。。
思路：上来写nlogn的LIS是我无脑了。。。wa了之后想了下。。其实只要统计不同的字母数就好了啊。。。set一下
/* *********************************************** Author :111qqz Created Time :2016年08月14日 星期日 12时13分22秒 File Name :code/ccpc2016/1011.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char s[N]; int a[N]; int dp[N]; int g[N]; set&amp;lt;int&amp;gt;se; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>20160813随笔</title><link>https://111qqz.com/2016/08/20160813/</link><pubDate>Fri, 12 Aug 2016 19:58:06 +0000</pubDate><guid>https://111qqz.com/2016/08/20160813/</guid><description>
感觉终于走在了正确的道路上了。
要是时间再多一点就好了。
我对成绩没有太多期待，顺其自然就好咯。
唯一的执念，就是，争取艹翻Pacedect (微笑脸)
嘛，其实也不是有仇恨啦
非要说就是有人太不可爱，我比较记仇2333333
晚安。</description></item><item><title>hdu 3374 String Problem (字符串的最小/大表示法+kmp)</title><link>https://111qqz.com/2016/08/hdu-3374/</link><pubDate>Fri, 12 Aug 2016 19:39:21 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3374/</guid><description>
hdu 3374 题目链接 题意：给出一个循环字符串，问最小表示出现的位置以及次数，最大表示出现的位置以及次数。 思路：之前只写过最小表示。。最大表示其实是一样的。。。把不等式方向变号即可。。。对于出现的次数。。。其实就等同于这个字符串是由几个子串组成。。。跑一遍kmp。。答案为len-nxt[len]，1A
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 03时22分47秒 File Name :code/hdu/3374.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; char s[N],tmp[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j +=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 2609 How many (字符串的最小表示法+set)</title><link>https://111qqz.com/2016/08/hdu-2609/</link><pubDate>Fri, 12 Aug 2016 19:07:37 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2609/</guid><description>
hdu 2609 题目链接
题意：给出n个循环字符串，问有多少种。
思路：将每个字符串换成最小表示，然后set存一下即可。
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 02时44分21秒 File Name :code/hdu/2609.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; char s[N][105]; set&amp;lt;string&amp;gt;se; int minRep(char *s) { int n = strlen(s); int i = 0 ; int j = 1 ; int k = 0 ; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n] - s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 4162 Shape Number (字符串的最小表示法)</title><link>https://111qqz.com/2016/08/hdu-4162/</link><pubDate>Fri, 12 Aug 2016 18:42:04 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-4162/</guid><description>
hdu 4162
题意：给出一串代表8个方向的数字，求这串序列的一阶差分（the first difference）的字典序最小的表示。
思路：先做个变换，按照题意，第i位的一阶差分 s[i] = ((s[i+1]-s[i])+8)%8;
然后求出最小表示开始的位置。。输出即可。
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 02时17分45秒 File Name :code/poj/4162.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0 ; int j = 1; int k = 0 ; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>poj 1509 Glass Beads (字符串的最小表示法)</title><link>https://111qqz.com/2016/08/poj-1509/</link><pubDate>Fri, 12 Aug 2016 17:21:21 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1509/</guid><description>
poj 1509 题目链接
题意&amp;amp;思路：同uva 1314
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 18时48分29秒 File Name :code/uva/1314.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>ural 1314 Hidden Password (字符串的最小表示法模板题)</title><link>https://111qqz.com/2016/08/ural-1314-hidden-password-/</link><pubDate>Fri, 12 Aug 2016 17:14:46 +0000</pubDate><guid>https://111qqz.com/2016/08/ural-1314-hidden-password-/</guid><description>
uva 1314 题目链接
题意：给定一个循环字符串，问字典序最小的串的开始位置。最小表示法裸题。
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 18时48分29秒 File Name :code/uva/1314.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>最小表示法学习笔记（同构问题+模板）</title><link>https://111qqz.com/2016/08/</link><pubDate>Fri, 12 Aug 2016 08:37:06 +0000</pubDate><guid>https://111qqz.com/2016/08/</guid><description>
首先放一波资料：叶子豪_最小表示法
周源_《浅谈最小表示法在字符串循环同构问题中的应用》 参考博客 对于字符串循环同构的最小表示法，其问题实质是求S串的一个位置，从这个位置开始循环输出S，得到的S’字典序最小。
一种朴素的方法是设计i,j两个指针。其中i指向最小表示的位置，j作为比较指针。
令i=0,j=1 如果S[i] S[j] i=j, j=i+1 如果S[i] S[j+k] i=j,j=i+1** _ 否则j++ **返回i** 注意到，朴素算法的缺陷在于斜体的情况下i指针的移动太少了。针对这一问题改进就得到了最小表示法的算法。最小表示法的算法思路是维护两个指针i,j。
令i=0,j=1 如果S[i] S[j] i=j, j=i+1 如果S[i] S[j+k] i=i+k ** 否则j++ **返回i****和j****的小者** 注意到上面两个算法唯一的区别是粗体的一行。这一行就把复杂度降到O(n)了。 值得一提的是，与KMP类似，最小表示法处理的是一个字符串S的性质，而不是看论文时给人感觉的处理两个字符串。 应用最小表示法判断两个字符串同构，只要将两个串的最小表示求出来，然后从最小表示开始比较。剩下的工作就不用多说了。
模板：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; const int N = 100000+10; char str[N]; int minimalRepresentation() { int n = strlen(str); int i = 0,j = 1, k = 0; while(i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;n &amp;amp;&amp;amp; k&amp;lt;n) { int t = str[(i+k)%n] - str[(j+k)%n] ; if(t == 0) k++; else { if(t&amp;gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k = 0; } } return i &amp;lt; j ?</description></item><item><title>hdu 4300 Clairewd’s message (kmp)</title><link>https://111qqz.com/2016/08/hdu4300/</link><pubDate>Fri, 12 Aug 2016 07:34:47 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu4300/</guid><description>
hdu 4300题目链接
吐槽：题意难懂的一逼，关键的地方根本没有说清好么。。。竟然还是多校题。。。。出题人英语是体育老师教的吧。。？本来挺傻逼一道题。。被这完全没有说清楚的题意搞得很不爽。。。
题意：给一个26个字母一一对应的密码表。
然后给出一个字符串，先是密文再是明文，明文可能不全。问最小的可能的密文+明文串是什么。。
思路：
把字符串按照密码表转化得到一个新的字符串，然后跑kmp得到原字符串a的后缀等于转化后的字符串b的前缀的最长长度的字符串。（需要注意的是,kmp匹配的时候，由于密文长度一定是大于等于明文的，并且如果字符串a和字符串b相等，匹配全部是没有意义的，所以我们从中间位置开始匹配，更具体的说，是从第一个后面的字符串的长度大于等于前面的字符串的长度的位置开始匹配）
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 13时55分42秒 File Name :code/hdu/4300.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N],b[N]; map&amp;lt;char,char&amp;gt;mp; char table[30]; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i] = ++ j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); getnxt(b); int i = 0; int j = 0; if (n%2==0) i = n/2; //明文可能残缺，因此密文长度大于等于明文，i要从一半往后开始，不然的话会匹配到自身 else i = n/2+1; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } if (i==n) return j; return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3336 Count the string （nxt函数的运用kmp+（dfs|dp )）</title><link>https://111qqz.com/2016/08/hdu3336/</link><pubDate>Fri, 12 Aug 2016 05:33:08 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu3336/</guid><description>
hdu 3336 题目链接
题意：给一个字符串，问这个字符串的所有前缀的出现次数的和。
思路：这道题需要完全理解nxt函数是干嘛的。。nxt[i]表示的是字符串的0..i-1位中，前缀和后缀相等的串的最长长度为nxt[i]
这东西对于这道题有什么用呢？
举个例子，对于字符串ababa：
s a b a b a i 0 1 2 3 4 5 next[i] -1 0 0 1 2 3
ans初始为len(因为长度为len的字符串有len个前缀，每个前缀至少出现一次) next[3] = 1，ans + 1 = 6，next[1] = 0 next[4] = 2，ans + 1 = 7，next[2] = 0 next[5] = 3，ans + 1 = 8，next[3] = 1，ans + 1 = 9
首先，我们不是很关心nxt[i]具体的值，只关心nxt[i]是否大于0.如果大于0，比如对于nxt[3]==1，说明字符串0..2位置中，存在一个后缀和前缀相等，因此答案+1.
其次，其实我们仍然关心nxt[i]具体的值，对于nxt[5]==3，具体对应的含义是有后缀“aba”和前缀“aba”相等
但是这就完了吗？因为nxt[3]仍然大于0，对应“aba&amp;quot;中有一个前缀”a“和后者”a“相等。。。你可能要问。。这个不是刚刚算过了吗。。。然而这里其实算的是字符串2..4的”aba&amp;quot;。
看到有人说这是dp...不是很懂dp做法是什么鬼。。。
忘记取模wa了一发。。智力-2.
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 12时59分12秒 File Name :code/hdu/3336.</description></item><item><title>hdu 2594 Simpsons’ Hidden Talent (kmp)</title><link>https://111qqz.com/2016/08/hdu-2594/</link><pubDate>Thu, 11 Aug 2016 17:40:49 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2594/</guid><description>
hdu 2594 题目链接
题意：given string s1,s2, find the longest prefix of s1 that is a suffix of s2.
思路：kmp。。。懒得说了。注意边界。
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 01时12分51秒 File Name :code/hdu/2594.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; char a[N],b[N]; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0; int j = 0; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } if (i==n) return j; return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>一点感受，其实你并没有那么弱</title><link>https://111qqz.com/2016/08/</link><pubDate>Thu, 11 Aug 2016 17:15:25 +0000</pubDate><guid>https://111qqz.com/2016/08/</guid><description>
* 很多题毫无思路，真的只是见过的套路太少，如果知道套路，瞬间成水题。 * 很多算法觉得难懂，九成原因是看到的资料不够好或者不够适合你。</description></item><item><title>hdu 2203 亲和串 (kmp)</title><link>https://111qqz.com/2016/08/hdu2203/</link><pubDate>Thu, 11 Aug 2016 17:11:48 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu2203/</guid><description>
hdu 2203 题目链接 题意：给定字符串A（一个环），和字符串B，问B是否在A中出现过。
思路：环的问题。。复制一遍到末尾就好了。。出于严谨的考虑。。我们只复制n-1个字符。
以及要记得判断文本串的长度是否大于等于模板串，如果小于，直接判断no//然而题目数据太水，没判也过了
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 00时56分28秒 File Name :code/hdu/2203.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N],b[N]; int n; int nxt[N]; void getnxt(char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } bool kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0; int j = 0 ; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) return true; } return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3746 Cyclic Nacklace (最小覆盖子串，kmp)</title><link>https://111qqz.com/2016/08/hdu-3746/</link><pubDate>Thu, 11 Aug 2016 16:53:06 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3746/</guid><description>
hdu 3746题目链接 题意：给定一个字符串，是一个环（首尾相连），问至少再添加多少个珠子才能使得整个串是循环的。。。
思路：一下子想到了最小覆盖子串的模型。。。我求出最小覆盖子串的长度（n-nxt[n]）。然后特判下最小覆盖子串的长度等于字符串长度的情况。。。试着叫了一发。。。竟然就A了2333.。。大概是所谓的题感吧（逃
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 00时41分19秒 File Name :code/hdu/3746.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N]; int n; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5763 || 2016 multi #4 1001 Another Meaning (kmp+dp)</title><link>https://111qqz.com/2016/08/hdu-5763/</link><pubDate>Thu, 11 Aug 2016 15:41:57 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5763/</guid><description>
hdu 5763 题目链接
题意：给定两个字符串A和B，每个出现在A中的B(可以overlap)都有两种含义，问A串一共可能有多少种含义。
思路：kmp+dp.
考虑dp[i]为前i个字符（也就是从开始长度为i，注意不是字符串的下标为i）的含义数。
我们考虑第i个字符对其他位置字符的贡献。
首先第i位的含义数可以无条件得转移到i+1位。也就是dp[i+1]+=dp[i];
此外，如果第i位是一个B串开始的位置，那么第i位对i+len2位就有贡献。也就是dp[i+len2]+=dp[i];
初始化dp[0]=1，其他为0.
剩下我们要做的就是处理出A串中的哪些位置是B串开始的位置。
kmp处理下就好，用一个布尔数组标记。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 11时07分24秒 File Name :code/hdu/5763.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD = 1E9+7; const int N=1E5+7; int nxt[N]; char a[N],b[N]; bool v[N]; int dp[N]; void getnxt(char *s) { int i = 0; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } void kmp( char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0 ; int j = 0 ; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) { v[i-m] = true;//长度为i的位置的下标是i-1,开始的位置是（i-1）+m+1,也就是i-m // cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; i-m:&amp;quot;&amp;lt;&amp;lt;i-m&amp;lt;&amp;lt;endl; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1867 A + B for you again （kmp，最短的字符串a+b）</title><link>https://111qqz.com/2016/08/hdu-1867/</link><pubDate>Wed, 10 Aug 2016 22:03:19 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1867/</guid><description>
hdu 1867 题意 题意：给两个字符串，将两个字符串首尾拼接之后得到一个长度最短的字符串，求这个最短的字符串（一个串的前缀可能是另一个串的后缀，这样的话只出现一次就行了）
思路：kmp。。注意和hdu 1841区分。那道题是只要得到一个串包含两个串即可。这道题是首尾拼接得到。
还要注意。。这道题要求了长度相同时按照字典序小的方法拼接。。。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 05时08分32秒 File Name :code/hdu/1867.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N],b[N]; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i] = ++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); int i = 0; int j = 0; getnxt(b); while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;m) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } if (i==n) //因为要保证，两个串是首尾拼接得到的，这样子必须是文本串的后缀和模式串的前缀相等。这是和hdu 1841的不同。 return j; return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1841 Find the Shortest Common Superstring (kmp)</title><link>https://111qqz.com/2016/08/hdu1841/</link><pubDate>Wed, 10 Aug 2016 20:48:04 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu1841/</guid><description>
hdu 1841题目链接 题意：给两个字符串，问包含这两个字符串的最小的字符串的长度（最小是因为，一个串的子串可能是另一个串的后缀，这样出现一次就可以了）
思路：其实这道题最关键的思想部分是和kmp没有关系的。。。
我们考虑最naive的匹配方式。
如果存在文本串的子串（之前写成了后缀，特此更正，不一定是首尾拼接，这是和hdu 1867的区别）等于模式串的前缀，那么这段子串或者后缀的长度为最后的j。
两个串各做一次模式串和文本串。
不过暴力匹配复杂度爆炸，所以用了kmp。。。
upd:代码新添加了注释。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 04时32分08秒 File Name :code/hdu/r1841.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; char a[N],b[N]; int nxt[N]; void getnxt(char *s) { int i = 0; int j = -1; int n = strlen(s); nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0 ; int j = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;m) //由于不一定哪个是模式串，所以要记得判边界j&amp;lt;m,因为这个而wa了一发 { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } return j; //这道题只要求得到一个串同时包含这两个字符串，不是首尾拼接也可以，所以不用判断文本串是否为后缀（i==n) return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1358 Period (kmp，求字符串的周期)</title><link>https://111qqz.com/2016/08/hdu-1358-period-kmp/</link><pubDate>Wed, 10 Aug 2016 19:41:13 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1358-period-kmp/</guid><description>
hdu 1358 题目链接
题意：给一个字符串，求这个字符串的每个前缀（包括本身）的能否由k个子串组成（K&amp;gt;1）
思路：和poj 2406 比较类似。。
结论：字符编号从0开始，如果又i%(i-next[i])==0，则i前面的 串为一个轮回串，其中轮回子串出现i/(i-next[i])次。
证明类似之前最小覆盖中的，不断的等价交换，两两相等...（这个证明在字符串这里总是遇到2333）
然而其实我。。。做的时候。。并没有想到去证明。。。而是打印出了nxt数组然后找规律求得2333.
之前一直觉得找规律不是什么拿的上台面的做法。。。但是今年打了几场多校。。尤其是电子科大的那场。。。我发现。。。其实有的题目的正解就是找规律，猜结论。。。
&amp;amp;nbs;
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 03时20分44秒 File Name :code/hdu/1358.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int nxt[N]; char a[N]; int n ; void getnxt( char *s) { int i = 0 ; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==a[j]) nxt[++i]=++j; else j = nxt[j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2087 剪花布条 (kmp，不允许重叠的匹配)</title><link>https://111qqz.com/2016/08/hdu-2087/</link><pubDate>Wed, 10 Aug 2016 19:13:51 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2087/</guid><description>
hdu 2087 题目链接
题意：问模式串在文本串中出现的次数，不允许重叠。
思路：kmp，关键在于不允许重叠。。。
其实只要每次找到的时候j=0一下就好咯。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 02时52分44秒 File Name :code/hdu/2087.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; char a[N],b[N]; int nxt[N]; void getnxt(char *s) { int i = 0; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0; int j = 0; int cnt = 0 ; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j=nxt[j]; if (j==m) { cnt++; j=0; //不允许重叠 } } return cnt; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1711 Number Sequence (kmp)</title><link>https://111qqz.com/2016/08/hdu1711/</link><pubDate>Wed, 10 Aug 2016 18:52:00 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu1711/</guid><description>
hdu 1711 题目链接
题意：给定两个数列，问第二个数列在第一个数列中出现的位置（第一个元素对应的位置）
思路：数列也可以看成字符串，然后左kmp，返回的答案是i+1-m。。。1A
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 02时30分23秒 File Name :code/hdu/1711.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; const int M=1E4+7; int a[N]; int b[M]; int nxt[M]; int n,m; void getnxt(int n) { int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||b[i]==b[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp( int n,int m) { getnxt(m); int i = 0; int j = 0; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) return i+1-m; } return -1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3080 Blue Jeans (n个字符串的最长公共子串，暴力+kmp)</title><link>https://111qqz.com/2016/08/poj-3080/</link><pubDate>Wed, 10 Aug 2016 17:54:27 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3080/</guid><description>
poj 3080 题目链接
题意：给出n个字符串（n&amp;lt;=10），字符串长度不超过70，问出现在全部n个字符串中的最长并且字典序最小的长度大于等于3的子串。
思路：数据范围很小。。。直接暴力枚举+kmp匹配一下。。。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 01时29分02秒 File Name :code/poj/3080.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=70; int nxt[N]; string dna[15]; int n ; void getnxt( string a) { int i = 0 ; int j = -1; int n = a.</description></item><item><title>poj 2185 Milking Grid (最小覆盖子矩形，kmp)</title><link>https://111qqz.com/2016/08/poj-2185/</link><pubDate>Wed, 10 Aug 2016 16:54:11 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2185/</guid><description>
poj 2185 题目链接
题意：给出一个字符矩形，问一个面积最小的矩形，覆盖掉整个矩形。大概就是二维的最小覆盖子串。
思路：对于每一行做最小覆盖子串，然后求lcm，每一列也是如此。最后记得判断不能超过原有的n,m。
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 23时46分47秒 File Name :code/poj/2185.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char s[N][80]; int n,m; int nxt[N]; void getrownxt(int row,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[row][i]==s[row][j]) nxt[++i]=++j; else j = nxt[j]; } void getcolnxt(int col,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i][col]==s[j][col]) nxt[++i]=++j; else j = nxt[j]; } int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } int lcm(int a,int b) { return a/gcd(a,b)*b; //蒟蒻的自我修养 } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>KMP与最小覆盖子串</title><link>https://111qqz.com/2016/08/kmp/</link><pubDate>Wed, 10 Aug 2016 16:28:58 +0000</pubDate><guid>https://111qqz.com/2016/08/kmp/</guid><description>
参考资料（本文大部分是参考这篇博客，附带一些证明步骤的解释） 首先明确一些概念： 最小覆盖子串：对于某个字符串s，它的最小覆盖子串指的是长度最小的子串p，p满足通过自身的多次连接得到q，最后能够使s成为q的子串。 比如： 对于s=&amp;quot;abcab&amp;quot;，它的最小覆盖子串p=&amp;quot;abc&amp;quot;，因为p通过在它后面再接上一个p（即重叠0个字符），可以得到q=&amp;quot;abcabc&amp;quot;，此时s是q的子串。 对于s=&amp;quot;ababab&amp;quot;，它的最小覆盖子串为p=&amp;quot;ab&amp;quot;。
pre[i]（或next[i]）的实质是串str[1..i]的最长且小于i的“相等前、后缀”分别为str[1..pre[i]]（前缀）与str[(i-pre[i]+1)..i]（后缀），通俗讲就是：使str[1..i]前k个字母与后k个字母相等的最大k值。
结论先行：最小覆盖子串（串尾多一小段时，用前缀覆盖）长度为n-next[n]（n-pre[n]），其中n为串长，串的最后一位为为s[n-1].
证明分两部分：
１－长为n-next[n]的前缀必为覆盖子串。
当next[n]&amp;lt;n-next[n]时，如图a，长为next[n]的前缀A与长为next[n]的后缀B相等，故长为n-next[n]的前缀C必覆盖后缀B；
当next[n]&amp;gt;n-next[n]时，如图b，将原串X向后移n-next[n]个单位得到Y串，根据next的定义，知长为next[n]的后缀串A与长为前缀串B相等，X串中的长为n-next[n]的前缀C与Y串中的前缀D相等，而X串中的串E又与Y串中的D相等……可见X串中的长为n-next[n]的前缀C可覆盖全串（其实是一个不断的等价交换的过程，用同样的方法可以证明每两个相邻的相等，所以可以覆盖全串）
２－长为n-next[n]的前缀是最短的。
如图c，串A是长为n-next[n]的前缀，串B是长为next[n]的后缀，假设存在长度小于n-next[n]的前缀C能覆盖全串，则将原串X截去前面一段C，得到新串Ｙ，则Ｙ必与原串长度大于next[n]的前缀相等，与next数组的定义（使str[1..i]前k个字母与后k个字母相等的最大k值。）矛盾。得证！有人问，为什么Ｙ与原串长大于next[n]的前缀相等？由假设知原串的构成必为CCC……E（E为C的前缀），串Ｙ的构成必为CC……E（比原串少一个Ｃ），懂了吧！</description></item><item><title>poj 2752 Seek the Name, Seek the Fame (kmp 理解nxt函数)</title><link>https://111qqz.com/2016/08/poj-2752/</link><pubDate>Wed, 10 Aug 2016 13:25:59 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2752/</guid><description>
poj 2752题目链接
题意：求出所有的前缀和后缀相同的子串的长度。
思路:求出nxt函数，观察发现，从从len递归向前就是答案。
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 21时05分52秒 File Name :code/poj/2752.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E6+7; int n; string a; int nxt[N]; void getnxt( int n) { int i = 0 ; int j = -1 ; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||a[i]==a[j]) nxt[++i]=++j; else j = nxt[j]; } void print( int x) { if (nxt[x]!</description></item><item><title>hdu 1686 Oulipo (kmp模板题)</title><link>https://111qqz.com/2016/08/hdu1686/</link><pubDate>Wed, 10 Aug 2016 12:38:43 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu1686/</guid><description>
hdu1686
题意：给出模式串和文本串，问模式串在文本串中出现了多少次，可以overlap.
思路：思考naive的匹配过程。nxt函数不过是改进了当失配发生时，不是移动1位，而是移动多位。nxt函数的含义是当失配发生时，移动到的位置....所以有的教程管这个叫失配函数吧，也不是很难理解的样子。
学会kmp之后的第一道kmp，嘿嘿嘿（是的，poj2406的时候我并不会kmp 2333)
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 20时02分33秒 File Name :code/hdu/1686.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; string a,b; int ans; int nxt[N]; void getnxt( int n) { int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||b[i]==b[j]) nxt[++i]=++j; else j = nxt[j]; } void kmp( int n,int m) { int i = 0 ; int j = 0 ; getnxt(m); // for ( int i = 0 ; i &amp;lt; m ; i++) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;nxt[i]&amp;lt;&amp;lt;endl; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) ans++,j=nxt[j]; // cout&amp;lt;&amp;lt;&amp;quot;n:&amp;quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&amp;quot; i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; j:&amp;quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>2016七夕，关于爱情的随想</title><link>https://111qqz.com/2016/08/2016-Tanabata/</link><pubDate>Tue, 09 Aug 2016 11:48:00 +0000</pubDate><guid>https://111qqz.com/2016/08/2016-Tanabata/</guid><description>
其实一个妹子身上，最让人着迷的，是对生活的态度吧。 ** 过了好久我终于领悟到这点。**</description></item><item><title>KMP算法学习</title><link>https://111qqz.com/2016/08/kmp-notes/</link><pubDate>Mon, 08 Aug 2016 11:26:45 +0000</pubDate><guid>https://111qqz.com/2016/08/kmp-notes/</guid><description>
20170801update:当时竟然没有强调next函数的含义？
next[i]的含义是,i之前的整个前缀中，最长的该前缀的前缀和后缀相同的长度。
看图：
KMP感觉是我学到现在最难懂的一个算法了QAQ 为什么你们都那么强啊，看几个小时就看懂了...
先放一波我觉得值得看的资料： kmp算法讲解（配图比较全....） kmp学习资料2
说下我对kmp算法的理解：
理解kmp算法大概分成两个部分。
一部分是理解一个naive的kmp算法，可以叫&amp;quot;fast slide&amp;quot; algorithm
思想大概就是，当mismatch发生时，我们并不是一无所有，而是知道在mismatch发生前所匹配的字符的信息的。
然后知道这些信息我们可以做什么呢？
先观察一下最最暴力的求解字符串匹配的算法：
//*********************************************************** //brute force n = T.length(); m = P.length(); i0 = 0; // Line P up with the first character of T i = 0; // Start matching with first char in T j = 0; // Start matching with first char in P while ( i &amp;lt; n ) // Not all characters used { if ( T[i] == P[j] ) { /* =============================================== T[i] and P[j] match ==&amp;gt; try next pair =============================================== */ i++; // Match next pair j++; if ( j == m ) return ( i0 ); // Match found at position i0 !</description></item><item><title>whust 2016 #1 D Zhenya moves from the dormitory (贪心，模拟)</title><link>https://111qqz.com/2016/08/whust-2016-1-d-zhenya-moves-from-the-dormitory-/</link><pubDate>Sun, 07 Aug 2016 17:32:21 +0000</pubDate><guid>https://111qqz.com/2016/08/whust-2016-1-d-zhenya-moves-from-the-dormitory-/</guid><description>
题目链接 傻逼模拟。。读完题就ac了。。。
/* *********************************************** Author :111qqz Created Time :2016年08月07日 星期日 18时04分18秒 File Name :code/whust2016/#1/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=280; int n,m; int total,adva,advb; struct Friend { int money; int adv; }f[N]; struct Room { int type; int cost; int adv; }r[N]; struct Ans { int val; int rid; int fid; bool operator &amp;lt; (Ans b)const { return val&amp;gt;b.</description></item><item><title>whust 2016 #1 H - Pair: normal and paranormal</title><link>https://111qqz.com/2016/08/whust-2016-1-h-pair-normal-and-paranormal/</link><pubDate>Sun, 07 Aug 2016 17:29:31 +0000</pubDate><guid>https://111qqz.com/2016/08/whust-2016-1-h-pair-normal-and-paranormal/</guid><description>
题目链接
其实就是括号匹配的模型。。用栈即可。。被我写挂好几发。。该死该死。。。
/* *********************************************** Author :111qqz Created Time :2016年08月07日 星期日 17时34分13秒 File Name :code/whust2016/#1/HH.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;cctype&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char st[N]; int s[N]; int n; int plow[N]; int pup[N]; int ans[N]; stack&amp;lt;int&amp;gt;stk; bool ok(int x, int y) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; if (plow[x]&amp;gt;0&amp;amp;&amp;amp;pup[y]&amp;gt;0) { ans[pup[y]] = plow[x]; return true; } if (plow[y]&amp;gt;0&amp;amp;&amp;amp;pup[x]&amp;gt;0) { ans[pup[x]] = plow[y]; return true; } return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3415 Max Sum of Max-K-sub-sequence (单调队列)</title><link>https://111qqz.com/2016/08/hdu-3415/</link><pubDate>Fri, 05 Aug 2016 12:32:50 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3415/</guid><description>
hdu 3415 题意：给出n个整数，是一个环（也就是a[n]右边是a[1]）求一段长度不超过k的数使得和最大，问最大和是多少并给出这段数的位置。
思路：为了处理环，先把n个数复制一下就好，然后求前缀和sum[i]
由于区间[l,r]的和可以用前缀和表示为sum[r]-sum[l-1]
因此在区间长度小于等于k的前提下，我要求sum[r]-sum[l-1]的最大值，如果我们考虑把端点r固定，那么就是要求[l-1,r-1]中的sum的最小值。
因此我们考虑用单调队列来维护sum[i-k]到sum[i-1]的最小值。
我们的做法是：枚举区间右端点i，同时用单调队列维护i之前的k个数[i-k,i-1]的最小值。
由于要求“If there are more than one result, output the minimum start position, if still more than one , output the minimum length of them.”，因此从后面出队的判断条件是严格的sum[dq.back()]&amp;gt;sum[i-1]
/* *********************************************** Author :111qqz Created Time :2016年08月05日 星期五 18时02分36秒 File Name :code/hdu/3415.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N],sum[N]; int n,k; int on; deque&amp;lt;int&amp;gt;dq; inline bool read(int &amp;amp;num) { char in; bool ISN = false; in=getchar(); if (in==EOF) return false; while (in!</description></item><item><title>ural 1126. Magnetic Storms (单调队列模板题)</title><link>https://111qqz.com/2016/08/ural1126/</link><pubDate>Thu, 04 Aug 2016 16:04:14 +0000</pubDate><guid>https://111qqz.com/2016/08/ural1126/</guid><description>
ural 1126 题意：n个数，求从第k个元素开始，求每k个元素的最大值（一共求n-k+1次） 思路：单调队列。 单调队列学习链接 其实单调队列挺容易的理解的。。。当时觉得写不明白大概是因为看到的代码写得太丑了2333
说下我的理解：
单调队列的尾端（就是后进入元素的那一端）其实和单调栈类似。
首端加了个元素期限的概念，不断删除“过期”的元素。
所谓过期的元素，对于这道题来说，当我往前移动到第k+1个元素的时候，第1个元素就是过期了的元素，堆答案不会再有贡献。
理论上单调队列中的元素是&amp;lt;元素的期限，元素&amp;gt;的二元组。
而一般元素的&amp;quot;期限&amp;quot;是由下标的位置决定的，而得到下标就可以知道元素。
所以我们实际操作的时候只需要将下标存入单调队列中就行了。
那么查询最大值呢？ 队首元素就是最大值。
以及，用到了stl的双端队列deque(double end queue)，头文件是#include
由于每次的答案是队首元素，因此设置哨兵而使得队列不为空就使得问题变得繁琐。
所以这里不同于单调栈的写法，我们不设置哨兵，而是.empty()判断双端队列是否为空。
也正是因为这个原因，没有办法像单调栈一样写成for的样子（因为没有哨兵，初始x=dq.front()的时候可能dp中还没有元素，导致RE），而是写成while的样子。。具体见代码。
/* *********************************************** Author :111qqz Created Time :2016年08月04日 星期四 23时08分34秒 File Name :code/ural/1126.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;deque&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E4+7; int a[N]; int f[N]; int n,k; deque&amp;lt;int&amp;gt;dq; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1559 最大子矩阵 (二维前缀和)</title><link>https://111qqz.com/2016/08/hdu-1559/</link><pubDate>Wed, 03 Aug 2016 13:19:58 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1559/</guid><description>
hdu 1559
题意：给你一个m×n的整数矩阵，在上面找一个x×y的子矩阵，使子矩阵中所有元素的和最大。
思路：二维前缀和就好。。。和单调栈没有半毛钱关系吧。。。
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 21时08分18秒 File Name :code/hdu/1559.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int a[N][N]; int sum[N][N]; int n,m,x,y; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3494 Largest Submatrix of All 1’s (单调栈)</title><link>https://111qqz.com/2016/08/poj-3494/</link><pubDate>Wed, 03 Aug 2016 12:02:59 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3494/</guid><description>
poj 3494
题意：给出一个n*m个0-1图，求最大的全部由1组成的矩阵。
思路：同poj 1964,一共做n+2×m次单调栈。。。数组开小re一发。。某处stk忘记清空re 1发。。。智力-2.。。3A
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 19时33分14秒 File Name :code/poj/3494.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+50; int maze[N][N]; int a[N][N],l[N][N],r[N][N]; stack&amp;lt;int&amp;gt;stk; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2796 Feel Good (前缀和，单调栈)</title><link>https://111qqz.com/2016/08/poj-2796/</link><pubDate>Wed, 03 Aug 2016 11:30:56 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2796/</guid><description>
poj 2796
题意：给出一个人n（1E5）天的情绪值（0..1E6），一段时间的value的定义是这段时间的情绪之和*这段时间情绪的最小值。
现在求value的最大值，并且输出得到这个最大值的区间。
思路：单调栈。 考虑把每一天作为最小值的时候能向左向由延伸的最远的点的下标，两个方向各做一次单调栈来预处理。和的haunted前缀和搞下。。
然后最后想着了LL,但是读入的时候前缀和的那里忘了LL wa了一发。。。2A
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 19时14分42秒 File Name :code/poj/2796.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; LL sum[N]; int l[N],r[N]; stack&amp;lt;int&amp;gt;stk; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2082 Terrible Sets (前缀和，单调栈)</title><link>https://111qqz.com/2016/08/po2082/</link><pubDate>Wed, 03 Aug 2016 11:07:24 +0000</pubDate><guid>https://111qqz.com/2016/08/po2082/</guid><description>
poj 2082 题目链接
题意：这道题简直就是。。。教给大家怎么把一句话把简单的题让人出得看不懂。。。真的一点意思都没有。给出n个矩形的宽度和高度，这些矩形并排顺次排列在x轴上，问最大面积。
思路：单调栈。 之前的最大矩形面积的宽度都是1.。这次不是1.。做个宽度的前缀和就好。。。1A
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 18时54分40秒 File Name :code/poj/2082.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; pi a[N]; int l[N],r[N]; int sum[N]; int n; stack&amp;lt;int&amp;gt;stk; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1964 City Game(单调栈，输入挂)</title><link>https://111qqz.com/2016/08/poj-1964/</link><pubDate>Wed, 03 Aug 2016 10:42:29 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1964/</guid><description>
poj 1964
题意：n*m的maze,由'R'和‘F’组成，现在要求找到面积最大的矩形，使得矩形中所有格子都是'F'。
思路：单调栈...一开始神tm tle....复杂度没问题啊。。。
结果看到有人说这题由于数据量比较大。。。scanf会超时。。。所以要用输入挂。。。。。getchar什么的。。。
poj竟然也卡读入。。。人性呢。。。。
改了输出以后再交wa了。
发现想错了，我是写了从(i,j)到两个方向能到的最大距离。。但是这样写有些点上的情况是没有考虑到的。。比如如果(i+1,j+1)上的点是'R'，实际上是不可以构成l*r的矩形的(l&amp;gt;=2&amp;amp;r&amp;gt;=2)。。。但是我这样做无法体现。
改了下，变成：
仍然对于每行做一次单调栈，预处理出点(i,j)能往右的最远距离a[i][j]。
然后观察一下。。。如果我把每一列分别看成x轴，那a[i][j]不就是矩形的高度了吗。。。
那我要求的不又变成了最大矩形面积了吗。。。
于是接下来对于每一列，做上下两个方向的单调栈得到（i,j）上下能延伸到的最远距离。
(i,j)点所在的矩形面积就是** (r[i][j]-l[i][j]+1)a[i][j];*
再交，A了
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 05时55分30秒 File Name :code/poj/1964.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; char maze[N][N]; int row[N][N],col[N][N]; int a[N][N]; int l[N][N],r[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3250 Bad Hair Day(单调栈)</title><link>https://111qqz.com/2016/08/poj-3250/</link><pubDate>Tue, 02 Aug 2016 21:40:50 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3250/</guid><description>
poj 3250
题意：
n头牛排成一列，第n只牛在最前面，第1只牛在最后面。第i只牛能看到的牛的个数是，它前面的且没有被其他牛遮挡的牛的个数，遮挡的条件是高度大于或者相同。现在问所有牛能看到的牛的个数的和。
思路：单调栈。具体见代码。1A.
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 05时12分47秒 File Name :code/poj/3250.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=8E4+7; int a[N]; int c[N]; stack&amp;lt;int&amp;gt;stk; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2559 Largest Rectangle in a Histogram (单调栈)</title><link>https://111qqz.com/2016/08/poj-2559/</link><pubDate>Tue, 02 Aug 2016 21:09:28 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2559/</guid><description>
poj 2559
题意：给定从左到右多个矩形，已知这此矩形的宽度都为1，长度不完全相等。这些矩形相连排成一排，求在这些矩形包括的范围内能得到的面积最大的矩形，求该面积。所求矩形可以横跨多个矩形，但不能超出原有矩形所确定的范围。
思路：单调栈。。。好久没写了，感觉之前一直也没有完全掌握单调栈的技巧。这回一定要掌握。
对于这道题，我们对于每个位置i，用两个单调栈维护出最左边和最右边最远能到达的位置。然后扫一遍更新最大值。
单调栈部分我用了stl 的stack
细节见注释
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 04时27分31秒 File Name :code/poj/2559.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;stack&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int l[N],r[N]; stack&amp;lt;int&amp;gt;stk; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 123 D. String　（后缀数组+两次二分得到区间＋rmq）</title><link>https://111qqz.com/2016/08/cf-123/</link><pubDate>Tue, 02 Aug 2016 15:23:55 +0000</pubDate><guid>https://111qqz.com/2016/08/cf-123/</guid><description>
题目链接
题意：定义一个函数F．．
For exampe: _F_(_babbabbababbab_, _babb_) = 6. The list of pairs is as follows: (1, 4), (4, 7), (9, 12)
Its continuous sequences are:
* (1, 4) * (4, 7) * (9, 12) * (1, 4), (4, 7) * (4, 7), (9, 12) * (1, 4), (4, 7), (9, 12) erfen
． erfen 题目描述得很烂．．看例子把．．大概就是：如果字符串y在字符串x中出现n次，那么F(x,y)=n*(n+1)/2
现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串．
思路：由于刚刚写了一个求一个字符串所有不同子串个数的题目．．．于是就想到了后缀数组．．．
写完之后观察height[i]．如果把height[i]看成底在x轴上的第i个矩形的高的话，n就是一段连续的矩形的长度．</description></item><item><title>poj 2406 Power Strings (后缀数组||kmp)</title><link>https://111qqz.com/2016/08/poj-2406/</link><pubDate>Tue, 02 Aug 2016 13:49:47 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2406/</guid><description>
poj 2406
题意:给定一个字符串 L,已知这个字符串是由某个字符串 S 重复 R 次而得到的, 求 R 的最大值
思路:论文题.
转载论文中的题解:
做法比较简单,穷举字符串 S 的长度 k,然后判断是否满足。判断的时候, 先看字符串 L 的长度能否被 k 整除,**再看 suffix(1)和 suffix(k+1)的最长公共** **前缀是否等于 n-k**。在询问最长公共前缀的时候,suffix(1)是固定的,所以 RMQ 问 题 没 有 必 要 做 所 有 的 预 处 理 , 只 需 求 出 height 数 组 中 的 每 一 个 数 到 height[rank[1]]之间的最小值即可。整个做法的时间复杂度为 O(n) 最关键的在加黑的那句话:看 suffix(1)和 suffix(k+1)的最长公共 前缀是否等于 n-k
why???
转载一段证明:
为什么这样就行了呢？这要充分考虑到后缀的性质。当lcp（1，k+1）=n-k时，后缀k+1是后缀1（即整个字符串）的一个前缀。（因为后缀k+1的长度为n-k）那么，后缀1的前k个字符必然和后缀k+1的前k个字符对应相同。**而后缀1的第k+1..2k个字符，又相当于后缀k+1的前k个字符，所以与后缀1的前k个字符对应相同，且和后缀k的k+1..2k又对应相同**。依次类推，只要lcp(1,k+1)=n-k,那么s[1..k]就可以通过自复制n/k次得到整个字符串。找出k的最小值，就可以得到n/k的最大值了。 虽然这道题不适合用后缀数组做,倍增会tle,dc3也是卡时间才能过,但是接触到了一个想法.
要看一个字符串s能否由一个较小的长度为k的字符串t重复若干次得到,除了要整除以外,
gengxin判断suffix(1)和 suffix(k+1)的最长公共****前缀是否等于 n-k即可.</description></item><item><title>spoj SUBST1 - New Distinct Substrings(后缀数组)</title><link>https://111qqz.com/2016/08/spoj-subst1-new-distinct-substrings/</link><pubDate>Tue, 02 Aug 2016 10:50:52 +0000</pubDate><guid>https://111qqz.com/2016/08/spoj-subst1-new-distinct-substrings/</guid><description>
题目连接
题意：求所有不同的子串个数。
思路：后缀数组。和上一道题一样，就是数据范围变成了 5E4...1A
/* *********************************************** Author :111qqz Created Time :2016年08月02日 星期二 18时32分28秒 File Name :code/spoj/subst1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; char s[N]; int sa[N],rk[N],t[N],t2[N],cnt[N],height[N]; int cmp (int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x=t,*y=t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n-k ; i &amp;lt; n ; i++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt;n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ;i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++ ) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>hdu 5787 K-wolf Number 2016 Multi-University Training Contest 5 1007 (不允许前导0的数位dp)</title><link>https://111qqz.com/2016/08/hdu-5787/</link><pubDate>Tue, 02 Aug 2016 09:39:08 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5787/</guid><description>
hdu5787
题意:给出l,r,k求区间[l,r]中满足任意相邻k个数字都不相同的数的个数.
思路:数位dp,dp[i][k1][k2][k3][k4]表示长度为i,前1位是k1,前2位是k2,前3位是k3,前4位是k4的方案数. 注意不允许前导0.2A
/* *********************************************** Author :111qqz Created Time :2016年08月02日 星期二 16时28分29秒 File Name :code/multi2016/#5/1007.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL l,r; int k; LL digit[25]; LL dp[22][11][11][11][11]; int LEN; LL dfs(int pos,int k1,int k2,int k3,int k4,bool limit,bool prehasnonzero) { if (pos==0) return 1; if (prehasnonzero&amp;amp;&amp;amp;!</description></item><item><title>spoj DISUBSTR - Distinct Substrings (统计字串个数，后缀数组)</title><link>https://111qqz.com/2016/08/spoj-disubstr/</link><pubDate>Sun, 31 Jul 2016 19:31:42 +0000</pubDate><guid>https://111qqz.com/2016/08/spoj-disubstr/</guid><description>
题目链接
题意：给出一个字符串，问所有不同的字串的个数。
思路：直接求比较困难。我们考虑，假如组成字符串的所有字符都不相同，那么就没有相同的字串，假设字符串的长度为n，那么长度为1的子串有n个，为2的有n-1个。。。为n的有1个，一共就是n*(n+1)/2个。。但是实际上会有重复的。。。
我们再次考虑这张图。
先找一个字符重复的个数，对应height[i]数组就是找height[i]大于等于1个的个数（因为x个height代表了x+1个后缀，保留1个，重复了x个，所以重复的个数恰好和符合条件的height数组对应）
接着找大于等于2的个数，大于等于3的个数...
最后再把所有答案累加起来，就是总共重复的次数。
然后按照我推出的这个结论，试着写了一发。。。1A蛤蛤蛤。。。
能想到这里大概是因为之前的题目让我得出了，“height数组是个小妖精”的结论,所以入手就先观察了一下height数组。。。
具体的实现呢，就是先统计height[i]中每个值出现的次数，然后做一个后缀和，最后累加。
/* *********************************************** Author :111qqz Created Time :2016年08月01日 星期一 02时43分19秒 File Name :code/spoj/disubstr.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n; char s[N]; int sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x = t,*y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i] += cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i ; for ( int k = 1 ; k &amp;lt;= n; k &amp;lt;&amp;lt;=1 ) { int p = 0 ; for ( int i = n-k ; i &amp;lt; n; i ++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 3261 Milk Patterns (最长公共子串，后缀数组)</title><link>https://111qqz.com/2016/08/poj-3261/</link><pubDate>Sun, 31 Jul 2016 18:18:04 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3261/</guid><description>
poj3261
题意：给一个字符串，要求找出至少出现k次的最长重复子串...
思路：后缀数组，然后再次用到了根据height数组对后缀进行分组的套路...二分判定合法性，对于当前的最长长度x,分组使得每组中的height[i]都大于等于x,所不同的是，判定变成了存在一个组，后缀的个数至少为k个（因为这样，就可以对于大于等于k个的后缀，同时取前x长度，得到的就是出现了至少k次且长度为x的前缀）1A,蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年08月01日 星期一 01时30分34秒 File Name :code/poj/3261.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; const int M=2E6+11; const int C = 5; int n,sa[N],rk[N],t[N],t2[N],cnt[M]; int height[N]; int s[N]; int k; int cmp(int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n-k ; i &amp;lt; n; i++) y[p++] = i ; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt;n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt;m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 1743 Musical Theme (不可重叠最长重复子串，后缀数组)</title><link>https://111qqz.com/2016/08/poj-1743-musical-theme-/</link><pubDate>Sun, 31 Jul 2016 16:38:25 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1743-musical-theme-/</guid><description>
poj 1743
题意：n个数字（1..88）表示的音符，问最长的连续两段长度至少为5的变化相同的音符段的长度。。。
思路：求最长重复字串。。。。很容易想到后缀数组。。但是这道题多了一个不可重叠的要求。
先二分答案,把题目变成判定性问题:判断是否 存在两个长度为 k 的子串是相同的,且不重叠。解决这个问题的关键还是利用 height 数组。把排序后的后缀分成若干组,其中每组的后缀之间的 height 值都 不小于 k。例如,字符串为“aabaaaab”,当 k=2 时,后缀分成了 4 组,如图 5 所示。
容易看出,有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然 后对于每组后缀,只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于 k。如果有一组满足,则说明存在,否则不存在。整个做法的时间复杂度为 O(nlogn)。**本题中利用 height 值对后缀进行分组的方法很常用,**请读者认真体 会。 这是论文中的题目。这个做法的确想不到，不过很好理解。
如果没有不允许重叠的条件就变成了求所有height[i]中的最大值，而每个height[i]对应的两个后缀的位置是sa[i]和sa[i-1]。
分组使得每组中的height[i]都大于等于k(那height[i]小于k的去哪里了？ 因为height[i]是由两个相邻的后缀得到的，如果某两个后缀的height[i]小于k,只需要将这两个后缀分成两组，这样这个height[i]就不存在了，从而保证了每组中的height[i]都大于等于k)
而我们知道，任意两个后缀的最长公共前缀是他们之间的所有height的最小值。因为对于处于同一组内的两个后缀来说，由于之前保证了每组中的height[i]&amp;gt;=k,也就是保证了任意两个后缀的最长公共前缀大于等于k.
因此用二分判定长度k的时候，这样分组以后，只需要再判断是否相交（也就是如果长度k不满足，可能是因为没有办法分组使得每个height都大于等于k,也可能是存在这样的分组，但是两个后缀相交）。
判断相交其实非常简单，sa[i]表示的是排名第i的后缀的开始位置，那么如果存在sa[j]-sa[i]&amp;gt;=k（其实是sa[i]+k-1&amp;lt;sa[j],sa[i]位置开始的后缀的长度为k的前缀的最后一个字符的所在位置sa[i]+k-1比sa[j]小，就说明不相交，由于是整数，就可以变成sa[i]+k&amp;lt;=sa[j]，也就是sa[j]-sa[i]&amp;gt;-=k）
而某一组内只要有一组i,j，满足sa[j]-sa[i]&amp;gt;=k就是有解，因此我们只需要判断最可能符合条件的一组，也就是找到一组中sa[i]的最大值和最小值，也正因为我们这样，我们在具体实现的过程中也没必要真的模拟分组的过程，只需要一直更新两个极值即可。
以及：lrj的板子是错的！！会re!!!! 已改正。
其他细节见代码注释
/* *********************************************** Author :111qqz Created Time :2016年07月31日 星期日 18时23分53秒 File Name :code/poj/1743.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; const int C=100; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r ,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} int a[N]; void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=a[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n-k ; i &amp;lt; n ; i++) y[p++] = i ; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i] +=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n; i ++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>ural 1517. Freedom of Choice (后缀数组，最长公共子串)</title><link>https://111qqz.com/2016/07/ural1517/</link><pubDate>Sat, 30 Jul 2016 17:18:19 +0000</pubDate><guid>https://111qqz.com/2016/07/ural1517/</guid><description>
ural1517 题意：给出两个字符串，求最长的公共字串（要求出具体的字符串是什么）
思路：依然是后缀数组，在更新长度 的时候记录起始位置即可，1A。以及，发现多开了一个完全没有必要的数组w[],这次已删。
20160730update:模板已更正，lrj的模板的rk[i]为0 的时候会出现re的问题...已特判。
/* *********************************************** Author :111qqz Created Time :2016年07月31日 星期日 00时36分19秒 File Name :code/ural/1517.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char s[N]; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r,int a,int b,int l) {return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x = t,*y= t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n - k ; i &amp;lt; n ; i++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 2774 Long Long Message (最长公共字串，后缀数组模板题)</title><link>https://111qqz.com/2016/07/poj-2774/</link><pubDate>Sat, 30 Jul 2016 16:02:42 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-2774/</guid><description>
poj2774
题意：给出两个字符串，问最长的公共连续字串。
思路：后缀数组模板题。
具体可以参考两篇国集论文（09，04） topcoder中的讲解 codechef上的讲解 还有一篇讲 dc3算法的论文：SuffixArrays_dc3 这里不谈具体的后缀数组的学习内容，说说大概的学习过程。
首先要理解**后缀，后缀数组（sa[]），名次数组(rk[])，height数组，lcp **这些概念
先从定义入手，得到sa数组的n2logn的求法...
由于复杂度爆炸，所以有了两个算法来优化求sa的过程，一个是nlogn的倍增，还有一个是O(n)的dc3。。。
倍增的算法中用到了radix sort
上面这些，都是在说如何求sa,但是如果只有sa一个数组的话，就没有办法很好感受 后缀数组的power.
于是引入了height数组。
**定义 height[i]=suffix(sa[i-1])和 suffix(sa[i])的最长公** **共前缀,也就是排名相邻的两个后缀的最长公共前缀。那么对于 j 和 k,不妨设** **rank[j]有很多问题都是基于height数组的，慢慢感受。
再说这道题：我们可以把两个字符串中间用一个特殊符号连接起来。
那么两个字符串的最长公共字串，就变成了求合并后的字符串的所有后缀的最长公共前缀。（原因是字符串的任何一个字串都可以看成是该字符串的某个后缀的前缀）
那么容易知道，该最长公共前缀的长度一定是某个height值（原因是，height[i]表示的是排名相邻的两个后缀的最长公共前缀的长度，如果不相邻，那么取的是他们排名之间所有height的最小值，只会越来越小。）
还需要注意的是，必须满足得到该height的两个后缀分别出现在原来的两个字符串中...
要怎么办到呢？ 其实很容易，由于sa[i]数组存放的是排名第i的后缀是后缀几(定义从第x个字符开始的后缀就是后缀x)
设初始第一个字符串的长度为len1,那么如果是第一个字符串的后缀，一定有sa[i]&amp;lt;len1,如果是第二个字符串的后缀，就一定有sa[i]&amp;gt;len1 (sa[i]==len1的是插入的特殊符号开始的后缀)
还有一些细节可以参考代码注释
UD20160730:改正了lrj书中的错误。。对于rk[i]==0的情况进行了特判。。不然会re...
/* *********************************************** Author :111qqz Created Time :2016年07月30日 星期六 20时58分10秒 File Name :code/poj/2774.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char s[N]; int sa[N],t[N],t2[N],cnt[N],n; int c[N]; int w[N]; int rk[N],height[N]; int cmp( int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l] ;}; void build_sa(int n,int m) //其实我觉得。。。sa怎么得到的不用管。。这部分讲道理不会变。。。反正知道能nlogn得到sa就对了2333 { int *x=t,*y=t2; // 基数排序（不是计数排序！） radix sort.</description></item><item><title>hdu 1280 前m大的数 （计数排序）</title><link>https://111qqz.com/2016/07/hdu-1280/</link><pubDate>Sat, 30 Jul 2016 10:13:30 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1280/</guid><description>
hdu1280
题意：给出n(3000)个数，两两求和，输出最大的m(5000)个和。
思路：由于数据有限，想到计数排序。。。以及，m个可能刚好某个数据没有全部输出，要在while里判断一下。。
。。。好好的人。。怎么开始刷水了。。。。。
其实是因为最近在看.suffix array...然后里面涉及到了radix sort..算法课的时候到是写过。。。不过快忘了orz。。所以打算找几道题目。。。？ 然而这是计数排序不是基数排序啊摔/！
/* *********************************************** Author :111qqz Created Time :2016年07月30日 星期六 17时58分04秒 File Name :code/hdu/1280.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3005; const int M=1E4+7; int n; int a[N]; int cnt[M]; int m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>suffix array (转自 codechef)</title><link>https://111qqz.com/2016/07/suffix_array_tutorial/</link><pubDate>Sat, 30 Jul 2016 09:12:57 +0000</pubDate><guid>https://111qqz.com/2016/07/suffix_array_tutorial/</guid><description>
原文链接：链接
讲了后缀数组的概念，然后从最暴力的O(nnlogn )的复杂度(O(n)用来比较字符串，O(nlogn)是排序的复杂度)逐步优化，依据各个串之间的关系，大概讲了倍增算法，以及给出了一篇The Skew Algorithm 的论文。
文中实现的倍增算法的复杂度是O（Nlog2N）的。。是因为作者不会基数排序23333。
This text will focus on the construction of Suffix Arrays, it will aim to explain what they are and what they are used for and hopefully some examples will be provided (it will be mainly simple applications so that the concepts don't get too attached to the theoretical explanation).
As usual, this follows my somewhat recent series of tutorials in order to make the reference post with links as complete as possible!</description></item><item><title>bzoj 1874: [BeiJing2009 WinterCamp]取石子游戏 (sg函数，要求输出第一步具体方案)</title><link>https://111qqz.com/2016/07/bzoj1874/</link><pubDate>Fri, 29 Jul 2016 16:19:48 +0000</pubDate><guid>https://111qqz.com/2016/07/bzoj1874/</guid><description>
1874: [BeiJing2009 WinterCamp]取石子游戏 Time Limit: 5 Sec Memory Limit: 162 MB Submit: 726 Solved: 296 [Submit][Status][Discuss]
Description 小H和小Z正在玩一个取石子游戏。 取石子游戏的规则是这样的，每个人每次可以从一堆石子中取出若干个石子，每次取石子的个数有限制，谁不能取石子时就会输掉游戏。 小H先进行操作，他想问你他是否有必胜策略，如果有，第一步如何取石子。
Input 输入文件的第一行为石子的堆数N 接下来N行，每行一个数Ai，表示每堆石子的个数 接下来一行为每次取石子个数的种类数M 接下来M行，每行一个数Bi，表示每次可以取的石子个数，输入保证这M个数按照递增顺序排列。
Output 输出文件第一行为“YES”或者“NO”，表示小H是否有必胜策略。 若结果为“YES”,则第二行包含两个数，第一个数表示从哪堆石子取，第二个数表示取多少个石子，若有多种答案，取第一个数最小的答案，若仍有多种答案，取第二个数最小的答案。
Sample Input 4 7 6 9 3 2 1 2
Sample Output YES 1 1Hint 样例中共有四堆石子，石子个数分别为7、6、9、3，每人每次可以从任何一堆石子中取出1个或者2个石子，小H有必胜策略，事实上只要从第一堆石子中取一个石子即可。
数据规模和约定 数据编号 N范围 Ai范围 数据编号 N范围 Ai范围 1 N=2 Ai≤10 6 N≤10 Ai≤10 2 N=2 Ai≤1000 7 N≤10 Ai≤100 3 N=3 Ai≤100 8 N≤10 Ai≤1000 4 N≤10 Ai≤4 9 N≤10 Ai≤1000 5 N≤10 Ai≤7 10 N≤10 Ai≤1000 对于全部数据，M≤10，Bi≤10</description></item><item><title>codeforces 429 B. Working out (dp)</title><link>https://111qqz.com/2016/07/cf429b/</link><pubDate>Wed, 27 Jul 2016 19:05:42 +0000</pubDate><guid>https://111qqz.com/2016/07/cf429b/</guid><description>
cf429 b 题目链接 题意：
n*m个格子，每个格子有一个人value a[i][j]&amp;gt;0，连个人，一个从左上角到右下角，每次只能向下或者向右移动，一个从左下到右上，每次只能向上或者向右移动，现在要求两个人恰好相遇一次，相遇点的a不算数，问在满足这样的条件下使得两个人的a最大。。。（很坑的一点是。。这里相遇并不考虑时间。。就是说，不在同一时间都到达过某一格子，也认为相遇。所以我认为，题目含义更准确的说法是，路径只有一个交点）
思路：很巧妙。先预处理4个二维数组，分别表示点(i,j）到四个角落的最大值。（这个处理很容易，类似数字三角形）
然后枚举相遇的点，对于确定的相遇的点(x,y)，我们可以认为是四个角落各连一条线到点(i,j)
由于只能相遇一次，所以连接方式只有两种情况。
/* *********************************************** Author :111qqz Created Time :2016年07月28日 星期四 02时13分58秒 File Name :code/cf/429B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; LL a[N][N]; LL dp[5][N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2050 折线分割平面 (找规律，递推)</title><link>https://111qqz.com/2016/07/hdu-2050/</link><pubDate>Wed, 27 Jul 2016 12:35:15 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2050/</guid><description>
hdu 2050题目链接
题意：n条折线。。最多能把平面分成几部分。。 思路：联想到m条直线，最多能把平面分成m*(m+1)/2+1部分。。
画图发现。。。 f[2*n-1]==g[n]。。
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 20时28分57秒 File Name :code/hdu/2050.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2049 不容易系列之(4)——考新郎 (错排公式，注意精度)</title><link>https://111qqz.com/2016/07/hdu-2049/</link><pubDate>Wed, 27 Jul 2016 12:06:46 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2049/</guid><description>
hdu 2049 题目链接 题意：n个妹子和n个汉子对应。。然后让每个汉子取选一个妹子，不能重复，问恰好有m个汉子选错妹子的可能的方案数。
思路：从n个中选n-m个，然后做剩余m个错排即可。
答案就是c[n][n-m]*d[m] c[]为组合数公式，d为错排公式。 然而wa到死。。。
因为我用了double....有毒。。。
double表示整数也是会丢失精度的！！！
double表示整数也是会丢失精度的！！！
double表示整数也是会丢失精度的！！！
double表示整数也是会丢失精度的！！！
double表示整数也是会丢失精度的！！！
我自杀去了，世界再见（x
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 16时39分21秒 File Name :code/hdu/2049.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=22; LL d[N]; LL c[N][N]; int n,m; void cal_c() { c[1][0] = 1; c[1][1] = 1; c[2][0] = 1; c[2][1] = 2; c[2][2] = 1; for ( int i = 1 ; i &amp;lt; N; i++) c[i][0] = 1; for ( int i = 3 ; i &amp;lt; N ; i++) for ( int j = 1 ; j &amp;lt;= i ;j++) c[i][j] = c[i-1][j]+c[i-1][j-1]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>解决fedora无线驱动在update后不能用的问题</title><link>https://111qqz.com/2016/07/fedoraupdate/</link><pubDate>Wed, 27 Jul 2016 11:14:42 +0000</pubDate><guid>https://111qqz.com/2016/07/fedoraupdate/</guid><description>
。。。重新编译一次就可以了。。。orz</description></item><item><title>hdu 2048 神、上帝以及老天爷 (错排公式)</title><link>https://111qqz.com/2016/07/hdu-2048/</link><pubDate>Wed, 27 Jul 2016 08:18:13 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2048/</guid><description>
hdu2048 题目链接
题意:n个人不放回的从一个有n个每个人对应id的卡片的盒子取一张卡片，取的正好和自己的对应就算中奖。求所有人都没有中奖的概率。
思路：错排。。。
复习了一下错排公式。。。d[n] = (n-1)*(d[n-1]+d[n-2]) （d[1]=0,d[2]=1）
然后求概率的时候。。惊讶得发现概率稳定在了36.79%（1/e）附近。。。
这是因为。。。错排还有一个公式：D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].
求概率每次把n!除掉了。。剩下的。。其实就是e的泰勒展开，当x=-1时的值。
因为当n越大时。。这个概率越接近1/e
这道题里。。。在保留百分数的小数点两位的精度的条件下。。当n为7的时候。。答案就已经是36.79保持不变了。。。
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 15时53分04秒 File Name :code/hdu/2048.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=22; double d[N]; double f[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2047 阿牛的EOF牛肉串 (递推)</title><link>https://111qqz.com/2016/07/hdu-2047/</link><pubDate>Wed, 27 Jul 2016 07:33:20 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2047/</guid><description>
hdu 2047 题目链接
题意：一个由'E' 'O' 'F' 组成的长度为n的字符串。‘O’不能相邻。。问方案数。。
思路：递推。。。蒙对了（误
考虑第n位，如果为'E'或者‘F’，此时对n-1位没有限制，答案为f[n-1]，所以 一共是2×f[n-1]
如果为'O'，此时第n-1位为'E'或者'F'，此时对n-2位没有限制，答案为f[n-2],一共是2×f[n-2]
因此 f[i] = 2*(f[i-1]+f[i-2])
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 15时22分19秒 File Name :code/hdu/2047.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=42; int n; LL f[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2045 不容易系列之(3)—— LELE的RPG难题 (递推)</title><link>https://111qqz.com/2016/07/hdu-2045/</link><pubDate>Wed, 27 Jul 2016 07:06:33 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2045/</guid><description>
hdu2045 题目链接
题意：
一串 方格，每个格子可以涂三种颜色，要求相邻的格子颜色不能相同，首尾格子也不能相同。
思路：递推。没推出来23333 我好菜啊.jpg.
考虑有n个格子。。那么假设第n-1个格子的颜色是a,根据第一个格子和第n-1个格子颜色是否相同分为两种情况。
如果不相同，那么第n个格子不能和第1个格子颜色相同，也不能和第n-1个格子颜色相同，所以只有一种选择。
如果相同，那么第n个格子有两种选择。
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 14时53分16秒 File Name :code/hdu/2045.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; LL f[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2018 母牛的故事 (基础dp，记忆化搜索)</title><link>https://111qqz.com/2016/07/hdu-2018/</link><pubDate>Wed, 27 Jul 2016 05:57:39 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2018/</guid><description>
hdu2018题目链接
题意:第1年有1头奶牛，每年生一头奶牛，新生的奶牛从生下来的第四年（包括生下来那年）也开始每年一头奶牛。 问第n年有多少头奶牛。 思路：最容易想到的。。递推一下。。。dp[i] = dp[i-1] + dp[i-3] (注意初始化不是一个dp[1]=1,而是dp[1..4]=1..4)
递推代码：
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 13时19分17秒 File Name :code/hdu/2018.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first a#define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=60; int n; LL dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2084 数塔 (基础dp)</title><link>https://111qqz.com/2016/07/hdu-2084/</link><pubDate>Wed, 27 Jul 2016 05:12:10 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2084/</guid><description>
hdu2084题目链接
题意：dp入门题。。。数字三角形。。
思路：
昨天看mit公开课。。。讲到dp的精髓是sub-problem+ reuse...
为什么自底向上呢。。。
初始化dp[n][i] = a[n][i]其实是在处理只有最后一行的子问题。。。
需要特别强调的是。。处于某个子问题的时候。。。其他部分就好像不存在一样。。。
每一个点只能向下或者向右下两条路可走。。。
那么对于这一点的最大值。。。一定是取后来可走的两点的最大值加上自身。。。
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 12时56分28秒 File Name :code/hdu/2084.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N][N]; int dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4283 You Are the One (区间dp)</title><link>https://111qqz.com/2016/07/hdu-4283/</link><pubDate>Tue, 26 Jul 2016 07:38:44 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-4283/</guid><description>
hdu 4283题目链接
题意：有N个人按顺序排成一排上台表演，每个都有一个num[]值，若在他是第k个上场的人，则会有num[]*(k-1)的unhappiness。台下有一个黑屋（stack），对每一个人，可以选择让他先进屋子或者直接上台。现在让你找到一个最优方案使得所有人的unhappiness之和最小。
思路：
我想对了的： 无。状态设计就错了。。。转移方程也就不可能对。。。
错的一塌糊涂。。。嗯。。基础题。。完全不会2333
参考题解：参考博客1 参考博客2
/* *********************************************** Author :111qqz Created Time :2016年07月26日 星期二 15时03分41秒 File Name :code/hdu/4283.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; int sum[N]; int dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3661 Running (区间dp)</title><link>https://111qqz.com/2016/07/poj-3661-running-dp/</link><pubDate>Mon, 25 Jul 2016 16:51:22 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-3661-running-dp/</guid><description>
poj 3661题目链接
题意：锻炼，一共n分钟，每分钟可以选择跑步或者休息，第i分钟跑步可以跑d[i]米，并增加一点疲劳度，如果选择休息，那么每分钟减少1点疲劳值。一旦开始休息，必须休息到疲劳值为0才能再次开始跑步。疲劳值不能超过m.第n分钟的时候疲劳值必须为0，否则之后会感觉身体被掏空。问n分钟最远多多远。
思路：
我能想到的： * dp[i][j]表示第i分钟疲劳度为j的时候能跑的最远距离 * 初始化dp为0. * 最后的答案为dp[n][0] * 如果第i分钟跑步，转移方程为dp[i][j] = max(dp[i][j],dp[i-1][j-1]+d[i]); 我想错了的： * 休息的时候的转移方程应该是第i天刚好**休息好**时：dp[i][0]=max(dp[i-j][j],dp[i][0]) 而不是**开始休息**时 * 由于是第i天休息好时的状态，那么开始休息的时间是固定的（第i-j天），只进行一个转移，而不会影响中间的那些天 我想的不够好的： * 考虑到了可能最后几天为了疲劳度为0干脆就不跑，我的做法是取了所有的dp[i][0]的最大值。但是更好的做法似乎是dp[i][0] = dp[i-1][0]转移一下。 参考博客：参考博客
参考题解：
分析：先设dp[i][j]表示小明在i分钟，疲劳值为j时所能走的最远距离。 a)、先看dp[i][0]的情况，表示第i分钟时，疲劳值为0，考虑这个值由哪些情况得到，1、dp[i][0] = dp[i-1][0]，这个没有任何问题。2、dp[i][0] = dp[i-j][j]。表示i-j分钟时的疲劳值为j，然后一直休息j分钟把疲劳值降成0。
b)、现在考虑dp[i][j]的情况，它可以由dp[i-1][j-1] + Di得到，表示第i分钟选择走Di。因为要保证没有后效性，所以只有这一种情况可以转移。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 23时42分26秒 File Name :code/poj/3661.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; const int M=505; int n; int m; int d[N]; int dp[N][M]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1651 Multiplication Puzzle (区间dp)</title><link>https://111qqz.com/2016/07/poj-1651/</link><pubDate>Mon, 25 Jul 2016 15:09:40 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-1651/</guid><description>
poj 1651题目链接
题意：n个数，删掉a[i]的得分是a[i]*a[i-1]*a[i+1]，两个端点的不允许删。问删完n-2个数得到的最小分数是多少。
思路：能想到设计状态dp[i][j]表示区间[i,j]的最小分数。然后就没思路了。 T T
参考了几篇题解，思路大概是，枚举最后剩下的那个数。
**对于一个区间(l, r),如果最后删除的是k位置的数的话，将得到a[l]*a[k]*a[r]分，而要得到这个情况的前提是吧区间(l, k) 和(k, r)的中间数字删掉所以的转移方程是** DP(l, r) = DP(l, k) + DP(k, r) + a[l]*a[k]*a[r];
以及。。。初始化又想错了。。。
要注意。。初始化可能没办法一次完成。。。这道题的初始化就是分情况的。。。
对于区间长度不够的。。初始化为0.。
区间长度为3的。。初始化为a[i]*a[i+1]*a[i+2]。。
其他的初始化为正无穷。。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 22时44分55秒 File Name :code/poj/1651.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; int dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3280 Cheapest Palindrome (区间dp)</title><link>https://111qqz.com/2016/07/poj-3280/</link><pubDate>Mon, 25 Jul 2016 13:26:14 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-3280/</guid><description>
poj 3280 题目链接
题意：一个字符串，给出添加一个字符或者删掉该字符的花费，问最小的话费使得字符串变成回文串。
思路：dp[i][j]表示区间[i,j]的字符串变成回文的最小花费。。。
这个可以想到。。dp[i][j] = dp[i+1][j-1] (a[i]==a[j])这个也可以想到。。。
增加和删除是等价的，所以取小的那个代价就行。。这个我也想到了。。
然后转移的地方没有特别明白。。。
和之前的找到一个划分的点k不同的是。。。
如果不等于。。
那么
, dp[i][j] = min(dp[i][j],dp[i+1][j]+cost[a[i]]); dp[i][j] = min(dp[i][j],dp[i][j-1]+cost[a[j]]); 这个方程可以理解。。。但是感觉自己想不出来 QAQ
以及。。我初始化写错了。。。
以为是求 最小值就初始化成了0x3f...
但是这样是错的。。。
具体见代码注释。。。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 19时42分19秒 File Name :code/poj/3280.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; char s[N]; int dp[N][N]; int n,len; int cost[N]; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>light oj 1422 - Halloween Costumes (区间dp)</title><link>https://111qqz.com/2016/07/light-oj-1422-halloween-costumes-dp/</link><pubDate>Mon, 25 Jul 2016 11:24:27 +0000</pubDate><guid>https://111qqz.com/2016/07/light-oj-1422-halloween-costumes-dp/</guid><description>
light oj 1422 题目链接
题意：
按顺序去参加舞会。每个舞会对衣服都有要求。可以连续穿好多件衣服。需要时候就脱下来，但是一旦脱下来，这件衣服就报废了。问最少需要几件衣服。
思路：没有思路。我连这题是dp都看不出来。。知道是dp也一点思路都没。。虽然这道题是道区间dp的入门题。。。但是不怕被鄙视。。我一点也没思路。。
参考了10多篇题解。。。终于懂了一点。。
参考博客1 参考博客2 参考博客3 参考博客4
**当a[i]和a[j]相等的时候 dp[i][j]=dp[i][j-1] 嗯，就这一个转移。然后就是区间dp的固定写法了。** 这句话让我恍然大悟。。。难道。。都是套路？
dp[i][j]表示的是[i,j]之间最少需要的衣服数量。
初始化dp[i][i] = 1，表示每天都换一件新衣服，显然不优。
a[i]==a[j]时，dp[i][j] = dp[i][j-1] ，表示第j天不用新换衣服，
然后枚举划分区间的点k,分成[i,k]和[k+1,j]两部分，取所有情况中最好的（这大概就是区间dp的套路？）
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 18时49分07秒 File Name :code/loj/1422.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int dp[N][N]; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1141 Brackets Sequence (区间dp,括号匹配，记录路径)</title><link>https://111qqz.com/2016/07/poj-1141/</link><pubDate>Mon, 25 Jul 2016 08:29:03 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-1141/</guid><description>
poj 1141题目链接
题意：给出一个括号序列，要求添加最少的括号，使得这个序列变成合法的括号匹配，输出最后的序列。
思路：区间dp。。。有了那么一点思路。。。我们可以用dp[i][j]表示区间[i,j]的序列最少需要添加几个符号使得匹配。。转移的话。。。和之前差不多。。dp[i][j] = dp[i+1][j-1] (s[i]与s[j])匹配。。。不匹配的话也是找中间某个点。。。初始化的话。。要变成最大值。。。比较没思路的是输出括号序列这部分。。。
参考了这篇题解：参考题解
记录路径的思路是。。。记录转移的点。。。
cut[i][j]表示的是区间[i,j]的最优值是由点cut[i][j]这里划分得到的。。。
cut[i][j]为-1表示区间[i,j]的最优值不是从中间分成两部分得到。。。
打印路径的时候。。。如果[i,j]的长度小于等于0.。直接return.
如果长度为1.。。直接输出。。。
如果长度大于1.。。。要分这段区间是否中间有划分两种情况。。具体见代码。。。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 15时55分47秒 File Name :code/poj/1141.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char s[105]; int dp[105][105]; //dp[i][j]表示区间[i,j]最少需要添加多少字符达到匹配。 int cut[105][105] ; //记录一段区间是在哪里断开最优，是为了记录路径，打印括号 bool check(char a,char b) { if (a=='['&amp;amp;&amp;amp;b==']') return true; if (a=='('&amp;amp;&amp;amp;b==')') return true; return false; } void print(int i ,int j) { if (i&amp;gt;j) return ; if (i==j) { if (s[i]=='('||s[i]==')') printf(&amp;quot;()&amp;quot;); if (s[i]=='['||s[i]==']') printf(&amp;quot;[]&amp;quot;); return ; } if (cut[i][j]==-1) { printf(&amp;quot;%c&amp;quot;,s[i]); print(i+1,j-1); printf(&amp;quot;%c&amp;quot;,s[j]); } else { print(i,cut[i][j]); print(cut[i][j]+1,j); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2955 Brackets（区间dp....括号匹配。。。人生第一道区间dp）</title><link>https://111qqz.com/2016/07/poj2955/</link><pubDate>Mon, 25 Jul 2016 07:46:23 +0000</pubDate><guid>https://111qqz.com/2016/07/poj2955/</guid><description>
poj2955题目链接
题意：给出若干括号，问最大匹配数是多少。
思路：没有思路。我知道这是dp。。。然后其他就什么都不知道了。。。转移方程？ 完全没思路。。知道了转移方程。。。。嗯，还是不会。。。边界怎么写？状态怎么推？循环顺序? 循环次序？我一点思路都没有。。。。。
人生中第一道区间dp(这话我都说了不知道多少次了。。。每次都学不会。。。。sad)
我的dp水平和其他部分的水平还真是不匹配。。。
看了题解。。。自己写（抄）了一遍。。还是觉得好玄学。。。
细节见代码。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 15时12分28秒 File Name :code/poj/2955.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; char st[N]; int dp[N][N]; bool check(char a,char b) { //cout&amp;lt;&amp;lt;&amp;quot;a:&amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; b:&amp;quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; if((a=='['&amp;amp;&amp;amp;b==']')||(a=='('&amp;amp;&amp;amp;b==')')) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3980 Paint Chain (sg函数，环形串取石子)</title><link>https://111qqz.com/2016/07/hdu-3980/</link><pubDate>Sat, 23 Jul 2016 08:50:39 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-3980/</guid><description>
hdu 3980 题目链接 题意：一个有n个石子的环形串，初始没有被涂颜色，两个人轮流，涂连续m个没有被涂色的石子，不能操作的人为负。问先手是否有必赢策略。
思路：和hdu2999很像。。所不同的是。。。那道题是线型的珠子。。。这道题是环型的数字。。。
然而我们机智得发现。。。环形的任意涂一次。。就变成了线型的啊orz。。。
所以先随便取一次，然后剩下的n-m个按照线型串的方法搞，划分区间即可。
由于先随便取了一次，所以和线型的交换输赢的结论。。。
以及。。要特判一次都不能取的情况。。。2A
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 15时53分18秒 File Name :code/hdu/3980.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; bool vis[N]; int sg[N]; void sg_init(int m) { ms(sg,0); for ( int i = 1 ; i &amp;lt; N ; i++) { ms(vis,false); int tmp = m; tmp = i-m; for ( int j = 0 ; tmp-j&amp;gt;=j ; j++) vis[sg[j]^sg[tmp-j]] = true; for ( int k = 0 ; ;k++) if (!</description></item><item><title>hdu 2999 Stone Game, Why are you always there? (sg函数，线性串取石子)</title><link>https://111qqz.com/2016/07/hdu-2999/</link><pubDate>Sat, 23 Jul 2016 07:48:00 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2999/</guid><description>
hdu2999题目链接
题意：有一串石子，给定一个集合S，每次只能拿连续x个石子，石子必须是在集合S中的数，问先手是否有必赢策略。需要注意石子的位置是不能变化的，也就是说如果一串连续的石子因为中间有石子被取走，那么这段石子就变成不连续的了，也就不能一次取走。
思路：一开始没有读懂题。需要特别强调的是。石子的位置是不能合并的。。
举个例子，如果我有5个石子，S={2},那么我取完一次剩下的情况是 {3,4,5}或者{1},{4,5}或者{1,2},{5}或者{1,2,3} 一共四种。
题意搞清楚以后就好做了。。类似于bomb game那道题。。我们仍然可以把取一次的操作拆分两个子过程，也就是两个区间。我们不关心区间具体的情况，只关心区间的长度。以及，取完只有一个区间的情况不需要特殊考虑，认为是长度为0就可以了，因为sg[0]为0，不影响答案。
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 15时02分17秒 File Name :code/hdu/2999.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2005; int sg[N]; bool vis[N]; set&amp;lt;int&amp;gt;ok; set&amp;lt;int&amp;gt;::iterator it ; int n; int q; void sg_init() { ms(sg,0); for ( int i = 1 ; i &amp;lt; N ; i++) { ms(vis,false); for ( it = ok.</description></item><item><title>hdu 2873 Bomb Game（Sg函数）</title><link>https://111qqz.com/2016/07/hdu-2873/</link><pubDate>Sat, 23 Jul 2016 06:57:10 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2873/</guid><description>
hdu 2873题目链接
题意：n*m个格子，有若干炸弹。对于在第一行或者第一列的炸弹，爆炸后会到那一行或者那一列的更前面（总的来说就是更靠近左上角）的位置。对于其他位置的炸弹，爆炸后会生成两个炸弹，分别到那一行的更前面或者那 一列的更前面。问先手是否有必赢策略。
思路： 不会做2333 参考了 参考博客1 参考博客2
大概明白了一点。整个游戏可以分为若干个炸弹的游戏的和，而实际上一个不在边界行或者列的炸弹，依然可以继续分，分成两个炸弹的和。而位于(i.j)的炸弹，分成两个炸弹的和，有(i-1)*(j-1)种方案（这个不重要2333）
处于边界行或者列的点的sg值我们是可以知道的。。因为规则单一。。和移动等价。。
然后根据边界来进一步处理一般的情况。。
有点类似dp的思想。。。？
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 04时52分16秒 File Name :code/hdu/2873.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n,m; int sg[N][N]; bool vis[N*N]; char maze[N][N]; int px[N],py[N]; void sg_init() { ms(sg,0); for ( int i = 0 ; i &amp;lt; N ; i++) //在边界的只能往一个方向生成炸弹，和移动了炸弹等价。 sg[i][0]=sg[0][i]=i; //还是0based好一点。。。这样（1,1）点的sg值自然就是0了。。。 for ( int i1 = 1 ; i1 &amp;lt; N ; i1++) for ( int i2 = 1 ; i2 &amp;lt; N ; i2++) { ms(vis,false); for ( int j1 = 0 ; j1 &amp;lt; i1 ; j1++) for ( int j2 = 0 ; j2 &amp;lt; i2 ; j2++) vis[sg[i1][j2]^sg[j1][i2]] = true; //注意sg函数的变化规则。。其实是把一次爆炸考虑成两个爆炸的叠加，所以异或了。 for ( int k = 0 ; ; k++) if (!</description></item><item><title>hdu 2509 Be the Winner (anti-sg,sg函数，sj定理)</title><link>https://111qqz.com/2016/07/hdu-2509/</link><pubDate>Fri, 22 Jul 2016 20:47:57 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2509/</guid><description>
hdu2509题目链接 题意：？？？
思路：同1907
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 04时41分38秒 File Name :code/hdu/2509.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1022 ||hdu 1907 John (sg函数，sj定理，anti-sg)</title><link>https://111qqz.com/2016/07/hdu-1907/</link><pubDate>Fri, 22 Jul 2016 20:37:37 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1907/</guid><description>
hdu1907题目链接
题意：n堆石子，每次选一堆，最少拿一个，最多拿光那一堆，拿走最有一个的人输。 问是否有必胜策略。
思路：anti-nim问题。。。
要用到sj定理（是啥。。。?)
参考资料：参考博客
SJ定理 **对于任意一个Anti-SG游戏，如果定义所有子游戏的SG值为0时游戏结束，先手必胜的条件： ** **1、游戏的SG值为0且所有子游戏SG值均不超过1。 ** 2、游戏的SG值不为0且至少一个子游戏SG值超过1。
/* *********************************************** Author :111qqz Created Time :2016年07月22日 星期五 23时09分42秒 File Name :code/hdu/1907.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E3+7; int n; int sg[N]; bool vis[N]; void sg_init() { ms(sg,0); for ( int i = 1 ; i &amp;lt; N ; i++) { sg[i] = i; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1730 Northcott Game (二维sg函数)</title><link>https://111qqz.com/2016/07/hdu-1730/</link><pubDate>Fri, 22 Jul 2016 14:02:29 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1730/</guid><description>
hdu 1730
题意：n行格子，每行m个，每行有一黑一白两个棋子，给定初始位置，先手执黑棋，后手执白棋，每次可以在同一行内向左移动，不能超过边界，且不能越过对方的棋子，同一个格子只能有一个棋子。问先手是否必赢。
思路：可以看成n个独立的游戏的 叠加。。。所以最后异或和一下就好。。
我们来求sg函数。。。一开始的是想把点对hash成一个数。。。然后发现其实没必要。。。直接二维就好了。。
由于初始化的时候要考虑最大。。。所以sg函数的值会有一个便宜。。。和设定N有关。。减去偏移就好了。。。（我的代码里这个偏移是11026）
1A蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年07月22日 星期五 21时01分19秒 File Name :code/hdu/1730.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E2+7; bool vis[N*N]; int sg[N][N]; int n,m; void sg_init(int m) { ms(sg,0); for ( int i1 = 1 ; i1 &amp;lt;= m ; i1++) for ( int i2 = 1 ; i2 &amp;lt;= m ; i2++) { if (i1==i2) continue ; // 棋子不能在同一个位置？ ms(vis,false); int x = i1; int y = i2; if ( x&amp;lt;y ) { for ( int j = x+1 ; j &amp;lt;=y-1; j++) vis[sg[x][j]] = true; for ( int j = 1 ; j &amp;lt;= x-1 ; j++) vis[sg[j][y]] = true; } else { for ( int j = y + 1 ; j &amp;lt;= x-1 ; j++) vis[sg[j][y]] = true; for ( int j =1 ; j &amp;lt;= y-1 ; j++) vis[sg[x][j]] = true; } for ( int j1 = 1 ; j1 &amp;lt;= m ; j1++ ) for ( int j2 = 1 ; j2 &amp;lt;= m ; j2++) if (!</description></item><item><title>hdu 1404 Digital Deletions (博弈论，根据定义)</title><link>https://111qqz.com/2016/07/hdu-1404/</link><pubDate>Fri, 22 Jul 2016 12:39:22 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1404/</guid><description>
hdu 1404题目链接
题意：一个数字串，每次可以选择一位减少任意大小到一个非负数，或者清除一个0以及该位右边的所有数字。问是否有必胜策略。。
思路：定义来搞。。所有能一步走到p点的都是n点，那么如果我们现在知道p点，就可以反过来推n点。。
看到一些人强行把变量名起成sg就说自己用了sg函数也是笑死我了呵呵呵呵
/* *********************************************** Author :111qqz Created Time :2016年07月22日 星期五 19时11分16秒 File Name :code/hdu/1404.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; int sg[N]; bool vis[N]; char st[10]; void solve( int x) { int dig[10]; int cnt = 0; ms(dig,0); int xx = x; while (x) { dig[++cnt] = x % 10; x/=10; } x = xx; // cout&amp;lt;&amp;lt;&amp;quot;cnt:&amp;quot;&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl; // for ( int i = 1 ; i &amp;lt;= cnt ; i ++) cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; dig[i]:&amp;quot;&amp;lt;&amp;lt;dig[i]&amp;lt;&amp;lt;endl; int base = 1; for ( int i = 1 ; i &amp;lt;= cnt ; i++) { for ( int j = dig[i] + 1 ; j &amp;lt;= 9 ; j++) if (x+(j-dig[i])*base&amp;lt;N)sg[x+(j-dig[i])*base] = 1; base *=10; } if (cnt&amp;lt;6) { base = 1; for ( int i = cnt ; i &amp;lt; 6 ; i++) { x*=10; for ( int j = 0 ; j &amp;lt; base ;j++) sg[x+j] = 1; base*=10; } } } void sg_init() { ms(sg,0); // sg[0] = 1; for ( int i = 1 ; i &amp;lt; N ; i++) if (!</description></item><item><title>科学上网小记</title><link>https://111qqz.com/2016/07/</link><pubDate>Fri, 22 Jul 2016 11:37:30 +0000</pubDate><guid>https://111qqz.com/2016/07/</guid><description>
终于忍不了因为没办法科学上网而不能做什么事的感觉了。。。
买了班瓦工 20刀/年。。。搭了ss。。然后全平台（ios/androd/fedora/win）的上网问题就全解决了。。。
网速似乎很快。。。youtube 1080p好无压力，虽然我不看2333</description></item><item><title>hdu 1536 S-Nim (sg函数)</title><link>https://111qqz.com/2016/07/hdu-1536/</link><pubDate>Wed, 20 Jul 2016 15:45:35 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1536/</guid><description>
hdu 1536题目链接
题意：还是若干堆石子，但是每次取的个数只能是集合S中有的数。。问是否必赢。。。
思路：sg函数。。。1A
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 23时32分48秒 File Name :code/hdu/1536.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int sg[N]; bool vis[N]; int ok[N]; int k,m; void sg_init() { ms(sg,0); for ( int i = 1; i &amp;lt; N ; i++) { ms(vis,false); for ( int j = 1 ; j &amp;lt;= k ; j++) if (i-ok[j]&amp;gt;=0) vis[sg[i-ok[j]]] = true; for ( int j = 0 ; ; j++) if (!</description></item><item><title>hdu 1517 A Multiplication Game (博弈论，将点的局势对应到段)</title><link>https://111qqz.com/2016/07/hdu-1517/</link><pubDate>Wed, 20 Jul 2016 13:27:59 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1517/</guid><description>
hdu 1517 题目链接
题意：初始为1，每次可以乘2..9中的一个数，最先达到或者超过n的人胜利。问谁有必赢策略。。
思路：一开始想用sg函数。。然而n太大（4e10）。。。绝对会超时。。。
所以可以更朴素得，去画n点和p点。。。我们可以发现。。。连续一段的局势是相同的。。。所以不能，也没必要找到每一个点对应的局势。
[n,+oo]是p点，那么[n/9,n-1]是n点，那么[n/9/2,n/9)又是p点。。。以此类推。。
这道题同时也告诉我们。。。没有什么方法是万能的。。。就算sg函数很神。。也有不能用的时候。。。所以掌握最本质的东西还是很重要的。。。
转载一段题解：
**** 这道题如果用sg函数，利用点的局势做一定会超时，因为相同的局势能够形成连续的段，所以我们可以将局势对应到段来达到一定的优化：
首先题目中能够了解到必败态[n,+oo)，那么可以由此推出必胜态
必胜态就是[n/9,n-1]，也就是有一定有策略达到必败态
另一个必败态就是[n/9/2,n/9)，之后就是一直循环这样的局势，找到了循环，我们可以固定一个点，固定区间的左端点比较易操作，也就是我们通过固定左端点找到１在必胜态区间，还是必败态区间．
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 20时27分11秒 File Name :code/hdu/1517.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1848 Fibonacci again and again (sg函数)</title><link>https://111qqz.com/2016/07/hdu-1848/</link><pubDate>Wed, 20 Jul 2016 12:22:06 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1848/</guid><description>
hdu 1848题目链接
题意：三堆石头，每次任选一堆取，取的石子数目必须是斐波那契数列中的数(1,2,3,5,8....)问先手是否有必赢策略。
思路：sg函数即可。。。。这次sg函数的优越性终于体现出来了。。。其他方法估计很难写吧。。
以及，这道题不知道为什么让我联想到了生成函数。。。感觉生成函数和sg函数作为工具还是有不少共同点的。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 20时08分38秒 File Name :code/hdu/1848.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; bool vis[N]; int sg[N]; int f[N]; int a,b,c; void sg_init() { f[1] = 1; f[2] = 2; ms(sg,0); for ( int i = 3 ; i&amp;lt;=18 ; i++) f[i] = f[i-1] + f[i-2]; // cout&amp;lt;&amp;lt;&amp;quot;jhhhh;&amp;quot;&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt; N ; i++) { ms(vis,false); for ( int j = 1 ; f[j] &amp;lt;= i ; j++) vis[sg[i-f[j]]] = true; for ( int j = 0 ; ; j++) if (!</description></item><item><title>hdu 1850 Being a Good Boy in Spring Festival (nim游戏问必胜方案数，sg函数)</title><link>https://111qqz.com/2016/07/hdu-1850/</link><pubDate>Wed, 20 Jul 2016 12:03:45 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1850/</guid><description>
hdu1850题目链接 题意：n堆石子。。每堆可以取任意多个。。。先取完的赢。。问先手能否赢。。能赢的话第一步有几种取法。。 思路：sg函数。。对于方案数，可以用nim游戏的结论。
。设异或和为sum..那么统计满足 a[i]^sum&amp;lt;a[i]的个数就是第一步能走的方案数。
以及。。sg函数。。如果走的步数是任意的。。也就是没有限制。。。那么sg[i] = i...此时也就退化成了一般的nim游戏。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 19时47分48秒 File Name :code/hdu/1850.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; const int M=1E6+7; int n; int sg[M]; int a[N]; void sg_init() { //这个可以记成结论23333 for ( int i = 1 ; i &amp;lt; M ; i ++) sg[i] = i ; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1847 Good Luck in CET-4 Everybody! (巴什博奕,找规律｜｜sg函数)</title><link>https://111qqz.com/2016/07/hdu-1847/</link><pubDate>Wed, 20 Jul 2016 10:59:43 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1847/</guid><description>
hdu1847题目链接 题意：n个石子，每次只能取2的幂次个。。。问先手是否有必赢策略。。。 思路：画n点p点。。。发现n为３的倍数的时候先手必输。。。否则先手必赢。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 18时54分46秒 File Name :code/hdu/1847.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>nim游戏以及证明过程</title><link>https://111qqz.com/2016/07/nim/</link><pubDate>Wed, 20 Jul 2016 08:06:50 +0000</pubDate><guid>https://111qqz.com/2016/07/nim/</guid><description>
参考资料　（后面的证明写错了，差评，不要看，看图就好了）
1. 题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。 题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。 嘿嘿，这个游戏我早就见识过了。小时候用珠算玩这个游戏：第一档拨一个，第二档拨两个，依次直到第五档拨五个。然后两个人就轮流再把棋子拨下来，谁要是最后一个拨谁就赢。有一次暑假看见两个小孩子在玩这个游戏，我就在想有没有一个定论呢。下面就来试着证明一下吧 先解决第一个问题吧。 定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则， 为利己态，用S表示。 [定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。 证明：  若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态，  c = A(1) xor A(2) xor … xor A(n) 0;  把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t)(注：我觉得应该是必然存在奇数个),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。  那么我们把x = A(t) xor c,则得到x  A(1) xor A(2) xor … xor x xor … xor A(n)　（**需要注意的是，这里是没有A(t)这一项的，前面之所以要说明x  = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n)  = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n)  = 0 这就是说从A(t)堆中取出 A(t) - x 根火柴后状态就会从S态变为T态。证毕</description></item><item><title>hdu 2147 kiki's game (巴什博奕)</title><link>https://111qqz.com/2016/07/hdu-2147/</link><pubDate>Wed, 20 Jul 2016 07:35:25 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2147/</guid><description>
hdu 2147 题目链接
题意：一个n*m的方格，有一个棋子初始在右上角（１，m）,每次可以将棋子向下或者向左或者向左下移动**一个格子，**不能移出边界，当无路可走的时候就输了，问谁存在必赢策略。
思路：画n点p点。。。左下肯定是p　然后最后发现　n%2==1&amp;amp;&amp;amp;m%2==1的时候必输，否则必赢。
然后因为把m%2谢成名m&amp;amp;2 WA了好多发呵呵呵呵呵呵。
/* *********************************************** Author :111qqz Created Time :2016年07月19日 星期二 20时09分37秒 File Name :code/hdu/2147.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1846 Brave Game　（巴什博奕）</title><link>https://111qqz.com/2016/07/hdu-1846-brave-game/</link><pubDate>Tue, 19 Jul 2016 11:55:09 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1846-brave-game/</guid><description>
hdu 1846 题目链接
题意：有n个石子，每次最多取m个，最少取１个，如果没有石子可取就输了。给出n,m，两个人都很聪明，问先手和后手谁赢。。
思路：
首先定义几个概念：
p点：即必败点，某玩家位于此点，只要对方无失误，则必败
**　N点 ：即必胜点，某玩家位于此点，只要自己无失误，则必胜。**
** 一、 所有终结点都是必败点P（这道题目中，轮到谁取石子，还剩0个石子的时候，此人无石子可取，就输了）；**
** 二、所有一步能走到必败点P的就是N点；（这里是_存在一种_情况可以走到p点即可）**
** 三、通过一步操作只能到N点的就是P点；　（这里是_所有_的情况都只能走到n点）**
那么当m=3的时候，则有：
 x ：0 1 2 3 4 5 6 7 8 9 10...
pos：P N N N P N N N P N N ...
１，２，３为n点是因为一步可以走到p点0,直观得说就是剩余１，２，３个石子的时候可以一次拿走。
４为p点是因为，不管怎么走，下一步一定是处于１，２，３这三个n点的，因此４是p点。
因此我们可以得出结论：n%(m+1)==0的时候，后手赢，否则先手赢。
（之前遇到的时候只记了结论，不清楚为什么，这下明白了orz
/* *********************************************** Author :111qqz Created Time :2016年07月19日 星期二 19时41分16秒 File Name :code/hdu/1846.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust 2016 warm up G ||codeforces 689C. Mike and Chocolate Thieves</title><link>https://111qqz.com/2016/07/cf689c/</link><pubDate>Mon, 18 Jul 2016 12:29:16 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689c/</guid><description>
cf689C
题意：给出一个m。。问恰好使得不超过某个n的a*b^3（a,b是正整数）的方案数为m的n是多少。。。
思路：暴力+二分。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 15时58分55秒 File Name :code/2016whust/G.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL m,n; LL ans; LL cal( LL x) { LL res = 0LL; for ( LL i =2 ; i * i * i &amp;lt;= x ; i++) res+=x/(i*i*i); return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust 2016 warm up E ||codeforces 689 B. Mike and Shortcuts (spfa)</title><link>https://111qqz.com/2016/07/cf689b/</link><pubDate>Mon, 18 Jul 2016 12:20:08 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689b/</guid><description>
cf689B题目链接
题意：n点。。点i到点j的代价是|i-j|..给出n条近路。。。a[i]表示点i到a[i]的代价为1（注意近路不一定就近）
思路：一开始建边卡了一下。。。实际上只要连相邻的就好了。。。然后边表只开了2N蠢哭。。。实际上应该3M...因为连相邻的边是双向的。。。再加上近路的单向。。。然后spfa就好了。。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 13时33分18秒 File Name :code/2016whust/F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int a[N]; bool inq[N]; int d[N]; int head[N]; int cnt; struct Edge { int v; int w; int nxt; }edge[8*N]; void addedge( int u,int v,int w) { edge[cnt].</description></item><item><title>whust 2016 warm up E||codeforces 689 A. Mike and Cellphone (模拟)</title><link>https://111qqz.com/2016/07/cf689a/</link><pubDate>Mon, 18 Jul 2016 12:12:44 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689a/</guid><description>
cf689A
思路：一个老式的电话键盘。。。。给出一个拨号的移动路径。。。问这个路径是否唯一。
思路：如果唯一就说明。。。不能平移。。。否则不唯一。。
平移可以上下左右。。所以先写4个常亮数组。。。标记平移后的结果。。。设置不合法位就可以了。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 12时56分28秒 File Name :code/2016whust/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int up[15]={8,-1,-1,-1,1,2,3,4,5,6}; const int down[15]={-1,4,5,6,7,8,9,-1,0,-1}; const int l[15]={-1,-1,1,2,-1,4,5,-1,7,8}; const int r[15]={-1,2,3,-1,5,6,-1,8,9,-1}; int n; string st; bool solve() { bool flag = true; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = st[i]-'0'; // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; x+up[x]&amp;quot;&amp;lt;&amp;lt;x+up[x]&amp;lt;&amp;lt;endl; x = up[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;uuuuu&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; flag = true; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = st[i]-'0'; x = down[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;ddd&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; flag = true; for ( int i = 0 ; i &amp;lt; n; i++) { int x = st[i]-'0'; x = l[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;lll&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; flag = true; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = st[i]-'0'; x = r[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;rrr:::&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust 2016 warm up C ||codeforces 682 C. Alyona and the Tree (最大连续和,树形dp)</title><link>https://111qqz.com/2016/07/cf682c/</link><pubDate>Mon, 18 Jul 2016 12:06:00 +0000</pubDate><guid>https://111qqz.com/2016/07/cf682c/</guid><description>
cf682C题目链接
题意：给一棵树。。有点权和边权。。。如果一个点v的子树中存在某点u,满足dis(u,v)&amp;gt;a[u]，那么点v就非常sad...
dis(u,v)表示点u到v的距离。。。a[u]是u的点权。。现在问最少要删除多少个叶子节点才能使得没有点节点感到sad..
思路：dfs一下。。。需要注意的是边权有负数。。。所以类似于区间的最大连续区间和。。。我们也也可以维护在树上的最大连续和。。。只需要如果当前为负就变成0即可。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 14时27分58秒 File Name :code/2016whust/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,long long &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL a[N]; LL sum[N]; bool vis[N]; vector &amp;lt; pi&amp;gt; edge[N]; int ans; int n; void dfs( int u,int pre,LL d) { if (d&amp;gt;a[u]) return ; ans++; int siz = edge[u].</description></item><item><title>whust 2016 warm up ||codeforces 682 B. Alyona and Mex (离散化)</title><link>https://111qqz.com/2016/07/cf682b/</link><pubDate>Mon, 18 Jul 2016 11:56:35 +0000</pubDate><guid>https://111qqz.com/2016/07/cf682b/</guid><description>
cf682B题目链接
题意：给出n个数。。每个数可以任意减小到一个正整数。。。问进行恰当的操作后。。。最小的没有出现的正整数的最大可能取值。。
思路：傻逼题。。。直接离散化。。。。注意不能超过初始。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 12时43分41秒 File Name :code/2016whus/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int b[N]; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust2016 warm up A ||codeforces 682 A. Alyona and Numbers (计数问题，水)</title><link>https://111qqz.com/2016/07/cf682a/</link><pubDate>Mon, 18 Jul 2016 11:49:37 +0000</pubDate><guid>https://111qqz.com/2016/07/cf682a/</guid><description>
cf682A题目链接
题意：两个数组，分别为1..n和1..m。。。从两个数组中各取一个，问和能被5整除的方案数。。。
思路：傻逼题。。。统计%5。。。然后乘法原理。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 12时32分22秒 File Name :code/2016whust/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n,m; LL a[N],b[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4123 Bob’s Race (树的直径+尺取+rmq)(珍爱生命，远离log)</title><link>https://111qqz.com/2016/07/hdu-4123/</link><pubDate>Sun, 17 Jul 2016 16:21:03 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-4123/</guid><description>
hdu 4123 题目链接
题意：一棵树，定义d[i]为点i到树上某点的最大距离。。。给出若干查询，每个查询一个x,问最多能有多少点满足这些点中，最大的d与最小的d的差小于等于x.要求这些点的编号必须是连续的。
思路：可以三遍bfs处理出所有点的d...
由于不能排序。。。所以就是尺取+rmq....
然而神Tm TLE.....
这复杂度还TLe...
结果最后发现是。。。log运算的常数太大被卡。。。
所以做法是先预处理一下。。。嗯。。。。
珍爱生命，远离log! 珍爱生命，远离log! 珍爱生命，远离log! /* *********************************************** Author :111qqz Created Time :2016年07月17日 星期日 19时37分55秒 File Name :code/hdu/4123.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair #define log2 0.</description></item><item><title>POJ 1849 Two (树的直径)</title><link>https://111qqz.com/2016/07/poj1849/</link><pubDate>Sun, 17 Jul 2016 11:33:09 +0000</pubDate><guid>https://111qqz.com/2016/07/poj1849/</guid><description>
题目链接
题意:一棵树。。然后初始两个推雪机在点s,问如何选择路径使得处理完所有边上的积雪所耗费的汽油最少（走过一条有雪的边和一条没雪的边耗费的汽油一样）
思路：很容易想到，我们应该尽可能不走已经被清理过雪了的边，因为这样很浪费。。。这样不难想到应该是和树的直径有关。但是初始的位置是给定的。。。怎么办？突然发现由于是给了两个推雪机。。所以其实相当于。。。只有一个推雪机&amp;amp;我们可以从任意位置开始推雪。。。第二个问题是。。。对于不在直径上的边。。我们怎么算cost?解决办法是读边的时候进行记录。。。然后求直径的时候记录路径。。。对于一条边。。。只要有一个点不在直径上。。。那么这条边的代价就是2倍。。。
1A蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年07月17日 星期日 19时04分49秒 File Name :code/poj/1849.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector &amp;lt; pi &amp;gt; edge[N]; int n,s; int lst; int beg; int d[N]; bool vis[N]; bool onpath[N]; int path[N]; int ans; struct Edge { int u,v,w; }e[N]; void init( int n) { for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>hdu 3873 Invade the Mars (有限制条件的最短路。。)</title><link>https://111qqz.com/2016/07/hdu-3873/</link><pubDate>Thu, 14 Jul 2016 17:25:24 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-3873/</guid><description>
hdu3873题目链接
题意：n个点的图。。。每个点可能被若干其他点保护。。。被保护的意思是。。。如果想访问某个点。。那么必须先访问保护该点的所有点。。。问从点1到点n的最小代价。。
思路：。。一开始写了spfa。。。然后一脸懵逼。。。因为我第一次访问某个点的时候无法保证距离是最短的。。。所以还是上dij吧。。。
然后dij写得比较少。。。不是很熟练。。参考了这篇题解参考题解
思路倒是不难想，我在写spfa的时候也是这样想法，然后试图记录路径递归来搞。。。。。然而并不可以2333
也是第一次遇到带限制条件的最短路。。。还是多积累吧。。。
哦对了。。。权值比较大。。。要记得开long long
/* *********************************************** Author :111qqz Created Time :2016年07月15日 星期五 00时32分14秒 File Name :code/hdu/3873.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; long long ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E3+7; const int M=7E4+7; int n,m; int cnt; int head[N]; int in[N]; //in[i]表示点i被几个点保护。。。 vector &amp;lt;int&amp;gt;prec[N]; LL d[N]; bool vis[N]; LL maxt[N]; struct Edge { int v; LL w; int nxt; }edge[M]; void init() { ms(head,-1); ms(in,0); cnt = 0 ; for ( int i = 1 ; i &amp;lt;= n ; i++) prec[i].</description></item><item><title>poj 2031 Building a Space Station (最小生成树)</title><link>https://111qqz.com/2016/07/poj-2031/</link><pubDate>Thu, 14 Jul 2016 09:05:01 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-2031/</guid><description>
poj 2031
题意：三维空间中n个球要相连。。。通路的代价是距离。。。如果球相交（切）或者包含那么不用建通路就能联系。。。问联系所有球的最小代价。。。
思路：裸的最小生成树。。。。先预处理球和球表面的距离。。。距离是负数的处理成0.。。然后mst搞之。。。不算CE的话是1A....
/* *********************************************** Author :111qqz Created Time :2016年07月14日 星期四 15时44分53秒 File Name :code/poj/2031.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =105; int n; int m; double a[N][N]; int f[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>poj 1789 Truck History (mst,prim)</title><link>https://111qqz.com/2016/07/poj-1789/</link><pubDate>Wed, 13 Jul 2016 17:40:56 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-1789/</guid><description>
poj1789题目链接
题意：其实题目不难理解。。。直接按照定义去搞就行了。。。
思路：由于距离在分母上。。所以要quality最大。。。就是要分母最小。。。
然后由于题目中说每一种类型的type只能由其他一种派生出来。。。我们可以把这个派生关系看做一条边。。。把每种类型看成点。。
这样就构成了一棵树。。。先o(nn7)预处理出权值。。。然后最小生成树即可。。。
这种给了坐标距离作为权值的图一定是稠密图。。。图小用kruskal糊弄一下就过去了。。。图大的话还是乖乖的用prim吧。。。
然而仍然 TLE???wtf??
最后发现。。因为我习惯用string...但是又怕卡cin...所以做法是scanf读入字符数组然后再赋值给string..
然而这种操作不知为何神tm慢。。。。。（求指教）
以至于：
要知道。。。这题时限2s啊。。。为毛能差1s多。。。也就是说时间的瓶颈完全是在读入了orz...
/* *********************************************** Author :111qqz Created Time :2016年07月14日 星期四 00时13分04秒 File Name :code/poj/1789.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,m; int f[N]; int v[N]; char st[N][10]; //string st[N]; int matrix[N][N]; void init() { for ( int i = 0 ; i &amp;lt; n; i++) for ( int j = 0 ; j &amp;lt;n ; j++) matrix[i][j] = inf; } int getw(char * a,char * b) { int res = 0 ; for ( int i = 0 ; i &amp;lt; 7 ; i++) if (a[i]!</description></item><item><title>poj 2349 Arctic Network (mst)</title><link>https://111qqz.com/2016/07/poj-2349/</link><pubDate>Wed, 13 Jul 2016 16:01:33 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-2349/</guid><description>
Poj2349题目链接
题意：给出n个点坐标。。。然后可以建s个卫星基站。。。有卫星基站的地方之间可以互相免费通信。。现在要建一些无线电通讯线路（不同于卫星基站，是另一种通信方式），两个点之间线路的代价是他们的距离。。。问最小距离是多少。。。使得任意两个点之间都可以直接或者间接联系。。。
思路：mst即可。。。s个卫星基站可以减少s-1条最大的边。。。多组数据。。m忘记清0.。。re一发。。。2a
/* *********************************************** Author :111qqz Created Time :2016年07月13日 星期三 16时35分42秒 File Name :code/poj/2349.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,s; int m; int f[N]; struct Edge { int u,v; double w; bool operator &amp;lt; (Edge b)const { return w&amp;lt;b.</description></item><item><title>poj 1751 Highways (最小生成树，空间卡常数有毒啊)</title><link>https://111qqz.com/2016/07/poj-1751-highways/</link><pubDate>Wed, 13 Jul 2016 13:28:29 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-1751-highways/</guid><description>
poj1751题目链接
题意：一开始有一些边，然后添加一些边，使得代价之和最小。
思路：先把给定的边merge掉。。然后计算其余可以添加的边。。。接下来就是最小生成树。。。
然而因为多开了一个750*750的数组空间被卡了常。。。毫无人性。。。。
/* *********************************************** Author :111qqz Created Time :2016年07月13日 星期三 19时53分29秒 File Name :code/poj/1751.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=755; int n; int m; int om; pi ans[N*N]; bool conc[N*N]; int f[N]; struct Edge { int u,v; double w; bool operator &amp;lt; (Edge b)const { return w&amp;lt;b.</description></item><item><title>hdu 4607 Park Visit (树的直径，推公式)</title><link>https://111qqz.com/2016/07/hdu-4607/</link><pubDate>Wed, 13 Jul 2016 07:00:27 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-4607/</guid><description>
hdu4607题目链接 题意：给出一棵树。。。边权都为1. m个查询。。每个查询给一个k,表示只访问k个点。。。问每次的最小路径和是多少。。。 思路：我们发现。。会使路径和变大的一个不利因素是折返。。也就是访问某景点后。。必须要回去才能继续前进。。这样的距离是2倍。。那为了使得路径和尽可能小。。我们就尽量不要访问这样的点。。。而不是这样的点一定在直径上。。。以及我们还发现。。。不在直径上的点。。 。。不管深度如何（深度的意思是说，与和该点最近的直径上的点的距离），距离的贡献是一样的。。都是2倍。。所以我们可以推出一个公式。。。如果树的直径是d,那么k&amp;lt;=d+1的时候，答案为k-1,否则答案为d+(k-d-1)*2。。。
因为bfs的时候忘记标记起点WA了一发蠢哭。。。。2A
/* *********************************************** Author :111qqz Created Time :2016年07月13日 星期三 14时33分29秒 File Name :code/poj/4607.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector&amp;lt; int &amp;gt;edge[N]; int n,m; int d[N]; int lst,beg; bool vis[N]; void bfs( int s) { ms(d,0); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 3310 Caterpillar (树的直径+并查集判环+dfs判断连通性)</title><link>https://111qqz.com/2016/07/poj-3310/</link><pubDate>Wed, 13 Jul 2016 06:21:41 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-3310/</guid><description>
poj3310 题目链接
题意：给出一个无向图。。。问是否满足。。联通，并且无环，并且能找到一条路径，图中所有的顶点要么在这条路径上，要么与这条路径上的顶点相邻。
思路：一个一个来。。。联通的话任意起点开始跑一遍dfs? 开一个bool数组标记走过的点。。最后扫一遍。。看是否有点没走过
环的话并查集就好。。
关键是第三个条件。。。根据题中题中的例子。。感觉如果存在这样的路径。。。那么这样的路径应该尽可能长？
于是想到求直径。。。然后在bfs的时候顺便记录路径。。。这样我就知道直径是哪些点。。。然后对于所有点。。判断是否在这条直径上或者与之相邻就好。。。
具体做法是。。。开了一个bool数组ok标记直径上的点。。。在存边的时候用一个to[]数组表示相连。。。to[u]=v,to[v]=u...
然后只要ok[i]或者ok[to[i]]满足其一就好。。。
又是1A，蛤蛤蛤蛤蛤，我好神啊（误
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 20时27分28秒 File Name :code/poj/3310.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int n,m; vector &amp;lt; int &amp;gt;edge[N]; int f[N]; bool vis[N]; bool die; int d[N]; int to[N]; int pre[N];//记录最长的路径。。。 int lst,beg; bool ok[N]; struct Edge { int u,v; }e[N]; void init() { ms(to,-1); ms(pre,-1); ms(vis,false); //for dfs ms(ok,false); for ( int i = 1 ; i &amp;lt;= n ; i++) f[i] = i; for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>poj 1679 The Unique MST (判断mst的唯一性，次小生成树)</title><link>https://111qqz.com/2016/07/poj1679/</link><pubDate>Tue, 12 Jul 2016 09:53:17 +0000</pubDate><guid>https://111qqz.com/2016/07/poj1679/</guid><description>
poj1679
题意：问最小生成树是否唯一。。
思路：求一下次小生成树。。。如果无解，或者次小生成树的权值之和和最小生成树的权值之和不同，那么唯一，否则不唯一。1A
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 16时16分52秒 File Name :code/poj/1679.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; int ans; int f[N]; struct Edge { int u,v,w; int in; void input() { scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;u,&amp;amp;v,&amp;amp;w); } bool operator &amp;lt; (Edge b)const { return w&amp;lt;b.</description></item><item><title>hdu 4514 湫湫系列故事——设计风景线 (无向图并查集判环+非联通图的最长路径)</title><link>https://111qqz.com/2016/07/hdu4514/</link><pubDate>Tue, 12 Jul 2016 07:59:55 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu4514/</guid><description>
hdu4514
题意：给出一个无向图。。问是否有环。。。有的话输出YES。。如果没有环的话。。输出最长路径。。
思路：无向图判环并查集就好。。。关于最长路径这里。。一开始以为就是树的直径。。。
但是需要注意的是。。。题目并没有保证图一定是联通的。。。所以gg了。。
也就是要在一个不联通的图中求最长路径。。。
没想出来。。搜了一下。。有树形dp的做法。。。有并查集的时候带权的做法。。。
不过感觉最容易想到的还是求多次直径的做法。。。
也就是。。每一个联通块求一次直径。。。取最大。。。
具体做的时候。。。加一个bool数组在bfs标记一下就好。。。
以及bfs的时候。。。由于我之后是要得到最大值。。。而图本身可能是不联通的。。所以要注意d数组初始化的问题。。。不能初始化成0x3f...（这么说来即使联通也没必要初始化成0x3f。。。。)
还有一点，这道题数据量比较大。。。用vector存图会MLE ...
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 14时31分09秒 File Name :code/hdu/4514.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M=1E6+7; int n,m; int f[N]; int lst; int far; int cnt; bool cyc; struct Edge { int v,w; int nxt; }edge[M]; int d[N]; bool vis[N]; bool used[N]; int head[N]; int root ( int x) { if (x!</description></item><item><title>hdu 2196 Computer (树的直径||树形dp)</title><link>https://111qqz.com/2016/07/hdu2196/</link><pubDate>Tue, 12 Jul 2016 06:02:39 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu2196/</guid><description>
hdu2196
题意：给出一棵树。。。求距离每个点的最远距离是多少。。。
思路：最远距离什么的。。能想到树的直径。。。但是有什么关系呢？ 我们在求树的直径的时候。。。直径的两个端点是可以知道的。。。如果再从两个端点分别做两次bfs。。。每个点取两个距离的较大值就是答案。。。。？
1A.
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 13时29分49秒 File Name :code/hdu/2196.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; vector &amp;lt; pi &amp;gt;edge[N]; int d[N]; int ans[N]; bool vis[N]; int beg,lst; int far; void bfs( int s) { ms(d,0x3f); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 2631 Roads in the North (树的直径)</title><link>https://111qqz.com/2016/07/poj2631/</link><pubDate>Tue, 12 Jul 2016 05:57:18 +0000</pubDate><guid>https://111qqz.com/2016/07/poj2631/</guid><description>
poj2631 题意：一棵树中求两个点的最远距离。。。 思路：就是求树的直径。。。裸体。。。。1A
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 13时03分39秒 File Name :code/poj/2631.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; vector &amp;lt; pi&amp;gt; edge[N]; int lst; int ans; int d[N]; bool vis[N]; void bfs( int s) { ms(d,0x3f); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 1985 Cow Marathon (树的直径模板题)</title><link>https://111qqz.com/2016/07/poj1985/</link><pubDate>Tue, 12 Jul 2016 04:07:00 +0000</pubDate><guid>https://111qqz.com/2016/07/poj1985/</guid><description>
poj1985 题意：求树上两点的最长距离。。。也就是传说中的树的直径。。。
思路： **两遍BFS :先任选一个起点BFS找到最长路的终点，再从终点进行BFS，则第二次BFS找到的最长路即为树的直径；** 原理: 设起点为u,第一次BFS找到的终点v一定是树的直径的一个端点 证明: 1) 如果u 是直径上的点，则v显然是直径的终点(因为如果v不是的话，则必定存在另一个点w使得u到w的距离更长，则于BFS找到了v矛盾) 2) 如果u不是直径上的点，则u到v必然于树的直径相交(反证),那么交点到v 必然就是直径的后半段了 所以v一定是直径的一个端点，所以从v进行BFS得到的一定是直径长度 参考博客
实际写的时候，第一次bfs最后一个出队的点就是直径的一个端点。。。 好像错了。。。还是稳妥一点。。。最后扫一遍。。距离最远的一定是端点。。。 然后因为题目没有数据范围。。。？re多次orz。。。
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 11时26分41秒 File Name :code/poj/1985.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+5; int n,m; vector &amp;lt; pi &amp;gt;edge[N]; int d[N]; int lst; int ans; bool vis[N]; void bfs( int s) { ms(vis,false); ms(d,0x3f); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>2016暑假计划</title><link>https://111qqz.com/2016/07/2016/</link><pubDate>Mon, 11 Jul 2016 19:54:36 +0000</pubDate><guid>https://111qqz.com/2016/07/2016/</guid><description>
* &amp;lt;del&amp;gt;树的直径，次小生成树（）&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;最小生成树（拒绝划水，推一波难题）&amp;lt;/del&amp;gt; * 《编程珠玑》 * 博弈论。。全部搞定。。。 * dp。。。基础dp，区间dp，树形dp，概率dp。。至少搞定这些。。（从头开始学dp2333） * &amp;lt;del&amp;gt;markdown语法。。还是有必要学一下的。&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;multi 2016 #4 1006 -&amp;gt; SA SA? SA SA!&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;单调栈？单调栈？单调栈单调栈！ （一堆题卡在这里了。。。）&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;单调队列也来一发&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;kmp?kmp? kmp!kmp!&amp;lt;/del&amp;gt; * 扩展kmp * &amp;lt;del&amp;gt;trie-&amp;gt;ac自动机&amp;lt;/del&amp;gt; * 线段树线段树？ 线段树线段树！ * mutli 2016 %5 1006 -&amp;gt; 回文树 * &amp;lt;del&amp;gt;字符串的最小表示法。。。是啥。。。同构什么的orz&amp;lt;/del&amp;gt; * 复习数论同余-&amp;gt;高斯消元 * bitset？！ * hdu 5313 -&amp;gt;二分图的黑白染色？ * 交叉染色法判断二分图？ -&amp;gt;http://blog.csdn.net/yujuan_mao/article/details/8221091</description></item><item><title>ural 1416. Confidential (次小生成树模板题)</title><link>https://111qqz.com/2016/07/ural1416/</link><pubDate>Mon, 11 Jul 2016 19:50:37 +0000</pubDate><guid>https://111qqz.com/2016/07/ural1416/</guid><description>
URAL1416 题意：次小生成树模板题
思路：用Kruskal求最小生成树，标记用过的边。求次小生成树时，依次枚举用过的边，将其去除后再求最小生成树，得出所有情况下的最小的生成树就是次小的生成树。复杂度o(m2)。。。貌似有其他优化。。。
写的时候。。因为点数是500。。我把边集的数组大小开成了500.。。交了10遍越界才意识到问题在哪里。。。真的是智商掉线啊orz...
/* *********************************************** Author :111qqz Created Time :2016年07月11日 星期一 20时44分28秒 File Name :code/ural/1416.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m; int f[N]; int mst; int ans; int cnt = 0 ; vector &amp;lt; pi &amp;gt; e[N*N]; bool flag; struct Edge { int u,v; int w; int in;//标记边是否在生成树中。 bool operator &amp;lt; (Edge b)const { return w&amp;lt;b.</description></item><item><title>退路？</title><link>https://111qqz.com/2016/07/the-way-to-escape/</link><pubDate>Sun, 10 Jul 2016 18:15:40 +0000</pubDate><guid>https://111qqz.com/2016/07/the-way-to-escape/</guid><description>
没有退路。</description></item><item><title>BZOJ 1681: [Usaco2005 Mar]Checking an Alibi 不在场的证明 (spfa)</title><link>https://111qqz.com/2016/07/bzoj-1681-usaco2005-marchecking-an-alibi--spfa/</link><pubDate>Wed, 06 Jul 2016 13:18:30 +0000</pubDate><guid>https://111qqz.com/2016/07/bzoj-1681-usaco2005-marchecking-an-alibi--spfa/</guid><description>
1681: [Usaco2005 Mar]Checking an Alibi 不在场的证明 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 250 Solved: 178 [Submit][Status][Discuss]
Description A crime has been comitted: a load of grain has been taken from the barn by one of FJ's cows. FJ is trying to determine which of his C (1 &amp;lt;= C &amp;lt;= 100) cows is the culprit. Fortunately, a passing satellite took an image of his farm M (1 &amp;lt;= M &amp;lt;= 70000) seconds before the crime took place, giving the location of all of the cows.</description></item><item><title>实训相关&amp;&amp;近况</title><link>https://111qqz.com/2016/07/something-about-school-engineering-training/</link><pubDate>Mon, 04 Jul 2016 20:03:55 +0000</pubDate><guid>https://111qqz.com/2016/07/something-about-school-engineering-training/</guid><description>
哈哈哈哈哈哈哈哈哈 即将身败名裂。。。。 [audio mp3=&amp;quot;https://111qqz.com/wordpress/wp-content/uploads/2016/07/少女幻葬　～Necro-Fantasy-来夢緑.mp3&amp;quot;][/audio]
所以大概老师说的分模块的方法才是正解。。。。。？ 前提是默认每个人都会数据库。。。java....jsp....。。。然而并不。一个都不会。。哈哈哈哈哈哈
这几天大概。。。前几天在看java....嗯。。。。 然后开始配环境。。。linux的eclipse根本没法用。。。。然后就入了idea.... 在idea的官方教程里。。。。一不小心就入了hibernate的坑啊233333 新手友好？ 高度封装了jdbc所以接口更简单？？？ 哈哈哈哈哈 恩，其实都挺好的。。。。然后就死活数据库写不进。。。。。。卡了两天+。。。。。？ 恩。。。hibernate中文文档只有到3.6的。。。。 然后每个版本语法都在变。。。日。。。 找到了4.2的官方文档。。。英文其实就算了。。。尼玛。。这文档应该叫《如何成为一个hibernate高手》吧。。。
一句话。。。被这东西坑成傻逼。。。 可是明明，明明只是要用hibernate框架的最简单的部分啊。。。？ 可是log信息里毫无异常哈哈哈哈
然后大概把mysql学了下。。。不过这东西蛮简单。。。。。所以也不觉得学到了什么。。。。 然后就是一些。。。琐碎的。。。？ 主要是hibernate看了不少。。。。不过据说这东西是深坑。。。。嗯。。。
不过这种项目和ACM的感觉真是非常不一样。。。
ACM是我遇到一道题。。。要用一个新算法。。我知道这个算法的名字。。。。但是智力不够无法理解。。。 项目的话。。。对我来说？）就是出现奇怪的错误。。。然后一脸茫然。。。。不知如何解决。。。。。 不爽的是。。。好多问题。。。全是环境相关的。。。版本不兼容。。IDE不一样。。。容器不一样。。。数据库不一样。。。连接方式不一样。。。每一个不一样都会导致一堆问题。。。真正代码的问题呢。。。？其实并不多。。。。（？
到底还是太缺乏项目经验了。。。。
然后我作为组内唯一一个软工的同学。。。也是唯一一个有一丁丁经验的（面向对象课设）的人。。。必须背锅吧。。。
一个是之前的OS大作业异常顺利平时分拿了满分。。。以及OS课设成功carry全组给了我这种蒟蒻一些奇怪的自信。。。？ （然而并不是一个难度好么233333） 一个是把全组带入了hibernate的坑。。。。哦。。。还有idea....。。。。
身败名裂。。。。没做出来成品的人答辩简直就是羞耻play好么哈哈哈
嘛，天快亮了，整个6月。。。考试。。课设。。。考试。。。实训。。。多久没写题了呢。。。。
暑假。。。暑假。。。。小可前天已经到上海了的样子 。。。（？ google实习太强了orz....ym....
其实我想表达的是。。。。。a holiday without kk....所以。。大概。。。
去年因为见到小可会心情不好所以一个假期几乎（？ 都没有去启明集训的事情不会。。。也不应该再发生了吧。。。。
还是解不开心结。嘛，眼不见，心不烦。
珍惜这个心无杂念的暑假。。。。。</description></item><item><title>实训相关。。。。</title><link>https://111qqz.com/2016/07/</link><pubDate>Sat, 02 Jul 2016 07:44:27 +0000</pubDate><guid>https://111qqz.com/2016/07/</guid><description>
列个技能表。。。。。
java.... mysql... tomcat apache jsp..... idea...?
tomcat是apache的进化。。。。？？？
hibernate...持久层的设计模式。。？？ http://docs.jboss.org/hibernate/orm/</description></item><item><title>poj 2342 Anniversary party (基础树形dp)</title><link>https://111qqz.com/2016/06/poj2342/</link><pubDate>Fri, 24 Jun 2016 06:31:14 +0000</pubDate><guid>https://111qqz.com/2016/06/poj2342/</guid><description>
题目链接
题意：n个人的上下级关系形成一棵树..每一个人有一个val（可正可负），要选若干个人参加一个party,要求是一个人和他的直接上级不能同时在场。问参加party的人最大的val之和。
思路：树形dp入门题。
dp[i][0]和dp[i][1]分别表示第i个人不参加和参加party对应的val和。
注意dp转移方程是放在每次dfs之后的回溯位置的。。。
这样做的话访问是从根节点到叶子节点，更新就成了从叶子节点到根节点。。。
联想到数字三角形...其实是一样的。。
sad...dp苦手如我也开始刷dp了吗。。。。
/* *********************************************** Author :111qqz Created Time :2016年06月24日 星期五 13时07分51秒 File Name :code/poj/2342.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=6E3+7; int n; int a[N]; int in[N]; vector &amp;lt;int&amp;gt; edge[N]; int dp[N][2]; int root; void debug() { for ( int i = 1 ; i &amp;lt;= n ; i++) printf(&amp;quot;%d %d %d\n&amp;quot;,i,dp[i][0],dp[i][1]); } void dfs ( int u,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;endl; int siz = edge[u].</description></item><item><title>geekos project 1 （ELF文件相关）</title><link>https://111qqz.com/2016/06/geekos-project-1-elf/</link><pubDate>Sat, 18 Jun 2016 19:43:34 +0000</pubDate><guid>https://111qqz.com/2016/06/geekos-project-1-elf/</guid><description>
一、目的 熟悉ELF文件格式，了解GeekOS系统如何将ELF格式的可执行程序装入到内存，建立内核进程并运行的实现技术。 二、流程 1、修改/geekos/elf.c文件：在函数Parse_ELF_Executable( )中添加代码，分析ELF格式的可执行文件（包括分析得出ELF文件头、程序头，获取可执行文件长度，代码段、数据段等信息），并填充Exe_Format数据结构中的域值。 2、在Linux环境下编译系统得到GeekOS镜像文件。 3、编写一个相应的bochs配置文件。 4、在bochs中运行GeekOS系统显示结果。
编译以及启动bochs同project0... project0遇到的那些错误还是都会遇到一遍233.
然后在project1/src/geekos/ 目录下的elf.c中添加函数：int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength, struct Exe_Format *exeFormat)
原理部分不过多阐释，具体可见我参考的博客。
最后实现为：
int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength, struct Exe_Format *exeFormat) { elfHeader* header = exeFileData; programHeader* pHeader = (exeFileData+header-&amp;gt;phoff); exeFormat-&amp;gt;numSegments = header-&amp;gt;phnum; exeFormat-&amp;gt;entryAddr = header-&amp;gt;entry; int i = 0; for (; i&amp;lt; header-&amp;gt;phnum; i++) { exeFormat-&amp;gt;segmentList[i].offsetInFile = pHeader-&amp;gt;offset; exeFormat-&amp;gt;segmentList[i].lengthInFile = pHeader-&amp;gt;fileSize; exeFormat-&amp;gt;segmentList[i].startAddress = pHeader-&amp;gt;vaddr; exeFormat-&amp;gt;segmentList[i].sizeInMemory = pHeader-&amp;gt;memSize; exeFormat-&amp;gt;segmentList[i].protFlags = pHeader-&amp;gt;flags; pHeader++; } return 0; //!</description></item><item><title>geek OS project 0 （下）</title><link>https://111qqz.com/2016/06/geek-os-project-0-/</link><pubDate>Sat, 18 Jun 2016 09:48:06 +0000</pubDate><guid>https://111qqz.com/2016/06/geek-os-project-0-/</guid><description>
现在我们环境已经搭好了，参考 geekos实验环境的搭建
在main.c中新加个函数，命名为projecto,函数的代码如下：
/* * GeekOS C code entry point * Copyright (c) 2001,2003,2004 David H. Hovemeyer &amp;lt;daveho@cs.umd.edu&amp;gt; * Copyright (c) 2003, Jeffrey K. Hollingsworth &amp;lt;hollings@cs.umd.edu&amp;gt; * Copyright (c) 2004, Iulian Neamtiu &amp;lt;neamtiu@cs.umd.edu&amp;gt; * $Revision: 1.51 $ * * This is free software. You are permitted to use, * redistribute, and modify it as specified in the file &amp;quot;COPYING&amp;quot;. */ #include &amp;lt;geekos/bootinfo.h&amp;gt; #include &amp;lt;geekos/string.h&amp;gt; #include &amp;lt;geekos/screen.h&amp;gt; #include &amp;lt;geekos/mem.h&amp;gt; #include &amp;lt;geekos/crc32.h&amp;gt; #include &amp;lt;geekos/tss.</description></item><item><title>geekok project0（上）（实验环境的搭建）</title><link>https://111qqz.com/2016/06/geekok-project0/</link><pubDate>Sat, 18 Jun 2016 08:35:49 +0000</pubDate><guid>https://111qqz.com/2016/06/geekok-project0/</guid><description>
apt-get install build-essential apt-get install bochs bochs-x nasm
此处下载的bochs应该是比较新的...如果之后遇到
failed assertion in init_idt :g_handlersizenoterr == g_handlersizeerr 这个错误，建议安装比较老的nasm版本，比如2.08.02链接
下载geekos-0.3软件包，地址为： geekOS下载地址
然后解压到~/work目录。
然后进入到 /work/geekos-0.3.0/src/project0/build 目录下
之后的操作都是在这个目录下进行的。
rkz2013@111qqz-ThinkPad-X200 ~/work/geekos-0.3.0/src/project0/build $ make depend Makefile:249: depend.mak: 没有那个文件或目录 touch depend.mak gcc -M -O -Wall -Werror -g -DGEEKOS -I../include \ ../src/geekos/idt.c ../src/geekos/int.c ../src/geekos/trap.c ../src/geekos/irq.c ../src/geekos/io.c ../src/geekos/keyboard.c ../src/geekos/screen.c ../src/geekos/timer.c ../src/geekos/mem.c ../src/geekos/crc32.c ../src/geekos/gdt.c ../src/geekos/tss.c ../src/geekos/segment.c ../src/geekos/bget.c ../src/geekos/malloc.c ../src/geekos/synch.c ../src/geekos/kthread.c ../src/geekos/main.c \ | perl -n -e 's,^(\S),geekos/$1,;print' \ &amp;gt; depend.mak gcc -M -O -Wall -Werror -I.</description></item><item><title>OS课设之geek os 非最终版</title><link>https://111qqz.com/2016/06/osgeek-os-/</link><pubDate>Fri, 17 Jun 2016 04:09:37 +0000</pubDate><guid>https://111qqz.com/2016/06/osgeek-os-/</guid><description>
参考了这篇博客
流程部分不再具体描述，可以参考上面的博客。
只详细给出我遇到的问题。
我的pc环境是：Linux 111qqz-ThinkPad-X200 3.16.0-38-generic #52~14.04.1-Ubuntu SMP Fri May 8 09:43:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
linux mint 17.2 cinnamon
apt-get install build-essential apt-get install bochs bochs-x nasm http://sourceforge.net/projects/geekos/files/ 下载geekos软件包并且解压
$ cd ~/geekos-0.3.0/src/project0/build$ $ make depend $ make 报错。。
解法办法：修改/home/rkz2013/geekos-0.3.0/src/project0/build
目录下的Makefile文件。
CC_GENERAL_OPTS := $(GENERAL_OPTS) -Werror 改为 CC_GENERAL_OPTS := $(GENERAL_OPTS) make后再次出现错误：
fmtout.c:(.text+0xa16)：对‘__stack_chk_fail’未定义的引用 解决办法：
在project0/build 目录下的makefile文件的148行 添加编译选项 -fno-stack-protector 然后又报错
i386 architecture of input file `geekos/lowlevel.o' is incompatible with i386:x86-64 output 解决办法：</description></item><item><title>华科软院计组概念复习</title><link>https://111qqz.com/2016/06/</link><pubDate>Mon, 13 Jun 2016 09:48:32 +0000</pubDate><guid>https://111qqz.com/2016/06/</guid><description>
noip初赛加强版既视感...
自己手动整理的
第二章 机器数：正负符号数码化后的数据称为机器数。 BCD码：用二进制编码的十进制数称为bcd码。 有权码：每位二进制数码元都有确定权值的编码。 校验码：为了发现或纠正数据传送中出现错误的编码。 浮点数的精度由尾数的位数决定。 第三章 溢出：运算结果超出了机器能表示的数据范围。 溢出的特征：结果的符号与操作数的符号不同。 变形补码：两个符号位的补码（用来检测溢出，00,11说明没有溢出，10,01说明有溢出） 对阶：使阶码相等的过程（原则是小阶码向大阶码看齐） 结果规格化：将非规格化数处理为规格化形式。 *根据指令中所含操作数地址的数量可分为（4种）： 三地址指令 双地址指令 单地址指令 零地址指令
第四章 存储位：存储器记忆信息中的最小单元。 地址：每个存储单元的编号。 主存储器的技术指标：存储容量，存取时间，存储周期，存储器带宽。（两类：存取速度和存储容量） 存储体：存储器中的记忆部件，通常由大量的存储单元组成。 MROM:掩膜型只读存储器。 PROM:可编程只读存储器。 EPROM：可擦写可编程只读存储器。 EEPROM：电可擦除可编程只读存储器（扩展） CACHE对程序员是透明的。 内存：Cache 与主存合称为内存。 全相联映射：将主存分成若干块，主存的任意一快可定位于Cache的任意一块中。 组相联映射：将主存分成若干区，每一区包括若干组，每一组包含若干块；将Cache也分成若干组，每组若干块。 组之间用直接映射方式，组内的块采用全相联映射方式 替换策略：最不经常使用（LFU，近期最少使用(LRU，随机替换 写操作策略：全写法（命中时既写入Cache，又写入主存） 写回法（命中时只写入Cache，不写入主存） 写一次法（第一次采取全写法，之后采取写回法） 硬盘存储器的主要指标包括存储密度、存储容量、存取时间及数据传输率。 平均存取时间：从发出读/写命令后到开始从盘片表面读出或写入信息所需要的平均时间。 平均存取时间=平均寻道时间+平均等待时间。
数据传输率：存储器在单位时间向主机传送数据的字节数。
*DRAM刷新方式： 集中刷新方式 分散刷新方式 异步刷新方式 第五章 机器指令：计算机能够直接识别，执行的指令称为机器指令，简称指令。 指令集；一台计算机中所能执行的指令的集合称为指令集（指令系统） 指令包含两种信息：指令和数据。 寻址方式：根据指令中的信息寻找物理地址的方式。 寻址方式包含指令寻址方式和操作数寻址方式两大类。 指令寻址方式：顺序寻址方式和跳跃寻址方式。 操作数寻址方式：直接寻址，寄存器相对寻址，寄存器间接寻址，基指+变址等 为什么多种寻址方式：效率和方便性上达到平衡，满足各种需要。 RISC指令系统特点： 指令系统简单，指令条数少； 寻址方式少； 指令格式简单，指令长度固定 cpu中设置大量寄存器以减少对存储器的访问。
**cache的工作原理： 当cpu访问的内存地址给出后，该地址先与相连存储器中存放的地址比较， 判定要访问的字是否在Cache中，在则访问Cache，称为命中； 不在则访问主存，称为未命中。 命中时需要先产生访问Cache的地址 未命中时根据cpu给出的地址访问主存。 第六章 中央控制器的主要功能： 指令序列控制 操作控制 时间控制</description></item><item><title>差不多是条咸鱼了</title><link>https://111qqz.com/2016/06/kk-is-salty-fish/</link><pubDate>Sat, 11 Jun 2016 08:01:04 +0000</pubDate><guid>https://111qqz.com/2016/06/kk-is-salty-fish/</guid><description>
最近睡眠特别差...
一睡能睡18个小时。。。醒了之后依旧头疼。。。
一直在做乱七八糟的梦...
除了那种特别恶劣的噩梦...就是特别让人感到委屈的梦...
比如小学某次老师提问古诗，我在梦里都不会背错的一句，然后就偏说我错了╭(╯^╰)╮
然而正确答案和我背的没区别啊。。。。还被罚写20遍。。。。妈蛋
诸如这种，委屈+max
然后不知道是不是之前用力过猛（？
明显觉得没力气了
可是明明还有一堆考试还有OS课设以及实训...
就感觉特别没力气
休息不过来的感觉...
sad</description></item><item><title>codeforces 660 C. Hard Process (ruler)</title><link>https://111qqz.com/2016/06/codeforces-660-c-hard-process-ruler/</link><pubDate>Wed, 08 Jun 2016 16:17:00 +0000</pubDate><guid>https://111qqz.com/2016/06/codeforces-660-c-hard-process-ruler/</guid><description>
cf660C
solution:ruler.1A
/* *********************************************** Author :111qqz Created Time :2016年06月08日 星期三 23时43分18秒 File Name :code/cf/problem/660C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int n,k; int sum[N],a[N]; void ruler() { int head = 1; int tail = 1; int l,r; int res = -1; int cnt = 0 ; while (tail&amp;lt;=n) { while (a[tail]==1) tail++; // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;endl; if (a[tail]==0&amp;amp;&amp;amp;tail&amp;lt;=n) cnt++; while (sum[tail]-sum[head-1]&amp;lt;=k&amp;amp;&amp;amp;tail&amp;lt;=n) tail++; // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot;tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;endl; if (tail-head&amp;gt;res) { res = tail-head; // cout&amp;lt;&amp;lt;&amp;quot;res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; l = head; r = tail-1; } while (head&amp;lt;=tail&amp;amp;&amp;amp;sum[tail]-sum[head-1]&amp;gt;k) head++; // cout&amp;lt;&amp;lt;&amp;quot;head::&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;endl; if (tail&amp;lt;=n&amp;amp;&amp;amp;tail-head+1&amp;gt;res) { res = tail-head+1; l = head; r = tail; } } for ( int i = l ; i &amp;lt;= r ; i++) a[i] = 1; cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt;= n ; i++) cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>（转）树形dp题目集</title><link>https://111qqz.com/2016/06/dp/</link><pubDate>Sun, 05 Jun 2016 18:37:06 +0000</pubDate><guid>https://111qqz.com/2016/06/dp/</guid><description>
树，一种十分优美的数据结构，因为它本身就具有的递归性，所以它和子树见能相互传递很多信息，还因为它作为被限制的图在上面可进行的操作更多，所以各种用于不同地方的树都出现了，二叉树、三叉树、静态搜索树、AVL树，线段树、SPLAY树，后缀树等等..
枚举那么多种数据结构只是想说树方面的内容相当多，本专辑只针对在树上的动态规划，即树形DP.做树形DP一般步骤是先将树转换为有根树，然后在树上进行深搜操作，从子节点或子树中返回信息层层往上更新至根节点。这里面的关键就是返回的信息部分，这个也没一般性的东西可讲，因为每道题目要求做的事都不尽相同。
这个专辑暂时氛围3哥部分，分的可能不是很好，后面题目做多了理解更深了可能会更改，但那都是后话了。
一、常规树形DP 1、 Hdu 1520 Anniversary party 每个节点有权值，子节点和父节点不能同时选，问最后能选的最大价值是多少？解题报告Here
 2、Hdu 2196 Computer 经典题，求树每个点到其他点的最远距离，转化为有根树，深搜两次，一次记录到叶子的最远距离，一次更新最终答案。解题报告Here
 3、Poj 1741 Tree(难) 经典题，求树上两点间距离小等于K的方案数，树上分治。解题报告Here
 4、Poj 2152 Fire（难）  罕见的O(n^2)的树形DP，在树上建消防站，要求每个节点离最近的消防站距离小于K,问最小花费。解题报告Here
 5、Poj 3162 Walking Race（难）  树形DP找最远距离+线段树查询最大最小值，然后再维护两个指针遍历整个序列。解题报告Here
 6、cf 218D. Choosing Capital for Treeland 把边方向转变成边权，正向为0，反向为1.经过转换，问题变成求某点为根到所有点的边权总和，求边权总和最小的那些点。
二、树形背包问题(在树上进行分组背包处理) 1、Poj 1155 TELE 把每个节点的子节点看成一组背包，最大容量是这点的叶子子孙数量，选几个节点就是选择的容量，价值就是用户给的Money-中转费用。解题报告Here
 2、Hdu 1011Starship Troopers 和上题相似，要选择父节点必先子节点，特判m为0的时候。
 3、Poj 1947 Rebuilding Roads 求最少删除几条边使得子树节点个数为p，具体的模型和上题很像。解题报告Here
 4、Hdu 1561 The more, The Better 在一棵树上选择若干个点获得的最大价值，选子节点必须先选父节点，求解情况和上两题相同。解题报告Here
 5、Hdu 4003 Find Metal Mineral (推荐，好题) 树形DP+选且只能选一个物品的分组背包，状态转移方程难想。解题报告here</description></item><item><title>匈牙利算法总结</title><link>https://111qqz.com/2016/06/</link><pubDate>Sun, 05 Jun 2016 17:20:45 +0000</pubDate><guid>https://111qqz.com/2016/06/</guid><description>
学完了km..感觉匈牙利真是非常的。。easy... 匈牙利算法学习链接
有一种题目会用1*2的小格子填充大的，问能不能填满之类的，可以用匈牙利搞。hdu 4185解题报告 poj2446解题报告
其实主要是关于建图的启示，上面两个题，还有这道题： poj1325解题报告
还有就是一些有用的结论：
**(1)二分图的最小顶点覆盖 ** 最小顶点覆盖要求用最少的点（X或Y中都行），让每条边都至少和其中一个点关联。
Knoig定理：二分图的最小顶点覆盖数等于二分图的最大匹配数。
(2)DAG图的最小路径覆盖
用尽量少的不相交简单路径覆盖有向无环图(DAG)G的所有顶点，这就是DAG图的最小路径覆盖问题。
结论：DAG图的最小路径覆盖数 = 节点数（n）- 最大匹配数（m）
(3)二分图的最大独立集
最大独立集问题： 在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边．求m最大值
结论：二分图的最大独立集数 = 节点数（n）— 最大匹配数（m）
还有一个比较常用的角度：n个数的某种排列，可以看做是一个位置集合{1..n}和数字集合{1..n}的二分图最大匹配。可以用来剪枝什么的。hdu3225解题报告</description></item><item><title>KM算法总结</title><link>https://111qqz.com/2016/06/km/</link><pubDate>Sun, 05 Jun 2016 17:07:59 +0000</pubDate><guid>https://111qqz.com/2016/06/km/</guid><description>
km算法我的理解
刷了不到20道题。。。回来总结一发。。
如果题目求的是最小权值匹配，比较好的做法是将权值取取值，最后res再取负就好。需要注意的是初始化的时候w和lx要比所有值都小，所以要ms(lx,0xc0)
最正确解最小权匹配的办法是用一个很大的数-当前边权值，而不是直接对边权取反(这样只能处理左右点相等的完全二分图，即K(n, n)(bin神博客看到的)
有时候需要考虑无解的情况，一般如果有无解的情况，对应了存在lx[i]=初始化的值。
不少题目有一个点都是先用一种暴力或者不暴力的方法处理出w,然后裸的km hdu3722解题报告
有向图的覆盖可以对应二分图最佳匹配的模型，用km算法搞 hdu1853解题报告
遇到了一种题是之前有一些已经安排好了，然后仍然求最优匹配，并且尽可能少得改变原有的安排。hdu2853解题报告 不得不说做法很厉害。
还有一些网络流的题似乎也可以转化成km来做，打算先去搞一发网络流再去A.
这些题里就两个比较好，一个是对于有向环覆盖的，第一次遇到真想不到，还有一个就是那个权值×k的。。。佩服。。。
其他的都是套路。</description></item><item><title>20160605随笔</title><link>https://111qqz.com/2016/06/20160605/</link><pubDate>Sun, 05 Jun 2016 13:35:06 +0000</pubDate><guid>https://111qqz.com/2016/06/20160605/</guid><description>
妈呀。。。6天之后两门考试。。。计组+OS...害怕。。。。
小可开始刷神题了orz... 一个只有40+人过的神级状压dp...吓傻了。。
毕竟小可啊，要是有她一半实力就满足了orz...
然后大物。。。重修。。因为没去过。。。所以没有考试资格。。。？？？卧槽。。。。
正在想办法补救。。打算把作业都补好然后去找老师。。。
然后手头还有一个软件工程大作业，然后大作业之后就是考试。。。然后考完还有一个课设。。然后还有一个工程实训。。。。妈蛋。。。
大一什么的。。。不堪回首。。。什么都没做。。。哦也不是，要说做了什么，就是大一下所有科目差不多都挂了（手动微笑）。。。还差点死了2333
所以我之后的日子有多少，都是因为大一下那一学期。。。。
算了不提，好歹活到了现在，应该心怀感激才对吧。
倒也没什么压力，就是有点烦。。。
其实这学期还是进步得比较多的。。。？虽然说好的这学期学数学。。。买了《组合数学》在看，以及叉姐在知乎上推荐的某数论电子版。。。然而组合数学只看了排列组合，抽屉原理，容斥原理，母函数就没看了。。。数论。。。似乎也没看多少。。。？
基本都是比赛倒向型了。。。每次比赛卡什么题目就去学什么。。。
所以这学期大概学了：区间莫队。。。母函数。。。数位dp。。。LCA的离线写法。。容斥。。。动态连通性的低配版。。。manacher.....（kmp还是没看懂orz）.。。。rmq。。。lca的在线写法。。。匈牙利。。。KM....
主要就这些。。其他都是些小东西了。。。这么一列好像又挺少的。。。
然后最大的收货大概是之前有一个误区。。。。之前有点太在意cf rating了。。。
我觉得我是不太适合打cf的。。。之前也补了好多题。。但是cf rating却也不见长。。也别无力。。。
这学期基本没打cf。。。还是刷专题比较重要。。。。
感觉刷专题就像高一高二学习知识一样。。。。cf嘛。。。更像高三的时候做的事也许？
嘛，有的人说cf是为了保持比赛的感觉。。。。平时的比赛还是挺多的。。。所以也不会缺这个感觉。
祝我平安度过这个月。。。
然后暑假，干他丫的！</description></item><item><title>HDU 3523 Image copy detection (二分图最佳匹配，KM算法，题意杀)</title><link>https://111qqz.com/2016/06/hdu-3523/</link><pubDate>Fri, 03 Jun 2016 11:55:36 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3523/</guid><description>
hdu 3523 题目链接
题意：有m个排列，每个排列有n个，然后要找一个长度为n的排列（1..n每个数字恰好出现一次），使得这个排列到其他m个排列的距离之和最小。 两个排列之间的距离是对应位置上数字差的绝对值的和。
思路：妈蛋，什么鬼题面。。。看不懂。。。然后看了题解。。。知道了题意。。
的的确确做过相当类似的一道呢。
先nnn的复杂度(1E6)处理权值，然后KM.
1A.
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 19时34分36秒 File Name :code/hdu/3523.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; int a[N][N]; int w[N][N]; int lx[N],ly[N]; int link[N]; bool visx[N],visy[N]; int slk[N]; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0xc0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= n ; j++) if (!</description></item><item><title>hdu 3315 My Brute （二分图最佳匹配,KM算法）</title><link>https://111qqz.com/2016/06/hdu-3315/</link><pubDate>Fri, 03 Jun 2016 09:26:47 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3315/</guid><description>
hdu3315 题目链接
题意：两个人分别各有n个怪物。进行n场pk.每只怪物必须恰好进行一场pk.如果先手的第i只怪物赢，会获得v[i]的val,输会减少v[i]的val.给出两个人n只怪物的血量和攻击力。先手的初始战斗顺序为1,2,3..n（后手的战斗顺序一直都是1,2,3..n) 现在问能否通过调整顺序使得先手获得的val最大，如果这个val大于0，表示先手可以赢。如果可以赢，那么还要求调整后的顺序和原始顺序的相似度，并且使得相似度尽可能大（If there are multiple orders, you should choose the one whose order changes the least from the original one）
思路：先根据血量和攻击力，n*n的时间处理出每场战斗的输赢信息，然后结合v[i]，得到每两个怪物战斗的先手得到的val的值。
然后和hdu 1853类似，依然希望尽可能多的安排不改变。
我们的做法仍然是把w*N,然后钦定的w再+1
然后改变个数，由于存在负数。。。和hdu 1853的处理有区别。。。
想了一下。。。其实用link数组对照初始钦定顺序就好了啊。。。
1A.爽上天。。。
最近各种1A...？好开心。
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 15时46分12秒 File Name :code/hdu/3315.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int val[N]; int h[N],p[N],a[N],b[N]; int win[N][N]; int w[N][N]; int lx[N],ly[N]; bool visx[N],visy[N]; int link[N]; int slk[N]; int num; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0xc0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while(1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= n ; j++) if (!</description></item><item><title>hdu 2853 Assignment (二分图最佳匹配，KM算法+数论，做法太神)</title><link>https://111qqz.com/2016/06/hdu-2853/</link><pubDate>Fri, 03 Jun 2016 07:36:50 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2853/</guid><description>
hdu 2853题目链接
题意：n个公司，m个任务（m&amp;gt;=n),一个公司只能对应一个任务，一个任务也只能对应一个公司。给出一个n*m的mat,表示每个公司对应每个任务产生的val。 然后给出n个数，表示初始钦定（雾）这n个公司分别做哪些任务。 但是可能初始的安排得到的val表示最大的。我们现在想得到最大的val,并且保证改变的安排数最少。求安排后得到的 val比初始安排大多少，以及需要改变的安排数量。
思路：最大val很好求，KM就好。。。但是，怎么才能保证改变的安排数最少呢？ 尤其是当两个安排val一样的时候，如何才能保证优先选已经安排好的，而不取选另一个呢？
并没有想出来，看了题解T T
太神辣。
由于KM算法会根据权值来选取，权值大的会优先。
如果我们把每个权值*k(k&amp;gt;n)，然后对于已经钦定的安排，每个权值再+1.
这样，钦定的安排就会有更高的优先级，最后统计的时候除以k,那么权值答案不会有影响（利用到了初等数论的整除知识。。。？）
然后这样做该有一个好处。
不除以k的权值和再模k,就是没有改变的安排数。
原因是由于没有钦定的安排的权值每个都乘了k,最后%k都为0，只有那些钦定的安排每个会贡献1.
又由于k&amp;gt;n,这样就保证了正确性。
这做法太神了。。。。。吓傻了。。。。
我试着推广一下。。。？
对于根据权值来决定优先顺序，但是权值相同的时候还是需要对一些赋有更高的优先权的模型。。。？
除了再增加一维的大家都能想到的做法。。。这样的做法是不是有通用性呢。。。？
做法太神，我得慢慢体会。。
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 14时35分46秒 File Name :code/hdu/2853.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 55; int n,m; int w[N][N]; int id[N]; int lx[N],ly[N]; int link[N]; bool visx[N],visy[N]; int slk[N]; int num; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= m ;v++) { if(visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= m ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= m ; j++) if (!</description></item><item><title>hdu 2448 Mining Station on the Sea (floyd+KM)</title><link>https://111qqz.com/2016/06/hdu-2448/</link><pubDate>Thu, 02 Jun 2016 22:15:14 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2448/</guid><description>
hdu2448 题目链接
题意：n个船n个港口，一个港口只能承接一个船，m个油田，给出n个船各自在哪个油田，然后给出m个油田之间的无相图，然后给出油田和港口之间的有向图。求n个船到达港口的最小距离之和。
思路：想到了用floyd先更新一下距离，然后KM.不过思维不够严谨，只更新了港口通过油田到达油田的距离，而没有更新油田通过油田到达油田的距离QAQ.
所以应该先更新油田通过油田到达油田的距离，然后再更新港口通过油田到达油田的距离。。。
哦，还有。。。不要把n个船所对应的港口作为下标。。而是转化成1..n，这样写KM里会比较好写。。。不然总得带着那个id[i].
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 03时07分16秒 File Name :code/hdu/2448.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n,m,k,p; int id[N]; int a[N][N],b[N][N]; int lx[N],ly[N]; int link[N]; bool visx[N],visy[N]; int slk[N]; int w[N][N]; bool find( int u) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;endl; visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if(tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } LL KM() { ms(link,-1); ms(lx,0xc0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= n ; j++) if (!</description></item><item><title>hdu 3718 Similarity (二分图最优匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-3718/</link><pubDate>Thu, 02 Jun 2016 18:37:58 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3718/</guid><description>
hdu 3718题目链接
题意：东西分类作业，有n个东西,k组，m个学生，不同种类的东西用不同的字母表示，相同种类的用同一个字母表示。不同学生和标准答案之间可能表示同一类东西用的字母不同，但是字母只是一个标号（But the LABEL of group doesn't make sense and the LABEL is just used to indicate different groups. ） 给出事物分类的标准答案和每个学生的答案现在问每个学生的正确率是多少。
思路：用map&amp;lt;char,int&amp;gt;把字母转化成点的标号。然后初始化权值为0. 对于每个学生，o(n)扫一遍统计出w。然后做一遍KM求最大正确数。从而得到正确率。 因为一个map忘记每次清空，WA了一次。。。2A..
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 01时32分27秒 File Name :code/hdu/3718.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,k,m; char a[35][N]; int w[35][35]; map&amp;lt;char,int&amp;gt;mp1,mp2; int tot1,tot2; int lx[35],ly[35]; bool visx[35],visy[35]; int link[35]; int slk[35]; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= k ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= tot2 ; i++) for ( int j = 1 ; j &amp;lt;= k ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= tot2 ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ;j &amp;lt;= k ; j++) if (!</description></item><item><title>hdu 3722 Card Game (有向环覆盖，拆点，二分图最佳匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-3722/</link><pubDate>Thu, 02 Jun 2016 16:03:28 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3722/</guid><description>
hdu 3722题目链接
题意：n个串，a串放在b串前面的val值是“The score of sticking two cards is the longest common prefix of the second card and the reverse of the first card”.问如何放使得总的val最大。
思路：先暴力处理出每两个的权值。。2002001000的复杂度。。还是可以接受的。。
然后把每个串看成了一个点，由于一个串最多可以被放在前面一次，被放在后面一次，所以可以类比图论中的环的入度和出度为1.
然后跑一遍KM. 1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年06月02日 星期四 23时37分55秒 File Name :code/hdu/3722.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n; char st[N][1005]; int w[N][N]; int link[N]; int lx[N],ly[N]; bool visx[N],visy[N]; int slk[N]; int solve(string a,string b) { int la = a.</description></item><item><title>hdu 3435 A new Graph Game (有向环覆盖，拆点，二分图最优匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-3435/</link><pubDate>Thu, 02 Jun 2016 15:10:43 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3435/</guid><description>
hdu 3435题目链接
题意：给你一张图，图上可能有多个哈密顿回路。叫你求出形成多个哈密顿回路的总距离最小值
思路：题意杀啊。。。什么鬼了。。。然后时间。。1000的数据。。n3复杂度。。。还多组数据。。。。不是很懂这个时间是怎么算的。。为毛才2600MS啊。。。。
做法同hdu 1853...
/* *********************************************** Author :111qqz Created Time :2016年06月02日 星期四 20时13分25秒 File Name :code/hdu/1853.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+4; int n,m; bool visx[N],visy[N]; int link[N]; int lx[N],ly[N]; int slk[N]; int w[N][N]; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(lx,0xc0); ms(ly,0); ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) if (lx[i]==-inf-1) return -1; //?</description></item><item><title>hdu 1853 Cyclic Tour (有向环覆盖，拆点，二分图最佳匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-1853/</link><pubDate>Thu, 02 Jun 2016 12:44:26 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-1853/</guid><description>
hdu 1853 题目链接
题意：一个带权有向图，要求找出若干的环，满足每个点恰好在一个环里，并且环的权值和最小……问最小权值和。
思路：没有思路，不知道怎么处理环的问题。于是去群里问了下。正确做法是拆点。
如果有一条边i-&amp;gt;j,那么就连一条i-&amp;gt;j'的边。
正确性：
对于满足条件的环，每个点的入度和出度均为1，我们可以把每个点拆成入点和出点，那么也就是说一个入点对应一个出点，反之亦然，那么这个问题就变成了一个二分图匹配问题， 然后这道题有重边，2A.
又一次体会到了拆点的神奇。。。这个大概算是需要慢慢积累的技巧吧。。像辅助线一样的。。。
还有体会到了环的模型竟然也可以转化成二分图匹配，真是厉害==
/* *********************************************** Author :111qqz Created Time :2016年06月02日 星期四 20时13分25秒 File Name :code/hdu/1853.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n,m; bool visx[N],visy[N]; int link[N]; int lx[N],ly[N]; int slk[N]; int w[N][N]; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(lx,0xc0); ms(ly,0); ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) if (lx[i]==-inf-1) return -1; //?</description></item><item><title>hdu 2813 One fihgt one (二分图最优匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-2813/</link><pubDate>Thu, 02 Jun 2016 11:44:03 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2813/</guid><description>
hdu 2813 题目链接
题意：吕布有n个武将，曹操有m（m&amp;gt;=n）个武将。给出k个关系，为吕布的某个武将和曹操的某个武将pk后会受到的伤害。吕布要求他所有n的武将都要上场，每个武将只能战斗一次，问如何安排，使得所有武将受到的伤害总和最小。
思路：裸的KM。 用map把武将名字变成点的编号。
/* *********************************************** Author :111qqz Created Time :2016年06月02日 星期四 19时17分19秒 File Name :code/hdu/2813.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n,m,k; map&amp;lt;string,int&amp;gt;mp,mp2; int tot1,tot2; int w[N][N]; int lx[N],ly[N]; int link[N]; bool visx[N],visy[N]; int slk[N]; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= m ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(lx,0xc0); ms(ly,0); ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= m ; j++) lx[i] = max(lx[i],w[i][j]); // for ( int i = 1 ; i &amp;lt;= n ; i++) cout&amp;lt;&amp;lt;&amp;quot;lx[i]:&amp;quot;&amp;lt;&amp;lt;lx[i]&amp;lt;&amp;lt;endl; for ( int i = 1; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= m ; j++) if (!</description></item><item><title>hdu 2282 Chocolate (二分图最优匹配,KM算法)</title><link>https://111qqz.com/2016/06/hdu-2282/</link><pubDate>Thu, 02 Jun 2016 11:08:10 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2282/</guid><description>
hdu 2282 题目链接
题意：n个盒子围成一个圈，给出n个盒子中每个盒子中的巧克力个数，巧克力的总数不超过n，从一个盒子中移动一块巧克力到相邻的盒子里称为one “move”，（由于围成一个圈，所以第1个和第n个盒子也是相邻的） 问最小的移动“move”数，使得每个盒子里最多有一快巧克力。
思路：先记录每块巧克力的位置，为了之后算w,然后将巧克力和盒子分别看做X,Y集合。。。建图。 然后KM 。。1A
/* *********************************************** Author :111qqz Created Time :2016年06月01日 星期三 21时12分48秒 File Name :code/hdu/2282.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m; int p[N]; //p[i]表示第i个巧克力的初始位置。 int a[N]; int lx[N],ly[N]; bool visx[N],visy[N]; int link[N]; int slk[N]; int w[N][N]; void init() { m = 0 ; ms(p,-1); } int calw(int x,int y) { int res = abs(x-y); res = min(res,n-res); //cout&amp;lt;&amp;lt;&amp;quot;res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; return -res; } bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - calw(p[u],v); if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0xc0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= m ; i++) for ( int j = 1 ; j &amp;lt;= n ;j++) lx[i] = max(lx[i],calw(p[i],j)); // for ( int i = 1 ; i &amp;lt;= m ; i++) cout&amp;lt;&amp;lt;&amp;quot;p[i]:&amp;quot;&amp;lt;&amp;lt;p[i]&amp;lt;&amp;lt;endl; // for ( int i = 1 ; i &amp;lt;= m ; i++) cout&amp;lt;&amp;lt;&amp;quot;lx[i]:&amp;quot;&amp;lt;&amp;lt;lx[i]&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt;= m ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= n ; j++) if (!</description></item><item><title>kkkkk?</title><link>https://111qqz.com/2016/06/kkkkk/</link><pubDate>Thu, 02 Jun 2016 10:50:21 +0000</pubDate><guid>https://111qqz.com/2016/06/kkkkk/</guid><description>
可可可可可？</description></item><item><title>hdu 3395 Special Fish (二分图最佳匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-3395/</link><pubDate>Wed, 01 Jun 2016 13:03:25 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3395/</guid><description>
hdu 3395题目链接
题意：鱼，一些鱼认为自己是汉子，然后他会去和他认为是妹子的鱼啪啪啪，然后被啪啪啪的妹子就会产卵？ 卵的val是它parent的val的异或。给出n，为鱼的数量，然后给出一个n*n的 mat,a[i][j]==1表示第i条鱼认为第j条鱼是妹子。问卵的最大val之和是多少。需要注意的是：每条鱼最多可以去和一个妹子啪，并且可以作为妹子被啪一次（这两个是独立的。。。） （Each fish can attack one other fish and can only be attacked once）
思路：二分图最佳匹配，KM算法，2A.
/* *********************************************** Author :111qqz Created Time :2016年06月01日 星期三 20时38分58秒 File Name :code/hdu/3395.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int w[N][N]; char a[N][N]; int val[N]; bool visx[N],visy[N]; int link[N]; int lx[N],ly[N]; int slk[N]; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } } else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(lx,0); ms(ly,0); ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); // for ( int i = 1 ; i &amp;lt;= n ; i++) if (lx[i]==0) return -1; for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= n ; j++) if (!</description></item><item><title>hdu 2426 Interesting Housing Problem (二分图最佳匹配，km算法)</title><link>https://111qqz.com/2016/06/hdu-2426/</link><pubDate>Wed, 01 Jun 2016 12:33:45 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2426/</guid><description>
hdu 2426 题目链接
题意：n个学生，m个宿舍，每个学生住一个宿舍，然后n个学生给若干个宿舍打分，分数可正可0可负，学生不能住打的分为负的宿舍，或者没有打分的宿舍。问在满足上述条件的前提下，所有学生住的宿舍的分数之和最大是多少。如果无解输出-1.
思路：二分图最佳匹配。。。读漏题QAQ. 原来分数为负的房间是不能住的啊。。。。
考虑无解的情况，如果学生数比宿舍数多，无解。
如果一个学生不喜欢任何宿舍或者没给任何宿舍打分，无解。
然后KM.
/* *********************************************** Author :111qqz Created Time :2016年06月01日 星期三 19时35分04秒 File Name :code/hdu/2426.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m,e; int w[N][N]; int link[N]; int lx[N],ly[N]; bool visx[N],visy[N]; int slk[N]; void init() { ms(w,0xc0); } bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= m ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u ; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(lx,0xc0); ms(ly,0); ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= m ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) if (lx[i]==-inf-1) return -1; for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (true) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= m ; j++) if (!</description></item><item><title>hdu 1533 Going Home (二分图最佳匹配，KM算法)</title><link>https://111qqz.com/2016/06/hdu-1533/</link><pubDate>Wed, 01 Jun 2016 11:23:49 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-1533/</guid><description>
hdu 1533 题目链接
题意：给出一个n*m的maze，其中包含不超过一个人（用m表示），以及和人数相等的房子（用H表示），其他都是‘.’，表示可以经过的路径。人向一个方向移动花费代价1.问每个人都回到一个房子里的最小代价是多少。ps:每个格子是无限大的，也就是所有人可以同时踩在一个格子里。以及：路过一个房子可以不住，而只是“经过”。
思路：有了那两个条件，这题就是赤裸的二分图最优匹配了。建图也很easy.可以预处理下w,就是两点的哈密顿距离.
需要注意的是这道题求的是最小权值。那么做法就是将w取负，然后答案再次取负即可。
（还有其他方法处理，不过这种最easy应该？）
（不过要保证初始化某些数组的时候要比所有的值小，所以不能是0，而应该是-inf)
以及：初始化数组为-inf的方法，可以memset(lx,0xc0,sizeof(lx));
这样得到的-inf只和inf的绝对值差1，好评如潮。
0xc0,0xc0,0xc0,重要的常数说三遍
哦还有，不要忘记在每次find的时候记录X集合中的点，这是比hungary算法的find里多的一个步骤，并且是容易忘记的。。。
/* *********************************************** Author :111qqz Created Time :2016年06月01日 星期三 16时45分41秒 File Name :code/hdu/1533.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; char maze[N][N]; int tot1,tot2; int w[N][N]; int link[N]; bool visx[N],visy[N]; int lx[N],ly[N]; int slk[N]; struct point { int x,y; point(){} point(int _x,int _y): x(_x),y(_y){}; int dis(point b) { int res; res = abs(x-b.</description></item><item><title>hdu 2255 奔小康赚大钱 (二分图最佳匹配，KM算法模板题）</title><link>https://111qqz.com/2016/06/hdu-2255--km/</link><pubDate>Wed, 01 Jun 2016 08:30:31 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2255--km/</guid><description>
hdu 2255 题目链接
题意：传说在遥远的地方有一个非常富裕的村落,有一天,村长决定进行制度改革：重新分配房子。 这可是一件大事,关系到人民的住房问题啊。村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。 另一方面,村长和另外的村领导希望得到最大的效益,这样村里的机构才会有钱.由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万.(当然是在他们的经济范围内).现在这个问题就是村领导怎样分配房子才能使收入最大.(村民即使有钱购买一间房子但不一定能买到,要看村领导分配的).
思路：这是一道裸的二分图最佳匹配题目。
如果G为加权二分图,则权值和最大的完备匹配称为最佳匹配. 解决二分图最佳匹配的常用算法为KM算法，该算法的前置技能点为匈牙利算法。
参考了以下文章： 关于KM算法的详细解释 km算法 求最大权二分匹配的KM算法
km算法模板
先粗浅得说下我对这个算法的理解，等A掉足够多的题目之后再回来总结。
因为才刚刚学习这个算法，可能有很多没理解透彻或者理解错误的地方，还望各位多多指教。
KM算法引入了一个交顶标的概念，lx[i]表示X集合中第i个点的顶标，ly[i]表示Y集合中第i个点的顶标。至于这个顶标具体代表什么先不用考虑，只需要知道，这个概念的引入是为了解决二分图最佳匹配的问题。
如果一组xi,yi,满足lx[xi]+ly[yi]-w[xi][yi]&amp;gt;=0成立，那么我们称这组点为【可行的】
我们要时刻保证每组点都是可行的。
如果我们把所有满足lx[xi]+ly[yi]==w[xi][yi]的（xi,yi）导出，形成一个新的图，那么新图的最大匹配一定是原图的最佳匹配。原因也很简单：新图的权值和等于所有的顶标和，而根据【可行】点对的定义，最好的情况就是所有不等式都取了等号。
为了保证初始时lx[xi]+ly[yi]-w[xi][yi]对于任意xi,yi成立，不妨这样构造lx[],ly[]:
lx[i]=max(w[i][j]),(1=&amp;lt;j&amp;lt;=ny) ，ly[i]=0;
注意是“不妨”，也就是初始值并不是唯一的，只不过这种构造方法在满足不等式的前提下相对简单。
然后就和hungary算法基本类似，从每一个X集合中的点开始寻找增广路。
但是。。但是哪有那么好的事情。。。就那么恰好满足lx[xi]+ly[yi]=w[xi][yi]了。。？
没有满足的怎么办。
接下来就要说KM算法最关键的一步，调整顶标。
我们调整顶标的目的是让更多的点对满足式子lx[xi]+ly[yi]==w[xi][yi]，从而进入相等子图,直到图中存在仅由可行边组成的完全匹配为止.
**调整的过程中仍然要保证所有点对都【可行】**也就是保证lx[xi]+ly[yi]&amp;gt;=w[xi][yi]一直成立。
由于当前lx[xi]+ly[yi]-w[xi][yi]是比我们预期的大，所以我们要想办法减小。
具体方法为：
方法为：将所有在增广轨中（就是在增广过程中遍历到）的X方点的标号全部减去一个常数d，所有在增广轨中的Y方点的标号全部加上一个常数d，则对于图中的任意一条边(i, j, W)（i为X方点，j为Y方点）： 点对经过调整后分为四种情况：
i和j都在增广轨中：此时边(i, j)的(lx[i]+ly[j])值不变，也就是这条边的可行性不变（原来是可行边则现在仍是，原来不是则现在仍不是）； **i在增广轨中而j不在：此时边(i, j)的(lx[i]+ly[j])的值减少了d，也就是原来这条边不是可行边（否则j就会被遍历到了），而现在可能是；** j在增广轨中而i不在：此时边(i, j)的(lx[i]+ly[j])的值增加了d，也就是原来这条边不是可行边（若这条边是可行边，则在遍历到j时会紧接着执行DFS(i)，此时i就会被遍历到），现在仍不是； &amp;lt;4&amp;gt;i和j都不在增广轨中：此时边(i, j)的(lx[i]+ly[j])值不变，也就是这条边的可行性不变。
简单得说：(1) (3)(4)三种情况，不会改变一组点的可行性，用白话解释就是，以前满足那个等式而进入相等子图的点对不会因为调整而从相等子图中出来，以前不满足那个等式的点不会因为调整而进入相等子图。
而对于情况（2），因为lx[xi]+ly[yi]-w[xi][yi]减少了，那么以前不满足，现在有可能满足。注意，现在还只是可能满足。
那么这个常数d到底是多少？怎么确定？
是的，接下来的着手点就在这个d上。
那么d的值应取多少？显然，整个点标不能失去可行性，也就是对于上述的第类边，其lx[i]+ly[j]=W这一性质不能被改变，故取所有第类边的(lx[i]+ly[j]-W)的最小值作为d值即可。这样一方面可以保证点标的可行性，另一方面，**经过这一步后，图中至少会增加一条可行边。** 这样的最小值d,会恰好使得得到最小值d的那组点对的lx[i]+ly[j]-w的值从大于0变成0（好像是废话，我只是为了强调一下）
但是如果朴素得去找最小值更新d的话，复杂度是O(n4)（不会分析复杂度。。。mzdd)
#define M 505 #define inf 0x3fffffff bool sx[M], sy[M]; int match[M], w[M][M], n, m, d, lx[M], ly[M]; //n：左集元素个数； m：右集元素个数 void init () { memset (w, 0, sizeof(w)); //不一定要，求最小值一般要初始化为负无穷！ } bool dfs (int u) { int v; sx[u] = true; for (v = 0; v &amp;lt; m; v++) { if (!</description></item><item><title>poj 3041 Asteroids (二分图的最小顶点覆盖，匈牙利算法)</title><link>https://111qqz.com/2016/05/poj-3041/</link><pubDate>Mon, 30 May 2016 13:56:28 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-3041/</guid><description>
poj 3041题目链接 题意：一个nn的网格中，有k个大小为11的小行星，现在可以用激光枪每次消灭一行的小行星或者消灭一列的小行星。问最少需要使用多少次激光枪消灭所有的小行星。
思路：一个建图技巧是：对于网格图，我们可以把某个格子的横纵坐标看成点，而格子所代表的内容看成边来建图。
如果我们按照这样的方式建图，那么这道题的行或者列就成了点，而小行星就成了边。我们要做得是选最少的点，使得这些点覆盖所有的边。
根据Knoig定理，二分图的最小顶点覆盖数等于二分图的最大匹配数。
匈牙利一遍即可。1A
/* *********************************************** Author :111qqz Created Time :2016年05月30日 星期一 21时42分55秒 File Name :code/poj/3041.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; const int M=1E4+7; int n,k; int cnt; struct Edge { int v; int nxt; }edge[M]; int head[N]; bool vis[N]; int link[N]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>poj 1719 Shooting Contest (匈牙利算法)</title><link>https://111qqz.com/2016/05/poj-1719/</link><pubDate>Mon, 30 May 2016 13:25:39 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1719/</guid><description>
poj1719题目链接
题意：射箭比赛，靶子是一个n*m的网格。网格的特点是没列只有两个白色，剩下的全是黑色。一共射m次，每列射一次，要求每行都射到至少一次才算合法，问是否有合法射法，如果有输出一组解。
思路：由于列数可能比行数多，那么我们把行编号作为左集合，列编号作为右集合，做一次匈牙利，对于每一行都找到它匹配的列，如果匹配数等于n，说明有解。对于输出一组街的问题，m列中已经匹配了n列，输出他们对应的link即可。对于剩下的m-n列，可以任意输出。由于之前不知道会剩下哪n-m列，所以在读入的时候有必要保存每一列的white格子的位置信息。
1A,有点爽。
/* *********************************************** Author :111qqz Created Time :2016年05月30日 星期一 20时44分59秒 File Name :code/poj/1719.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; char maze[N][N]; int head[2*N]; int cnt; int link[2*N]; int vis[2*N]; pi white[N]; struct Edge { int v; int nxt; }edge[N*2]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>hdu 4185 Oil Skimming (二分图最大匹配，匈牙利算法)</title><link>https://111qqz.com/2016/05/hdu-4185/</link><pubDate>Mon, 30 May 2016 05:33:18 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-4185/</guid><description>
hdu 4185题目链接 题意：给出一个nn的字符maze,‘.’代表水，‘#’代表油田。 挖油的机器一次会挖两个相邻方块。要求是必须两块必须都是油，不然会有杂质。问最多能挖多少次。 思路：和那道用12的小矩形块填充是一个思路。根据奇偶性对点标号，然后建图，匈牙利，2A. 第一遍是dfs写错了一个变量QAQ.a
/* *********************************************** Author :111qqz Created Time :2016年05月30日 星期一 12时53分34秒 File Name :code/hdu/4185.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1000; int n; char maze[N][N]; int f1[N][N],f2[N][N]; int tot1; int tot2; int cnt; int link[N*N]; bool vis[N*N]; int head[N*N]; struct Edge { int v; int nxt; }edge[N*N*2]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>hdu 1068 Girls and Boys (二分图的最大独立集，匈牙利算法)</title><link>https://111qqz.com/2016/05/hdu1068/</link><pubDate>Sat, 28 May 2016 01:34:53 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu1068/</guid><description>
hdu 1068题目链接 题意：有n个同学。。给出同学之间的 爱慕关系。。。选出一个集合使得集合中的人没有爱慕关系。问能选出的最大集合是多少。
思路：没有数据范围，差评！题意说得也不清楚。。由数据知道。。爱慕关系一定是相互的。。。
这道题实际上是二分图的最大独立集问题。
**最大独立集问题： 在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边．求m最大值** 学到的一点是：对于二分图，可能并不能明显得分成两个不相交的集合，而是一个整体。（有左集合到又集合的边，同时有又集合到左集合的边，就是说每条边都是无相边。。？） 这其实等于把两个无向图叠加在了一起（从左指向右的和从又指向左的）
所以hungary得到的最大匹配数应该除以2，才是真正的最大匹配数。
/* *********************************************** Author :111qqz Created Time :2016年05月28日 星期六 08时42分19秒 File Name :code/hdu/1068.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+5; int n; int head[N]; //vector &amp;lt;int&amp;gt;edge[N]; int link[N]; bool vis[N]; int cnt; struct Edge { int v; int nxt; }edge[10005]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>hdu 3225 Flowers Placement （dfs+匈牙利算法剪枝，太神了）</title><link>https://111qqz.com/2016/05/hdu-3225/</link><pubDate>Fri, 27 May 2016 12:38:07 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-3225/</guid><description>
hdu 3225题目链接
题意：给出一个n*m的矩阵。每个格子有一个数。每行1..n必须每个出现一次。每列1..n每个数最多出现一次。现在要添加一行，并且补违反上述规则。问添加的方案中字典序第k小的方案。如果一共不足k种方案，那么输出-1.
思路：有点像八皇后。。。就是纯搜。。。不过n好大。。。这么搜会TLE...
想了半天也没思路。。。看了题解。。发现是用二分图匹配来剪枝。。
比较重要的一点是。。。
n个数的某种排列，可以看做是一个位置集合{1..n}和数字集合{1..n}的二分图最大匹配。
我们可以根据这个来剪枝。
具体做法：
**我们先求出一个完备匹配，然后搜索每个位置能够种的花，假设当前位k置种了花i,那么判断k+1--n位置能不能形成一个完备匹配（即能否种出满足条件的花），若能那么当前位置可以种该花，继续搜索，若不能这返回** 然后把一个false写了true.调了一个小时。。。。。。。。。。。。。。无语凝噎。
/* *********************************************** Author :111qqz Created Time :2016年05月27日 星期五 00时42分16秒 File Name :code/hdu/3225.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; bool lie[N][N]; bool hang[N]; int n,m,k; int cnt; //vector &amp;lt;int&amp;gt;ans[N]; //不用每个都存，只存第k个就好。。。前面的随便覆盖。。。 int cur[N]; int link[N],tmp[N]; bool vis[N]; bool g[N][N]; bool findgirl( int x,int limit) { if (x&amp;lt;=limit) return false;//找到的匹配位置一定要在当前的后面。 for ( int i = 1 ; i &amp;lt;= n ; i++) { if (g[x][i]&amp;amp;&amp;amp;!</description></item><item><title>poj 1469 COURSES (匈牙利算法)</title><link>https://111qqz.com/2016/05/poj1469/</link><pubDate>Thu, 26 May 2016 16:20:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1469/</guid><description>
poj 1469 题目链接
题意：p个课程，n个学生，给出每个课程对应选取该课程的学生编号，问能否选出p个学生，使得和课程一一对应。
思路：一眼二分图最大匹配。。。需要注意的是。。两个集合可能分别给出。。建图的最大点数是两个集合的最大数目之和。。。因为没注意这个细节RE了一次。。
/* *********************************************** Author :111qqz Created Time :2016年05月26日 星期四 23时53分39秒 File Name :code/poj/1469.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=30003; int n,p; int head[405]; int cnt ; int link[405]; bool vis[405]; struct Edge { int v; int nxt; }edge[N]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>poj 1325 Machine Schedule(二分图的最小顶点覆盖，匈牙利算法)</title><link>https://111qqz.com/2016/05/poj-1325-machine-schedule/</link><pubDate>Thu, 26 May 2016 15:40:56 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1325-machine-schedule/</guid><description>
poj 1325 题目链接 题意：有两台机器A和B,分别有n和m种工作模式。 现在有k个job,三元组（i,x,y),job i可以用A机器的x模式完成或者用B机器的y模式完成。初始两个机器都在模式0.机器更换模式的时候需要重启，问最少的重启次数。
思路：这道题的难点在于建图。。。每个job恰好对应了两种模式。。那么如果把模式看成点。。边就对应了这个job。。这样就是一个二分图。。。至于方向。。。怎么指都可以。。。统一就行。。
完全没有图的影子的题依然可以用图论解决。。。而且算是加深了对图这种模型的理解把。
然后这道题就变成了二分图的最小顶点覆盖。
**二分图中，选取最少的点数，使这些点和所有的边都有关联（把所有的边的覆盖），叫做最小点覆盖。** 根据Knoig定理：二分图的最小顶点覆盖数等于二分图的最大匹配数。
一个证明：二分图最小顶点覆盖的证明
剩下的就是裸的hungary..
然而WA了好几次。。。
一个小细节没处理好。。。
由于初始是模式0.。。
所以模式0肯定要特殊考虑。。。因为初始状态是没有重启的。。。
但是我错误得以为只有当存在（i,0,0）这样的边时才忽略不算。。。
但是其实只要有一个端点是0就好了啊。。。不管哪端是0，我就用这个0来完成工作。。。依然不增加重启次数。。。
这不是什么坑点。。。脑袋秀逗了。。。
/* *********************************************** Author :111qqz Created Time :2016年05月26日 星期四 21时41分11秒 File Name :code/poj/1325.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m,k; int cnt; struct Edge { int v; int nxt; }edge[N]; int head[N]; int link[N]; bool vis[N]; void addedge( int u,int v) { edge[cnt] .</description></item><item><title>poj 1422 Air Raid (DAG的最小路径覆盖，匈牙利算法)</title><link>https://111qqz.com/2016/05/poj-1422/</link><pubDate>Thu, 26 May 2016 13:02:47 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1422/</guid><description>
poj 1422题目链接
题意+思路：DAG的最小路径覆盖。。。匈牙利算法。。。poj 2594的低配版。。
/* *********************************************** Author :111qqz Created Time :2016年05月26日 星期四 20时24分15秒 File Name :code/poj/r2594.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m; bool conc[N][N]; bool vis[N]; int link[N]; void floyd() { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (conc[i][k]&amp;amp;&amp;amp;conc[k][j]) conc[i][j] = true; } bool dfs( int u) { for ( int i = 1 ; i &amp;lt;= n ; i++) { if (conc[u][i]) { if (vis[i]) continue; vis[i] = true; if (link[i]==-1||dfs(link[i])) { link[i] = u; return true; } } } return false; } int hungary() { int res = 0 ; ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(vis,false); if (dfs(i)) res++; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2594 Treasure Exploration (DAG图最小路径覆盖变形，匈牙利算法+floyd求传递闭包)</title><link>https://111qqz.com/2016/05/poj-2594/</link><pubDate>Thu, 26 May 2016 12:43:12 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-2594/</guid><description>
poj 2594 题目链接
题意：一个DAG图，每个点有宝藏...可以降落任意个机器人到任意点...然后机器人可以沿着路径走，路过某个点的时候，可以取走该点的宝藏。问要取走所有宝藏，最少需要多少个机器人。
思路：乍一看。。很像DAG图的最小路径覆盖。。但是最小路径覆盖是要求每个点只能经过一次的。。而这道题路过某个点的时候，可以不取走宝藏。。以及题面里明确说了“you should notice that the roads of two different robots may contain some same point. ”
那是否还可以用最小路径覆盖做呢。。答案是可以的。。。
区别就在于一个点如果被一条路径使用过一次，还可不可以使用第二次。。。
如果我们按照传统的DAG图的最小路径覆盖考虑。。。如果一个点会被路径经过两次。。。那么我们不妨增加一个点。。。 进一步考虑。。。我们要的是尽可能覆盖所有点。。。如果这条路径前后的点不会因为这个点而中断，那么这个增设点是否存在，其实是无所谓的，只要改点前后的点连通性不受影响即可。 说到连通性，不禁想到floyd求传递闭包。
然后对于DAG图的最小路径覆盖问题。。。就可以用hungary算法求解。。。
ans = n - 最大匹配数。
这应该算作hungary的一个应用。</description></item><item><title>poj 2446 Chessboard (匈牙利算法)</title><link>https://111qqz.com/2016/05/poj2446/</link><pubDate>Thu, 26 May 2016 11:19:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj2446/</guid><description>
poj 2446 题目链接 题意：一个nm的矩形方格里，有k个坏点，然后问能否用12的矩形块将矩形方格填满。坏点不能填，小的矩形块不能重叠，不能超出边界。不能有好点没有被填。
思路：乍一看没什么好的思路。。。然后发现小的矩形块只能有两种放置方法（横着放，竖着放） 可能我们对于第i个，可以横着放，也可以竖着放，但是可能某种方案使得后面的某一块没办法放置，因此我们需要反过来调整第i块的放法。 这个过程似乎和二分图匹配有点类似。。？ 那到底有没有相似点呢。。。又如何划分集合呢。。。？
如果每个小方格看做点，能不能填满，其实就等价与这些点的最大匹配数×2+坏点数=mn是否成立。。。那如何划分集合呢。。。？ 我们可以根据点的坐标的奇偶性划分集合。。。因为小矩形块是21的，所以容易知道，每块矩形块放置的两个点一定属于不同的集合。。这样就满足了二分图匹配问题的模型。。。
然后匈牙利搞之。
这题一开始WA了。。WA在没有注意到一个小细节，使得连边的时候，有的是左点指向右点，而有的连成了右点指向左点。
/* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 20时19分04秒 File Name :code/poj/2446.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 40; int n,m,k; bool hole[N][N]; int f1[N][N],f2[N][N]; int tot1,tot2; int head[N*N*2]; int cnt; bool vis[N*N*2]; int link[N*N*2]; struct Edge { int v; int nxt; }edge[2*N*N]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>poj 1274 The Perfect Stall （匈牙利算法）</title><link>https://111qqz.com/2016/05/poj-1274-the-perfect-stall-/</link><pubDate>Wed, 25 May 2016 09:59:54 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1274-the-perfect-stall-/</guid><description>
poj 1274题目链接
裸的匈牙利。
/* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 17时49分22秒 File Name :code/poj/1274.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=405; int n,m; int head[N]; int cnt; int link[N]; bool vis[N]; struct Edge { int v; int nxt; }edge[N*N]; void addedge(int u,int v) { edge[cnt].</description></item><item><title>hdu 2063 过山车 (匈牙利算法模板题)</title><link>https://111qqz.com/2016/05/hdu-2063/</link><pubDate>Wed, 25 May 2016 09:43:01 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-2063/</guid><description>
hdu2063题目链接
题意：求二分图最大匹配。
思路：匈牙利算法。
通过这三篇博客了解了相关概念，学习了匈牙利算法。 趣写算法系列之--匈牙利算法 二分图的最大匹配、完美匹配和匈牙利算法 匈牙利算法详解
感受就是：这个是相对容易学的算法。。并没有名字那么不明觉厉。。。
主体就是一个dfs的过程。。。。
不过据说有比较多的应用。
所以打算切一些题目加深理解以后再回来总结。
/* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 16时51分32秒 File Name :code/hdu/2063.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m,k; int head[N]; int link[N]; bool vis[N]; int cnt; int tot; struct Edge { int to; int nxt; }edge[N]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>uva 10986 Sending email (spfa)</title><link>https://111qqz.com/2016/05/uva-10986/</link><pubDate>Tue, 24 May 2016 20:14:32 +0000</pubDate><guid>https://111qqz.com/2016/05/uva-10986/</guid><description>
uva10986题目链接 题意：裸的spfa.
思路：模板，1A.
/* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 03时25分27秒 File Name :code/uva/10986.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; int n,m; int S,T; vector &amp;lt; pi &amp;gt; edge[N]; int d[N]; bool inq[N]; bool spfa( int s,int t) { ms(d,0x3f); ms(inq,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 2949 Word Rings (spfa+栈优化)</title><link>https://111qqz.com/2016/05/poj-2949-word-rings/</link><pubDate>Tue, 24 May 2016 19:55:02 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-2949-word-rings/</guid><description>
poj2949 题目链接 题意：我们有 n 个 (n&amp;lt;=100000) 字符串,每个字符串都是由 a~z 的小写英文字 母组成的字符串。如果字符串 A 的结尾两个字符刚好与字符串 B 的开头两字符相 匹配,那么我们称 A 与 B 能相连(注意: A 能与 B 相连不代表 B 能与 A 相连)。 我们希望从给定的字符串中找出一些,使得他们首尾相接形成一个环串(一个串首尾相连也算) 我们想要使这个环串的平均长度最长。
思路：参考了国家集训队论文《spfa算法的优化与应用》
首先我卡在了关于接龙问题的处理方法，只能想到n^2的方法。。显然gg.
而正解是把每个单词看做一条边，把每个单词开头的两个字母和结尾两个字母看做起点和终点，由于都是小写字母，2位26进制数最多表示26*26。
这个建图方式并不是特别显然，不过想一下还是可以理解的。。以及这应该算是处理单词接龙问题的一个技巧。。。
这道题综合了两种常见的问题：字符串的接龙以及平均值的最优化问题。对于前者，我们可以采取把单词看成边，把首尾字母组合看成点的方法。例如对于单词ababc就是点”ab”向点”bc”连一条长度为5的边。这样问题的模型变得更加清晰，规模也得到减小。那么原问题就可以转化成在此图中找一个环，使得环上边权的平均值最大。对于这种问题，我们有很经典的解决方法： 由于Average=(E1+E2+…..+Ek)/K 所以Average*K=E1+E2+……+Ek 即（E1-Average）+（E2-Average）+….+ （Ek-Average）=0 另外注意到上式中的等于号可以改写为小于等于，那么我们可以二分答案Ans，然后判断是否存在一组解满足（E1+E2+…..+Ek）/K&amp;gt;Ans,即判断 （E1- Ans）+（E2- Ans）+….+ （Ek- Ans）&amp;gt;0 于是在二分答案后，我们把边的权值更新，问题就变成了查找图中是否存在一个正环。
然后参考了这篇题解学习了一下栈优化的spfa： spfa栈优化 
以及这篇博客中比较了dfs的spfa和普通栈优化的spfa... 200+ms vs 2000+ms...十倍的优化。。太神了。。。
/* 枚举每一个平均长度mid值。 如果存在一个环，(E1+...+Ek)/k=mid(其中k是边数，E1……Ek是各个边权)， 那么正解比mid大，否则比mid小，这就是二分策略。 那么怎样知道是否存在(E1+...+Ek)/k=mid 呢？ 如下转化：(E1+...+Ek)=mid*k E1-mid + E2–mid + E3-mid + ... + Ek-mid = 0 所以，把所有的边权改为Ei – mid，然后看是否存在正环就可以，存在就是满足条件。 */ /* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 00时25分51秒 File Name :code/poj/2949.</description></item><item><title>poj 1860 Currency Exchange (spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1860/</link><pubDate>Tue, 24 May 2016 16:16:38 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1860/</guid><description>
poj 1860 题目链接
题意：有n种货币，m个货币交易点，每个货币交易点只能是两种货币之间交换，给出两个方向的汇率和手续费。初始拥有数量v的货币s,问能否经过一些py交易，使得最后手里的货币s比v多。
思路：大概还是用spfa求最长路。。松弛那里需要注意一下算法。。。
1A。。。好爽啊。。。。。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 23时41分46秒 File Name :code/poj/1860.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n,m,s; double v; double d[N]; bool inq[N]; vector &amp;lt;pair&amp;lt;int,pair&amp;lt;double,double&amp;gt; &amp;gt; &amp;gt; edge[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>poj 1932 XYZZY (floyd传递闭包+spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1932/</link><pubDate>Tue, 24 May 2016 13:00:45 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1932/</guid><description>
poj1932题目链接
题意：初始在点1，有100点能量，然后每个点有一个能量值【-100,100】，经过某个点会加上这个点的能量值，问能否找到一条到点n且的路线，且路径任何点的能量值一直为正。一共不超过100个点。
思路：像样例中是直接联通，一路上的能量值都大于0，这是有解的一种情况。另一种是存在一个正环，可能一次路过后面的能量值不够，但是我们可以走多次啊。
因为要求每一步的能量值都大于0，那么我们可以初始化d[]数组为0，然后用spfa求最长路（只需要把那个三角形等式换个方向即可）
如果可以直接联通，也就是d[n]&amp;gt;0，那么有解。
还有可能是存在一个环（判断环的方法是用一个数组在spfa的时候统计每个点入队的次数，如果一个点的入队次数大于n，那么就存在环，且这个点在环中）
但是我们还要保证起点1和终点n是经过这个环的。
所以先跑一发floyd. 其实n才100也算给了提示吧，不用floyd的话没道理这么小的数据。。？
感觉这道题很棒，把spfa和floyd结合在了一起。
学到了判断环的方法，spfa求最长路的方法，复习了传递闭包。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 20时03分37秒 File Name :code/poj/1932.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; vector&amp;lt; int &amp;gt; edge[N]; int a[N]; bool conc[N][N]; int in[N]; //统计入队次数，大于n次表明有环。 bool inq[N]; int n; int d[N]; void floyd() //传递闭包 { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (conc[i][k]&amp;amp;&amp;amp;conc[k][j]) conc[i][j] = true; } bool spfa(int s) //spfa求最长路。 { ms(in,0); ms(d,0);//因为小于等于0就死，所以初始是0，这样更新的时候一定是正值才更新。 ms(inq,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 1511 Invitation Cards (链式前向星存图+spfa)</title><link>https://111qqz.com/2016/05/poj-1511/</link><pubDate>Tue, 24 May 2016 11:36:07 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1511/</guid><description>
poj 1511 题目链接 题意：和那道奶牛的舞会类似，要求所有点到点1的距离和加上1点到所有点的距离和。 思路：正反存边建两次图，跑两次spfa. 然而用vector会TLE....所以去学习了新的建图方式。。。也就是链式前向星：链式前向星（边表）学习链接 也叫边表。
是一种几乎没有什么缺点的存图方式。。。？ 比起普通的前向星少了个排序。
哦，还有我发现貌似很多人把这个东西叫邻接表。。但是根据这里：几种建图方式
这个东西还是交边表或者链式前向星比较合适。。。？
/* *********************************************** Author :111qqz Created Time :2016年05月23日 星期一 20时31分19秒 File Name :code/poj/1511.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E7+7; LL d[N]; bool inq[N]; int n,m; struct Edge { int v,w; int nxt; }edge1[N],edge2[N]; //反向存一次 int head1[N],head2[N]; int cnt; void addedge(Edge *edge,int *head,int u,int v,int w) { edge[cnt].</description></item><item><title>BZOJ 1614: [Usaco2007 Jan]Telephone Lines架设电话线 (二分+spfa)</title><link>https://111qqz.com/2016/05/bzoj-1614/</link><pubDate>Sun, 22 May 2016 13:09:49 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj-1614/</guid><description>
1614: [Usaco2007 Jan]Telephone Lines架设电话线 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1325 Solved: 570 [Submit][Status][Discuss]
Description Farmer John打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。 FJ的农场周围分布着N(1 &amp;lt;= N &amp;lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1 &amp;lt;= P &amp;lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。 第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为 L_i (1 &amp;lt;= L_i &amp;lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。 经过谈判，电信公司最终同意免费为FJ连结K(0 &amp;lt;= K &amp;lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过 K对，那么FJ的总支出为0。 请你计算一下，FJ最少需要在电话线上花多少钱。
Input 第1行: 3个用空格隔开的整数：N，P，以及K
第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i
Output 第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成， 输出-1 Sample Input 5 7 1 1 2 5 3 1 4 2 4 8 3 2 3 5 2 9 3 4 7 4 5 6</description></item><item><title>BZOJ 1631: [Usaco2007 Feb]Cow Party (SPFA)</title><link>https://111qqz.com/2016/05/bzoj-1631/</link><pubDate>Sat, 21 May 2016 13:09:57 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj-1631/</guid><description>
1631: [Usaco2007 Feb]Cow Party Time Limit: 5 Sec Memory Limit: 64 MB Submit: 670 Solved: 493 [Submit][Status][Discuss]
Description  农场有N(1≤N≤1000)个牛棚，每个牛棚都有1只奶牛要参加在X牛棚举行的奶牛派对．共有M(1≤M≤100000)条单向路连接着牛棚，第i条踣需要Ti的时间来通过．牛们都很懒，所以不管是前去X牛棚参加派对还是返回住所，她们都采用了用时最少的路线．那么，用时最多的奶牛需要多少时间来回呢？
Input 第1行:三个用空格隔开的整数.
第2行到第M+1行,每行三个用空格隔开的整数:Ai, Bi,以及Ti.表示一条道路的起点,终点和需要花费的时间.
Output 唯一一行:一个整数: 所有参加聚会的奶牛中,需要花费总时间的最大值.
Sample Input 4 8 2 1 2 4 1 3 2 1 4 7 2 1 1 2 3 5 3 1 2 3 4 4 4 2 3
Sample Output 10
HINT 样例说明: 共有4只奶牛参加聚会,有8条路,聚会位于第2个农场. 第4只奶牛可以直接到聚会所在地(花费3时间),然后返程路线经过第1和第3个农场(花费7时间),总共10时间.
思路：想了一下。。因为要知道每个点到x的最短距离。。。以及反过来。。
单向很容易知道。。。以x点为起点做一遍spfa,那么x到每个点的最短距离就知道了。。
那么反过来怎么办呢？
我的做法是反向建边再跑一遍spfa...
1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年04月04日 星期一 19时36分38秒 File Name :code/bzoj/1631.</description></item><item><title>hdu 3790 最短路径问题 (spfa模板题)</title><link>https://111qqz.com/2016/05/hdu3790/</link><pubDate>Sat, 21 May 2016 11:09:54 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3790/</guid><description>
hdu 3790 题目链接
题意：给出n个点m条无向边，每条边有一个距离和一个花费。给出s,t。问从s到t的最短距离以及最短距离时的最小花费。当有多个距离最短的方案时，选取花费最少的。
spfa学习链接
usetc 每周算法讲堂之spfa
先写几道题加深理解。
记得初始化。。。。。。
/* *********************************************** Author :111qqz Created Time :2016年05月21日 星期六 18时42分24秒 File Name :code/hdu/3790.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; int d[N]; int p[N]; bool inq[N]; vector &amp;lt; pair&amp;lt;int,pair&amp;lt;int,int&amp;gt; &amp;gt; &amp;gt; edge[N]; int s,t; void init() { ms(inq,false); ms(d,0x3f); ms(p,0x3f); for ( int i = 0 ; i &amp;lt;=n ; i++) edge[i].</description></item><item><title>zoj 3195 Design the city （lca,dfs+rmq）</title><link>https://111qqz.com/2016/05/zoj-3195/</link><pubDate>Sat, 21 May 2016 08:31:20 +0000</pubDate><guid>https://111qqz.com/2016/05/zoj-3195/</guid><description>
zoj 3195题目链接 题意：求树上三点的最短距离。。。 思路：两两求，和除以2. 因为忘记初始化p=0..WA了将近两个小时。。。？ 妈的智障。
/* *********************************************** Author :111qqz Created Time :2016年05月21日 星期六 14时44分39秒 File Name :code/zoj/3195.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; int n,m; vector &amp;lt; pi &amp;gt; edge[N]; int q; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>hdu 2874 Connections between cities (添加虚点，并查集+LCA(rmq+dfs))</title><link>https://111qqz.com/2016/05/hdu-2874/</link><pubDate>Sat, 21 May 2016 04:58:22 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-2874/</guid><description>
hdu2874题目链接
题意：给一个森林，问两点的最短距离，或者输出两点不联通。
思路：最最重要的一点是:添加虚点！
最最重要的一点是:添加虚点！
最最重要的一点是:添加虚点！
所谓虚点，就是之前假设某个不存在的点，有点类似做辅助线。
通过添加虚点，我们可以把这个森林转化成一棵树。
这样求两点的距离就可以转化成一棵树上的两点的距离。
用dis[u]+dis[v]-2*dis[LCA(u,v)]来求。 dis[i]表示节点i到新的树根节点的距离。
不联通的话就是LCA 为0的情况（0是添加的虚点，作为新的树的根）
具体添加虚点的方法是：森林中每棵树的根连边到虚点上。权值大小随意，因为最后会抵消（？） 为了知道每棵树的根，需要用到并查集(其实根是随便定义的，但是森林中每棵树只能一个点和虚点相连不然就出现环了，所以需要用到并查集）
以及了解了（？）并查集的非递归的路径压缩写法。。。？
缺点是速度更慢，优点是不会爆栈。。。
还有需要学习一下按rank合并和按size合并的进阶并查集。。。？
以及：RE了好多次是因为。。。添加了虚点0，所以各种下标都应该是从0开始，初始化清空的时候忘了（从0开始）清vector...导致多组数据一直往edge[0]里面添加边。。。然后就炸了（手动微笑）
/* *********************************************** Author :111qqz Created Time :2016年05月20日 星期五 19时31分44秒 File Name :code/hdu/2874.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; int n,m,q; vector &amp;lt; pi &amp;gt; edge[N]; int dis[N]; int E[2*N],depth[2*N],R[2*N]; int p; int dp[2*N][20]; int f[N]; /*int root2 ( int a) { int x = a,ret; while (x!</description></item><item><title>poj 1986 Distance Queries (lca,在线做法dfs+rmq)</title><link>https://111qqz.com/2016/05/poj-1986/</link><pubDate>Fri, 20 May 2016 11:25:49 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1986/</guid><description>
题目链接 题意：求树上两点的最短距离？ 思路： dis[i]表示点i到根节点的距离，那么任意两点u,v的最短距离d = dis[u]+dis[v]-2*dis[LCA(u,v)]. 只需要求出rmq+dfs的在线方法求出lca(u,v)即可。
/* *********************************************** Author :111qqz Created Time :2016年05月20日 星期五 15时36分47秒 File Name :code/poj/1986.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; int n,m; vector &amp;lt; pi &amp;gt; edge[N]; int q; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>hdu 3530 Subsequence (尺取+rmq)</title><link>https://111qqz.com/2016/05/hdu3530/</link><pubDate>Thu, 19 May 2016 09:44:36 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3530/</guid><description>
hdu 3530题目链接
题意：给出n个数，m,k，问最大的j-i+1,使得【i,j】间的最大值与最小值的差属于[m,k] 思路：rmq+尺取。 2A.
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 16时52分03秒 File Name :code/hdu/3530.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int dp[N][20],dp2[N][20]; int m,k; void rmq_init() { for ( int i = 1 ; i &amp;lt;= n ; i ++) dp[i][0] = dp2[i][0] = a[i]; for ( int j = 1 ; (1&amp;lt;&amp;lt;j) &amp;lt;= n ; j++) for ( int i = 1 ; i + (1&amp;lt;&amp;lt;j) -1 &amp;lt;= n ; i++) { dp[i][j] = max(dp[i][j-1],dp[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); dp2[i][j]=min(dp2[i][j-1],dp2[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } } int rmq( int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; int mx = max(dp[l][k],dp[r-(1&amp;lt;&amp;lt;k)+1][k]); int mn = min(dp2[l][k],dp2[r-(1&amp;lt;&amp;lt;k)+1][k]); return mx-mn; } int ruler() { int head = 1; int tail = 1; int res = -1 ; while (tail&amp;lt;=n) { int cur = rmq(head,tail); while (head&amp;lt;tail&amp;amp;&amp;amp;rmq(head,tail)&amp;gt;k) head++; while (tail&amp;lt;n&amp;amp;&amp;amp;rmq(head,tail)&amp;lt;m) tail++; //if (tail&amp;gt;n) break; cur = rmq(head,tail); if (cur&amp;gt;=m&amp;amp;&amp;amp;cur&amp;lt;=k) { res = max(res,tail-head); } // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; tail++; } return res+1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1470 Closest Common Ancestors (lca,rmq+dfs,读入技巧)</title><link>https://111qqz.com/2016/05/poj1470/</link><pubDate>Thu, 19 May 2016 08:42:05 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1470/</guid><description>
poj1470题目链接
题意：求两点的lca. 思路：dfs+rmq. 读入技巧。 读入比较坑爹。。。 学会了一种新的读入技巧。
scanf(&amp;quot;%2s&amp;quot;,st);
表示读一个长度为2的字符串。。。读的时候会忽略各种空白字符。
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 15时44分12秒 File Name :code/poj/1470.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=905; int n; vector &amp;lt;int&amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N]; int depth[2*N]; int p; int dp[2*N][12]; int cnt[N]; void dfs( int u,int dep) { p++; E[p] = u ; depth[p] = dep; R[u] = p; int siz = edge[u].</description></item><item><title>poj 1330 Nearest Common Ancestors (lca,用dfs+rmq在线求解)</title><link>https://111qqz.com/2016/05/poj1330/</link><pubDate>Thu, 19 May 2016 07:39:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1330/</guid><description>
poj1330题目链接
题意：给出一棵树，求两点的lca. 思路：将lca转化成rmq在线求解。
代码部分参考了：参考代码
感觉实现得很巧妙。。。 把树存成了有向图，dfs遇到的时候一定是第一次遇到，此时更新R. 然后第二次遇到某个点就是在回溯的时候了。
算法学习链接
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 15时05分31秒 File Name :code/poj/1330.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; vector &amp;lt;int&amp;gt;edge[N]; int n; int in[N]; int cur; int E[2*N]; int R[N]; int depth[2*N]; int dp[2*N][16]; void dfs ( int u,int dep) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;endl; cur++; E[cur] = u; depth[cur] = dep; R[u] = cur; //有向图存的话，在这里访问的一定是第一次经过。 int siz = edge[u].</description></item><item><title>hdu 4122 Alice's mooncake shop(rmq)</title><link>https://111qqz.com/2016/05/hdu4122/</link><pubDate>Wed, 18 May 2016 13:03:34 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu4122/</guid><description>
hdu2142题目链接 题意：有n个订单和可以在m小时内制作月饼 接下来是n个订单的信息:需要在mon月,d日,year年,h小时交付订单r个月饼 接下来一行t,s表示制作的月饼可以保质t天，每保质一天需要花费s的价值 接下来m行表示从第0小时开始在该时间制作月饼的花费的价值 求完成所有订单消耗的最小价值
思路：一开始毫无头绪。。因为读错题了。。。之后发现做月饼只能在整点做，即使是提前，也只能提前整数个小时做。 然后发现冰箱的容量是没有限制的，所以每个订单单独考虑即可。
那么对于每一个订单，我们要找到订单当天以及之前T天，这T+1天中做月饼花费最少的那天做月饼。
但是如果对于每个订单，如果每次都更新相应的价值，找一次最小值，复杂度会炸。
这里我卡了一下。。。然后发现，可以只初始化一次。虽然在不同时间做月饼的花费会因为订单时间的不同而不同，但是每相邻的两个小时之间做月饼花费的差是固定的，也就是花费的相对大小是固定的。
因此对于每个订单，我在相应的区间内找到花费最小的时间的下标，然后恢复成实际的花费（因为花费是一个等差数列，很好恢复）
由于之后给的花费是开始后的第i小时。。。那么订单不妨也转化成小时的形式。。。
注意判断闰年。。
2A,开心。
/* *********************************************** Author :111qqz Created Time :2016年05月18日 星期三 19时37分03秒 File Name :code/hdu/4122.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M[15]={-1,31,28,31,30,31,30,31,31,30,31,30,31}; //平年每月天数，1 indexed.</description></item><item><title>poj 3368 Frequent values （暴力+rmq，分类讨论）</title><link>https://111qqz.com/2016/05/poj3368/</link><pubDate>Wed, 18 May 2016 07:47:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj3368/</guid><description>
poj 3368 题目链接
题意：给出n个非减的数a[i],求区间[l,r]中出现次数最多的数的出现的次数。
思路：由于数列非减，那么相等的数一定相邻。很容易系哪个到构造另一个数组f[i]，表示从当前位置向左边延伸最多延伸几个相等的数。
f[i] = f[i-1] + 1 (iff a[i]==a[i-1])
然后查询的时候。
如果直接用ST算法查询rmq的话。。。
可能产生错误结果，原因是f[i]是从左边1到i这段连续区间里当前数出现的次数。
但是查询区间不一定是从1开始，所以查询区间内的第一段连续相等的数可能不完整。。。想了半天。。最后看了题解，发现是这部分暴力来搞。但是如果所有数列中所有数都相等，这样的复杂度就达到了o(1E10)?。。。2s应该过不了吧。。。但是所有题解都是这么写的。。。不是很懂。。。所谓的面向数据编程？
不过还是有启示的：分类讨论的思想。一道题未必用一种算法解。如果因为一小部分导致某算法不能用的话，不妨暴力搞之然后再用这个算法。
/* *********************************************** Author :111qqz Created Time :2016年05月18日 星期三 13时44分47秒 File Name :code/poj/3368.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int q; int dp[N][20]; void init_rmq() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp[i][0] = a[i].</description></item><item><title>poj 2452 Sticks Problem (rmq+二分，需要返回最值位置)</title><link>https://111qqz.com/2016/05/poj2452/</link><pubDate>Wed, 18 May 2016 05:40:40 +0000</pubDate><guid>https://111qqz.com/2016/05/poj2452/</guid><description>
poj2452题目链接
题意：给你一组数a[n]，求满足a[i] &amp;lt; a[k] &amp;lt; a[j] (i &amp;lt;= k &amp;lt;= j)的最大的j-i。
思路：大概能想到是rmq，然后想出了一个错误复杂度的错误思路，还直到对拍才发现==
转载一篇题解：poj2452解题报告
收获最大的是：
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
只要
int _min(int l,int r) { if (a[l]&amp;lt;a[r]) return l; return r; } 这样一个函数就可以实现完美转化。。。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 13时42分56秒 File Name :code/poj/2452.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; int n; int a[N]; int dp[N][20]; int dp2[N][20]; int _min(int l,int r) { if (a[l]&amp;lt;a[r]) return l; return r; } int _max( int l,int r) { if (a[l]&amp;gt;a[r]) return l; else return r; } void max_init() { for ( int i = 1 ; i &amp;lt;= n ; i++) dp[i][0] = i; for ( int j = 1 ; (1&amp;lt;&amp;lt;j)&amp;lt;=n ; j++) for (int i = 1 ; i + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= n ;i++) dp[i][j] = _max(dp[i][j-1],dp[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } void min_init() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp2[i][0] = i; for ( int j = 1 ; (1&amp;lt;&amp;lt;j)&amp;lt;= n ; j++) for ( int i = 1 ; i + (1&amp;lt;&amp;lt;j) -1 &amp;lt;= n ; i++) dp2[i][j] = _min(dp2[i][j-1],dp2[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } int rmq_max(int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; return _max(dp[l][k],dp[r-(1&amp;lt;&amp;lt;k)+1][k]); } int rmq_min( int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; return _min(dp2[l][k],dp2[r-(1&amp;lt;&amp;lt;k)+1][k]); } int bin (int x,int l,int r) { while (l&amp;lt;=r) { if (l==r) return l; int m = (l+r)&amp;gt;&amp;gt;1; if (a[x]&amp;lt;a[rmq_min(l,m)]) l = m + 1; else r = m; } } void solve() { int ans = 0; for ( int i = 1 ; i+ans &amp;lt; n ; i++) { int r = bin(i,i+1,n); int k = rmq_max(i,r); if (a[k]&amp;gt;a[i]) ans = max(ans,k-i); } if (ans==0) puts(&amp;quot;-1&amp;quot;); else printf(&amp;quot;%d\n&amp;quot;,ans); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3193 find the hotel (思维题)</title><link>https://111qqz.com/2016/05/hdu-3193/</link><pubDate>Tue, 17 May 2016 11:39:28 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-3193/</guid><description>
hdu3193题目链接
题意：给出n个price 和distance,找到一个集合，集合中的每对在全集中找不到比他price和distance都要小的元素。小于是严格的。
思路：一开始以为找到最小值就好。。。结果漏洞百出。。这题还找不到题解。。。大概是太简单了。。？ 看了一份代码大概看明白了。。。
/* *********************************************** Author :111qqz Created Time :2016年05月17日 星期二 19时20分14秒 File Name :code/hdu/r3193.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; bool ok[N]; pi a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>linux下的对拍写法</title><link>https://111qqz.com/2016/05/linux/</link><pubDate>Mon, 16 May 2016 13:44:16 +0000</pubDate><guid>https://111qqz.com/2016/05/linux/</guid><description>
首先先生成三个程序： $ g++ a+b.cpp -o a+b $ g++ a+b2.cpp -o a+b2 $ g++ make.cpp -o make 然后生成数据 $ ./make &amp;gt; in.txt 然后运行两个程序 $ ./a+b &amp;lt; in.txt &amp;gt; out.txt $ ./a+b2 &amp;lt; in.txt &amp;gt; ans.txt 最后对拍 $ diff out.txt ans.txt 输出的结果可以man diff查阅一下相关文档中关于输出含义的内容 注：上面的$都是命令提示符，复制粘贴时不需要</description></item><item><title>lightoj 1081 Square Queries (二维rmq，降维)</title><link>https://111qqz.com/2016/05/loj1081/</link><pubDate>Mon, 16 May 2016 12:06:33 +0000</pubDate><guid>https://111qqz.com/2016/05/loj1081/</guid><description>
lightoj 1081 题目链接
题意：和上一道一样，但是由于size变成了500，如果按照之前的做法会tle + mle...
很容易发现，由于是方阵，长宽是相等的，所以有一维是可以省略的。
也就是所谓的降维？
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 19时24分26秒 File Name :code/loj/1081.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=501; int a[N][N]; int dp[N][N][9]; int n,q; void init_rmq() { for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) dp[i][j][0] = a[i][j]; for ( int i = 1 ; (1&amp;lt;&amp;lt;i)&amp;lt;= n ; i++) for ( int p = 1 ; p + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; p++) for ( int q = 1 ; q + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; q++) dp[p][q][i] = max(max(dp[p][q][i-1],dp[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1]),max(dp[p][q+(1&amp;lt;&amp;lt;(i-1))][i-1],dp[p+(1&amp;lt;&amp;lt;(i-1))][q+(1&amp;lt;&amp;lt;(i-1))][i-1])); } int rmq_max(int x1,int y1,int x2,int y2) { int k = 0; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;= x2-x1+1) k++; int tmp1 = dp[x1][y1][k]; int tmp2 = dp[x2-(1&amp;lt;&amp;lt;k)+1][y1][k]; int tmp3 = dp[x1][y2-(1&amp;lt;&amp;lt;k)+1][k]; int tmp4 = dp[x2-(1&amp;lt;&amp;lt;k)+1][y2-(1&amp;lt;&amp;lt;k)+1][k]; return max(max(tmp1,tmp2),max(tmp3,tmp4)); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2019 Cornfields (二维rmq)</title><link>https://111qqz.com/2016/05/poj2019/</link><pubDate>Mon, 16 May 2016 11:01:34 +0000</pubDate><guid>https://111qqz.com/2016/05/poj2019/</guid><description>
poj2019题目链接
题意：给一个方阵，k个查询，每个查询求某个方阵的最大值和最小值之差。
思路：二维rmq.同时用到最大值和最小值的话可以把初始化写在一起。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 18时31分23秒 File Name :code/poj/2019.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=251; int a[N][N]; int dp[N][N][8][8]; int dp2[N][N][8][8]; int n,b,q; void init_rmq() { for ( int i = 1 ;i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) dp[i][j][0][0] = dp2[i][j][0][0] = a[i][j]; for ( int i = 0 ; (1&amp;lt;&amp;lt;i)&amp;lt;= n ; i++) for ( int j = 0 ; (1&amp;lt;&amp;lt;j) &amp;lt;= n ; j++) if (i==0 &amp;amp;&amp;amp; j==0) continue; else for ( int p = 1 ; p + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; p++) for ( int q = 1 ; q + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= n ; q++) if (i==0) { dp[p][q][i][j] = max(dp[p][q][i][j-1],dp[p][q+(1&amp;lt;&amp;lt;(j-1))][i][j-1]); dp2[p][q][i][j] = min(dp2[p][q][i][j-1],dp2[p][q+(1&amp;lt;&amp;lt;(j-1))][i][j-1]); } else { dp[p][q][i][j] = max(dp[p][q][i-1][j],dp[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1][j]); dp2[p][q][i][j] = min(dp2[p][q][i-1][j],dp2[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1][j]); } } int _rmq(int x1,int y1,int x2,int y2) { int k1 = 0 ; int k2 = 0 ; while (1&amp;lt;&amp;lt;(k1+1)&amp;lt;=x2-x1+1) k1++; while (1&amp;lt;&amp;lt;(k2+1)&amp;lt;=y2-y1+1) k2++; int tmp1 = dp[x1][y1][k1][k2]; int tmp2 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y1][k1][k2]; int tmp3 = dp[x1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int tmp4 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int mx = max(max(tmp1,tmp2),max(tmp3,tmp4)); tmp1 = dp2[x1][y1][k1][k2]; tmp2 = dp2[x2-(1&amp;lt;&amp;lt;k1)+1][y1][k1][k2]; tmp3 = dp2[x1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; tmp4 = dp2[x2-(1&amp;lt;&amp;lt;k1)+1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int mn = min(min(tmp1,tmp2),min(tmp3,tmp4)); // cout&amp;lt;&amp;lt;&amp;quot;mx:&amp;quot;&amp;lt;&amp;lt;mx&amp;lt;&amp;lt;&amp;quot; mn:&amp;quot;&amp;lt;&amp;lt;mn&amp;lt;&amp;lt;endl; return mx - mn; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2888 check corners (二维rmq模板题)</title><link>https://111qqz.com/2016/05/hdu2888/</link><pubDate>Mon, 16 May 2016 10:43:05 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu2888/</guid><description>
hdu2888题目链接
题意：问某个矩阵内的最大值，并且问最大值是否是在四个角中出现。 思路：二维rmq.需要注意数组稍微开大1就会MLE,因为是四维数组，一维大一点，整个就会大很多==。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 16时51分00秒 File Name :code/hdu/2888.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=301; int n,m,q; int a[N][N]; int dp[N][N][9][9]; void init_rmq() { for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1; j &amp;lt;= m ; j++) dp[i][j][0][0] = a[i][j]; for ( int i = 0 ; (1&amp;lt;&amp;lt;i)&amp;lt;= n ; i++) for ( int j = 0 ; (1&amp;lt;&amp;lt;j)&amp;lt;= m ;j++) if (i==0&amp;amp;&amp;amp;j==0) continue; else for ( int p = 1 ; p + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; p++) for ( int q = 1 ; q + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= m ;q ++) if (i==0) dp[p][q][i][j] = max(dp[p][q][i][j-1],dp[p][q+(1&amp;lt;&amp;lt;(j-1))][i][j-1]); else dp[p][q][i][j] = max(dp[p][q][i-1][j],dp[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1][j]); } int rmq_max(int x1,int y1,int x2,int y2) { int k1 = 0 ; int k2 = 0 ; while (1&amp;lt;&amp;lt;(k1+1)&amp;lt;=x2-x1+1) k1++; while (1&amp;lt;&amp;lt;(k2+1)&amp;lt;=y2-y1+1) k2++; int tmp1 = dp[x1][y1][k1][k2]; int tmp2 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y1][k1][k2]; int tmp3 = dp[x1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int tmp4 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; return max(max(tmp1,tmp2),max(tmp3,tmp4)); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3183 A Magic Lamp ( 暴力)</title><link>https://111qqz.com/2016/05/hdu3183/</link><pubDate>Mon, 16 May 2016 05:40:38 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3183/</guid><description>
hdu3183题目链接
题意：n位长的数字串（n&amp;lt;=1000),删掉m个（m&amp;lt;=n），使得剩下的数字串表示的数字最小。 忽略前导0.
思路：暴力搞就可以。要注意每位数字是有一定位置的范围的。比如当前是第i位数字，后面还要取n-m-i位数字，那么第i位数字最多只能取到第k位，k=m+i,因为这样才能保证后面还有n-m-i位数字。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 13时15分44秒 File Name :code/hdu/3183.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; int ans[N]; char st[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1636: [Usaco2007 Jan]Balanced Lineup (RMQ模板题)</title><link>https://111qqz.com/2016/05/bzoj1636/</link><pubDate>Sun, 15 May 2016 13:31:30 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj1636/</guid><description>
1636: [Usaco2007 Jan]Balanced Lineup Time Limit: 5 Sec Memory Limit: 64 MB Submit: 680 Solved: 493 [Submit][Status][Discuss]
Description For the daily milking, Farmer John's N cows (1 &amp;lt;= N &amp;lt;= 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game.</description></item><item><title>BZOJ 1689: [Usaco2005 Open] Muddy roads 泥泞的路 （模拟）</title><link>https://111qqz.com/2016/05/bzoj1689/</link><pubDate>Tue, 10 May 2016 13:26:29 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj1689/</guid><description>
1689: [Usaco2005 Open] Muddy roads 泥泞的路 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 311 Solved: 227 [Submit][Status][Discuss]
Description Farmer John has a problem: the dirt road from his farm to town has suffered in the recent rainstorms and now contains (1 &amp;lt;= N &amp;lt;= 10,000) mud pools. Farmer John has a collection of wooden planks of length L that he can use to bridge these mud pools. He can overlap planks and the ends do not need to be anchored on the ground.</description></item><item><title>hdu 4513 吉哥系列故事——完美队形II (回文串,manacher)</title><link>https://111qqz.com/2016/04/hdu-4513/</link><pubDate>Mon, 18 Apr 2016 13:06:49 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu-4513/</guid><description>
题目链接：hdu4513
题意：给出一个n的数的序列，求出一个最长的回文字串，并且满足从[l,mid]单调增（非严格单调，可以相等），[mid,r]单调减（同样是可以相等）
思路：manacher...int型的也是可以搞的。。要求单调的话。。。while扩展的时候判一下就好了。。。
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 20时32分45秒 File Name :code/hdu/4513.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int p[N]; int a[N]; int manacher( int *s) { for ( int i = n ; i &amp;gt;= 0 ; i--) { s[i+i+2] = s[i]; s[i+i+1] = 300; } s[0] = 400;s[2*n+3] =405; // for ( int i = 1 ; i &amp;lt; 2*n+1 ; i++) cout&amp;lt;&amp;lt;&amp;quot;s[i]:&amp;quot;&amp;lt;&amp;lt;s[i]&amp;lt;&amp;lt;endl; int id = 0 ; int maxlen = 0 ; for ( int i = 2 ; i &amp;lt; 2*n +1 ; i++) { if (p[id]+id&amp;gt;i) p[i] = min(p[2*id-i],p[id]+id-i); else p[i] = 1; while (s[i-p[i]]==s[i+p[i]]) { if (s[i-p[i]]==300) { p[i]++; } else if (s[i-p[i]]&amp;lt;300) { if (s[i-p[i]]&amp;gt;s[i-p[i]+2]) break; p[i]++; } // cout&amp;lt;&amp;lt;&amp;quot;aaaaaaaaaooooooo&amp;quot;&amp;lt;&amp;lt;endl; } // cout&amp;lt;&amp;lt;&amp;quot;p[i]:&amp;quot;&amp;lt;&amp;lt;p[i]&amp;lt;&amp;lt;endl; if (id+p[id]&amp;lt;i+p[i]) id = i ; if (maxlen&amp;lt;p[i]) maxlen = p[i]; } return maxlen-1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3294 Girls' research (manacher,回文串)</title><link>https://111qqz.com/2016/04/poj3294/</link><pubDate>Mon, 18 Apr 2016 12:27:55 +0000</pubDate><guid>https://111qqz.com/2016/04/poj3294/</guid><description>
poj 3294 题意：先做个简单替换，然后求替换后的字符串的最长回文串，以及这个最长回文串的开始和结束位置。 思路：manacher..需要注意的是，返回下标的时候如果字符串长度为偶数，那么中间是没有字符的。。。需要特判一下。。（我的做法是left+(ans%2==0);
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 19时40分06秒 File Name :code/hdu/3294.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E5+7; char st[N],st2[N]; int p[N]; char ch; void manacher(char *s) { int len = strlen(s); for ( int i = len ; i&amp;gt;= 0 ; i--) { s[i*2+2] = s[i]; s[i*2+1] = '#'; } int id = 0 ; int maxlen = 0 ; int center = 0 ; s[0]='%'; for ( int i = 2 ; i &amp;lt; 2*len+1 ; i++) { if (id+p[id]&amp;gt;i) p[i] = min(p[2*id-i],p[id]+id-i); else p[i] = 1; while (s[p[i]+i]==s[i-p[i]]) p[i]++; if (id+p[id]&amp;lt;i+p[i]) id = i; if (p[i]&amp;gt;maxlen) { maxlen = p[i]; center = i; } } int ans = (maxlen-1); // cout&amp;lt;&amp;lt;&amp;quot;ans:&amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&amp;quot; center:&amp;quot;&amp;lt;&amp;lt;center&amp;lt;&amp;lt;endl; if (ans&amp;lt;2) { puts(&amp;quot;No solution!</description></item><item><title>poj 3974 Palindrome (最长回文字串，manacher裸题)</title><link>https://111qqz.com/2016/04/poj-3974-palindrome-manacher/</link><pubDate>Mon, 18 Apr 2016 08:46:54 +0000</pubDate><guid>https://111qqz.com/2016/04/poj-3974-palindrome-manacher/</guid><description>
poj3974 题意：求最大长度的回文字串。 思路：manacher裸题，用来练习算法。
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 16时32分25秒 File Name :code/poj/3974.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E6+7; char st[2*N]; int p[2*N]; int manacher(char *s) { int len = strlen(s); for ( int i = len ; i &amp;gt;= 0 ; i-- ) { s[i+i+2]=s[i]; s[i+i+1]='#'; } s[0]='$'; int id = 0 ; int maxlen = 0 ; for ( int i = 2 ; i &amp;lt; 2*len+1 ; i++) { if (id+p[id]&amp;gt;i) p[i] = min(p[2*id-i],id+p[id]-i); else p[i] = 1; while (s[i+p[i]]==s[i-p[i]]) p[i]++; if (id+p[id]&amp;lt;i+p[i]) id = i; if (p[i]&amp;gt;maxlen) maxlen = p[i]; } return maxlen-1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3068 最长回文（O(n)求回文串，manacher算法模板题）</title><link>https://111qqz.com/2016/04/hdu-3068/</link><pubDate>Mon, 18 Apr 2016 07:53:47 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu-3068/</guid><description>
题目链接 题意：求一个字符串中的最长回文串。 思路：昨天武大校赛遇到了一个manacher算法的题。。。我竟然听都没听过。。。
于是去学习了一发。
感觉这篇博客讲得最详细manachar算法学习
于是切了个模板题练手。
先简单说下我对这个算法的理解，等做一些题目以后再来总结一发。 我觉得manachar算法最关键的一点是，如果你枚举回文串的中心位置，当你枚举到i的时候，那么i之前的位置回文串长度的最大值是已经确定的了。 换句话说，后面的中心位置不会影响前面的中心位置的答案。 于是可以利用前面已经做过的匹配来获得一些信息，避免了重复。 不过讲真。。。O(n)的复杂度。。这算法还是相当让人感到震撼的。。。 更具体的部分见代码注释。。。
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 14时06分59秒 File Name :code/hdu/3068.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E6+999; char st[N]; int p[2*N]; //p[i]为以第i个位置的字符为中心的回文串的半径长，默认为1.</description></item><item><title>20160416</title><link>https://111qqz.com/2016/04/20160416/</link><pubDate>Sat, 16 Apr 2016 16:00:19 +0000</pubDate><guid>https://111qqz.com/2016/04/20160416/</guid><description>
最近各种比赛各种滚粗。。。 武大。。。武科大。。。地大。。。还有在路上的华农以及我科校赛。。。 然而还有10天考试。 然而还有15天要搞定OS大作业，然而我还没开始。
和小可算是彻底闹僵了。。。。虽然完全不懂是怎么回事。。。妹子的心思啊。。。完全搞不懂。。。 就当她只活在我记忆中吧。
明天武大校赛，晚安。</description></item><item><title>BZOJ 1660: [Usaco2006 Nov]Bad Hair Day 乱发节 (单调栈)</title><link>https://111qqz.com/2016/04/bzoj-1660-usaco2006-novbad-hair-day--/</link><pubDate>Fri, 15 Apr 2016 08:49:50 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1660-usaco2006-novbad-hair-day--/</guid><description/></item><item><title>BZOJ 1657: [Usaco2006 Mar]Mooo 奶牛的歌声 (单调栈)</title><link>https://111qqz.com/2016/04/bzoj-1657-usaco2006-marmooo--/</link><pubDate>Fri, 15 Apr 2016 08:07:59 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1657-usaco2006-marmooo--/</guid><description>
1657: [Usaco2006 Mar]Mooo 奶牛的歌声 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 634 Solved: 447 [Submit][Status][Discuss]
Description Farmer John's N (1 &amp;lt;= N &amp;lt;= 50,000) cows are standing in a very straight row and mooing. Each cow has a unique height h in the range 1..2,000,000,000 nanometers (FJ really is a stickler for precision). Each cow moos at some volume v in the range 1..10,000. This &amp;quot;moo&amp;quot; travels across the row of cows in both directions (except for the end cows, obviously).</description></item><item><title>BZOJ 1656: [Usaco2006 Jan] The Grove 树木(神奇的bfs之射线法)</title><link>https://111qqz.com/2016/04/bzoj-1656/</link><pubDate>Fri, 15 Apr 2016 07:23:53 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1656/</guid><description>
1656: [Usaco2006 Jan] The Grove 树木 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 143 Solved: 88 [Submit][Status][Discuss]
Description The pasture contains a small, contiguous grove of trees that has no 'holes' in the middle of the it. Bessie wonders: how far is it to walk around that grove and get back to my starting position? She's just sure there is a way to do it by going from her start location to successive locations by walking horizontally, vertically, or diagonally and counting each move as a single step.</description></item><item><title>BZOJ 3407: [Usaco2009 Oct]Bessie's Weight Problem 贝茜的体重问题(01背包)</title><link>https://111qqz.com/2016/04/bzoj-3407/</link><pubDate>Thu, 14 Apr 2016 11:39:25 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-3407/</guid><description>
3407: [Usaco2009 Oct]Bessie's Weight Problem 贝茜的体重问题 Time Limit: 3 Sec Memory Limit: 128 MB Submit: 88 Solved: 79 [Submit][Status][Discuss]
Description 贝茜像她的诸多姊妹一样，因为从约翰的草地吃了太多美味的草而长出了太多的赘肉．所以约翰将她置于一个及其严格的节食计划之中．她每天不能吃多过H(5≤日≤45000)公斤的干草．贝茜只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了．她有一个完整
的N(1≤N≤500)捆可以给她当作晚餐的干草的清单．她自然想要尽量吃到更多的干草．很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）．
给定一个列表表示每捆干草的重量Si(1≤Si≤H)，求贝茜不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）．
Input 第1行：两个由空格隔开的整数日和N.
第2到第N+1行：第i+l行是一个单独的整数，表示第i捆干草的重量Si．
Output 一个单独的整数表示贝茜在限制范围内最多可以吃多少公斤的干草．
Sample Input 56 4 15 19 20 21
Sample Output 56
HINT 有四捆草，重量分别是15，19，20和21.贝茜在56公斤的限制范围内想要吃多少就可以吃多少．
贝茜可以吃3捆干草（重量分别为15，20，21）．恰好达到她的56公斤的限制．
``
/* *********************************************** Author :111qqz Created Time :2016年04月14日 星期四 19时33分09秒 File Name :code/bzoj/3407.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; int n,V; int a[505]; int dp[N]; void solve ( int cost,int val) { for ( int i = V ; i &amp;gt;= cost ; i--) dp[i] = max(dp[i],dp[i-cost]+val); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1655: [Usaco2006 Jan] Dollar Dayz 奶牛商店 (母函数，高精度)</title><link>https://111qqz.com/2016/04/bzoj1655/</link><pubDate>Thu, 14 Apr 2016 10:28:28 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1655/</guid><description>
1655: [Usaco2006 Jan] Dollar Dayz 奶牛商店 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 353 Solved: 190 [Submit][Status][Discuss]
Description Farmer John goes to Dollar Days at The Cow Store and discovers an unlimited number of tools on sale. During his first visit, the tools are selling variously for $1, $2, and $3. Farmer John has exactly $5 to spend. He can buy 5 tools at $1 each or 1 tool at $3 and an additional 1 tool at $2.</description></item><item><title>BZOJ 1653: [Usaco2006 Feb]Backward Digit Sums(暴力)</title><link>https://111qqz.com/2016/04/bzoj1653/</link><pubDate>Thu, 14 Apr 2016 07:12:27 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1653/</guid><description>
1653: [Usaco2006 Feb]Backward Digit Sums Time Limit: 5 Sec Memory Limit: 64 MB Submit: 349 Solved: 258 [Submit][Status][Discuss]
Description FJ and his cows enjoy playing a mental game. They write down the numbers from 1 to N (1 &amp;lt;= N &amp;lt;= 10) in a certain order and then sum adjacent numbers to produce a new list with one fewer number. They repeat this until only a single number is left. For example, one instance of the game (when N=4) might go like this: 3 1 2 4 4 3 6 7 9 16 Behind FJ's back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number N.</description></item><item><title>tmp</title><link>https://111qqz.com/2016/04/tmp/</link><pubDate>Wed, 13 Apr 2016 12:10:55 +0000</pubDate><guid>https://111qqz.com/2016/04/tmp/</guid><description>
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int N=1E4+7; int n,k,Q; int siz; int pos[N]; int sum[N]; int dis[N]; bool vis[N]; vector &amp;lt; pair&amp;lt;int,int&amp;gt; &amp;gt; edge[N]; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (pos[l]==pos[b.l]) return r&amp;lt;b.r; return pos[l]&amp;lt;pos[b.l]; } }q[N]; void dfs( int u,int val) { vis[u] = true; dis[u+1] = val; int Siz = edge[u].</description></item><item><title>hdu 2586 How far away ？ (tarjan算法求LCA模板题)</title><link>https://111qqz.com/2016/04/hdu2586/</link><pubDate>Tue, 12 Apr 2016 12:28:42 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu2586/</guid><description>
题目链接 题意：一棵树，给出n-1个边权，然后q组查询，每组查询询问两个点之间的距离。 思路：
dfs跑出根到每个点的距离，设为dis[i] 那么u,v两点的距离就是ans = dis[u]+dis[v]-2*dis[lca(u,v)];
其中lca(u,v)为u,v的最近公共祖先。 这个式子是利用容斥，其实也很直观。。不理解的话画个图就好。
所以终点就是求两个点的LCA.
据说有好多种做法。今天学习了大概是最简单的一种？ 学习链接
//parent为并查集，FIND为并查集的查找操作 //QUERY为询问结点对集合 //TREE为基图有根树 Tarjan(u) visit[u] = true for each (u, v) in TREE if !visit[v] Tarjan(v) parent[v] = u for each (u, v) in QUERY if visit[v] ans(u, v) = FIND(v) 我的理解：其实本质就是利用并查集。。在访问一个点的子树的时候，这个点其所有子树的祖先。。。由于祖先的节点比较小，所以merge的时候要f[大]=小...
要注意Tarjan 算法是离线算法。
哦对了。。这题要扩展语句才能过，不然会RE...
&amp;lt;span style=&amp;quot;color: blue;&amp;quot;&amp;gt;#pragma comment(linker, &amp;quot;/STACK:1024000000,1024000000&amp;quot;) &amp;lt;/span&amp;gt; /* *********************************************** Author :111qqz Created Time :2016年04月12日 星期二 19时39分38秒 File Name :code/hdu/2586.cpp ************************************************ */ #pragma comment(linker, &amp;quot;/STACK:1024000000,1024000000&amp;quot;) #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 4E4+7; int n,q; vector &amp;lt; pi &amp;gt; edge[N]; vector &amp;lt; pi &amp;gt;query[N]; bool vis[N]; int f[N]; int ans[N]; int dis[N]; void init() { for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>树边，前向边，后向边，横叉边</title><link>https://111qqz.com/2016/04/</link><pubDate>Tue, 12 Apr 2016 10:35:19 +0000</pubDate><guid>https://111qqz.com/2016/04/</guid><description>
转载自： 原文链接
树边，前向边，后向边，横叉边，应该说，不是一个图本身有的概念，应该是图进行DFS时才有的概念。图进行DFS会得到一棵DFS树（森林），在这个树上才有了这些概念。对图进行DFS，可以从任意的顶点开始，遍历的方式也是多样的，所以不同的遍历会得到不同的DFS树，进而产生不同的树边，前向边，后向边，横叉边。所以这4种边，是一个相对的概念。 在图的遍历中，往往设置了一个标记数组vis的bool值来记录顶点是否被访问过。但有些时候需要改变vis值的意义。令vis具有3种值并表示3种不同含义 vis = 0,表示该顶点没没有被访问 vis = 1,表示该顶点已经被访问，但其子孙后代还没被访问完，也就没从该点返回 vis = 2,，表示该顶点已经被访问，其子孙后代也已经访问完，也已经从该顶点返回 可以vis的3种值表示的是一种顺序关系和时间关系
《算法导论》334页有这4种边的准确定义，在此不累述 DFS过程中，对于一条边u-&amp;gt;v vis[v] = 0,说明v还没被访问，v是首次被发现，u-&amp;gt;v是一条树边 vis[v] = 1,说明v已经被访问，但其子孙后代还没有被访问完（正在访问中），而u又指向v？说明u就是v的子孙后代，u-&amp;gt;v是一条后向边，因此后向边又称返祖边 vis[v] = 3,z说明v已经被访问，其子孙后代也已经全部访问完，u-&amp;gt;v这条边可能是一条横叉边，或者前向边
注意：树边，后向边，前向边，都有祖先，后裔的关系，但横叉边没有，u-&amp;gt;v为横叉边，说明在这棵DFS树中，它们不是祖先后裔的关系它们可能是兄弟关系，堂兄弟关系，甚至更远的关系，如果是dfs森林的话，u和v甚至可以在不同的树上
在很多算法中，后向边都是有作用的，但是前向边和横叉边的作用往往被淡化，其实它们没有太大作用。</description></item><item><title>BZOJ 1652: [Usaco2006 Feb]Treats for the Cows (区间dp)</title><link>https://111qqz.com/2016/04/bzoj-1652/</link><pubDate>Tue, 12 Apr 2016 02:37:28 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1652/</guid><description>
1652: [Usaco2006 Feb]Treats for the Cows Time Limit: 5 Sec Memory Limit: 64 MB Submit: 290 Solved: 226 [Submit][Status][Discuss]
Description FJ has purchased N (1 &amp;lt;= N &amp;lt;= 2000) yummy treats for the cows who get money for giving vast amounts of milk. FJ sells one treat per day and wants to maximize the money he receives over a given period time. The treats are interesting for many reasons: * The treats are numbered 1.</description></item><item><title>BZOJ 1651: [Usaco2006 Feb]Stall Reservations 专用牛棚 (前缀和)</title><link>https://111qqz.com/2016/04/bzoj1651/</link><pubDate>Mon, 11 Apr 2016 12:31:58 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1651/</guid><description>
1651: [Usaco2006 Feb]Stall Reservations 专用牛棚 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 700 Solved: 393 [Submit][Status][Discuss]
Description Oh those picky N (1 &amp;lt;= N &amp;lt;= 50,000) cows! They are so picky that each one will only be milked over some precise time interval A..B (1 &amp;lt;= A &amp;lt;= B &amp;lt;= 1,000,000), which includes both times A and B. Obviously, FJ must create a reservation system to determine which stall each cow can be assigned for her milking time.</description></item><item><title>BZOJ 1650: [Usaco2006 Dec]River Hopscotch 跳石子 (二分)</title><link>https://111qqz.com/2016/04/bzoj-1650/</link><pubDate>Mon, 11 Apr 2016 12:07:02 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1650/</guid><description>
1650: [Usaco2006 Dec]River Hopscotch 跳石子 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 440 Solved: 290 [Submit][Status][Discuss]
Description Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 &amp;lt;= L &amp;lt;= 1,000,000,000).</description></item><item><title>BZOJ 1649: [Usaco2006 Dec]Cow Roller Coaster (dp，类似01背包)</title><link>https://111qqz.com/2016/04/bzoj-1649/</link><pubDate>Mon, 11 Apr 2016 09:19:52 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1649/</guid><description>
Time Limit: 5 Sec Memory Limit: 64 MB Submit: 504 Solved: 265 [Submit][Status][Discuss]
Description The cows are building a roller coaster! They want your help to design as fun a roller coaster as possible, while keeping to the budget. The roller coaster will be built on a long linear stretch of land of length L (1 &amp;lt;= L &amp;lt;= 1,000). The roller coaster comprises a collection of some of the N (1 &amp;lt;= N &amp;lt;= 10,000) different interchangable components.</description></item><item><title>BZOJ 1648: [Usaco2006 Dec]Cow Picnic 奶牛野餐 (dfs)</title><link>https://111qqz.com/2016/04/bzoj-1648/</link><pubDate>Mon, 11 Apr 2016 08:36:25 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1648/</guid><description>
1648: [Usaco2006 Dec]Cow Picnic 奶牛野餐 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 562 Solved: 352 [Submit][Status][Discuss]
Description The cows are having a picnic! Each of Farmer John's K (1 &amp;lt;= K &amp;lt;= 100) cows is grazing in one of N (1 &amp;lt;= N &amp;lt;= 1,000) pastures, conveniently numbered 1...N. The pastures are connected by M (1 &amp;lt;= M &amp;lt;= 10,000) one-way paths (no path connects a pasture to itself).</description></item><item><title>BZOJ 1646: [Usaco2007 Open]Catch That Cow 抓住那只牛 (BFS)</title><link>https://111qqz.com/2016/04/bzoj-1646-usaco2007-opencatch-that-cow--bfs/</link><pubDate>Sun, 10 Apr 2016 13:07:12 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1646-usaco2007-opencatch-that-cow--bfs/</guid><description>
1646: [Usaco2007 Open]Catch That Cow 抓住那只牛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 915 Solved: 441 [Submit][Status][Discuss]
Description Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 &amp;lt;= N &amp;lt;= 100,000) on a number line and the cow is at a point K (0 &amp;lt;= K &amp;lt;= 100,000) on the same number line.</description></item><item><title>BZOJ 1644: [Usaco2007 Oct]Obstacle Course 障碍训练课 (BFS,DP)</title><link>https://111qqz.com/2016/04/bzoj-1644-usaco2007-octobstacle-course--bfsdp/</link><pubDate>Sun, 10 Apr 2016 12:41:46 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1644-usaco2007-octobstacle-course--bfsdp/</guid><description>
1644: [Usaco2007 Oct]Obstacle Course 障碍训练课 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 451 Solved: 226 [Submit][Status][Discuss]
Description 考虑一个 N x N (1 &amp;lt;= N &amp;lt;= 100)的有1个个方格组成的正方形牧场。有些方格是奶牛们不能踏上的，它们被标记为了'x'。例如下图：
. . B x . . x x A . . . . x . . x . . . . . x . .
贝茜发现自己恰好在点A处，她想去B处的盐块舔盐。缓慢而且笨拙的动物，比如奶牛，十分讨厌转弯。尽管如此，当然在必要的时候她们还是会转弯的。对于一个给定的牧场，请你计算从A到B最少的转弯次数。开始的时候，贝茜可以使面对任意一个方向。贝茜知道她一定可以到达。
Input 第 1行: 一个整数 N 行
2..N + 1: 行 i+1 有 N 个字符 ('.', 'x', 'A', 'B')，表示每个点的状态。</description></item><item><title>BZOJ 1643: [Usaco2007 Oct]Bessie's Secret Pasture 贝茜的秘密草坪(母函数)</title><link>https://111qqz.com/2016/04/bzoj-1643-usaco2007-octbessies-secret-pasture-/</link><pubDate>Sun, 10 Apr 2016 08:58:22 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1643-usaco2007-octbessies-secret-pasture-/</guid><description>
1643: [Usaco2007 Oct]Bessie's Secret Pasture 贝茜的秘密草坪 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 330 Solved: 278 [Submit][Status][Discuss]
Description 农夫约翰已经从他的牧场中取得了数不清块数的正方形草皮，草皮的边长总是整数（有时农夫约翰割草皮的刀法不合适，甚至切出了边长为0的正方形草皮），他已经把草皮放在了一个奶牛贝茜已经知道的地方。 贝茜总是希望把美味的草皮放到她的秘密庄园里，她决定从这些草皮中取出恰好4块搬到她的秘密庄园中，然后把它们分成1×1的小块，组成一个面积为N(1&amp;lt;=N&amp;lt;=10,000)个单位面积的部分。 贝茜对选出这样四块草皮的方法数很感兴趣，如果她得到了一个4个单位面积的部分，那么她可以有5中不同的方法选4块草皮：(1,1,1,1),(2,0,0,0),(0,2,0,0),(0,0,0,2).顺序是有效的：(4,3,2,1)和(1,2,3,4)是不同的方法。
Input 第一行：一个单独的整数N。
Output 单独的一行包含一个整数，表示贝茜选四块草皮的方案数。
Sample Input 4
Sample Output 5
思路：母函数。把四个位置看作四个式子。每个式子的i可以取从0到i*i&amp;lt;=n的最大值。
/* *********************************************** Author :111qqz Created Time :2016年04月10日 星期日 16时34分31秒 File Name :code/bzoj/1643.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; int a[N],tmp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1642: [Usaco2007 Nov]Milking Time 挤奶时间 (dp,类似LIS)</title><link>https://111qqz.com/2016/04/bzoj1642/</link><pubDate>Sun, 10 Apr 2016 08:31:35 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1642/</guid><description>
Time Limit: 5 Sec Memory Limit: 64 MB Submit: 667 Solved: 389 [Submit][Status][Discuss]
Description 贝茜是一只非常努力工作的奶牛，她总是专注于提高自己的产量。为了产更多的奶，她预计好了接下来的N (1 ≤ N ≤ 1,000,000)个小时，标记为0..N-1。 Farmer John 计划好了 M (1 ≤ M ≤ 1,000) 个可以挤奶的时间段。每个时间段有一个开始时间(0 ≤ 开始时间 ≤ N), 和一个结束时间 (开始时间 &amp;lt; 结束时间 ≤ N), 和一个产量 (1 ≤ 产量 ≤ 1,000,000) 表示可以从贝茜挤奶的数量。Farmer John 从分别从开始时间挤奶，到结束时间为止。每次挤奶必须使用整个时间段。 但即使是贝茜也有她的产量限制。每次挤奶以后，她必须休息 R (1 ≤ R ≤ N) 个小时才能下次挤奶。给定Farmer John 计划的时间段，请你算出在 N 个小时内，最大的挤奶的量。
Input 第1行三个整数N，M，R.接下来M行，每行三个整数Si，Ei，Pi．
Output  最大产奶量．
Sample Input 12 4 2 1 2 8 10 12 19 3 6 24 7 10 31</description></item><item><title>BZOJ 1641: [Usaco2007 Nov]Cow Hurdles 奶牛跨栏 (floyd)</title><link>https://111qqz.com/2016/04/bzoj-1641-usaco2007-novcow-hurdles--floyd/</link><pubDate>Sat, 09 Apr 2016 17:41:46 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1641-usaco2007-novcow-hurdles--floyd/</guid><description>
1641: [Usaco2007 Nov]Cow Hurdles 奶牛跨栏 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 531 Solved: 344 [Submit][Status][Discuss]
Description Farmer John 想让她的奶牛准备郡级跳跃比赛，贝茜和她的伙伴们正在练习跨栏。她们很累，所以她们想消耗最少的能量来跨栏。 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。 奶牛的训练场中有 N (1 ≤ N ≤ 300) 个站台，分别标记为1..N。所有站台之间有M (1 ≤ M ≤ 25,000)条单向路径，第i条路经是从站台Si开始，到站台Ei，其中最高的栏的高度为Hi (1 ≤ Hi ≤ 1,000,000)。无论如何跑，奶牛们都要跨栏。 奶牛们有 T (1 ≤ T ≤ 40,000) 个训练任务要完成。第 i 个任务包含两个数字 Ai 和 Bi (1 ≤ Ai ≤ N; 1 ≤ Bi ≤ N)，表示奶牛必须从站台Ai跑到站台Bi，可以路过别的站台。奶牛们想找一条路径从站台Ai到站台Bi，使路径上最高的栏的高度最小。 你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。
Input 行 1: 两个整数 N, M, T 行</description></item><item><title>BZOJ 1640/1692 : [Usaco2007 Nov]Best Cow Line 队列变换 (贪心)</title><link>https://111qqz.com/2016/04/bzoj-1640/</link><pubDate>Sat, 09 Apr 2016 12:29:38 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1640/</guid><description>
1640: [Usaco2007 Nov]Best Cow Line 队列变换 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 710 Solved: 373 [Submit][Status][Discuss]
Description FJ打算带着他可爱的N (1 ≤ N ≤ 2,000)头奶牛去参加”年度最佳老农”的比赛.在比赛中,每个农夫把他的奶牛排成一列,然后准备经过评委检验. 比赛中简单地将奶牛的名字缩写为其头字母(the initial letter of every cow),举个例子,FJ带了Bessie, Sylvia,和Dora,那么就可以缩写为BSD. FJ只需将奶牛的一个序列重新排列,然后参加比赛.他可以让序列中的第一头奶牛,或者最后一头走出来,站到新队列的队尾. 利欲熏心的FJ为了取得冠军,他就必须使新队列的字典序尽量小. 给你初始奶牛序列(用头字母)表示,然后按照上述的规则组成新序列,并使新序列的字典序尽量小.
Input 第1行:一个整数N.
第2行至第N+1行:每行一个大写字母,表示初始序列中该奶牛的头字母.
Output 得到的最小字典序的序列.每输出80个字母需要一个换行!
Sample Input 6 A C D B C B
Sample Output ABCBCD
HINT Source Silver
思路：比较麻烦的一个贪心。。对拍才找出了一个错误。。。
写丑了QAQ
/* *********************************************** Author :111qqz Created Time :2016年04月08日 星期五 16时16分34秒 File Name :code/bzoj/1640.</description></item><item><title>BZOJ 1639: [Usaco2007 Mar]Monthly Expense 月度开支 (二分)</title><link>https://111qqz.com/2016/04/bzoj-1639/</link><pubDate>Fri, 08 Apr 2016 08:11:10 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1639/</guid><description>
1639: [Usaco2007 Mar]Monthly Expense 月度开支 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 767 Solved: 381 [Submit][Status][Discuss]
Description Farmer John是一个令人惊讶的会计学天才，他已经明白了他可能会花光他的钱，这些钱本来是要维持农场每个月的正常运转的。他已经计算了他以后N(1&amp;lt;=N&amp;lt;=100,000)个工作日中每一天的花费moneyi(1&amp;lt;=moneyi&amp;lt;=10,000)，他想要为他连续的M(1&amp;lt;=M&amp;lt;=N)个被叫做“清算月”的结帐时期做一个预算，每一个“清算月”包含一个工作日或更多连续的工作日，每一个工作日都仅被包含在一个“清算月”当中。 FJ的目标是安排这些“清算月”，使得每个清算月的花费中最大的那个花费达到最小，从而来决定他的月度支出限制。
Input 第一行：两个用空格隔开的整数：N和M
第2..N+1行：第i+1行包含FJ在他的第i个工作日的花费
Output 第一行：能够维持每个月农场正常运转的钱数
Sample Input 7 5 100 400 300 100 500 101 400
Sample Output 500 输入细节
这里有7个工作日来被5个“清算月”划分。他花费100，400，100，500，101，和400元在他的每个工作日。
输出细节
如果FJ安排他的月度预算，他将把前两天划分在一个月中，把第三天、第四天划分在一个月当中，最后的三个工作日各自在一个月当中，所以他一个月最多花费500元，其他的方法总是得出一个较大的结果。
100 400 300 100 500 101 400 每天花费 ---1--- ---2--- -3- -4- -5- 月度标号 500 400 500 101 400 月度花费
HINT Source Silver
思路：一开始以为是贪心。挨个放，然后每放完m个sort一次。但是有可能是连续多次都划分在一个里啊。。不一定是挨个放，所以是错的。
正解是二分：check的时候因为必须是连续的区间，每次大于x了，则划分数+1，最后判断划分数是否小于等于m.需要注意的是，初始的划分数就是1.</description></item><item><title>BZOJ 1637: [Usaco2007 Mar]Balanced Lineup (前缀和乱搞)</title><link>https://111qqz.com/2016/04/bzoj-1637/</link><pubDate>Fri, 08 Apr 2016 06:59:57 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1637/</guid><description>
1637: [Usaco2007 Mar]Balanced Lineup Time Limit: 5 Sec Memory Limit: 64 MB Submit: 503 Solved: 336 [Submit][Status][Discuss]
Description Farmer John 决定给他的奶牛们照一张合影，他让 N (1 ≤ N ≤ 50,000) 头奶牛站成一条直线，每头牛都有它的坐标(范围: 0..1,000,000,000)和种族(0或1)。 一直以来 Farmer John 总是喜欢做一些非凡的事，当然这次照相也不例外。他只给一部分牛照相，并且这一组牛的阵容必须是“平衡的”。平衡的阵容，指的是在一组牛中，种族0和种族1的牛的数量相等。 请算出最广阔的区间，使这个区间内的牛阵容平衡。区间的大小为区间内最右边的牛的坐标减去最做边的牛的坐标。 输入中，每个种族至少有一头牛，没有两头牛的坐标相同。
Input 行 1: 一个整数: N 行 2..N + 1: 每行两个整数，为种族 ID 和 x 坐标。
Output 行 1: 一个整数，阵容平衡的最大的区间的大小。
Sample Input 7 0 11 1 10 1 25 1 12 1 4 0 13 1 22</description></item><item><title>BZOJ 1635: [Usaco2007 Jan]Tallest Cow 最高的牛 (差分序列（前缀和的逆）)</title><link>https://111qqz.com/2016/04/bzoj-1635/</link><pubDate>Thu, 07 Apr 2016 16:19:00 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1635/</guid><description>
1635: [Usaco2007 Jan]Tallest Cow 最高的牛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 472 Solved: 278 [Submit][Status][Discuss]
Description FJ's N (1 &amp;lt;= N &amp;lt;= 10,000) cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height H (1 &amp;lt;= H &amp;lt;= 1,000,000) of the tallest cow along with the index I of that cow.</description></item><item><title>BZOJ 1634: [Usaco2007 Jan]Protecting the Flowers 护花(贪心)</title><link>https://111qqz.com/2016/04/bzoj1634/</link><pubDate>Thu, 07 Apr 2016 05:52:49 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1634/</guid><description>
1634: [Usaco2007 Jan]Protecting the Flowers 护花 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 605 Solved: 383 [Submit][Status][Discuss]
Description Farmer John went to cut some wood and left N (2 &amp;lt;= N &amp;lt;= 100,000) cows eating the grass, as usual. When he returned, he found to his horror that the cows were in his garden eating his beautiful flowers. Wanting to minimize the subsequent damage, FJ decided to take immediate action and transport the cows back to their barn.</description></item><item><title>BZOJ 1632: [Usaco2007 Feb]Lilypad Pond (BFS,dp)</title><link>https://111qqz.com/2016/04/bzoj-1632/</link><pubDate>Wed, 06 Apr 2016 15:37:13 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1632/</guid><description>
1632: [Usaco2007 Feb]Lilypad Pond Time Limit: 5 Sec Memory Limit: 64 MB Submit: 496 Solved: 153 [Submit][Status][Discuss]
Description Farmer John 建造了一个美丽的池塘，用于让他的牛们审美和锻炼。这个长方形的池子被分割成了 M 行和 N 列( 1 ≤ M ≤ 30 ; 1 ≤ N ≤ 30 ) 正方形格子的 。某些格子上有惊人的坚固的莲花，还有一些岩石，其余的只是美丽，纯净，湛蓝的水。 贝茜正在练习芭蕾舞，她从一个莲花跳跃到另一个莲花，当前位于一个莲花。她希望在莲花上一个一个的跳，目标是另一个给定莲花。她能跳既不入水，也不到一个岩石上。 令门外汉惊讶的是，贝茜的每次的跳跃像中国象棋的马一样：横向移动1，纵向移动2，或纵向移动1，横向移动2。贝茜有时可能会有多达8个选择的跳跃。 Farmer John 在观察贝茜的芭蕾舞联系，他意识到有时候贝茜有可能跳不到她想去的目的地，因为路上有些地方没有莲花。于是他想要添加几个莲花使贝茜能够完成任务。一贯节俭的Farmer John想添加最少数量的莲花。当然，莲花不能放在石头上。 请帮助Farmer John确定必须要添加的莲花的最少数量。在添加的莲花最少基础上，算出贝茜从起始点跳到目标点需要的最少的步数。最后，还要算出满足添加的莲花的最少数量时，跳跃最少步数的跳跃路径的条数。
Input 第 1 行: 两个整数 M , N
第 2..M + 1 行:第 i + 1 行，第 i + 1 行 有 N 个整数，表示该位置的状态: 0 为水; 1 为莲花; 2 为岩石; 3 为贝茜开始的位置; 4 为贝茜要去的目标位置.</description></item><item><title>BZOJ 1630/2023: [Usaco2005 Nov]Ant Counting 数蚂蚁 （母函数）</title><link>https://111qqz.com/2016/04/bzoj1630/</link><pubDate>Mon, 04 Apr 2016 11:28:12 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1630/</guid><description>
2023: [Usaco2005 Nov]Ant Counting 数蚂蚁 Time Limit: 4 Sec Memory Limit: 64 MB Submit: 149 Solved: 85 [Submit][Status][Discuss]
Description  有一天，贝茜无聊地坐在蚂蚁洞前看蚂蚁们进进出出地搬运食物．很快贝茜发现有些蚂蚁长得几乎一模一样，于是她认为那些蚂蚁是兄弟，也就是说它们是同一个家族里的成员．她也发现整个蚂蚁群里有时只有一只出来觅食，有时是几只，有时干脆整个蚁群一起出来．这样一来，蚂蚁们出行觅食时的组队方案就有很多种．作为一头有数学头脑的奶牛，贝茜注意到整个蚂蚁群由T(1≤T≤1000)个家族组成，她将这些家族按1到T依次编号．编号为i的家族里有Ni(1≤Ni≤100)只蚂蚁．同一个家族里的蚂蚁可以认为是完全相同的．
 如果一共有S，S+1…．，B(1≤S≤B≤A)只蚂蚁一起出去觅食，它们一共能组成多少种不同的队伍呢？注意：只要两支队伍中所包含某个家族的蚂蚁数不同，我们就认为这两支队伍不同．由于贝茜无法分辨出同一家族的蚂蚁，所以当两支队伍中所包含的所有家族的蚂蚁数都相同时，即使有某个家族换了几只蚂蚁出来，贝茜也会因为看不出不同而把它们认为是同一支队伍． 比如说，有个由3个家族组成的蚂蚁群里一共有5只蚂蚁，它们所属的家族分别为1，1，2，2，3．于是出去觅食时它们有以下几种组队方案：
 ·1只蚂蚁出去有三种组合：(1)(2)(3)
 ·2只蚂蚁出去有五种组合：(1，1)(1，2)(1，3)(2，2)(2，3)
 ·3只蚂蚁出去有五种组合：(1，1，2)(1，1，3)(1，2，2)(1，2，3)(2，2，3)
 ·4只蚂蚁出去有三种组合：(1，2，2，3)(1，1，2，2)(1，1，2，3)
 ·5只蚂蚁出去有一种组合：(1，1，2，2，3)
 你的任务就是根据给出的数据，计算蚂蚁们组队方案的总数．
Input  第1行：4个用空格隔开的整数T，A，S，B.
 第2到A+1行：每行是一个正整数，为某只蚂蚁所在的家族的编号．
Output  输出一个整数，表示当S到B（包括S和B）只蚂蚁出去觅食时，不同的组队方案数．
 注意：组合是无序的，也就是说组合1，2和组合2，1是同一种组队方式．最后的答案可能很大，你只需要输出答案的最后6位数字．注意不要输出前导0以及多余的空格．
Sample Input 3 5 2 3 1 2 2 1 3INPUT DETAILS:Three types of ants (1..3); 5 ants altogether. How many sets of size 2 or size 3 can be made?</description></item><item><title>BZOJ 1629: [Usaco2007 Demo]Cow Acrobats (贪心)</title><link>https://111qqz.com/2016/04/bzoj1629/</link><pubDate>Mon, 04 Apr 2016 09:27:55 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1629/</guid><description>
1629: [Usaco2007 Demo]Cow Acrobats Time Limit: 5 Sec Memory Limit: 64 MB Submit: 771 Solved: 398 [Submit][Status][Discuss]
Description Farmer John's N (1 &amp;lt;= N &amp;lt;= 50,000) cows (numbered 1..N) are planning to run away and join the circus. Their hoofed feet prevent them from tightrope walking and swinging from the trapeze (and their last attempt at firing a cow out of a cannon met with a dismal failure). Thus, they have decided to practice performing acrobatic stunts.</description></item><item><title>BZOJ 1628: [Usaco2007 Demo]City skyline (单调栈)</title><link>https://111qqz.com/2016/04/bzoj1628/</link><pubDate>Mon, 04 Apr 2016 08:47:38 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1628/</guid><description>
1628: [Usaco2007 Demo]City skyline Time Limit: 5 Sec Memory Limit: 64 MB Submit: 396 Solved: 317 [Submit][Status][Discuss]
Description Input 第一行给出N，W
第二行到第N+1行:每行给出二个整数x,y，输入的x严格递增，并且第一个x总是1
Output 输出一个整数，表示城市中最少包含的建筑物数量
Sample Input 10 26 1 1 2 2 5 1 6 3 8 1 11 0 15 2 17 3 20 2 22 1
INPUT DETAILS:
The case mentioned above
Sample Output 6
思路：我是正着做的，判断条件没有问题，但是细节不好处理，一直WA..大概是有什么地方没想到？ 正解是单调栈。
转载一段题解：
答案的上限 肯定是 n， 何时会减一呢？ 当有两座楼高度相等且它们的中间没有比它们低的楼。
所以要维护的是一个单调递增的序列， 每次弹出比它大的直到遇到一个和它相等的， 没有相等的话就把 它加入这个序列中。</description></item><item><title>BZOJ 1627: [Usaco2007 Dec]穿越泥地 (BFS)</title><link>https://111qqz.com/2016/04/bzoj1627/</link><pubDate>Mon, 04 Apr 2016 07:00:06 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1627/</guid><description>
1627: [Usaco2007 Dec]穿越泥地 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 624 Solved: 411 [Submit][Status][Discuss]
Description 清早6：00，Farmer John就离开了他的屋子，开始了他的例行工作：为贝茜挤奶。前一天晚上，整个农场刚经受过一场瓢泼大雨的洗礼，于是不难想见，FJ 现在面对的是一大片泥泞的土地。FJ的屋子在平面坐标(0, 0)的位置，贝茜所在的牛棚则位于坐标(X,Y) (-500 &amp;lt;= X &amp;lt;= 500; -500 &amp;lt;= Y &amp;lt;= 500)处。当然咯， FJ也看到了地上的所有N(1 &amp;lt;= N &amp;lt;= 10,000)个泥塘，第i个泥塘的坐标为 (A_i, B_i) (-500 &amp;lt;= A_i &amp;lt;= 500；-500 &amp;lt;= B_i &amp;lt;= 500)。每个泥塘都只占据了它所在的那个格子。 Farmer John自然不愿意弄脏他新买的靴子，但他同时想尽快到达贝茜所在的位置。为了数那些讨厌的泥塘，他已经耽搁了一些时间了。如果Farmer John 只能平行于坐标轴移动，并且只在x、y均为整数的坐标处转弯，那么他从屋子门口出发，最少要走多少路才能到贝茜所在的牛棚呢？你可以认为从FJ的屋子到牛棚总是存在至少一条不经过任何泥塘的路径。
Input 第1行: 3个用空格隔开的整数：X，Y 和 N
第2..N+1行: 第i+1行为2个用空格隔开的整数：A_i 和 B_i
Output 第1行: 输出1个整数，即FJ在不踏进泥塘的情况下，到达贝茜所在牛棚所需要 走过的最小距离 Sample Input 1 2 7 0 2 -1 3 3 1 1 1 4 2 -1 1 2 2</description></item><item><title>BZOJ 1626: [Usaco2007 Dec]Building Roads 修建道路 (MST)</title><link>https://111qqz.com/2016/04/bzoj1626/</link><pubDate>Mon, 04 Apr 2016 06:40:18 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1626/</guid><description>
1626: [Usaco2007 Dec]Building Roads 修建道路 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1362 Solved: 541 [Submit][Status][Discuss]
Description Farmer John最近得到了一些新的农场，他想新修一些道路使得他的所有农场可以经过原有的或是新修的道路互达（也就是说，从任一个农场都可以经过一些首尾相连道路到达剩下的所有农场）。有些农场之间原本就有道路相连。 所有N(1 &amp;lt;= N &amp;lt;= 1,000)个农场（用1..N顺次编号）在地图上都表示为坐标为(X_i, Y_i)的点(0 &amp;lt;= X_i &amp;lt;= 1,000,000；0 &amp;lt;= Y_i &amp;lt;= 1,000,000)，两个农场间道路的长度自然就是代表它们的点之间的距离。现在Farmer John也告诉了你农场间原有的M(1 &amp;lt;= M &amp;lt;= 1,000)条路分别连接了哪两个农场，他希望你计算一下，为了使得所有农场连通，他所需建造道路的最小总长是多少。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..N+1行: 第i+1行为2个用空格隔开的整数：X_i、Y_i * 第N+2..N+M+2行: 每行用2个以空格隔开的整数i、j描述了一条已有的道路， 这条道路连接了农场i和农场j
Output 第1行: 输出使所有农场连通所需建设道路的最小总长，保留2位小数，不必做 任何额外的取整操作。为了避免精度误差，计算农场间距离及答案时 请使用64位实型变量 Sample Input 4 1 1 1 3 1 2 3 4 3 1 4</description></item><item><title>BZOJ 1624: [Usaco2008 Open] Clear And Present Danger 寻宝之路 (Floyd)</title><link>https://111qqz.com/2016/04/bzoj1624/</link><pubDate>Sun, 03 Apr 2016 19:07:17 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1624/</guid><description>
1624: [Usaco2008 Open] Clear And Present Danger 寻宝之路 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 507 Solved: 345 [Submit][Status][Discuss]
Description  农夫约翰正驾驶一条小艇在牛勒比海上航行．
 海上有N(1≤N≤100)个岛屿，用1到N编号．约翰从1号小岛出发，最后到达N号小岛．一
张藏宝图上说，如果他的路程上经过的小岛依次出现了Ai，A2，…，AM(2≤M≤10000)这样的序列（不一定相邻），那他最终就能找到古老的宝藏． 但是，由于牛勒比海有海盗出没．约翰知道任意两个岛屿之间的航线上海盗出没的概率，他用一个危险指数Dij(0≤Dij≤100000)来描述．他希望他的寻宝活动经过的航线危险指数之和最小．那么，在找到宝藏的前提下，这个最小的危险指数是多少呢？
Input  第1行输入N和M，之后M行一行一个整数表示A序列，之后输入一个NxN的方阵，表示两两岛屿之间航线的危险指数．数据保证Dij=Dji，Dii=0．
Output  最小的危险指数和．
Sample Input 3 4 1 2 1 3 0 5 1 5 0 2 1 2 0
INPUT DETAILS:
There are 3 islands and the treasure map requires Farmer John to visit a sequence of 4 islands in order: island 1, island 2, island 1 again, and finally island 3.</description></item><item><title>BZOJ 1623: [Usaco2008 Open]Cow Cars 奶牛飞车 (贪心)</title><link>https://111qqz.com/2016/04/bzoj1623/</link><pubDate>Sun, 03 Apr 2016 18:44:56 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1623/</guid><description>
1623: [Usaco2008 Open]Cow Cars 奶牛飞车 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 386 Solved: 266 [Submit][Status][Discuss]
Description  编号为1到N的N只奶牛正各自驾着车打算在牛德比亚的高速公路上飞驰．高速公路有M(1≤M≤N)条车道．奶牛i有一个自己的车速上限Si(l≤Si≤1,000,000)．
 在经历过糟糕的驾驶事故之后，奶牛们变得十分小心，避免碰撞的发生．每条车道上，如果某一只奶牛i的前面有K只奶牛驾车行驶，那奶牛i的速度上限就会下降K*D个单位，也就是说，她的速度不会超过Si - kD(O≤D≤5000)，当然如果这个数是负的，那她的速度将是0．牛德比亚的高速会路法规定，在高速公路上行驶的车辆时速不得低于/(1≤L≤1,000,000)．那么，请你计算有多少奶牛可以在高速公路上行驶呢？
Input 第1行输入N，M，D，L四个整数，之后N行每行一个整数输入Si．
N&amp;lt;=50000
Output  输出最多有多少奶牛可以在高速公路上行驶．
Sample Input 3 1 1 5//三头牛开车过一个通道.当一个牛进入通道时，它的速度V会变成V-D*X(X代表在它前面有多少牛),它减速后，速度不能小于L 5 7 5
INPUT DETAILS:
There are three cows with one lane to drive on, a speed decrease of 1, and a minimum speed limit of 5.
Sample Output 2
OUTPUT DETAILS:
Two cows are possible, by putting either cow with speed 5 first and the cow with speed 7 second.</description></item><item><title>BZOJ 1622: [Usaco2008 Open]Word Power 名字的能量 (暴力)</title><link>https://111qqz.com/2016/04/bzoj1622/</link><pubDate>Sun, 03 Apr 2016 18:23:10 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1622/</guid><description>
1622: [Usaco2008 Open]Word Power 名字的能量 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 462 Solved: 228 [Submit][Status][Discuss]
Description  约翰想要计算他那N(1≤N≤1000)只奶牛的名字的能量．每只奶牛的名字由不超过1000个字待构成，没有一个名字是空字体串， 约翰有一张“能量字符串表”，上面有M(1≤M≤100)个代表能量的字符串．每个字符串由不超过30个字体构成，同样不存在空字符串．一个奶牛的名字蕴含多少个能量字符串，这个名字就有多少能量．所谓“蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现（不一定一个紧接着一个）．
 所有的大写字母和小写字母都是等价的．比如，在贝茜的名字“Bessie”里，蕴含有“Be”
“sI”“EE”以及“Es”等等字符串，但不蕴含“lS”或“eB”．请帮约翰计算他的奶牛的名字的能量．
Input  第1行输入两个整数N和M，之后N行每行输入一个奶牛的名字，之后M行每行输入一个能量字符串．
Output  一共N行，每行一个整数，依次表示一个名字的能量．
Sample Input 5 3 Bessie Jonathan Montgomery Alicia Angola se nGo Ont
INPUT DETAILS:
There are 5 cows, and their names are &amp;quot;Bessie&amp;quot;, &amp;quot;Jonathan&amp;quot;, &amp;quot;Montgomery&amp;quot;, &amp;quot;Alicia&amp;quot;, and &amp;quot;Angola&amp;quot;. The 3 good strings are &amp;quot;se&amp;quot;, &amp;quot;nGo&amp;quot;, and &amp;quot;Ont&amp;quot;.
Sample Output 1 1 2 0 1</description></item><item><title>BZOJ1621: [Usaco2008 Open]Roads Around The Farm分岔路口 (DFS)</title><link>https://111qqz.com/2016/04/bzoj1621/</link><pubDate>Sun, 03 Apr 2016 17:58:35 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1621/</guid><description>
1621: [Usaco2008 Open]Roads Around The Farm分岔路口 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 698 Solved: 513 [Submit][Status][Discuss]
Description 约翰的N(1≤N≤1,000,000,000)只奶牛要出发去探索牧场四周的土地．她们将沿着一条路走，一直走到三岔路口（可以认为所有的路口都是这样的）．这时候，这一群奶牛可能会分成两群，分别沿着接下来的两条路继续走．如果她们再次走到三岔路口，那么仍有可能继续分裂成两群继续走． 奶牛的分裂方式十分古怪：如果这一群奶牛可以精确地分成两部分，这两部分的牛数恰好相差K(1≤K≤1000)，那么在三岔路口牛群就会分裂．否则，牛群不会分裂，她们都将在这里待下去，平静地吃草． 请计算，最终将会有多少群奶牛在平静地吃草．
Input 两个整数N和K.
Output 最后的牛群数．
Sample Input 6 2
INPUT DETAILS:
There are 6 cows and the difference in group sizes is 2.
Sample Output 3
OUTPUT DETAILS:
There are 3 final groups (with 2, 1, and 3 cows in them).
6 / 2 4 / 1 3</description></item><item><title>BZOJ 1620: [Usaco2008 Nov]Time Management 时间管理 (贪心)</title><link>https://111qqz.com/2016/04/bzoj-1620/</link><pubDate>Sun, 03 Apr 2016 17:44:02 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1620/</guid><description>
1620: [Usaco2008 Nov]Time Management 时间管理 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 636 Solved: 387 [Submit][Status][Discuss]
Description Ever the maturing businessman, Farmer John realizes that he must manage his time effectively. He has N jobs conveniently numbered 1..N (1 &amp;lt;= N &amp;lt;= 1,000) to accomplish (like milking the cows, cleaning the barn, mending the fences, and so on). To manage his time effectively, he has created a list of the jobs that must be finished.</description></item><item><title>BZOJ1619: [Usaco2008 Nov]Guarding the Farm 保卫牧场 （BFS）</title><link>https://111qqz.com/2016/04/bzoj1619-usaco2008-novguarding-the-farm--bfs/</link><pubDate>Sun, 03 Apr 2016 17:23:04 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1619-usaco2008-novguarding-the-farm--bfs/</guid><description>
1619: [Usaco2008 Nov]Guarding the Farm 保卫牧场 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 661 Solved: 292 [Submit][Status][Discuss]
Description The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows. He wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 &amp;lt; N &amp;lt;= 700) rows and M (1 &amp;lt; M &amp;lt;= 700) columns.</description></item><item><title>BZOJ 1618: [Usaco2008 Nov]Buying Hay 购买干草 (完全背包)</title><link>https://111qqz.com/2016/04/bzoj-1618-usaco2008-novbuying-hay--/</link><pubDate>Sun, 03 Apr 2016 11:53:05 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1618-usaco2008-novbuying-hay--/</guid><description>
1618: [Usaco2008 Nov]Buying Hay 购买干草 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 906 Solved: 456 [Submit][Status][Discuss]
Description  约翰的干草库存已经告罄，他打算为奶牛们采购日(1≤日≤50000)磅干草．
 他知道N(1≤N≤100)个干草公司，现在用1到N给它们编号．第i个公司卖的干草包重量为Pi(1≤Pi≤5000)磅，需要的开销为Ci(l≤Ci≤5000)美元．每个干草公司的货源都十分充足，可以卖出无限多的干草包． 帮助约翰找到最小的开销来满足需要，即采购到至少H磅干草．
Input  第1行输入N和日，之后N行每行输入一个Pi和Ci．
Output  最小的开销．
Sample Input 2 15 3 2 5 3
Sample Output 9
FJ can buy three packages from the second supplier for a total cost of 9.
思路：完全背包。。。注意是买至少V,可以超过。我的做法是算了两倍，然后取最小值（V..2V)
/* *********************************************** Author :111qqz Created Time :2016年04月03日 星期日 19时40分29秒 File Name :code/bzoj/1618.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int p[N],c[N]; int n; int V; int dp[1000005]; void solve (int val,int cost) { for ( int i = value ; i &amp;lt;= V ; i++) dp[i] = min(dp[i],dp[i-value]+cost); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1617: [Usaco2008 Mar]River Crossing渡河问题 (DP)</title><link>https://111qqz.com/2016/04/bzoj1617/</link><pubDate>Sun, 03 Apr 2016 11:34:42 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1617/</guid><description>
1617: [Usaco2008 Mar]River Crossing渡河问题 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 837 Solved: 606 [Submit][Status][Discuss]
Description Farmer John以及他的N(1 &amp;lt;= N &amp;lt;= 2,500)头奶牛打算过一条河，但他们所有的渡河工具，仅仅是一个木筏。 由于奶牛不会划船，在整个渡河过程中，FJ必须始终在木筏上。在这个基础上，木筏上的奶牛数目每增加1，FJ把木筏划到对岸就得花更多的时间。 当FJ一个人坐在木筏上，他把木筏划到对岸需要M(1 &amp;lt;= M &amp;lt;= 1000)分钟。当木筏搭载的奶牛数目从i-1增加到i时，FJ得多花M_i(1 &amp;lt;= M_i &amp;lt;= 1000)分钟才能把木筏划过河（也就是说，船上有1头奶牛时，FJ得花M+M_1分钟渡河；船上有2头奶牛时，时间就变成M+M_1+M_2分钟。后面的依此类推）。那么，FJ最少要花多少时间，才能把所有奶牛带到对岸呢？当然，这个时间得包括FJ一个人把木筏从对岸划回来接下一批的奶牛的时间。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..N+1行: 第i+1为1个整数：M_i
Output 第1行: 输出1个整数，为FJ把所有奶牛都载过河所需的最少时间 Sample Input 5 10 3 4 6 100 1
输入说明:
FJ带了5头奶牛出门。如果是单独把木筏划过河，FJ需要花10分钟，带上 1头奶牛的话，是13分钟，2头奶牛是17分钟，3头是23分钟，4头是123分钟，将 5头一次性载过去，花费的时间是124分钟。
Sample Output 50
HINT 输出说明: Farmer John第一次带3头奶牛过河（23分钟），然后一个人划回来</description></item><item><title>BZOJ 1616: [Usaco2008 Mar]Cow Travelling游荡的奶牛(DP)</title><link>https://111qqz.com/2016/04/bzoj1616/</link><pubDate>Sun, 03 Apr 2016 07:52:18 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1616/</guid><description>
1616: [Usaco2008 Mar]Cow Travelling游荡的奶牛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1012 Solved: 553 [Submit][Status][Discuss]
Description 奶牛们在被划分成N行M列(2 &amp;lt;= N &amp;lt;= 100; 2 &amp;lt;= M &amp;lt;= 100)的草地上游走，试图找到整块草地中最美味的牧草。Farmer John在某个时刻看见贝茜在位置 (R1, C1)，恰好T (0 &amp;lt; T &amp;lt;= 15)秒后，FJ又在位置(R2, C2)与贝茜撞了正着。 FJ并不知道在这T秒内贝茜是否曾经到过(R2, C2)，他能确定的只是，现在贝茜在那里。 设S为奶牛在T秒内从(R1, C1)走到(R2, C2)所能选择的路径总数，FJ希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动1单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。 现在你拿到了一张整块草地的地形图，其中'.'表示平坦的草地，'*'表示挡路的树。你的任务是计算出，一头在T秒内从(R1, C1)移动到(R2, C2)的奶牛可能经过的路径有哪些。
Input 第1行: 3个用空格隔开的整数：N，M，T
第2..N+1行: 第i+1行为M个连续的字符，描述了草地第i行各点的情况，保证 字符是'.'和'*'中的一个 * 第N+2行: 4个用空格隔开的整数：R1，C1，R2，以及C2
Output 第1行: 输出S，含义如题中所述 Sample Input 4 5 6 .</description></item><item><title>BZOJ 1613: [Usaco2007 Jan]Running贝茜的晨练计划 (dp)</title><link>https://111qqz.com/2016/04/bzoj1613/</link><pubDate>Sat, 02 Apr 2016 09:41:36 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1613/</guid><description>
1613: [Usaco2007 Jan]Running贝茜的晨练计划 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1468 Solved: 706 [Submit][Status][Discuss]
Description 奶牛们打算通过锻炼来培养自己的运动细胞，作为其中的一员，贝茜选择的运动方式是每天进行N(1 &amp;lt;= N &amp;lt;= 10,000)分钟的晨跑。在每分钟的开始，贝茜会选择下一分钟是用来跑步还是休息。 贝茜的体力限制了她跑步的距离。更具体地，如果贝茜选择在第i分钟内跑步，她可以在这一分钟内跑D_i(1 &amp;lt;= D_i &amp;lt;= 1,000)米，并且她的疲劳度会增加 1。不过，无论何时贝茜的疲劳度都不能超过M(1 &amp;lt;= M &amp;lt;= 500)。如果贝茜选择休息，那么她的疲劳度就会每分钟减少1，但她必须休息到疲劳度恢复到0为止。在疲劳度为0时休息的话，疲劳度不会再变动。晨跑开始时，贝茜的疲劳度为0。 还有，在N分钟的锻炼结束时，贝茜的疲劳度也必须恢复到0，否则她将没有足够的精力来对付这一整天中剩下的事情。 请你计算一下，贝茜最多能跑多少米。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..N+1行: 第i+1为1个整数：D_i
Output 第1行: 输出1个整数，表示在满足所有限制条件的情况下，贝茜能跑的最大 距离 Sample Input 5 2 5 3 4 2 10
Sample Output 9
输出说明:
贝茜在第1分钟内选择跑步（跑了5米），在第2分钟内休息，在第3分钟内跑 步（跑了4米），剩余的时间都用来休息。因为在晨跑结束时贝茜的疲劳度必须 为0，所以她不能在第5分钟内选择跑步。
题意：一个人第i分钟可以选择跑步或者休息，如果跑步可以跑d[i]米，疲劳度+1，如果休息疲劳度-1，但是一旦开始休息必须休息到疲劳度为0，疲劳度为0以后再休息疲劳度仍然为0，初始疲劳度为0，问n分钟最多跑多远。</description></item><item><title>BZOJ 1612: [Usaco2008 Jan]Cow Contest奶牛的比赛(floyd,传递闭包)</title><link>https://111qqz.com/2016/04/bzoj1612/</link><pubDate>Sat, 02 Apr 2016 07:55:10 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1612/</guid><description>
1612: [Usaco2008 Jan]Cow Contest奶牛的比赛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 900 Solved: 597 [Submit][Status][Discuss]
Description FJ的N(1 &amp;lt;= N &amp;lt;= 100)头奶牛们最近参加了场程序设计竞赛:)。在赛场上，奶牛们按1..N依次编号。每头奶牛的编程能力不尽相同，并且没有哪两头奶牛的水平不相上下，也就是说，奶牛们的编程能力有明确的排名。 整个比赛被分成了若干轮，每一轮是两头指定编号的奶牛的对决。如果编号为A的奶牛的编程能力强于编号为B的奶牛(1 &amp;lt;= A &amp;lt;= N; 1 &amp;lt;= B &amp;lt;= N; A != B) ，那么她们的对决中，编号为A的奶牛总是能胜出。 FJ想知道奶牛们编程能力的具体排名，于是他找来了奶牛们所有 M(1 &amp;lt;= M &amp;lt;= 4,500)轮比赛的结果，希望你能根据这些信息，推断出尽可能多的奶牛的编程能力排名。比赛结果保证不会自相矛盾。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..M+1行: 每行为2个用空格隔开的整数A、B，描述了参加某一轮比赛的奶 牛的编号，以及结果（编号为A，即为每行的第一个数的奶牛为 胜者）
Output 第1行: 输出1个整数，表示排名可以确定的奶牛的数目 Sample Input 5 5 4 3 4 2 3 2 1 2 2 5</description></item><item><title>BZOJ 1611: [Usaco2008 Feb]Meteor Shower流星雨 (BFS)</title><link>https://111qqz.com/2016/04/bzoj-1611/</link><pubDate>Sat, 02 Apr 2016 07:06:38 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1611/</guid><description>
1611: [Usaco2008 Feb]Meteor Shower流星雨 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1239 Solved: 537 [Submit][Status][Discuss]
Description 去年偶们湖南遭受N年不遇到冰冻灾害，现在芙蓉哥哥则听说另一个骇人听闻的消息： 一场流星雨即将袭击整个霸中，由于流星体积过大，它们无法在撞击到地面前燃烧殆尽， 届时将会对它撞到的一切东西造成毁灭性的打击。很自然地，芙蓉哥哥开始担心自己的 安全问题。以霸中至In型男名誉起誓，他一定要在被流星砸到前，到达一个安全的地方 （也就是说，一块不会被任何流星砸到的土地）。如果将霸中放入一个直角坐标系中， 芙蓉哥哥现在的位置是原点，并且，芙蓉哥哥不能踏上一块被流星砸过的土地。根据预 报，一共有M颗流星(1 &amp;lt;= M &amp;lt;= 50,000)会坠落在霸中上，其中第i颗流星会在时刻 T_i (0 &amp;lt;= T_i &amp;lt;= 1,000)砸在坐标为(X_i, Y_i) (0 &amp;lt;= X_i &amp;lt;= 300；0 &amp;lt;= Y_i &amp;lt;= 300) 的格子里。流星的力量会将它所在的格子，以及周围4个相邻的格子都化为焦土，当然 芙蓉哥哥也无法再在这些格子上行走。芙蓉哥哥在时刻0开始行动，它只能在第一象限中， 平行于坐标轴行动，每1个时刻中，她能移动到相邻的（一般是4个）格子中的任意一个， 当然目标格子要没有被烧焦才行。如果一个格子在时刻t被流星撞击或烧焦，那么芙蓉哥哥 只能在t之前的时刻在这个格子里出现。请你计算一下，芙蓉哥哥最少需要多少时间才能到 达一个安全的格子。
Input 第1行: 1个正整数：M * 第2..M+1行: 第i+1行为3个用空格隔开的整数：X_i，Y_i，以及T_i Output 输出1个整数，即芙蓉哥哥逃生所花的最少时间。如果芙蓉哥哥无论如何都无法在流星雨中存活下来，输出-1
Sample Input 4 0 0 2 2 1 2 1 1 2 0 3 5 输入说明: 一共有4颗流星将坠落在霸中，它们落地点的坐标分别是(0, 0)，(2, 1)，(1, 1) 以及(0, 3)，时刻分别为2，2，2，5。</description></item><item><title>hdu 1950 Bridging signals (LIS)</title><link>https://111qqz.com/2016/04/hdu1950/</link><pubDate>Fri, 01 Apr 2016 13:16:54 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu1950/</guid><description>
题目链接 题意：有两跟柱子并排竖直放置，每根柱子有n个结点，从上往下标号1..n， 两根柱子间的结点间要连线，给出计划连接的情况。a[i]表示左边结点i连接右边结点a[i].但是要求连线不能交叉，所以计划可能不能全部执行。现在问最多能连接多少条线。 思路：由于不能交叉，而左边的结点是按照顺序给出的，所以右边连接的结点只能是越来越大。其实就是求a[i]的最长上升子序列。感觉算是LIS的一个比较巧妙的应用？ 由于n还是很大。所以必须nlogn的做法。
/* *********************************************** Author :111qqz Created Time :2016年04月01日 星期五 20时43分24秒 File Name :code/hdu/1950.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; int n; int a[N]; int dp[N]; int g[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1609: [Usaco2008 Feb]Eating Together麻烦的聚餐(LIS nlogn解法)</title><link>https://111qqz.com/2016/04/bzoj-1609/</link><pubDate>Fri, 01 Apr 2016 12:32:13 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1609/</guid><description>
1609: [Usaco2008 Feb]Eating Together麻烦的聚餐 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 1282 Solved: 766 [Submit][Status][Discuss]
Description 为了避免餐厅过分拥挤，FJ要求奶牛们分3批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按FJ的设想所有第3批就餐的奶牛排在队尾，队伍的前端由设定为第1批就餐的奶牛占据，中间的位置就归第2批就餐的奶牛了。由于奶牛们不理解FJ的安排，晚饭前的排队成了一个大麻烦。 第i头奶牛有一张标明她用餐批次D_i(1 &amp;lt;= D_i &amp;lt;= 3)的卡片。虽然所有N(1 &amp;lt;= N &amp;lt;= 30,000)头奶牛排成了很整齐的队伍但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如111222333或者333222111。哦，你也发现了，FJ不反对一条前后颠倒的队列，那样他可以让所有奶牛向后转，然后按正常顺序进入餐厅。 你也晓得，FJ是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在FJ改卡片编号的时候，都不会挪位置。
Input 第1行: 1个整数：N 第2..N+1行: 第i+1行是1个整数，为第i头奶牛的用餐批次D_i
Output 第1行: 输出1个整数，为FJ最少要改几头奶牛卡片上的编号，才能让编号变成他设想中的样子
Sample Input 5 1 3 2 1 1 输入说明:队列中共有5头奶牛，第1头以及最后2头奶牛被设定为第一批用餐，第2头奶牛的预设是第三批用餐，第3头则为第二批用餐。
Sample Output 1
输出说明:
如果FJ想把当前队列改成一个不下降序列，他至少要改2头奶牛的编号，一种可行的方案是：把队伍中2头编号不是1的奶牛的编号都改成1。不过，如果FJ选择把第1头奶牛的编号改成3就能把奶牛们的队伍改造成一个合法的不上升序列了。
思路：先考虑一个方向。最后要排列成一个不下降子序列。
需要修改的最少次数就是总长度减去最长的不下降子序列的长度。
所以问题就变成了最长求不下降子序列的长度。
由于n最大30000，O(n^2)的复杂度会TLE.所以去学了下nlogn的做法LIS nlogn解法讲解
然后再反正做一遍，求最小值即可。
以及：原来upper_bound和lower_bound可以对数组直接用啊。。。
以及：原来reverse也可以对数组用啊。。。。
/* *********************************************** Author :111qqz Created Time :2016年04月01日 星期五 13时03分19秒 File Name :code/bzoj/1609.</description></item><item><title>最长上升子序列nlogn解法</title><link>https://111qqz.com/2016/04/nlogn/</link><pubDate>Fri, 01 Apr 2016 12:15:41 +0000</pubDate><guid>https://111qqz.com/2016/04/nlogn/</guid><description>
首先回顾一下n^2的做法。 状态转移方程为dp[i] =max(1,dp[j]) (1=&amp;lt;j&amp;lt;=i-1&amp;amp;&amp;amp;a[i]&amp;gt;a[j])
for ( int i = 1 ; i &amp;lt;= n ; i++) cin&amp;gt;&amp;gt;a[i]; for ( int i = 1 ; i &amp;lt;= n ; i++) { dp[i] = 1; for ( int j = 1 ; j &amp;lt; i ; j++) { if (a[i]&amp;gt;a[j]) dp[i] = max(dp[i],dp[j]+1); } ans = max(ans,dp[i]); } 然后我们发现，使得dp[i]得到同一个值的dp[j]可能有多个，那么选择哪个呢？ 假设 x&amp;lt;y&amp;lt;i，a[x]&amp;lt;a[y],dp[x]==dp[y]，那么我们选择x好还是y好呢？ 显然是x好。为什么？因为选择x潜力大。因为可能在x,y之间存在一个z,满足a[x]&amp;lt;a[z]&amp;lt;a[y],如果选择a[y]，就没有办法选择可能使长度更长的a[z]了。通俗得说。。我们要求的是最长上升子序列。。你一开始就弄那么大。。。后面还上哪上升去啊。。。长度小啊。。。
因此我们得出一个结论，对于dp[t]==k的所有t,要选择a[t]最小的，这样有更大可能得到更长的序列。
我们用g[k]表示所有dp[t]==k的t中，最小的a[t]的值。g[k] = min{A[t]} (dp[t] = k)
我们可以发现关于g的两个性质。
（1） g[k]肯定是单调不增的。因为求最小值嘛，肯</description></item><item><title>bzoj 1599: [Usaco2008 Oct]笨重的石子 (暴力)</title><link>https://111qqz.com/2016/03/bzoj1599/</link><pubDate>Thu, 31 Mar 2016 13:22:31 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1599/</guid><description>
1599: [Usaco2008 Oct]笨重的石子 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 886 Solved: 614 [Submit][Status][Discuss]
Description 贝西喜欢棋盘游戏和角色扮演类游戏所以她说服Farmer John把她带到玩具店，在那里，她购买了三个不同的骰子，这三个质量均匀的骰子，分别有S1,S2,S3个面。(2 &amp;lt;= S1 &amp;lt;= 20; 2 &amp;lt;= S2 &amp;lt;= 20; 2 &amp;lt;= S3 &amp;lt;= 40). 贝西掷啊掷啊掷啊，想要知道出现几率最大的和是多少。 问题给出三个骰子的面数，让你求出出现几率最大的和是多少。如果有很多种和出现的几率相同，那么就输出小的那一个。
Input *第一行：三个由空格隔开的整数：s1,s2,s3
Output *第一行：所要求的解
Sample Input 3 2 3
Sample Output 5
输出详解:
这里是所有可能的情况.
1 1 1 -&amp;gt; 3 1 2 1 -&amp;gt; 4 2 1 1 -&amp;gt; 4 2 2 1 -&amp;gt; 5 3 1 1 -&amp;gt; 5 3 2 1 -&amp;gt; 6</description></item><item><title>bzoj1603: [Usaco2008 Oct]打谷机 (纱布题)</title><link>https://111qqz.com/2016/03/bzoj1603/</link><pubDate>Thu, 31 Mar 2016 13:10:27 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1603/</guid><description>
Time Limit: 5 Sec Memory Limit: 64 MB Submit: 774 Solved: 593 [Submit][Status][Discuss]
Description Farmer John有一个过时的打谷机（收割小麦），它需要带子来带动。发动机驱动轮1总是顺时针旋转的，用来带动转轮2，转轮2来带动转轮3，等等。一共有n（2&amp;lt;=n&amp;lt;=1000）个转轮（n-1条带子）。上面的图解描述了转轮的两种连接方式，第一种方式使得两个轮子旋转的方向相同，第二种则相反。 给出一串带子的信息： *Si—驱动轮 *Di—被动轮 *Ci—连接的类型（0=直接连接，1=交叉连接） 不幸的是，列出的信息是随即的。 作为样例，考虑上面的图解，n=4，转轮1是驱动轮，可以得知最后转轮4是逆时针旋转的。
Input *第一行：一个数n *第二行到第n行：每一行有三个被空格隔开的数：Si，Di，Ci
Output *第一行：一个单独的数，表示第n个转轮的方向，0表示顺时针，1表示逆时针。
Sample Input 4 2 3 0 3 4 1 1 2 0
Sample Output 1
思路：傻逼模拟题。。。。排下序。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 21时04分09秒 File Name :code/bzoj/1603.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; struct node { int s,d,c; bool operator &amp;lt; (node b)const { return s&amp;lt;b.</description></item><item><title>bzoj 1602: [Usaco2008 Oct]牧场行走 (bfs,优先队列)</title><link>https://111qqz.com/2016/03/bzoj1602/</link><pubDate>Thu, 31 Mar 2016 12:57:27 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1602/</guid><description>
Description
N头牛（2&amp;lt;=n&amp;lt;=1000）别人被标记为1到n，在同样被标记1到n的n块土地上吃草，第i头牛在第i块牧场吃草。 这n块土地被n-1条边连接。 奶牛可以在边上行走，第i条边连接第Ai，Bi块牧场，第i条边的长度是Li（1&amp;lt;=Li&amp;lt;=10000）。 这些边被安排成任意两头奶牛都可以通过这些边到达的情况，所以说这是一棵树。 这些奶牛是非常喜欢交际的，经常会去互相访问,他们想让你去帮助他们计算Q(1&amp;lt;=q&amp;lt;=1000)对奶牛之间的距离。
Input
*第一行：两个被空格隔开的整数：N和Q
*第二行到第n行：第i+1行有两个被空格隔开的整数：AI，BI，LI
*第n+1行到n+Q行：每一行有两个空格隔开的整数：P1，P2，表示两头奶牛的编号。
Output
*第1行到第Q行：每行输出一个数，表示那两头奶牛之间的距离。
Sample Input
4 2
2 1 2
4 3 2
1 4 3
1 2
3 2
Sample Output
2
7
思路：直接bfs....貌似因为每个点最多只和两个边相连。。。不用优先队列也行？ 1A,好爽23333.
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 20时27分01秒 File Name :code/bzoj/1602.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+5; int n,q; vector&amp;lt; pi &amp;gt;edge[N]; bool vis[N]; int d[N]; struct node { int x; int d; bool operator &amp;lt; (node b)const { return d&amp;gt;b.</description></item><item><title>bzoj 1601: [Usaco2008 Oct]灌水 (最小生成树)</title><link>https://111qqz.com/2016/03/bzoj-1601-usaco2008-oct-/</link><pubDate>Thu, 31 Mar 2016 12:17:03 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj-1601-usaco2008-oct-/</guid><description>
1601: [Usaco2008 Oct]灌水 Time Limit: 5 Sec Memory Limit: 162 MB Submit: 1624 Solved: 1059 [Submit][Status][Discuss]
Description Farmer John已经决定把水灌到他的n(1&amp;lt;=n&amp;lt;=300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1&amp;lt;=wi&amp;lt;=100000),连接两块土地需要花费Pij(1&amp;lt;=pij&amp;lt;=100000,pij=pji,pii=0). 计算Farmer John所需的最少代价。
Input *第一行：一个数n
*第二行到第n+1行：第i+1行含有一个数wi
*第n+2行到第2n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。
Output *第一行：一个单独的数代表最小代价.
Sample Input 4 5 4 4 3 0 2 2 2 2 0 3 3 2 3 0 4 2 3 4 0
Sample Output 9
输出详解：
Farmer John在第四块土地上建立水库，然后把其他的都连向那一个，这样就要花费3+2+2+2=9
思路：一开始觉得是dp.....本来打算放弃了。。。后来看到p的值，似乎一定能保证n个点相连。
那么每一个点的水源有两个来源，要么自己建，要么从别人那里来。
然后卡住了QAQ....看了题解。。
好巧妙。。因为自己建水库不好处理，我们可以假设一个源点，认为只有源点有水库，而其他点建水库的价钱认为是修一条源点到那个点的路的价钱，这样就把w[i]转化成了p[i][j]的形式。
然后包括源点在内的n+1个点，求最小生成树。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 19时32分43秒 File Name :code/bzoj/1601.</description></item><item><title>bzoj1600 [Usaco2008 Oct]建造栅栏 （排列组合）</title><link>https://111qqz.com/2016/03/bzoj1600-usaco2008-oct-/</link><pubDate>Thu, 31 Mar 2016 11:12:49 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1600-usaco2008-oct-/</guid><description>
勤奋的Farmer John想要建造一个四面的栅栏来关住牛们。他有一块长为n（4&amp;lt;=n&amp;lt;=2500）的木板，他想把这块本板切成4块。这四块小木板可以是任何一个长度只要Farmer John能够把它们围成一个合理的四边形。他能够切出多少种不同的合理方案。注意： *只要大木板的切割点不同就当成是不同的方案（像全排列那样），不要担心另外的特殊情况，go ahead。 *栅栏的面积要大于0. *输出保证答案在longint范围内。 *整块木板都要用完。
思路：排列组合。。减法原则。长度为n的木板，有n-1个切点，那么n-1个切点切三刀的方案数就是C(n-1,3) ，但是这里面有不能构成四边形的。
构成四边形的条件是：任意三边之和大于第四边。也就是任意a+b+c&amp;gt;d，可以得到d&amp;lt;n/2
为方便描述，我们不妨认为从左往右切，先且最左边，再切最右边。
并且先讨论最右边的木板是长度最长的。
所以我们最后一刀一定切在n/2之后的地方。
此时无论之前的两刀是怎么切的，由于切完出现的三块的长度和是一定的，所有都一定能构成四边形。
多算的部分就是从n/2点，最左边可以切到3点的方案数。
如果最后一刀切在点i,那么左边还剩下i-1个点，选两个点切，方案数为C(i-1,2)
将多切的方案数sad按照最后一刀的切点累加。
需要注意的是，我们之前为了方便讨论，设最后一个木板是最长的，然而实际上四块木板都有可能是最长的。 所以多切的方案数sad=sad*4
哦，听说这题dp也能过。。。。？反正我是想不到。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 18时23分16秒 File Name :code/bzoj/1600.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 2600; LL n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>快开始刷bzoj啊喂</title><link>https://111qqz.com/2016/03/just-start-bzoj/</link><pubDate>Thu, 31 Mar 2016 10:13:34 +0000</pubDate><guid>https://111qqz.com/2016/03/just-start-bzoj/</guid><description>
。。。。天天划水 药丸 妈的智障。</description></item><item><title>bc #74 div1 1001 || hdu 5636 Shortest Path (floyd？)</title><link>https://111qqz.com/2016/03/bc-74-div1-1001-hdu-5636-shortest-path-floyd/</link><pubDate>Thu, 31 Mar 2016 10:10:34 +0000</pubDate><guid>https://111qqz.com/2016/03/bc-74-div1-1001-hdu-5636-shortest-path-floyd/</guid><description>
题目链接 题意：有一条n个节点的链，节点i和节点j的距离为abs(i-j) 现在新增加三条边，距离也都为1，然后给出m个询问，每组询问给出两个点s,t，问s,t之间的最短距离。 思路：比赛的时候没搞出来。 观察特点，对于大多数点来说，都是没有直接的改变，只是增加了三条边。总的思路是：之前s到t的距离为abs(s-t),通过枚举中间经过的特殊点，观察是否能使得距离减小。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 17时18分34秒 File Name :code/hdu/5636.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const LL MOD =1E9+7; int n,m; int z[N]; LL a[10]; LL dp[10][10]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #346 div 2 D. Bicycle Race (思维，计算几何，公式)</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-d-bicycle-race-/</link><pubDate>Thu, 31 Mar 2016 09:02:23 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-d-bicycle-race-/</guid><description>
题目链接 题意：给出n+1个点，每次由i点到i+1点，每段线段之间保证不同向或者反向，第一个点和最后一个点保证重合。路径围城的封闭图形中间都是水，问有多少个危险点，使得如果在这个点忘记转弯就会掉进水里。
思路：搞了半天没搞出来qaq
From the track description follows that Maria moves the way that the water always located to the right from her, so she could fall into the water only while turning left. To check if the turn is to the left, let's give every Maria's moves directions a number: moving to the north — 0, moving to the west — 1, to the south — 2 and to the east — 3.</description></item><item><title>codeforces #346 div 2 C. Tanya and Toys (暴力乱搞)</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-c-tanya-and-toys-/</link><pubDate>Thu, 31 Mar 2016 08:36:59 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-c-tanya-and-toys-/</guid><description>
题目链接 题意:有1E9个礼物，第i个礼物价钱是i,然后现在已经有n个不重复的礼物，a[i],m元钱，想尽可能多得买不同种类的礼物，还能买多少个。 思路：先不考虑已经买的，从1连续买到k,然后考虑子啊这个区间内已经买的，等于实际上没有花钱。 反正就是暴力搞啊搞啊。。我也不知道怎么搞。。 结果最后。。方案数为0的时候。。。最后一个答案我是单独输出的。。忘了判断了。。。所以会输出两个0.宝宝心里苦啊。。。。。。。。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 00时00分03秒 File Name :code/cf/#346/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; LL n,m; LL a[N]; LL sum[N]; set&amp;lt;LL&amp;gt;se; LL ans[N]; bool vis[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #346 div 2 B. Qualifying Contest (排序)</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-b-qualifying-contest-/</link><pubDate>Thu, 31 Mar 2016 08:27:19 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-b-qualifying-contest-/</guid><description>
题目链接 题意：给出选手个数n，下面n行每个选手的信息“名字 区域编号 分数”.保证每个区域至少两个选手。问每个区域能否唯一确定一支二人的队伍（尽可能选分数高的，当要选的人里有分数相同的则不能确定。 思路：排序啊。。。然后搞啊。。结果发现思路没缕清。。。在某一个区域中，决定是否能唯一确定队伍的是第二个人和第三个人的成绩，和第一个人无关。 特殊处理一个区域只有两个人参加的，这种情况肯定能唯一确定队伍。 妈蛋，这种傻逼题卡了一个小时。。。。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 16时00分23秒 File Name :code/cf/#346/BB.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int m; int cnt[N]; struct node { string nam; int s; bool operator &amp;lt;(node b)const { return s&amp;gt;b.</description></item><item><title>codeforces #346 div 2 A. Round House</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-a-round-house/</link><pubDate>Thu, 31 Mar 2016 07:45:36 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-a-round-house/</guid><description>
题目链接
水题 乱搞。
/* *********************************************** Author :111qqz Created Time :2016年03月30日 星期三 23时59分47秒 File Name :code/cf/#346/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,a,b; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 484 B Maximum Value (暴力乱搞)</title><link>https://111qqz.com/2016/03/484b/</link><pubDate>Thu, 31 Mar 2016 07:20:25 +0000</pubDate><guid>https://111qqz.com/2016/03/484b/</guid><description>
题目链接 题意：给出n个元素的序列，求出最大的a[i]%a[j] (i&amp;gt;=j) 思路：没思路。。。。
Let us iterate over all different _a__j_. Since we need to maximize ![](http://codeforces.com/predownloaded/78/b3/78b367327f7d7a7eba50f5e1ebfaf0cb199e1837.png) , then iterate all integer _x_ (such_x_ divisible by _a__j_) in range from 2_a__j_ to _M_, where _M_ — doubled maximum value of the sequence. For each such _x_ we need to find maximum _a__i_, such _a__i_ 题解也没有特别懂。。。感觉和筛法有点类似。
不过学到了一个o(1)时间得到小于x的最大数是多少的做法。
Sort the array and just maintain another array `A` of `10^6` elements where`index i stores element just smaller than i` For example consider sorted array [2,4,7,11], then</description></item><item><title>codeforces 652 B. z-sort (简单构造)</title><link>https://111qqz.com/2016/03/cf652b/</link><pubDate>Thu, 31 Mar 2016 06:11:36 +0000</pubDate><guid>https://111qqz.com/2016/03/cf652b/</guid><description>
题目链接 题意：给出n个元素的序列，问能否得到一个新的序列，使得奇数位置非递减排列，偶数位数非递增排列。 思路：感觉一定可以啊。。。排序以后直接构造。。。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 14时05分11秒 File Name :code/cf/problem/652B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int a[N]; int ans[N]; int n ; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 334 B. Eight Point Sets (暴力)</title><link>https://111qqz.com/2016/03/cf334b/</link><pubDate>Thu, 31 Mar 2016 05:56:12 +0000</pubDate><guid>https://111qqz.com/2016/03/cf334b/</guid><description>
题目链接 题意：给出8个点，问能否构成一个8元素集合，使得x1/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 13时39分27秒 File Name :code/cf/problem/334B.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair
using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; pi a[N]; set&amp;lt; pi &amp;gt;se;</description></item><item><title>codeforces 137 C. History (sorting,贪心)</title><link>https://111qqz.com/2016/03/cf137c/</link><pubDate>Thu, 31 Mar 2016 05:33:39 +0000</pubDate><guid>https://111qqz.com/2016/03/cf137c/</guid><description>
题目链接 题意：给出n个时间的开始和截止时间，保证没有两个时间的开始或者截止时间相同，问有多少个时间被包含在其他事件中。即aj &amp;lt; ai and bi &amp;lt; bj.
思路：没有两个事件的时间相同很关键。 那么我们可以直接按照开始时间为关键字排序，然后结束时间取之前发生了的（可能还没发生完）时间的结束时间的最大值即可。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 13时23分21秒 File Name :code/cf/problem/137C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 274 A. k-Multiple Free Set (set的妙用)</title><link>https://111qqz.com/2016/03/cf274a/</link><pubDate>Thu, 31 Mar 2016 05:13:21 +0000</pubDate><guid>https://111qqz.com/2016/03/cf274a/</guid><description>
题目链接 题意：给出n个互不相同的元素和k,构成一个集合，使得集合中不存在两个元素满足y=kx,问能构成这样的集合的最大size是多少。 思路：set大法好。很重要的一点是题目中明确说每个元素都不重复。然后每次删掉元素x和元素xk,因为这两个元素最多留一个，然后答案+1. 需要注意k=1的特殊情况。
/* *********************************************** Author :111qqz Created Time :2016年03月30日 星期三 23时33分36秒 File Name :code/cf/problem/274A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; LL k; set&amp;lt;LL&amp;gt;se; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 617 C. Tourist's Notes (二分)</title><link>https://111qqz.com/2016/03/cf617e-2/</link><pubDate>Wed, 30 Mar 2016 15:24:59 +0000</pubDate><guid>https://111qqz.com/2016/03/cf617e-2/</guid><description>
题目链接 题意：有n天的旅行，但是只剩下了m天的旅行记录，记录格式为d[i],h[d[i]]，表示第i个记录是第d[i]天的，高度为h[d[i]],相邻两天的高度之差的绝对值不超过1.问满足以上条件的最大的h是多少。无解输出impossible. 思路：为了练习二分。 二分高度，然后check是否合法。注意边界，所以可以添加两个点。
/* *********************************************** Author :111qqz Created Time :2016年03月30日 星期三 16时53分57秒 File Name :code/cf/problem/538C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M=1E9; //上界并不是h的最大值。。因为还可以继续往上走啊。。 int n,m; int h[N],d[N]; bool check (int x) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt;= m-1 ; i++) { if (x&amp;lt;h[i]||x&amp;lt;h[i+1]) return true; int cost = abs(x-h[i]) + abs(h[i+1]-x); // cout&amp;lt;&amp;lt;&amp;quot;cost:&amp;quot;&amp;lt;&amp;lt;cost&amp;lt;&amp;lt;endl; if (cost&amp;lt;=d[i+1]-d[i]) return true; } return false; } int bin() { int l = 0 ; int r = M ; int mid; while (l&amp;lt;=r) { mid = (l+r)/2; if (check(mid)) l = mid + 1; else r = mid -1; } if (r&amp;gt;M) return -1; return r; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bc #77 ||hdu 5652 India and China Origins (图的动态连通性问题，并查集or 二分+bfs验证连通性)</title><link>https://111qqz.com/2016/03/hdu5652/</link><pubDate>Mon, 28 Mar 2016 12:37:40 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5652/</guid><description>
题目链接 题意：没图不好描述，有中文题面中文题面，直接看吧。 思路：据说这道题有三种做法。 当时比赛一种都不会。
先说一种：做法是把格子看成点，可以到达的相邻格子之间看成有边相连，然后倒过来用并查集判断无向图的连通性。具体做法是：先统计初始所有空的位置，然后把所有要增加的山都加上（先统计空的位置是因为山之后要去掉，而去掉以后要得到该点的标号），然后将把所有空的点以及china(设标号为n*m+1)点,和india(**设标号为n*m+2) **点通过并查集来合并..可以从上往下从左往右，每次只需要判断上面的点和左边的点是否有空，如果有就用并查集合并。 china点和india点特殊搞就好。
然后判断india和china是否联通，如果是则输出-1.否则从最后添加的山开始移除，每次移除一座山，添加四个方向能添加的边（注意这里不要忘记如果改点在第0行或者第n-1行还要添加和china或者india的边）
然后移除后询问india和china是否联通 （root(china)==root(india)?）
如果时间i联通了，而i+1没有联通，说明时间i是两国最早的失去联系的时间。
第一次做这种题目，这种题目的一般做法都是倒过来做。貌似还有一个二分删除的山+bfs判断连通性的。。。？ 窝再搞搞看。 update :二分+bfs判断连通性。其实这个思路更常规。。做法就是字面意思。注意无解的判断即可。
并查集解法：
/* *********************************************** Author :111qqz Created Time :2016年03月27日 星期日 20时11分02秒 File Name :code/bc/#77/1003.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; char maze[N][N]; int f[N*N]; int n,m; int q; int p[N][N]; int china; int india; struct node { int x,y; int id; }shan[N*N],kong[N*N]; int root ( int x) { if (x!</description></item><item><title>bc #77 div 2 1001 ||hdu 5650 so easy (傻逼题)</title><link>https://111qqz.com/2016/03/hdu5650/</link><pubDate>Sun, 27 Mar 2016 02:34:38 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5650/</guid><description>
题目链接 題意：已知一个包含 nn 个元素的正整数集合 SS，设 f(S)f(S) 为集合 SS 中所有元素的异或(XOR)的结果。 如：S={1,2,3}, 则 f(S) = 0f(S)=0。
给出集合 SS，你需要计算 将所有 f(s)进行异或后的值, s⊆S.
思路：当集合中元素大于1个的时候，每个元素对都会出现偶数次，对答案的贡献为0.
当集合中只有一个元素的时候，设为x,对答案的贡献为x.
/* *********************************************** Author :111qqz Created Time :2016年03月26日 星期六 18时52分14秒 File Name :code/bc/#77/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bc #77 div 2 B ||hdu 5651 xiaoxin juju needs help (排列组合，逆元)</title><link>https://111qqz.com/2016/03/hdu-5651/</link><pubDate>Sun, 27 Mar 2016 02:33:27 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu-5651/</guid><description>
题目链接 题意；给出一个字符串，只由小写字母组成，可以任意排列，但是不能减少字符，问最多能得到多少个回文串，答案9+7
思路：排列组合题。 首先考虑无解的情况。统计出每个字母出现的次数，当字符串长度为奇数而且出现次数为奇数的字母的个数多于1个时无解，或者当字符串长度为偶数，出现次数为奇数的字母的个数多于0个时无解。 接下来，由于是回文串，只需要考虑len/2的情况，另一半是一一对应的。 其实就是一共有len/2的元素，其中有一些重复的，然后全排列。 多重元素的排列问题。 答案为(len/2)! % （cnt[1]!）% (cnt[2]!)...即可 哦要先把cnt降序排一下，只考虑cnt[i]&amp;gt;1的元素，然后因为是要考虑一半长度，所以每个cnt[i]/2 那一堆阶乘直接逆元搞就好了。。。。
比赛的时候手滑，把cnt[i]!写成了cnt[i],wa了一发。。。
/* *********************************************** Author :111qqz Created Time :2016年03月26日 星期六 18时52分01秒 File Name :code/bc/#77/1001.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD =1E9+7; const int N=1E3+9; string s; int cnt[30]; //start from 1 LL ny[N]; LL fac[30]; bool cmp( int a,int b) { return a&amp;gt;b; } LL ksm(LL a,LL b) { LL res=1LL; while (b&amp;gt;0) { if (b%2==1) res = (res*a)%MOD; b = b&amp;gt;&amp;gt;1; a = (a*a)%MOD; } return res; } void getny() { ms(ny,0); for ( int i = 1 ; i &amp;lt;= 1004 ; i++) ny[i] = ksm(LL(i),MOD-2); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #120 div 2 (Virtual Participation)</title><link>https://111qqz.com/2016/03/codeforces-120-div-2-virtual-participation/</link><pubDate>Thu, 24 Mar 2016 06:41:11 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-120-div-2-virtual-participation/</guid><description>
比赛链接
两题QAQ
A：7分钟1A 有n个大人m个小孩乘公交车，票价每人一元，一个大人最多免费带一个小孩，没有大人陪同的小孩不能乘车。 问是否有解，如果有解输出所有乘客付的钱的可能的最小值和可能的最大值。
思路：最小值就是先尽量利用每个大人带一个孩子。最大值就是把所有孩子都给一个大人。
特殊情况是：没有大人的时候，孩子不能乘车，无解。没有小孩的时候，大人没办法免费带孩子，也要特殊考虑。
/* *********************************************** Author :111qqz Created Time :2016年03月24日 星期四 12时24分27秒 File Name :code/cf/#120/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int mx,mi; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5646 ||bc #76 div 2 (贪心)</title><link>https://111qqz.com/2016/03/hdu5646/</link><pubDate>Wed, 23 Mar 2016 08:16:05 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5646/</guid><description>
题目链接
题意：将正整数n(n&amp;lt;=1E9)，拆分成k个（k&amp;lt;=1E9）个**互不相等的正整数，**并且使得k个正整数的乘积最大。如果可以拆分，输出最大乘积，否则输出-1.
思路：其实是道贪心。。容易知道，k个互不相同的正整数的最小的和为sum=(k+1)*k/2，以此来判断是否有解。如果有解。那么找到最大的i，使得从i 开始的连续k个正整数相加的和小于等于n.
由于k不会超过1E5(否则一定无解)，所以可以开个数组存一下拆分的每个数。
然后设此时还需要添加r才能到n,那么贪心得想，一定是给最大的r个每个增加1最后的乘积会最大。这等效于直接将第k-r+1个直接增加r.
注意全程long long
以及：
开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 原因是puts也是&amp;lt;stdio.h&amp;gt;里的。。
c和c++各有一套指针。。随时同步，所以cin会慢。。关掉同步会快，但是由于已经关掉同步了，混用就会有问题。 以前不知道puts也是不能混用的QAQ
/* *********************************************** Author :111qqz Created Time :2016年03月22日 星期二 20时43分37秒 File Name :code/hdu/r5646.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; const LL MOD = 1E9+7; LL n,k; LL a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5645 DZY Loves Balls （古典概型）</title><link>https://111qqz.com/2016/03/hdu5645/</link><pubDate>Tue, 22 Mar 2016 11:45:19 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5645/</guid><description>
题目链接 题意：n（n&amp;lt;=300）个球，每个球上标有一个标号(a[i]&amp;lt;=300),从中拿一个，不放回，再拿一个，问第一个球上的数字严格大于第二个球上的数字的概率。 思路：古典概型。总数为n*(n-1)/2...然后标号最大300,不妨用cnt[i]统计标号为i的球的个数。从小往大扫一遍cnt,cnt[i]对分子的贡献就是cnt[i]*cur。。cur 为 sum{cnt[1]..cnt[i-1]}; 最后注意将分子除以2，因为有一半是第一个球比第二个球小的情况。
/* *********************************************** Author :111qqz Created Time :2016年03月22日 星期二 19时27分40秒 File Name :code/hdu/5645.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int n; int a[N]; int cnt[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #338 div2 B || 615B Longtail Hedgehog</title><link>https://111qqz.com/2016/03/cf615b/</link><pubDate>Tue, 22 Mar 2016 10:28:04 +0000</pubDate><guid>https://111qqz.com/2016/03/cf615b/</guid><description>
题目链接 题意：给出n个点，m条边，定义一条路径的价值为【路径长度*(路径终点的度)】，求最大价值。 思路：一月份的时候写过一个回溯。。。TLE22了。。。其实也能猜到是dp..但是无奈不会写。然而其实真的不难== 我们枚举路径的终点，dp[i]表示以点i为终点能得到的最长路径长度。
转移方程：dp[i] = max(dp[i],dp[edge[i][j]]+1);
含义是与i点相连的j点是否要将i点加在以j点为路径末尾的路径的终点，使i点成为新的路径终点。
具体看代码
/* *********************************************** Author :111qqz Created Time :2016年01月08日 星期五 21时55分26秒 File Name :code/cf/#338/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; vector&amp;lt;int&amp;gt;edge[N]; LL ans; LL cur; LL dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>20160321生活杂感</title><link>https://111qqz.com/2016/03/20160321/</link><pubDate>Mon, 21 Mar 2016 15:01:40 +0000</pubDate><guid>https://111qqz.com/2016/03/20160321/</guid><description>
博客坏了两天。。。有点sad.
现在手头还有几篇题解没写完。。。然而要断电了。。明天再写。。。
os实验真是日了狗了。。。其实我已经拿小黑做好了。。。
但是给室友搞的时候就怎么也复现不了。。。不明啊。
今天上毛概课的时候小可坐我后面吓傻了23333
哦对了，把小可的好友加了回来。。。不过貌似没什么和我说话的兴趣呢23333
晚安。</description></item><item><title>codeforces 330 B. Road Construction （图论基础）</title><link>https://111qqz.com/2016/03/cf330b/</link><pubDate>Mon, 21 Mar 2016 14:55:26 +0000</pubDate><guid>https://111qqz.com/2016/03/cf330b/</guid><description>
题目链接 题意：n个点，m（m&amp;lt;n/2）条不能走的边，问最少连多少条边，使得任何两个点之间的距离最多为2. 输出最少的边数和连接的哪些边。 思路： **数据范围很关键。**数据范围很关键。数据范围很关键。
因为m&amp;lt;n/2,每条禁止的边最多禁止两个点，所以禁止的点数&amp;lt;n..那么至少有一个点是和可以和其他所有点相连的。。于是把其他所有点和该点相连即可。
/* *********************************************** Author :111qqz Created Time :2016年03月19日 星期六 10时39分40秒 File Name :code/cf/problem/330B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int cnt[N]; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces croc 2016 C. Enduring Exodus</title><link>https://111qqz.com/2016/03/cf645c/</link><pubDate>Mon, 21 Mar 2016 14:46:43 +0000</pubDate><guid>https://111qqz.com/2016/03/cf645c/</guid><description>
题目链接 题意：给出n和k,给出一个长度为n的字符串表示房间的占用情况（0表示没占用，1表示已占用），从n个房间中找出k+1个，使得k+1中的k个距离k+1个中的1个的距离和最小。
思路：只需要考虑没被占用的位置。所以用pos[]数组记录0的位置。 找到第一个能住下的位置后向前平移即可。
/* *********************************************** Author :111qqz Created Time :2016年03月19日 星期六 00时21分28秒 File Name :code/cf/croc2016/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int ban[N]; int k,n; int sum[N]; int pos0[N]; string st; int dis(int x,int l,int r) { return max(pos0[x]-pos0[l],pos0[r]-pos0[x]); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces croc 2016 B. Mischievous Mess Makers (贪心)</title><link>https://111qqz.com/2016/03/cf645b/</link><pubDate>Mon, 21 Mar 2016 14:41:12 +0000</pubDate><guid>https://111qqz.com/2016/03/cf645b/</guid><description>
题目链接 题意：长度为n的初始为1，2,3...n的序列，最多进行k次两个数交换，变换后的序列中最懂能有多少逆序对。 思路：贪心得想。。每次变最外层的对答案贡献最多。 以及，最能能变化n/2次。
/* *********************************************** Author :111qqz Created Time :2016年03月19日 星期六 00时21分20秒 File Name :code/cf/croc2016/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n,k; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces croc2016 A. Amity Assessment (暴力)</title><link>https://111qqz.com/2016/03/cf645a/</link><pubDate>Mon, 21 Mar 2016 14:36:49 +0000</pubDate><guid>https://111qqz.com/2016/03/cf645a/</guid><description>
题目链接 题意：2×2的格子，有三个位置分别放”A“ &amp;quot;B&amp;quot; &amp;quot;C&amp;quot; ，一个位置为空。只有和空位相邻位置上的字母能移动到空位。没有其他移动规则。现在给出两个状态。问能否互相转化。 思路： 貌似可以dfs...？但是一共才2*2，可以直接暴力枚举。 手写一种变换最多能有12种。
/* *********************************************** Author :111qqz Created Time :2016年03月19日 星期六 00时21分02秒 File Name :code/cf/croc2016/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string a,b,c,d; int kind (string a,string b) { if (a==&amp;quot;AB&amp;quot;) return 1; if (a==&amp;quot;BC&amp;quot;) return 1; if (a==&amp;quot;CA&amp;quot;) return 1; if (b==&amp;quot;AC&amp;quot;) return 1; if (b==&amp;quot;BA&amp;quot;) return 1; if (b==&amp;quot;CB&amp;quot;) return 1; return 2; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>ural 1057. Amount of Degrees (b进制数位dp)</title><link>https://111qqz.com/2016/03/ural1057/</link><pubDate>Fri, 18 Mar 2016 07:06:05 +0000</pubDate><guid>https://111qqz.com/2016/03/ural1057/</guid><description>
题目链接 题意：设条件A为一个数恰好是k个互不相同的b的整数次幂的和，问某一个区间内满足条件A的数的个数是有多少个。
Example. Let X=15, Y=20, K=2, B=2. By this example 3 numbers are the sum of exactly two integer degrees of number 2:
17 = 24+20, 18 = 24+21, 20 = 24+22.
思路：数位dp..需要理解清楚恰好有k个b的互不相同的整数次幂的和这句话。
如果恰好是b的整数幂。。可以转化成b进制。。
互不相同。。说明。。所有位置上的数字要么是0，要么是1.
于是题目可以转化成求某区间内，满足一个数的b进制中恰好有k个1，其余都是0的数的个数有多少个。
然后就是数位dp的套路了。。。
注意dp数组的大小。。。应该按照位数最多的2进制考虑。。。一开始是按照10进制考虑结果只开了dp[15][15]....简直蠢哭。
/* *********************************************** Author :111qqz Created Time :2016年03月18日 星期五 12时13分55秒 File Name :code/ural//1057.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int l,r; int k,base; int digit[700]; int dp[700][700]; int dfs( int pos , int cnt, bool limit) { if (pos==0) return cnt==0; if (cnt&amp;lt;0) return 0; if (!</description></item><item><title>hdu 4734 F(x) (数位dp)</title><link>https://111qqz.com/2016/03/hdu4734/</link><pubDate>Fri, 18 Mar 2016 01:32:06 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu4734/</guid><description>
题目链接s 题意：将一个10进制数x按照2进制展开后得到的值设为f(x)...现在给出a,b（10^9）问【0，b】中满足f[x]&amp;lt;=f[a]的数的个数。 思路：先算出f[a]...然后我们发现f(x)最大也就10*2^10=10240.。。数组可以存下。。搞之。和上一道题类似。。我们不关心两个f函数的值具体是多少。。。只关心他们的相对大小情况。。所以还是可以合并成一个变量。。。然而我用两个变量为什么错了。。不懂==
错误代码（用两个变量分别记录）
/* *********************************************** Author :111qqz Created Time :2016年03月17日 星期四 21时30分57秒 File Name :code/hdu/4734.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int digit[15],digita[15]; int fa; int dp[10][110000];//dp[i][j]表示长度为i,f[x]为j的方案数.</description></item><item><title>bc #75 C || hdu 5642 King's Order （数位dp）</title><link>https://111qqz.com/2016/03/hdu5642/</link><pubDate>Thu, 17 Mar 2016 12:35:47 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5642/</guid><description>
hdu5642题目链接 题意：问长度为n的仅由26个小写字母组成的合法字符串有多少个。如果某个字符连续出现四次或以上，则这个字符串为非法。否则为合法。
思路：当时以为是组合数学的题。。。推了半天公式还是还是gg... 现在学了数位dp..果然是数位dp里很简单的一种。。。 dp[i][j][k]表示长度为i,最后一个字符对应的数字为j,最后一个字符出现了k次的方案数。
需要注意的是，这种连续几个位置相等或者不相等什么的。。。没有必要维护具体那些位置上的字符是什么。。。所以这种只统计最后一个字符，以及最后一个字符出现的次数的方法具有普遍意义。。注意理解。。。</description></item><item><title>hdu 3709 Balanced Number (数位dp)</title><link>https://111qqz.com/2016/03/hdu-3709-balanced-number-dp/</link><pubDate>Thu, 17 Mar 2016 11:46:31 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu-3709-balanced-number-dp/</guid><description>
题目链接 题意：找到某区间中平衡数的个数。所谓平衡数是指，存在某个位置，值得两边的力矩相等。举个例子。。比如14326，如果把4作为中间。。那么左边=11=1 右边=31+22+62=19。。。 思路：枚举中间的pivot。。。注意如果是个位数也是平衡数（就是认为两边的力矩都是0了。。。），所以每一个位置都可能是平衡位置。。枚举的时候从1到len... 一开始我是分别记录两边的值。。非常浪费空间。。。然而发现其实没必要。。我们只关心左边是否相等。。而不关心左右的值到底是多少。。所以可以把两边的值带符号合并成一个值（pivot左边为+，pivot右边为负）。。。如果最后为0。。说明左右相等。。。
以及。。这个值(设为sum)是递减的。。。所以任何时刻如果sum&amp;lt;0。。那么狗带。。算一个剪枝。。而且避免了下标为负。。。
以及，关于前导0的问题。。。有些题目不允许前导0.。。。但是并不是所有不允许前导0的都需要特别处理。。。像这道。。前导0不会导致更新答案。。。所以不用管。。。 但是要注意。。。由于0，00,000,0000都是合法的balanced数。。。然而其实他们是一个数。。多加了len-1次。。记得减去。
/* *********************************************** Author :111qqz Created Time :2016年03月17日 星期四 17时08分59秒 File Name :code/hdu/3709.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL l,r; int T; int digit[30]; LL dp[20][2000][20]; //窝要判断左边和右边是否相等，并不需要分别统计两边，只要把数值带上符号，统计左右两边的和即可。 //如果相等，那么和为0.</description></item><item><title>poj3252 Round Numbers (不允许前导0的二进制数位dp)</title><link>https://111qqz.com/2016/03/poj3252/</link><pubDate>Thu, 17 Mar 2016 08:51:14 +0000</pubDate><guid>https://111qqz.com/2016/03/poj3252/</guid><description>
题目链接 题意：问某区间中，round number 的个数是多少。所谓round number,当且仅当一个数的二进制表示中，‘0’的个数大于等于‘1’的个数。 思路：简单数位dp..和windy数那道题类似，都是不允许前导0.。。所以在dfs中要加一维判断前面是否有非0的数。。。
/* *********************************************** Author :111qqz Created Time :2016年03月17日 星期四 16时17分07秒 File Name :code/poj/3252.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int l,r; int digit[35]; int dp[35][35][35]; //dp[i][j][k]表示长度为i，有j个0，k个1的方案数。 int dfs( int pos,int cnt0,int cnt1,bool limit,bool prehasnonzero) //不允许前导0，所以要加prehasnonzero这个参数 //来确定是否位数减少了.</description></item><item><title>hdu 4507 吉哥系列故事——恨7不成妻 (返回平方和的数位dp)</title><link>https://111qqz.com/2016/03/hdu4507/</link><pubDate>Thu, 17 Mar 2016 07:55:35 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu4507/</guid><description>
题目链接 题意：如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 1、整数中某一位是7； 2、整数的每一位加起来的和是7的整数倍； 3、这个整数是7的整数倍；
现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。
思路;如果是求count的话毫无难度。。。和之前的题目没什么区别。。不多说了。
但是是求平方数。。。一开始我的做法是在dfs中加一个LL 的参数表示当前的和，然后每次到dfs的出口，之前统计count的时候返回的是1，表示找到了满足条件的一个数，那这回就返回平方和。。但是这样做是错的。。。具体为什么错没有想得很明白。。。大概会少算？
然后参考了如下博客： hdu4507解题报告1 hdu4507解题报告2
适牛的博客之数位dp
正解是，之前的dp只统计了一个cnt,这回要同时统计cnt,sum,sqsum(平方和)..
我们先讨论如何求得满足条件的数的和。
我们设某次进入dfs的数是x,当前长度为pos（长度是越来越短的，因为是从高位到低位，对于没有处理到的低位，是按0算的，比如一个五位数xxxxx，第一次dfs以后也许得到4xxxx,x表示没有填的数的位置，实际上这个数就是40000），当前位置要防止的数字是i,考虑其位置，i对这个数的大小（不是和，就是最后要得到的一个数）的贡献是i*10^(pos-1),设为f. 那么当前的数就是f+x. 我们要求的就是所有f+x的和。现在我们考虑当新添加pos位的数字i对于和的贡献。
当新添加i时，相当与把之前的数整体左移了一位，相当于×10（因为之前[1,x]中的每个满足条件的数都乘了10，所以和也乘了10），然后对于新添加的i，它的贡献是i*cnt[x]，含义是对于之前[1,x]所有满足条件的每个数，都进行了pos位置填i的操作，所有对于所有满足条件的和一共添加了cnt[x]个i.
**如果写成用递推的式子就是 **
*sum[10*x+i] = 10 * sum[x] + cnt[x]i;//感谢@clq学长
如果用dfs的话式子就是
sum[new_state] = Σ{ sum[old_state] + (number to add at the postion) * (its base) * count[old_state] }。
接下来我们考虑维护平方和，方法类似。
(f**+x)^2=ff+xx+2fx.**
ff直接可以算，xx..其实就是上一层dfs得到的(f'+x')^2嘛...也就是sum2[x] (sum2表示平方和)
2fx也可以算,x就是上一个状态的和。
同样，我们考虑现在已经有了x,处理到pos位置，填到该位置的数字是i的时候对平方和的影响。
xx部分在上一个状态处理过了，即为sum2[x], 2f*x 也可以通过sum[x]得到...
**注意ff,同样，对于之前的[1,x]中每个满足的数，都相当于第pos位添加了i,每个数对平方和的贡献都是ii,所以要*cnt[x]... **
以及要不断取模，为了方便写了两个函数来搞，代码看起来清楚一些。。。
哦，还有一个小坑。。取模相减以后可能为负数。。。。记得加MOD...
** **
/* *********************************************** Author :111qqz Created Time :2016年03月16日 星期三 10时44分58秒 File Name :code/hdu/4507.</description></item><item><title>hdu 3652 B-number (带整除的数位dp )</title><link>https://111qqz.com/2016/03/hdu3652/</link><pubDate>Wed, 16 Mar 2016 02:23:08 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu3652/</guid><description>
题目链接 题意：给出n,问[1,n]中，满足包含“13”且这个数（不是各位的和）能被13整除的数的个数。 思路：依然是数位dp..不过有一个小tip。。
由于包含13的情况非常难考虑（包含一个“13”，两个“13”.....)
所以要从反面考虑，即不包含13的情况。
但是由于还有另一个条件。
做法是把能被13整除的数考虑成全集U,然后在U中做分划，一部分是含13的，另一部分是不含13的。
这样我们要求两个答案，一个是能被13整除的，另一个是能被13整除并且不含13的，相减即为题目所求。
/* *********************************************** Author :111qqz Created Time :2016年03月16日 星期三 09时27分49秒 File Name :code/hdu/3652.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; LL dp[20][15]; LL dp2[20][2][15]; int digit[20]; LL dfs (int pos,int sum,bool limit) { if (pos==0) return sum==0; if (!</description></item><item><title>hdu 4722 good numbers (带整除的数位dp)</title><link>https://111qqz.com/2016/03/hdu4722/</link><pubDate>Wed, 16 Mar 2016 01:17:27 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu4722/</guid><description>
题目链接 题意：求一个区间内所有位数字之和能被10整除的数的个数。 思路：数位dp，dfs要一个参数记录从最高位到现在的pos位置的数字之和的结果。 dp[i][j] 表示长度为i，和为j的方案数。 记得开long long ，然而我开了那么多long long 忘了dp 的long long 结果wa到死。。果然大早上不清醒吗==
/* *********************************************** Author :111qqz Created Time :2016年03月16日 星期三 08时10分19秒 File Name :code/hdu/4722.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL l,r; int digit[30]; LL dp[30][15]; //dp 数组忘记开long long ,wa到死。。。。。。。。。日了哈士奇。 LL dfs ( int pos,int sum,bool limit) { if (pos==0) { if (sum==0) return 1; else return 0; } if (!</description></item><item><title>bzoj 1026 windy数(数位dp入门题)</title><link>https://111qqz.com/2016/03/bzoj1026/</link><pubDate>Tue, 15 Mar 2016 13:05:13 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1026/</guid><description>
题目链接 题意：不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 思路：数位dp 这道题的特点是前面不允许前导0，也就是说，如果第i位前面全是0的话，这个数就变成了i位数，i就变成了最高位，而最高位没有前面的数（**如果这里不考虑不允许前导0这个因素而把前面的一个数认为成是0就错了） **最高位的数可以直接取。 还有记忆化调用以及存储的时候也要注意...只有当位数相同的时候转移才有意义。 具体的方法是dfs中多了一个prehasnonzero的bool变量，就是字面意思，判断当前位置前面的位置是够存在一个非0的值。
/* *********************************************** Author :111qqz Created Time :2016年03月15日 星期二 19时49分57秒 File Name :code/bzoj/1026.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int l,r; int dp[30][10]; int digit[30]; int dfs ( int pos,int pre,bool limit,bool prehasnonzero) // prehasnonzero表示当前位前面的位是否有非0的位。 {zhi if (pos==0) return 1; if (prehasnonzero&amp;amp;&amp;amp;!</description></item><item><title>hdu 3555 Bomb （数位dp入门题）</title><link>https://111qqz.com/2016/03/hdu3555/</link><pubDate>Tue, 15 Mar 2016 11:48:19 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu3555/</guid><description>
题目链接 题意:问从1到n的所有数中，有多少个数含有数字串“49” 思路：和上一道不要62很像，但是由于是要统计有49的，但是有49的情况实在太多了，正难则反，用减法定理反过来考虑，先统计出不含49的数的个数，这样就和不要62一样了，然后再用总数减。
/* *********************************************** Author :111qqz Created Time :2016年03月15日 星期二 19时32分24秒 File Name :code/hdu/3555.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; LL digit[30]; LL dp[30][2]; LL dfs ( int pos,bool preis4,bool limit) { if (pos==0) return 1; if (!</description></item><item><title>hdu 2089 不要62 （数位dp模板题，附带详细解释）</title><link>https://111qqz.com/2016/03/hdu-2089/</link><pubDate>Tue, 15 Mar 2016 11:27:43 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu-2089/</guid><description>
题目链接 题意：问区间[n,m]中，不含数字4，也不含数字串“62”的所有数的个数。
思路：可以转化成求区间[0,x]
第一次接触数位dp,参考了这几篇博客。
不要62（数位dp）解题报告
解题报告2
解题报告3
比较重要的前提：
¨对于一个小于n的数，肯定是从高位到低位出现某一位&amp;lt;n的那一位。
¨如 n = 58 n为十进制数。
¨ x = 49 此时x的十位&amp;lt;n
¨ x = 51 此时x的个位&amp;lt;n
¨有了上述性质，我们就可以从高到低枚举第一次&amp;lt;n对应位是哪一位。
这样之前的位确定了，之后的位就不受n的限制即从00...0~99...9，可以先预处理
以及写成递归形式代码会简洁很多，所以就写了递归形式。
更详细的解释参加代码注释。
/* *********************************************** Author :111qqz Created Time :2016年03月15日 星期二 18时04分46秒 File Name :code/hdu/2089.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int dp[30][2]; int digit[30]; int dfs (int pos,bool preis6,bool limit) //pos表示从低到高的第几位，是从高位往低位递归的（也就是从左到又） // preis6 表示上一个数字是否为6， // limit表示该位置是否有限制。 { // cout&amp;lt;&amp;lt;pos&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;preis6&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;limit&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;endl; if (pos==0) return 1; //到该位置表明找到了一个解.</description></item><item><title>codeforces #345 div 2 C. Watchmen (容斥)</title><link>https://111qqz.com/2016/03/codeforces-345-div-2-c-watchmen-/</link><pubDate>Tue, 08 Mar 2016 08:56:54 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-345-div-2-c-watchmen-/</guid><description>
题目链接 题意：求曼哈顿距离和平方根距离相等的点的对数？ 思路：化简发现是绝对值乘积等于0，容斥搞搞。
/* *********************************************** Author :111qqz Created Time :2016年03月07日 星期一 18时43分02秒 File Name :code/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E6+7; struct node { int x,y; bool operator &amp;lt; (node b)const { if (x==b.</description></item><item><title>codeforces #345 div 2 B. Beautiful Paintings （暴力）</title><link>https://111qqz.com/2016/03/cf651b/</link><pubDate>Tue, 08 Mar 2016 08:40:35 +0000</pubDate><guid>https://111qqz.com/2016/03/cf651b/</guid><description>
题目链接 题意：给出一个数列，按照最好的策略排序使得a[i+1]&amp;gt;a[i]的对数尽可能多，问最多的对数是多少。 思路：类似计数排序？
/* *********************************************** Author :111qqz Created Time :2016年03月07日 星期一 17时06分48秒 File Name :code/cf/#345/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n ; int a[N]; int cnt[N]; int num[N]; int sum[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #345 div2 A. Joysticks (贪心)</title><link>https://111qqz.com/2016/03/cf651a/</link><pubDate>Tue, 08 Mar 2016 08:31:34 +0000</pubDate><guid>https://111qqz.com/2016/03/cf651a/</guid><description>
题目链接 题意：两个手柄？ 初始的电量给出，只有一个充电器，每经过一秒，充着电的手柄电量增加1，没有充电的手柄电量减少2，允许电量充到0以上，当有电量为0的时候，或者当某一分钟开始的时候有手柄电量为1，游戏立即结束。问最多能玩多少时间游戏。
思路：贪心。。每次给电量少的充电。 坑点在于当某一时刻有手柄电量为1，那么游戏在进行这一分钟之前就结束。
/* *********************************************** Author :111qqz Created Time :2016年03月07日 星期一 17时06分41秒 File Name :code/cf/#345/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>thatkk</title><link>https://111qqz.com/2016/03/thatkk/</link><pubDate>Sat, 05 Mar 2016 16:55:28 +0000</pubDate><guid>https://111qqz.com/2016/03/thatkk/</guid><description>
一年过去了。 现在看到小可，内心却依然无法平静... 强装镇定得打个招呼已经是我的极限了orz 其实还是觉得很可惜...曾经的好朋友变得形同陌路总是令人伤感的...
可是没办法啊orz 果然是绕不过去的一个人啊.... 我赌五毛永远没办法做朋友了orz,虽然我挺希望我输掉的... 以及：感觉《熔炉》中的妍斗好像小可== 以及：好喜欢代码写得好的妹子</description></item><item><title>bc #73 B || hdu 5631 Rikka with Graph （并查集判断无向图的连通性）</title><link>https://111qqz.com/2016/03/hdu5631/</link><pubDate>Fri, 04 Mar 2016 11:53:45 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5631/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5631 题意;给出一张n个点n+1（n&amp;lt;=100）条边的无向图，现在删除若干条边（至少一条边），问删完之后图依然联通的方案数。 思路：分析可知，由于只删边，不删点，n个点，最少需要n-1条边才能联通，所以最多删两条边。我们可以暴力枚举删除的两条边（或者一条边） O(n^2)的复杂度完全可以接受。剩下的问题就变成了每次删边之后判断图的连通性。 题解给出的是bfs。。。大概是bfs一遍，然后入队的点数是n就联通？ 或者dfs一遍也可以？ 也是标记过的点数是n就说明联通？ 但是看到排名考前的人都是用到了并查集来判断...比较巧妙。
具体做法是：先把所有的点孤立出来，然后开始添加边，每次union成功（就是添加了一条边）的时候计数器+1，n个点如果能合并n-1次，也就是添加了n-1条有效边（最多也只可能是n-1条，那么说明这n个点之间是联通的。
第一次这样用并查集...憋说话，用心感悟。
/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 21时11分19秒 File Name :code/hdu/5631.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int f[N]; bool ban[N]; pi edge[N]; void init() { ms(f,0); for ( int i = 0 ; i &amp;lt; N ; i++) f[i] = i; } int root ( int x) { if (f[x]!</description></item><item><title>hdu 5630 Rikka with Chess （暴力 ，计数问题）</title><link>https://111qqz.com/2016/03/hdu5630/</link><pubDate>Thu, 03 Mar 2016 12:53:20 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5630/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5630 题意：nm的棋盘，相邻格子的颜色相反，每次可以翻转一个任意大小矩形的格子，问最少需要翻转多少次使得棋盘的nm个格子颜色相同。（翻转的意思是颜色反色）
思路：手写了下。。发现。。答案就是n/2+m/2. 对应的最优策略是。。翻偶数行和偶数列，都翻一遍，颜色就一样了。
/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 20时47分47秒 File Name :code/hdu/5630.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4451 Dressing (计数，思维题)</title><link>https://111qqz.com/2016/03/hdu4451/</link><pubDate>Thu, 03 Mar 2016 12:26:59 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu4451/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4451 题意：N clothes, M pants and K shoes，然后给出p个不合法的搭配，形式是“clothes x pants y” or “pants y shoes z”.” 问有多少种合法的方案。 思路：一开始觉得是容斥。。当然可以。。但是实际上，不合法的搭配的形式比较简单，每种不合法的发配都是两个两个的不合法，以及每种不合法的形式都有pants,那么我们就可以通过先确定pants，对于每种pants，方案数就是能和当前pants搭配的clothes数，乘以能和当前pants搭配的shoes数，然后累加每种pants的答案即可。
/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 20时09分47秒 File Name :code/hdu/4451.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E6+7; int n,m,k; int p; int a[N]; int clo[N]; int sho[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3929 Big Coefficients (递归形式的容斥原理+lucas定理的结论)</title><link>https://111qqz.com/2016/03/hdu3929/</link><pubDate>Thu, 03 Mar 2016 11:50:32 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu3929/</guid><description>
题意：F(x) = (1+x)^a1 + (1+x)^a2 + … + (1+x)^am，求系数是奇数的项的个数。 思路：解题报告 涉及到的由lucas定理得到的推论的证明lucas定理证明 以及这篇理解里有递归形式的容斥定理的一般写法。。递归形式的容斥定理
dfs(int beg,set S,int sym) { ans+=num(S)*sym; for(int i=beg;i&amp;lt;=n;i++) dfs(i,S∩A[i],sym*-1); } for(int i=1;i&amp;lt;=n;i++) dfs(i,A[i],1); 第一次接触递归形式的容斥定理...还不是特别理解，据说要比循环的写法少一层msk(应该是少一个1&amp;lt;/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 18时55分21秒 File Name :code/hdu/3929.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair</description></item><item><title>指数型母函数总结</title><link>https://111qqz.com/2016/03/</link><pubDate>Thu, 03 Mar 2016 07:30:32 +0000</pubDate><guid>https://111qqz.com/2016/03/</guid><description>
指数型母函数网上的资料不是很多，推荐毛杰明的09年国家集训队论文《母函数的性质及应用》
以及Richard A.Brualdi 所著的《组合数学》的第七章来看...倒不用全看懂..但是这本上面干货比较多。
我来说下自己的理解：
指数型母函数和普通型母函数（不加普通二字也是指它）的区别是后者是用来求解组合问题（顺序无关行），而前者是求解排列问题（不同的顺序属于不同的方案）。
对于多重排列问题，由于某种元素可能有多个，需要去掉它的重复度（除以该种元素的个数的阶乘），而这个除以阶乘的形式和泰勒级数展开中的一些函数的展开形式一致（或者是一些变形）。
因此母函数可以用泰勒级数来化简。
这是求解这类问题最核心的内容。
也有直接算的。比如这个hdu1521排列组合。hdu1521排列组合解题报告但是由于阶乘的存在。。这类问题求解的范围十分有限。 所以更多的是下面这些题，难度递增，建议先独立思考... hdu2065解题报告 poj1322 chocolate解题报告 cf451E解题报告</description></item><item><title>codeforces 451E Devu and Flowers (指数型母函数)</title><link>https://111qqz.com/2016/03/cf451e/</link><pubDate>Wed, 02 Mar 2016 13:41:51 +0000</pubDate><guid>https://111qqz.com/2016/03/cf451e/</guid><description>
http://codeforces.com/problemset/problem/451/E 题意;有n个花坛，要选s支花，每个花坛有f[i]支花，同一个花坛的花颜色相同，不同花坛的花颜色不同，问说可以有多少种组合。 思路：典型的母函数...然而s有点大，根据泰勒展开什么的...先转一下官方题解。
The number of ways to choose _N_ items out of _R_ groups where each item in a group is identical is equal to the number of integral solutions to _x_1 + _x_2 + _x_3..._x__R_ = _N_, where 0 ≤ _x__i_ ≤ _L__i_, where _L__i_ is the number of items in _i__th_ group. Number of integral solutions are coefficient of _x__N_ in [Product of (1 + _x_ + _x_ * _x_ + .</description></item><item><title>poj 1322 chocolate (指数型母函数 )</title><link>https://111qqz.com/2016/03/poj1322chocolate/</link><pubDate>Wed, 02 Mar 2016 11:53:41 +0000</pubDate><guid>https://111qqz.com/2016/03/poj1322chocolate/</guid><description>
http://poj.org/problem?id=1322 题意：
思路：别看n,m很大。。。但是想一下。。m显然不可能大于c(如果大于c，那么根据抽屉原理，至少存在一种巧克力大于一个，然而大于一个就会被取走...矛盾) 这样概率为0.m也不可能大于n，因为最好的情况就是取出的巧克力都放在了桌子上，如果总共取的还不到n个，又怎么可能剩下m（m&amp;gt;n）个呢。此外，还需要n,m奇偶性相同，否则设n-m=2K+1 ,说明如果要剩余m个，那么就要减少2k+1个，但是巧克力是两个两个减少的，减少的个数一定是偶数，因此矛盾。所以n,m奇偶性相同。
接下来可以用概率dp做，由于n比较大，滚动一下应该可以... 然后看到别人的题解里写到当n&amp;gt;1000的时候已经趋向平衡（达到了要求的精度）... 这道题dp写起来的确容易，也不是很难想。
不过作为dp废宁愿选择数学方法，指数型母函数。
分析可知，取过偶数次的巧克力消失，只有取过奇数次的巧克力会留在桌子上。
那么要剩余m个巧克力，也就是有m种巧克力取了奇数次，剩下的c-m种巧克力取了偶数次。
对应的的生成函数（母函数）分别是(e^x-e(-x))/2和（e^x+e(-x)）/2 （推倒类似）hdu2065红色病毒解题报告
总事件个数为c^n
根据古典概型，所求概率为 (Gn*n!C[c][m])/(c^n) 其中Gnn!为生成函数，C[c][m]是因为不确定c种巧克力中的哪m种取了奇数个。
现在的问题就成了求Gn中x^n的系数。。我就是因为这个卡了两天这道题。。。
其实模拟就好，复杂度O(c^2)而已。。主要是好久没写二项式定理。。。有点忘了（手动智力-2）
/* *********************************************** Author :111qqz Created Time :2016年03月02日 星期三 18时57分58秒 File Name :code/poj/1322.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; double c[N][N]; int C,n,m; void pre() { c[0][0] = 1; for ( int i = 1 ; i &amp;lt; N ; i++) { c[i][0]=c[i][i] = 1; for ( int j = 1 ; j &amp;lt; i ; j++) c[i][j]=c[i-1][j-1]+c[i-1][j]; } } double ksm( double a,int b) { double res = 1.</description></item><item><title>无路可走了。。。</title><link>https://111qqz.com/2016/03/no-way-to-go/</link><pubDate>Wed, 02 Mar 2016 10:53:06 +0000</pubDate><guid>https://111qqz.com/2016/03/no-way-to-go/</guid><description>
。。。 醒来，发现，四面都是山。。。 每座山上都写着“线段树”三个字.... 不把线段树的lazy标记搞掉根本没法继续搞数据结构啊喂... 像莫队这种没有前置技能点的东西毕竟是少数吧==</description></item><item><title>poj 2356 Find a multiple (剩余类，抽屉原理)</title><link>https://111qqz.com/2016/02/poj2356/</link><pubDate>Mon, 29 Feb 2016 13:06:00 +0000</pubDate><guid>https://111qqz.com/2016/02/poj2356/</guid><description>
http://poj.org/problem?id=2356
题意：有n个数，从中选取若干个（1..n），和能被n整除。问是否有解，无解输出0，有解的话，输出个数以及选择的ai
由抽屉原理可知一定有解： 做一个带模的前缀和 sum[i]=(sum[i-1]+a[i])%n n个数，sum[i]最多有n种。 如果某个sum[i]为0，那么表示从1到i的和能被n整除。 如果所有的sum[i]不为0，那么一共有n个sum[i]，n-1个值（1..n-1），一定有sum[i]==sumj 那么a[i]到a[j]的和一定能被n整除。
/************************************************************************* &amp;gt; File Name: code/poj/2356.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月21日 星期五 13时43分41秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x3f3f3f3f; const int N=2E4+7; int a[N]; int sum[N]; int n; int p[N]; int main() { scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); sum[0]= 0; for ( int i = 1 ; i &amp;lt;= n ; i++){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]); sum[i] = (sum[i-1] + a[i])%n; } memset(p,0,sizeof(p)); for ( int i = 1 ; i &amp;lt;= n ; i++){ if (sum[i]==0){ printf(&amp;quot;%d\n&amp;quot;,i); for ( int j = 1 ; j &amp;lt;= i ; j++){ printf(&amp;quot;%d\n&amp;quot;,j); } break; } if (p[sum[i]]){ // cout&amp;lt;&amp;lt;&amp;quot;111qqz&amp;quot;&amp;lt;&amp;lt;endl; printf(&amp;quot;%d\n&amp;quot;,i-p[sum[i]]); for ( int j = p[sum[i]]+1 ; j &amp;lt;= i ; j++){ printf(&amp;quot;%d\n&amp;quot;,j); } break; } p[sum[i]] = i; } return 0; }</description></item><item><title>hdu 1205 吃糖果 （鸽笼原理）</title><link>https://111qqz.com/2016/02/hdu1205/</link><pubDate>Mon, 29 Feb 2016 12:51:51 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1205/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1205 题意：有n种糖果，第i种糖果有a[i]个，相邻两次不能吃一样的糖果，问能否有办法吃完所有糖果... 思路：如果第i种糖果有k个的话，那么其他所有种类的糖果之和至少有k-1个，才可能吃完。复杂度O(n) 看到有人说是抽屉原理.....大概。。。？不过不太明显。。直接想就好吧
/* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 20时40分00秒 File Name :code/hdu/1205.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; LL a[N]; LL total; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1796 How many integers can you find (容斥原理)</title><link>https://111qqz.com/2016/02/hdu1796/</link><pubDate>Mon, 29 Feb 2016 12:00:53 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1796/</guid><description>
hdu1796 题意：给出n（&amp;lt;=2^31）以及m(&amp;lt;=10)个元素组成的无重复元素集合，集合元素0&amp;lt;=a[i]&amp;lt;=20,问有多少个小于n的数能至少被集合中的一个元素整除。
思路：容斥，找到能被一个元素的，被两个元素的...加加减减。 一个元素的最小公倍数定义成自己，然后多个元素的就两个两个算...
一个坑点是，a[i]有0，而一个数除以0没有意义。。。所以读入的时候处理下。。。把0删掉（个人觉得这个坑点毫无技术含量。。。。0不能作为除数这种事情呵呵呵） 并且如果只有一个数且为0，那么删掉后集合就为空了，特判输出0.
另一个坑点是，别看每个数都很小。。但是求多个数的最小公倍数的时候会爆int...
**虽然最后结果没有爆，但是中间量会爆掉，要开long long **
/* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 19时09分31秒 File Name :code/hdu/1796.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int a[15]; int b[15]; LL gcd ( LL a,LL b) { if (b&amp;gt;a) return gcd(b,a); if (a%b==0) return b; return gcd(b,a%b); } LL lcm( LL a,LL b) { LL res; res = a*b; //10个数的最小公倍数会爆掉.</description></item><item><title>hdu 4336 Card Collector (2012多校 #4) （容斥原理模板题）</title><link>https://111qqz.com/2016/02/hdu4336/</link><pubDate>Mon, 29 Feb 2016 11:00:49 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu4336/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4336
题意：有n种卡片，买一包干脆面得到第i种卡片的概率是p[i],每包干脆面最多有一张卡片，问收集齐所有卡片要买的干脆面的包数的数学期望。
思路：容斥模板题。1.0/p[i]就是拿到某张卡片需要买的包数的数学期望
注意体会这种具体应用容斥的模拟方法，把1&amp;lt;&amp;lt;n转化成二进制来模拟有1个元素的集合，有2个元素的集合...有n个元素的集合。 核心代码：
for ( int msk = 1 ; msk &amp;lt;(1&amp;lt;&amp;lt;n) ; msk++) { double res = 0.0; int bits = 0; for ( int i = 0 ; i &amp;lt; n ; i++) { // cout&amp;lt;&amp;lt;&amp;quot;msk:&amp;quot;&amp;lt;&amp;lt;msk&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;i)&amp;lt;&amp;lt;endl; if (msk&amp;amp;(1&amp;lt;&amp;lt;i)) { bits++; res +=p[i]; } } if (bits%2==1) { ans += 1.0/res; } else { ans -= 1.0/res; } } /* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 18时39分23秒 File Name :code/hdu/4336.</description></item><item><title>poj 3734 Blocks (指数型母函数，泰勒级数展开)</title><link>https://111qqz.com/2016/02/poj-3734/</link><pubDate>Sun, 28 Feb 2016 06:37:08 +0000</pubDate><guid>https://111qqz.com/2016/02/poj-3734/</guid><description>
http://poj.org/problem?id=3734
题意+思路同******hdu2065红色病毒解题报告
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 16时39分53秒 File Name :code/poj/3734.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD =1E4+7; LL n; LL res; LL ksm(LL a,LL b) { LL res = 1; while (b) { if (b&amp;amp;1) res=(res*a)%MOD; b = b&amp;gt;&amp;gt;1; a = (a*a)%MOD; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2065 "红色病毒"问题 (指数型母函数，泰勒级数展开)</title><link>https://111qqz.com/2016/02/hdu2065/</link><pubDate>Sun, 28 Feb 2016 06:26:51 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu2065/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2065 题意：a,b,c,d四种元素，a,c只能出现偶数次（包括0次），b,d没有限制，问n个（2^64）个元素有多少种不同的组合。 思路：指数型母函数。。。n大的没办法用之前的办法做。
先来看下我们要求的式子：A=(1+x/1!+x^2/2!+x^3/3!……)^2*(1+x^2/2!+x^4/4!+x^6/6!……)^2.
其实一共四个式子相乘，但是a和c的情况相同，b和d的式子相同。
我们要求的是x^n的系数。。。n太大了。。直接搞肯定不行。
想到微积分学的泰勒展开。
e^x=1+x/1!+x^2/2!+x^3/3!+... (|x|&amp;lt;oo)
其实这里x的范围没有意义，因为母函数关注的是系数，不会代入x的值，所以可以不用考虑收敛性。
那么第一项(1+x/1!+x^2/2!+x^3/3!……)^2就可以换成(e^x)^2
第二项没有奇数项，很容易想到可以写成(（e^x+e^(-x)）/2)^2
继续化简：4A=(e^x)^2((e^x+e^(-x))/2)^2
4A = (e^(4x)+2e^(2x)+1)
我们要的是x^n的系数，再正向泰勒展开，得到x^n的系数应该是 (4^n+2*2^n)/4,也就是4^(n-1)+2^(n-1)
因为只要后两位的结果，其实就是结果0.快速幂搞之。
以及，2^64 long long 存不下，应该用unsigned long long ，类型说明符是 %llu
/* *********************************************** Author :111qqz Created Time :2016年02月28日 星期日 14时01分58秒 File Name :code/hdu/2065.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef unsigned long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD = 100; LL n; LL ksm(LL a,LL b) { LL res = 1LL; while (b) { if (b&amp;amp;1) res = (res*a)%MOD; b = b&amp;gt;&amp;gt;1; a =(a*a)%MOD; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1610 [Usaco2008 Feb]Line连线游戏 (计算几何)</title><link>https://111qqz.com/2016/02/bzoj1610/</link><pubDate>Sat, 27 Feb 2016 18:35:59 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj1610/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=1610 题意：给出n个点，问有多少条直线，这些之间之间都不平行。 思路：求斜率（注意考虑斜率不存在），看有多少种斜率。 妈蛋。。。。斜率不存在是横坐标相等啊，不是纵坐标啊。。。蠢哭了好么。。。。。。
妈蛋。。。。斜率不存在是横坐标相等啊，不是纵坐标啊。。。蠢哭了好么。。。。。。
妈蛋。。。。斜率不存在是横坐标相等啊，不是纵坐标啊。。。蠢哭了好么。。。。。。
太他妈惨了。。。。
/* *********************************************** Author :111qqz Created Time :2016年02月28日 星期日 01时34分35秒 File Name :code/bzoj/1610.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; const double oo=1897987987; struct node { double x,y; double getk(node b) { return (y-b.</description></item><item><title>bzoj 1607 [Usaco2008 Dec]Patting Heads 轻拍牛头 （筛法）</title><link>https://111qqz.com/2016/02/bzoj1607/</link><pubDate>Sat, 27 Feb 2016 17:30:18 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj1607/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=1607
题意：n个数，求对于每个数来说，其他n-1个数中是它约数的数的个数。
思路：类似筛法，从小到大处理，数i对其所有倍数的数的答案有cnt[i]的贡献 。最后记得把自己是自己的约数的情况减掉。
/* *********************************************** Author :111qqz Created Time :2016年02月28日 星期日 01时06分35秒 File Name :code/bzoj/1607.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int cnt[N*10]; int ans[N*10]; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>hdu 1521 排列组合 （指数型母函数模板题）</title><link>https://111qqz.com/2016/02/hdu1521/</link><pubDate>Sat, 27 Feb 2016 12:12:02 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1521/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1521
题意：有n种物品，并且知道每种物品的数量。要求从中选出m件物品的排列数。例如有两种物品A,B，并且数量都是1，从中选2件物品，则排列有&amp;quot;AB&amp;quot;,&amp;quot;BA&amp;quot;两种。
思路：指数型母函数。 对于相同的元素，需要去掉该元素的重复度，即为元素个数的阶乘。具体做法是用double类型存储（方案数除以重复度），然后在最后把阶乘乘回来四舍五入取整（为什么是四舍五入？）
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 19时48分31秒 File Name :code/hdu/1521.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double a[15],tmp[15],f[15]; int n,m; int num[15]; void pre() { f[0] = 1.</description></item><item><title>普通型母函数总结</title><link>https://111qqz.com/2016/02/</link><pubDate>Sat, 27 Feb 2016 09:38:24 +0000</pubDate><guid>https://111qqz.com/2016/02/</guid><description>
从这里母函数（Generating function）详解学习了普通型母函数
#include &amp;lt;iostream&amp;gt; using namespace std; // Author: Tanky Woo // www.wutianqi.com const int _max = 10001; // c1是保存各项质量砝码可以组合的数目 // c2是中间量，保存没一次的情况 int c1[_max], c2[_max]; int main() { //int n,i,j,k; int nNum; // int i, j, k; while(cin &amp;gt;&amp;gt; nNum) { for(i=0; i&amp;lt;=nNum; ++i) // ---- ① { c1[i] = 1; c2[i] = 0; } for(i=2; i&amp;lt;=nNum; ++i) // ----- ② { for(j=0; j&amp;lt;=nNum; ++j) // ----- ③ for(k=0; k+j&amp;lt;=nNum; k+=i) // ---- ④ { c2[j+k] += c1[j]; } for(j=0; j&amp;lt;=nNum; ++j) // ---- ⑤ { c1[j] = c2[j]; c2[j] = 0; } } cout &amp;lt;&amp;lt; c1[nNum] &amp;lt;&amp;lt; endl; } return 0; } ① 、首先对c1初始化，由第一个表达式(1+x+x^2+.</description></item><item><title>hdu 1284 铅笔兑换问题（母函数）</title><link>https://111qqz.com/2016/02/hdu1284/</link><pubDate>Sat, 27 Feb 2016 08:28:04 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1284/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1284 题意：有1分，2分，3分的钱若干，问组成n（n&amp;lt;=32767）分钱的方案数。 思路：母函数.
需要注意的是多组数据。每次都搞会TLE，可以先预处理出来存到数组里，每次直接调用。如果预处理时间也还是慢的话，可以先跑出来，然后打表。这算一个小tip吧2333
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 16时10分40秒 File Name :code/hdu/1284.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; int tmp[N],a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2082 找单词 （母函数）</title><link>https://111qqz.com/2016/02/hdu2082/</link><pubDate>Sat, 27 Feb 2016 08:09:18 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu2082/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2082 题意：26个字母，第i个字母有x[i]个，价值为i.问能组成多少个价值不超过50的单词（注意这里的单词只考虑字母的组成，不考虑字母之间的顺序） 思路：母函数。
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 15时56分31秒 File Name :code/hdu/2082.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4; LL a[N],tmp[N]; int x[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BC #70 B || hdu 5616 Jam's balance （母函数）</title><link>https://111qqz.com/2016/02/hdu5616/</link><pubDate>Sat, 27 Feb 2016 07:53:54 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5616/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5616 题意：有n个（n&amp;lt;=20）砝码，第i个重量为w[i],给出m个查询，每个查询一个重量，问这个重量能否被称量出。 思路：暴力（没美感），01背包（不会），母函数（瞬间成了傻逼题）和这题很像 hdu1709 balance hdu1709解题报告
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 15时35分32秒 File Name :code/hdu/5616.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int w[N]; int a[N],tmp[N]; int n; int m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2152 Fruit (母函数)</title><link>https://111qqz.com/2016/02/hdu2152/</link><pubDate>Sat, 27 Feb 2016 07:29:41 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu2152/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2152
题意：中文题目，大概是说有n（&amp;lt;=100）种水果，第i种至少拿l[i]个，最多拿r[i]个，现在挑选m种水果组成一个果盘，问方案数。
思路：母函数，之前的题目都是只对上界有限制，其实对下界有限制是一样的。以及。。。一开始以为是拿100元买。。。后来发现是“一打百元大钞”23333 其实再出难点可以对个数以及钱数都有限制。。。。
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 15时14分12秒 File Name :code/hdu/2152.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int a[N],tmp[N]; int n,m; int l[N],r[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2069 Coin Change(母函数)</title><link>https://111qqz.com/2016/02/hdu2069/</link><pubDate>Sat, 27 Feb 2016 07:12:44 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu2069/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2069
题意：有1,5,10,25,50面值的硬币若干，问组成n元钱有多少种不同的方案。一个额外的要求是硬币的总是不能超过100.（那句 your program should be able to handle up to 100 coins.真的是这个意思。。。？感觉好坑。。。）
思路：还是母函数，但是由于有了多硬币总数的限制条件，需要加一维.a[i][j]表示j个硬币组成i元钱的方案数（越来越想dp了） 如果转移的时候需要需要加一层硬币的个数。具体见代码。
/* *********************************************** Author :111qqz Created Time :2016年02月26日 星期五 12时19分21秒 File Name :code/hdu/2069.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=255; int n; int a[N][105],tmp[N][105]; //a[i][j]表示j个硬币构成i元钱的方案数 int s[10]={0,1,5,10,25,50}; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1709 The Balance (母函数)</title><link>https://111qqz.com/2016/02/hdu1709/</link><pubDate>Fri, 26 Feb 2016 10:38:09 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1709/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1709 题意：有n个砝码，第i个的重量为w[i]，问从1到sum(所有砝码的重量之和)那些重量无法称量。（所有质量都是整数） 思路：母函数。 一个砝码可以看做有三种状态，放，放左边（+），放右边（-）
需要注意的一点是放在右边(-)的时候，可能是j-w[i]，也可能是w[i]-j
/* *********************************************** Author :111qqz Created Time :2016年02月26日 星期五 17时57分05秒 File Name :code/hdu/1709.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int a[N],tmp[N]; int n; int w[N]; int ans[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2189 悼念512汶川大地震遇难同胞——来生一起走 (母函数)</title><link>https://111qqz.com/2016/02/hdu-2189-512--/</link><pubDate>Fri, 26 Feb 2016 08:39:56 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu-2189-512--/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2189 题意：n个人可以分成若干组，每组人数都为素数，问有多少种分法。 思路：母函数。先预处理素数，记得多处理一点...
/* *********************************************** Author :111qqz Created Time :2016年02月26日 星期五 16时24分17秒 File Name :code/hdu/2189.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt;muhanshu #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=155; int pri[N]; int a[N],tmp[N]; int cnt; int n; bool judge ( int n) { if (n&amp;lt;=3) return true; for ( int i = 2 ; i*i &amp;lt;= n ; i++) { if (n%i==0) return false; } return true; } void pre() { cnt = 0; for ( int i = 2 ; i &amp;lt;= 200 ; i++) { if (judge(i)) pri[++cnt] = i; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1085 Holding Bin-Laden Captive! （母函数）</title><link>https://111qqz.com/2016/02/hdu1085/</link><pubDate>Thu, 25 Feb 2016 14:49:19 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1085/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1085 题意;一元的钱有num_1张，2元的钱有num_2张，5元的钱有num_5张，问最小的不能组成的钱是多少。 思路：有限个个数的母函数，并且不知道最好要多少，所以限制条件变成了不同种类钱的个数。统计0到num_1+2num_2+5num_5的方案数，第一个为0的就是答案。
20161117更新：之前贴的代码好像有点问题...估计是最后一次更新以后忘记保存了orz
/* *********************************************** Author :111qqz Created Time :2016年02月25日 星期四 22时26分16秒 File Name :code/hdu.1085.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=9E3+7; int num_1,num_2,num_5; int a[N],tmp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1398 Square Coins (母函数裸题)</title><link>https://111qqz.com/2016/02/hdu1398/</link><pubDate>Thu, 25 Feb 2016 14:24:12 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1398/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1398 题意：所有的货币都是平方数，比如1,4,9...问凑出n块钱有多少种办法。 思路：母函数。
/* *********************************************** Author :111qqz Created Time :2016年02月25日 星期四 22时15分31秒 File Name :code/hdu/1398.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int a[N],tmp[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1028 Ignatius and the Princess III（整数拆分，母函数模板题）</title><link>https://111qqz.com/2016/02/hdu1028/</link><pubDate>Thu, 25 Feb 2016 14:13:47 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1028/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1028 题意：求整数拆分数。 思路：母函数模板题。关于母函数的学习：http://www.cnblogs.com/syxchina/archive/2011/07/07/2197205.html http://www.cppblog.com/tanky-woo/archive/2010/08/02/121969.html
具体解释见代码注释。
/* *********************************************** Author :111qqz Created Time :2016年02月25日 星期四 21时53分43秒 File Name :code/hdu/1028.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=125; int n; int a[N],tmp[N]; //a[i]表示每两个表达式运算时候的前一个表达式的x^i的系数，以及最后的表达式的x^i的系数 //tmp[i]是每次运算临时存储指数用 int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2926 Requirements （五维曼哈顿距离变换【拆点】）</title><link>https://111qqz.com/2016/02/poj2926/</link><pubDate>Wed, 24 Feb 2016 16:43:52 +0000</pubDate><guid>https://111qqz.com/2016/02/poj2926/</guid><description>
http://poj.org/problem?id=2926 题意：给出n(1E5)个五维空间内的坐标...问最远的两个点距离多少。 思路：拆点即可。去绝对值。可以由二维空间推广到k维空间。一个点可以拆成2^(k-1)个点。 具体见代码。
/* *********************************************** Author :111qqz Created Time :2016年02月25日 星期四 00时19分46秒 File Name :code/poj/2926.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iomanip&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; double p[16][N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5626 Clarke and points (曼哈顿距离变换，拆点)</title><link>https://111qqz.com/2016/02/hdu5626/</link><pubDate>Wed, 24 Feb 2016 15:56:56 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5626/</guid><description>
http://acm.split.hdu.edu.cn/showproblem.php?pid=5626
题意：给出n（1E6）个点的二维坐标，问距离最远的两个点的距离是多少。
思路：对曼哈顿距离进行变换。
先看曼哈顿距离的定义
|x1−x2|+|y1−y2|
拆绝对值
x1−x2+y1−y2或x1−x2+y2−y1
x2−x1+y1−y2或x2−x1+y2−y1
即|x1+y1−(x2+y2)|或|x1−y1−(x2−y2)|
设x1+y1为x′，x1−y1为y′
则|x1′−x2′|或|y1′−y2′|
所以原要求1转化为
max(|x1′−x2′|,|y1′−y2′|)&amp;lt;=c
然后分别对x,y排序即可..最大的距离一定是y[n-1]-y[0]或者x[n-1]-x[0]
/* *********************************************** Author :111qqz Created Time :2016年02月24日 星期三 23时42分15秒 File Name :code/hdu/5626.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; LL seed; int n; int x[N],y[N]; inline LL rand(LL l,LL r) { static LL mo =1E9+7,g=78125; return l+((seed*=g)%=mo)%(r-l+1); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>买了bzoj权限号</title><link>https://111qqz.com/2016/02/finally-get-bzoj-vip/</link><pubDate>Wed, 24 Feb 2016 13:37:11 +0000</pubDate><guid>https://111qqz.com/2016/02/finally-get-bzoj-vip/</guid><description>
本打算和队友一起买一个。。。 结果站长看到id填的学校是华科的。。然后买一送一，感动到cry...
所以结果是400元我和队友一人一个权限号... 正好到退役将近两年时间，加油。</description></item><item><title>bzoj 1604: [Usaco2008 Open]Cow Neighborhoods 奶牛的邻居 (曼哈顿距离的转化【拆点】+set+并查集)</title><link>https://111qqz.com/2016/02/bzoj1604/</link><pubDate>Wed, 24 Feb 2016 13:07:01 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj1604/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=1604 题意：了解奶牛们的人都知道，奶牛喜欢成群结队．观察约翰的N(1≤N≤100000)只奶牛，你会发现她们已经结成了几个“群”．每只奶牛在吃草的时候有一个独一无二的位置坐标Xi，Yi(l≤Xi，Yi≤[1．.10^9]；Xi，Yi∈整数．当满足下列两个条件之一，两只奶牛i和j是属于同一个群的： 1．两只奶牛的曼哈顿距离不超过C(1≤C≤10^9)，即lXi - xil+IYi - Yil≤C. 2．两只奶牛有共同的邻居．即，存在一只奶牛k，使i与k，j与k均同属一个群． 给出奶牛们的位置，请计算草原上有多少个牛群，以及最大的牛群里有多少奶牛
思路：一开始并没有什么思路...入手点是关于曼哈顿距离的转化。 先看曼哈顿距离的定义
|x1−x2|+|y1−y2|
拆绝对值
x1−x2+y1−y2或x1−x2+y2−y1
x2−x1+y1−y2或x2−x1+y2−y1
即|x1+y1−(x2+y2)|或|x1−y1−(x2−y2)|
设x1+y1为x′，x1−y1为y′
则|x1′−x2′|或|y1′−y2′|
所以原要求1转化为
max(|x1′−x2′|,|y1′−y2′|)&amp;lt;=c
引用自：http://blog.csdn.net/wzq_QwQ/article/details/47746091
这样就有思路了。如果两个点属于同一个群，那么必须这两个点的x的差在c范围内，并且两个点的y的差也在范围内。 我们可以先按照一个 坐标排序，不妨以x为关键字排序，然后维护一段点的序列，使得这段序列中的所有的点的横坐标（其实就是最大减去最小）的差都在c范围内。然后对于序列中的所有点，我们想要知道有没有群“接纳”最新加入的点，二分找到比当前新加入点的纵坐标大的最小值和比当前新加入点的纵坐标小的最大值（set的lower_bound 第一次用），判断是否满足纵坐标的差在c的范围内。如果是，则用并差集合合并一下。</description></item><item><title>nthu 10925 - Advanced Heap Sort</title><link>https://111qqz.com/2016/02/nthu-10925-advanced-heap-sort/</link><pubDate>Mon, 22 Feb 2016 09:13:55 +0000</pubDate><guid>https://111qqz.com/2016/02/nthu-10925-advanced-heap-sort/</guid><description>
http://140.114.86.238/problem/10925/ Description 有兩個序列S1和S2，各有N個元素。當我們在S1,S2各取一個數字時，總共會有NN這麼多可能的”和”(sum)。請找出這NN這麼多和裡最小的N個值，並將它們加總後輸出。
Input 只有一筆測資。
測試資料第一行為一個正整數N。 第二行有N個數字，以空白隔開，代表序列S1。 第二行有N個數字，以空白隔開，代表序列S2。 數字範圍：
0 &amp;lt; N &amp;lt; 10000
Output 輸出一行，N個最小的可能的和的加總。
Sample Input 5 1 3 5 7 9 2 4 6 8 10
EOF Sample Output 27 EOF
思路：贪心。先分别升序排列，枚举第一个数组，当枚举到第i个的时候，第二个数组的int(n*1.0/i+0.5)显然都没用。
/* *********************************************** Author :111qqz Created Time :2016年02月22日 星期一 16时26分18秒 File Name :yzy.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; int a[N]; int b[N]; int ans[N]; multiset&amp;lt;int&amp;gt;se; multiset&amp;lt;int&amp;gt;::iterator it; int main() {// #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>hdu 1575 Tr A （矩阵快速幂模板题）</title><link>https://111qqz.com/2016/02/hdu1575/</link><pubDate>Sun, 21 Feb 2016 03:21:51 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1575/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1575
题意：A为一方阵，求(A^k)73得到的矩阵的主对角线的和。
思路：矩阵快速幂。模板题。
/* *********************************************** Author :111qqz Created Time :2016年02月21日 星期日 10时28分33秒 File Name :code/hdu/1575.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=12; const int MOD = 9973; struct Mat { int mat[N][N]; void clear() { ms(mat,0); } }A; int n,k; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>To do list</title><link>https://111qqz.com/2016/02/to-do-list/</link><pubDate>Sat, 20 Feb 2016 20:12:39 +0000</pubDate><guid>https://111qqz.com/2016/02/to-do-list/</guid><description>
* 《程序员的自我修养—链接、装载与库》 * 了解多线程编程的通用做法，包括如何结束一个while(true)的循环等（tbb.abort()或者发送一个特殊值等） * Kafka分布式消息队列 * 调研分布式存储系统，以及levelDB * &amp;lt;del&amp;gt;学习gRPC&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;levelDB笔记，以及protobuff笔记&amp;lt;/del&amp;gt; * cuda编程相关 * 阅读facebook开源库**faiss 源码(github)** * &amp;lt;del&amp;gt;tensorRT&amp;lt;/del&amp;gt; * 补工程知识 * **阅读caffe代码（重要）** * 补C++(cpp11)知识 * &amp;lt;del&amp;gt;了解tf record 的机制...&amp;lt;/del&amp;gt; * 突然MPI.... * &amp;lt;del&amp;gt;在inception-v3上加fine-tune&amp;lt;/del&amp;gt; * [cs 231n 2017 sp&amp;lt;del&amp;gt;ring课程&amp;lt;/del&amp;gt;](https://www.youtube.com/watch?v=OoUX-nOEjG0&amp;amp;index=2&amp;amp;list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv) * &amp;lt;del&amp;gt;搞清楚tensorflow checkpoint的四个文件都是什么&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;补完tensorflow variable 的笔记&amp;lt;/del&amp;gt; * tensorflow异步训练 * &amp;lt;del&amp;gt;光流法是什么。。&amp;lt;/del&amp;gt; * LSTM-&amp;gt;RNN-&amp;gt;CNN+RNN处理视频 * &amp;lt;del&amp;gt;TF-slim&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;cs231n，先把slide啃完(15%)&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;coursera ML (3/11)&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;leetcode 102/200&amp;lt;/del&amp;gt; * 树上莫队。。。 * &amp;lt;del&amp;gt;分块题目遇到不少lazy标记-&amp;gt;线段树&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;普通型母函数&amp;lt;/del&amp;gt; * &amp;lt;del&amp;gt;最大曼哈顿距离&amp;lt;/del&amp;gt;（拆点法） * 最小曼哈顿距离 * &amp;lt;del&amp;gt;指数型母函数（基本的做了一点.</description></item><item><title>bzoj2002: [Hnoi2010]Bounce 弹飞绵羊 (分块)</title><link>https://111qqz.com/2016/02/bzoj2002/</link><pubDate>Sat, 20 Feb 2016 18:52:55 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj2002/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=2002
题意+思路： 同codeforces 13 E holes.
/* *********************************************** Author :111qqz Created Time :2016年02月21日 星期日 02时29分39秒 File Name :code/bzoj/2002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; int siz = 450; //sqrt(2E5) int a[N]; int pos[N]; int cnt[N]; int nxt[N]; int end[N]; void go( int x) { int ans = 0 ; while (1) { if (x&amp;gt;=n) { printf(&amp;quot;%d\n&amp;quot;,ans); break; } ans +=cnt[x]; x = nxt[x]; // cout&amp;lt;&amp;lt;&amp;quot;nxt[x]:&amp;quot;&amp;lt;&amp;lt;nxt[x]&amp;lt;&amp;lt;endl; } } void update ( int i,int j) { if (j&amp;gt;=n) { cnt[i]=1; nxt[i]=n; end[i]=i; } else { if (pos[i]==pos[j]) { cnt[i] = cnt[j] + 1; nxt[i] = nxt[j]; end[i]=end[j]; } else { cnt[i] = 1; nxt[i] = j; end[i] = end[j]; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 13 E. Holes (分块)</title><link>https://111qqz.com/2016/02/cf13e/</link><pubDate>Sat, 20 Feb 2016 18:10:19 +0000</pubDate><guid>https://111qqz.com/2016/02/cf13e/</guid><description>
http://codeforces.com/problemset/problem/13/E 题意：给你n个洞，进入某个洞后会跑到另一个洞，到了另一个洞之后又可能会继续到下一个洞，问你从一个洞进去，钻了几个洞才会出来，在哪个洞出来
n 个整数a[i] 表示进入i这个洞之后会跑到 i+a[i]....
思路：分块大法好。具体见代码注释。以及。。。cin加速之后还是很慢。。。能不用就不用吧。
/* *********************************************** Author :111qqz Created Time :2016年02月20日 星期六 23时48分28秒 File Name :code/cf/problem/13E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int cnt[N];//cnt[i]表示第i个洞的球跳出所在块所需要的步数 int end[N]; //end[i]表示第i个洞的球跳出序列之前所经历的最后一个洞的序号 int jmp[N]; //jmp[i]表示第i个洞的球跳出所在的块到下一个块的洞的序号。 int a[N]; int siz = 313; //sqrt(1E5) int pos[N]; void go ( int x) { int ans = 0 ; int e; while (1) { if (x&amp;gt;n) { //cout&amp;lt;&amp;lt;e&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; printf(&amp;quot;%d %d\n&amp;quot;,e,ans); break; } ans +=cnt[x]; e = end[x]; x = jmp[x]; } // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; cnt[x] :&amp;quot;&amp;lt;&amp;lt;cnt[x]&amp;lt;&amp;lt;endl; // cout&amp;lt;&amp;lt;e&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; } void update( int i,int j) { if (j&amp;gt;n)//跳出所有洞 { cnt[i] = 1; end[i] = i; jmp[i] = n+1;//只要是一个大于n的数表示跳出就可以了 } else { if (pos[i]==pos[j]) //在同一块 { cnt[i]=cnt[j]+1; end[i]=end[j]; jmp[i]=jmp[j]; } else { cnt[i] = 1; end[i]=end[j]; jmp[i] = j; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #339 div2 D</title><link>https://111qqz.com/2016/02/cf613b/</link><pubDate>Sat, 20 Feb 2016 12:59:29 +0000</pubDate><guid>https://111qqz.com/2016/02/cf613b/</guid><description>
http://codeforces.com/contest/613/problem/B 题意：有n个技能，初始每个技能的level为a[i]，每个技能最大level为A(不妨称为满级技能)，设满级技能个数为maxnum,最小的技能level为minval,问如何将m个技能点分配到n个技能上使得cfmaxsum+cmminval (n&amp;lt;=1E5,a[i],A&amp;lt;=1E9,cf,cm&amp;lt;=1E3,m&amp;lt;=1E15)
思路：贪心。如果让有限的maxsum个技能满级的话，那么一定是让初始最大的maxsum技能满级更优。我们O(n)可以预处理一个c[i]数组，表示将i个技能变成最大值的最小花费。 然后再预处理一个前缀和数组，sum[i]表示初始最小的i个的技能的花费之和。 然后从0到n枚举变成最大值的技能的个数，在剩下的技能中二分能达到的最小值。 注意要按照原来顺序输出，所以记得记录id.
/* *********************************************** Author :111qqz Created Time :2016年02月20日 星期六 13时11分30秒 File Name :code/cf/#339/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL n,A,cf,cm,m; LL b[N]; LL c[N]; //c[i]表示将i个变为最大值需要的最少花费 LL sum[N] ; //sum[i]表示花费最少的i个的价值和 struct node { LL val; int id; bool operator &amp;lt; (node b)const { return val&amp;gt;b.</description></item><item><title>BZOJ 3289 Mato的文件管理 (莫队算法套树状数组)</title><link>https://111qqz.com/2016/02/bzoj3289/</link><pubDate>Sat, 20 Feb 2016 03:33:15 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj3289/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=3289
题意：中文题目，简单来说就是求某一区间内的逆序对数。
思路：逆序对数想到树状数组。不过写莫队转移的时候没弄明白。。。。大概是树状数组理解的还不够透彻。。。需要复习一下了。。。
还有这题没给数据范围但是需要离散化。。。不然会re...
/* *********************************************** Author :111qqz Created Time :2016年02月17日 星期三 20时18分51秒 File Name :code/bzoj/3289.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+11; int n,m; int a[N],b[N]; int pos[N]; LL c[N]; LL ans[N]; LL sum; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (pos[l]==pos[b.</description></item><item><title>前缀和问题总结</title><link>https://111qqz.com/2016/02/</link><pubDate>Fri, 19 Feb 2016 07:31:21 +0000</pubDate><guid>https://111qqz.com/2016/02/</guid><description>
There are two types of problems solvable by partial sum. 1.Problems which you are asked to answer some queries about the sum of a part of elements (without modify queries).
Solution of all of this problems are the same. You just need to know how to solve one of them.
Example : You are asked some queries on an array _a_1, _a_2, ...a, n. Each query give you numbers l and r and you should print a__l + a__l + 1 + .</description></item><item><title>hdu 5416 CRB and Tree ( 2015 多校 #10 )</title><link>https://111qqz.com/2016/02/hdu5416/</link><pubDate>Fri, 19 Feb 2016 07:05:18 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5416/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5416 题意：给出一棵树（n&amp;lt;=1E5），定义二元函数函数f(u,v) (u可以等于v)表示节点u到节点v经过的路径的权值的异或和。给出q组查询（q&amp;lt;=10），每组一个s,问有多少对无序点对（u,v）满足f(u,v)=s. 思路：类似codeforces #340 div 2 E XOR and Favorite Number 先dfs,处理出从根节点都任意节点的异或前缀和。然后对于每个询问o(n)扫一遍，统计sum[i]^s出现多少次。 总的时间复杂度为O(Tqn);
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 13时52分32秒 File Name :code/hdu/5416.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector&amp;lt;pi&amp;gt;edge[N]; int n; LL sum[N]; LL cnt[N*10]; int q; void dfs( int x,LL val) { sum[x] = val; for ( int i = 0 ; i&amp;lt; edge[x].</description></item><item><title>hdu 5327 Olympiad （2015 多校 #4 ）</title><link>https://111qqz.com/2016/02/hdu5327/</link><pubDate>Fri, 19 Feb 2016 05:35:45 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5327/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5327 题意：问给出的区间[a,b]中有多少个美丽数，美丽数的定义是所有数字都不相同，如123是，100不是，333也不是。 思路：预处理1..100000的美丽数，可以把每个数字拆开放在set里，比较set的size和位数来实现。 然后用前缀和。
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 13时25分36秒 File Name :code/hdu/5327.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a,b; int sum[N]; int p[N]; bool ok ( int x) { set&amp;lt;int&amp;gt;se; se.</description></item><item><title>zoj 3693 Happy Great BG</title><link>https://111qqz.com/2016/02/zoj3693/</link><pubDate>Thu, 18 Feb 2016 09:03:10 +0000</pubDate><guid>https://111qqz.com/2016/02/zoj3693/</guid><description>
http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3693 题意： n+2个人取吃饭，每人w元，每k个人可以少付一个人的钱，问最后两个教练每人要付多少钱。
思路：贪心。坑点在读题。。选手n个人，不要忘记两个教练，以及，钱数是两个教练平分。
/* *********************************************** Author :111qqz Created Time :2016年02月18日 星期四 15时16分59秒 File Name :code/zoj/3693.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,k; double ans,w; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>codeforces 373 C. Counting Kangaroos is Fun</title><link>https://111qqz.com/2016/02/cf373c/</link><pubDate>Thu, 18 Feb 2016 06:39:04 +0000</pubDate><guid>https://111qqz.com/2016/02/cf373c/</guid><description>
http://codeforces.com/contest/373/problem/C 题意：n个袋鼠，每个袋鼠的size为a[i],一只袋鼠的size至少是另一只两倍时才能将它装下，被装下的袋鼠不能再装别的袋鼠且不能被看见。问能看见的袋鼠最少是多少。 思路：贪心。最多有n/2个袋鼠被装下。先排序，然后贪心即可。
/* *********************************************** Author :111qqz Created Time :2016年02月18日 星期四 14时32分29秒 File Name :code/cf/problem/373C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4638 Group</title><link>https://111qqz.com/2016/02/hdu4638/</link><pubDate>Wed, 17 Feb 2016 19:39:18 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu4638/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4638 题意：给定一个序列，序列由1-N个元素全排列而成，求任意区间连续的段数。例如序列2,3,5,6,9就是三段(2, 3) (5, 6)(9)。 思路：增加一个元素，如果它两边的元素都出现了，那么段数-1（相当于把两段连接起来合并成了一段），如果两边元素都没有出现，那么段数+1.反过来，减少一个元素时，如果两边元素都出现了，俺么段数+1（相当于把完整的一段断开成两段），如果两边元素都没有出现，那么段数-1.操作可以O(1)完成。。。上莫队。 因为id大小最大才100000，所以判断某个元素是否出现开一个100000大小的布尔数组即可（我竟然傻逼得去用set....然后华丽丽得TLE了2333）
/* *********************************************** Author :111qqz Created Time :2016年02月18日 星期四 03时03分48秒 File Name :code/hdu/4638.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int pos[N]; int a[N]; int ans[N]; int sum; bool vis[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>codeforces #339 div 2 C. Peter and Snow Blower</title><link>https://111qqz.com/2016/02/cf614c/</link><pubDate>Wed, 17 Feb 2016 15:54:12 +0000</pubDate><guid>https://111qqz.com/2016/02/cf614c/</guid><description>
http://codeforces.com/contest/614/problem/C 题意：给一个多边形和多边形外一定点，多边形绕定点旋转，问多边形扫过的面积。 思路：简单计算几何，找到多边形距离定点的最大和最小距离R和r,答案就是(R^2-R^2)*PI 需要注意的是：最大距离一定是从某点上取得，但是最小距离可能不在顶点上，而在某条边上。
/* *********************************************** Author :111qqz Created Time :2016年02月16日 星期二 16时58分59秒 File Name :code/cf/problem/614C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 1E5+7; const double PI = acos(-1.</description></item><item><title>莫队算法总结</title><link>https://111qqz.com/2016/02/</link><pubDate>Wed, 17 Feb 2016 09:20:31 +0000</pubDate><guid>https://111qqz.com/2016/02/</guid><description>
写了几道莫队，总结下。 目前只会区间莫队。。树上莫队以后再补。
莫队算法学习
说说我自己的理解： 莫队算法是一类用来处理离线静态区间问题的算法。 必须是离线，而且对区间没有修改。 还要满足，如果我们知道区间[l,r]的答案，那么知道区间[l-1,r],[l+1,r],[l,r-1],[l,r+1]的答案都是平凡的。。也就是O(1)可以实现才可以。
本质的话。。感觉就是分块+暴力？ 通过离线操作，把查询按照某种顺序均分使得复杂度降低。
除了bzoj的权限题。。。区间莫队基本都A掉了。</description></item><item><title>nbut 1457 Sona</title><link>https://111qqz.com/2016/02/nbut1457/</link><pubDate>Wed, 17 Feb 2016 09:17:44 +0000</pubDate><guid>https://111qqz.com/2016/02/nbut1457/</guid><description>
https://ac.2333.moe/Problem/view.xhtml?id=1457 题意：求一段区间内数字个数的立方和。 思路：由于一共才1E5,而数字1E9,所以先离散化，再莫队，类似小z的袜子。 注意 ：%lld会WA,要用%I64d
/* *********************************************** Author :111qqz Created Time :2016年02月17日 星期三 16时11分00秒 File Name :code/nbut/1457.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N],b[N]; LL cnt[N]; int pos[N]; LL ans[N]; LL sum; int n,m; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (pos[l]==pos[b.</description></item><item><title>hdu 5145 NPY and girls</title><link>https://111qqz.com/2016/02/hdu5145/</link><pubDate>Wed, 17 Feb 2016 07:34:05 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5145/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5145 题意：有n个女孩，编号1..n,第i个女孩在第a[i]个教室,m次访问，每次访问编号[L,R]的女孩，处于同一个教室的女孩一次只能访问一个，问有多少种访问方案。两个不同的方案当且仅当访问的顺序有所不同。
思路：正好刚刚听完学堂在线上的组合数学的那一节，讲到有重复元素的不重复排列的个数的计算方法：可以先将所有元素看成不重复，再除以每个元素的重复度的阶乘（重复度定义为每个元素个数）。 增加一个元素的影响是，乘一个增加的长度，并且除以该元素的重复度（因为每增加一个元素就要除以以此重复度，那么当同一元素c增加到第i次时，除以的就是i的阶乘），减少一个元素的影响正相反。 两种改变都可以O(1)实现，因此可以上莫队。 之前要预处理下逆元。
/* *********************************************** Author :111qqz Created Time :2016年02月17日 星期三 14时20分01秒 File Name :code/hdu/5145.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; const int MOD =1E9+7; int n,m; int a[N]; int pos[N]; LL ny[N]; LL p; LL num; int ans[N]; int cnt[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>codeforces #340 div 2 E XOR and Favorite Number</title><link>https://111qqz.com/2016/02/cf617e/</link><pubDate>Mon, 15 Feb 2016 12:32:37 +0000</pubDate><guid>https://111qqz.com/2016/02/cf617e/</guid><description>
http://codeforces.com/contest/617/problem/E
题意：给出n个数，m个查询，每个查询给定l,r，问在区间【l,r】内，有多少对i,j,满足i^(i+1)^(i+2)^...^j的值为给定的常数k.
思路：学了莫队算法以后。。。这题果然是莫队的一眼题。
入手点是，知道异或也像加一样有前缀和性质。如果我们处理一个按照异或规则的前缀和数组sum[i]=sum[i-1]^a[i]，那么i到j的异或和就是sum[i-1]^sum[j] （x^x==0,因此a[1]到a[i-1]的异或和被去掉了）
因此我们要找的就是区间内有多对i,j满足sum[i-1]^sum[j]==k,也就是sum[i-1]==k^sum[j]这和hdu 5213 a=k-b有如此类似的形式，做法也是类似的。
由于对于每个j，找的是i-1,在处理的时候记得将区间左端点-1，
最重要的一点是，莫队的添加和删除操作最好分开写，至少根据d的正负写个if else,因为顺序不一定相同。 最后一个注意的是，可能会爆int ,所以要用long long
/* *********************************************** Author :111qqz Created Time :2016年02月13日 星期六 21时47分47秒 File Name :code/cf/#340/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E6+7; int n,m,k; int siz; LL a[N]; LL sum[N]; int pos[N]; LL cur; LL cnt[N]; LL ans[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>hdu 5213 lucky （莫队算法）</title><link>https://111qqz.com/2016/02/hdu5213/</link><pubDate>Mon, 15 Feb 2016 08:58:30 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5213/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5213 题意：n个数，m个查询，每个查询由4个数l1,r1,l2,r2构成，询问分别从[l1,r1]和[l2,r2]中各取一个数，和为给定的常数k的方案数。
思路：首先分别由两个区间取数不好搞，我们可以用容斥原理对区间变换。这是这道题最关键的一步。
官方题解：这道题需要一些莫队算法的知识 定义记号f(A,B)f(A,B)表示询问区间A，B时的答案 用记号＋表示集合的并 利用莫队算法我们可以计算出任意f(A,A)f(A,A)的值 不妨假设A=[l1,r1],B=[l2,r2],C=[r1+1,l2-1]A=[l1,r1],B=[l2,r2],C=[r1+1,l2−1]容易知道（并没有很容易）f(A,B)=f(A+B+C,A+B+C)+f(C,C)-f(A+C,A+C)-f(C+B,C+B)f(A,B)=f(A+B+C,A+B+C)+f(C,C)−f(A+C,A+C)−f(C+B,C+B) 因此一个询问被拆成四个可以用莫队算法做的询问 总的时间复杂度为O(msqrt(n))O(msqrt(n)) 然后就是莫队算法的内容**。值得一提的是，被拆成的四个子询问不必做四次莫队，可以合在一起，因为每一次询问对答案的贡献都不会受顺序影响，而且这样用时更短。**
然后初始构造的时候用构造函数比赋值要方便许多。
还要记得多组数据记得清空各种数组。。。（因为忘记清空ans数组wa到死。。。）
最最关键的是，对于求两个数a+b==k这类问题（不一定是加，就是和两个数满足一个关系的时候），我们可以转换思维。a==k-b.也就是统计的时候是cnt[b]++,更新答案的时候，由于现在是b,我需要找有多少个a，也就是多少个k-b,所以是ans+=cnt[k-b];（要注意保证k-b&amp;gt;0) /* *********************************************** Author :111qqz Created Time :2016年02月14日 星期日 09时50分10秒 File Name :code/hdu/5213.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=6E4+7; int a[N]; int n,k; int m; int sum; int ans[N]; int pos[N]; int cnt[N]; struct node { int l,r; int add; int id; node(){} node(int a,int b,int c,int d){l=a,r=b,add=c,id = d;} bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>codeforces 220 B. Little Elephant and Array</title><link>https://111qqz.com/2016/02/codeforces-220-b-little-elephant-and-array/</link><pubDate>Sat, 13 Feb 2016 17:27:22 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-220-b-little-elephant-and-array/</guid><description>
http://codeforces.com/contest/220/problem/B
题意：n个数，m个查询区间，对于每一个区间[l,r]输出区间中cnt[x]==x的数的个数。 思路：首先，a[i]很大。。。但是n最大才1e5...每个a[i]最多出现1E5次。。所以对于大于1E5的a[i]对答案没有贡献。其次，上莫队算法。
/* *********************************************** Author :111qqz Created Time :2016年02月14日 星期日 00时47分18秒 File Name :code/cf/problem/220B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int a[N]; int pos[N]; int sum; int ans[N]; int cnt[N]; struct node { int l,r; int id; bool operator&amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>codeforces 86 D. Powerful array （莫队算法）</title><link>https://111qqz.com/2016/02/cf86d/</link><pubDate>Sat, 13 Feb 2016 15:59:22 +0000</pubDate><guid>https://111qqz.com/2016/02/cf86d/</guid><description>
http://codeforces.com/problemset/problem/86/D 题意：Ks为区间内s的数目，求区间[L,R]之间所有KsKss的和 思路：莫队算法，和小z的袜子差不多。不明白第一次tle#54是什么情况。把每一块的大小改成了常数之后就过了。 再交一遍就过了。。不过貌似根据最大数据把siz大小设置成一个常数比根号n要块很多==
/* *********************************************** Author :111qqz Created Time :2016年02月13日 星期六 23时17分58秒 File Name :code/cf/problem/86D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int t,n; int a[N]; int pos[N]; LL sum; LL ans[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>（莫队算法的学习）bzoj 2038 [2009国家集训队]小Z的袜子(hose)</title><link>https://111qqz.com/2016/02/bzoj-2038/</link><pubDate>Wed, 10 Feb 2016 08:51:04 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj-2038/</guid><description>
2038: [2009国家集训队]小Z的袜子(hose)
Time Limit: 20 Sec Memory Limit: 259 MB Submit: 5327 Solved: 2461 [Submit][Status][Discuss] Description
作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。
Input
输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。
Output
包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）
Sample Input
6 4
1 2 3 3 3 2
2 6
1 3
3 5
1 6
Sample Output
2/5
0/1
1/1
4/15
【样例解释】
询问1：共C(5,2)=10种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为(1+3)/10=4/10=2/5。
询问2：共C(3,2)=3种可能，无法抽到颜色相同的袜子，概率为0/3=0/1。
询问3：共C(3,2)=3种可能，均为抽出两个3，概率为3/3=1/1。
注：上述C(a, b)表示组合数，组合数C(a, b)等价于在a个不同的物品中选取b个的选取方案数。
【数据规模和约定】
30%的数据中 N,M ≤ 5000；
60%的数据中 N,M ≤ 25000；
100%的数据中 N,M ≤ 50000，1 ≤ L &amp;lt; R ≤ N，Ci ≤ N。</description></item><item><title>codeforces #342 div 2 D. Finals in arithmetic</title><link>https://111qqz.com/2016/02/cf625d/</link><pubDate>Mon, 08 Feb 2016 12:28:22 +0000</pubDate><guid>https://111qqz.com/2016/02/cf625d/</guid><description>
http://codeforces.com/contest/625/problem/D 题意：问能否找到一个s,满足s+s的反转=k 思路：如果是回文数。。。那么显然满足。除以2就可以得到答案。 如果不是回文数。。那么考虑进位的情况。 要么从后一位进1，要么从前一位退10回来。 需要特殊考虑1开头的。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 18时28分39秒 File Name :code/cf/#342/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;sstream&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; bool vis[N]; void pre() { ms(vis,false); for ( int i = 10 ; i &amp;lt;12000 ; i++) { int vala = i ; stringstream ss; ss&amp;lt;&amp;lt;vala; string tmp = ss.</description></item><item><title>codeforces #341 div 2 E. Wet Shark and Blocks (数位dp+矩阵加速)</title><link>https://111qqz.com/2016/02/cf621e/</link><pubDate>Mon, 08 Feb 2016 09:04:41 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621e/</guid><description>
http://codeforces.com/problemset/problem/621/E 题意：有b组数，每组数均有n个且相同。你必须在每组选一个数，组成一个新数sum，使得sum % x == k，问方案数 % (1e9+7)。
思路：数位dp.首先考虑b不是很大的一般情况。dp[i][j]表示处理到前i个块的时候结果为j的方案数。那么转移方程就是：**dp[i][(j_10+t)%x] = dp[i-1][j]_cnt[t] ** cnt[i]表示数字i出现的个数。
但是由于b很大（1E9）,所以需要用矩阵加速。
/* *********************************************** Author :111qqz Created Time :2016年02月08日 星期一 16时24分34秒 File Name :code/cf/#341/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD=1E9+7; int n,b,k,X; struct Matrix { LL a[110][110]; }; void add(LL &amp;amp;x,LL y) { x += y; x %= MOD; } Matrix multi(Matrix x,Matrix y ) //矩阵乘法。 { Matrix z; ms(z.</description></item><item><title>codeforces #341 div 2 D. Rat Kwesh and Cheese</title><link>https://111qqz.com/2016/02/cf621d/</link><pubDate>Sun, 07 Feb 2016 20:44:27 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621d/</guid><description>
http://codeforces.com/contest/621/problem/D 题意：给出12个式子，问哪个最大。 思路：主要记住两个。一个是比较指数形式的数一个常用办法是取对数，同时要考虑是否能取对数，分情况讨论对于不能取对数的情况经过变换去取对数。第二个是取了两次对数后比较时候的最大值可能是小于0的。所以初始时置于0不够小。官方题解说得很清楚。
The tricky Rat Kwesh has finally made an appearance; it is time to prepare for some tricks. But truly, we didn't expect it to be so hard for competitors though. Especially the part about taking log of a negative number. We need a way to deal with x__y__z and x__yz. We cannot directly compare them, 200200200 is way too big. So what we do? Take log! is an increasing function on positive numbers (we can see this by taking , then , which is positive when we are dealing with positive numbers).</description></item><item><title>codeforces #342 div 2 C. K-special Tables</title><link>https://111qqz.com/2016/02/cf625c/</link><pubDate>Sun, 07 Feb 2016 11:32:04 +0000</pubDate><guid>https://111qqz.com/2016/02/cf625c/</guid><description>
http://codeforces.com/contest/625/problem/C 题意：构造一个矩阵。。满足三个条件。。。 思路：简单构造。。。看代码把。。。。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 17时49分15秒 File Name :code/cf/#342/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; int n; int k; int ans[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #342 div 2 B. War of the Corporations</title><link>https://111qqz.com/2016/02/cf625b/</link><pubDate>Sun, 07 Feb 2016 11:27:57 +0000</pubDate><guid>https://111qqz.com/2016/02/cf625b/</guid><description>
http://codeforces.com/contest/625/problem/B 题意：给出两个字符串，问要替换掉多少个字符才能使得前者中不包含后者。 思路：直接搞...找到一个把收尾替换成‘#’,然后下次从该位置继续开始找，直到找不到。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 17时31分33秒 File Name :code/cf/#342/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string ori,tar; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #342 div 2 A. Guest From the Past</title><link>https://111qqz.com/2016/02/codeforces-342-div-2-a-guest-from-the-past/</link><pubDate>Sun, 07 Feb 2016 11:24:07 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-342-div-2-a-guest-from-the-past/</guid><description>
http://codeforces.com/contest/625/problem/A 题意：有n块钱，塑料瓶饮料a元一瓶，玻璃瓶饮料b元一瓶，退还玻璃瓶可以得到c元。问最多能买多少瓶饮料。 思路：贪心。如果塑料瓶比玻璃瓶的实际价格便宜，那么一定买塑料瓶的，否则先买玻璃瓶，再用塑料瓶填。注意一些边界的判断。。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 17时02分32秒 File Name :code/cf/#342/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,c,n; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces 148 D. Bag of mice</title><link>https://111qqz.com/2016/02/cf148d/</link><pubDate>Wed, 03 Feb 2016 19:34:38 +0000</pubDate><guid>https://111qqz.com/2016/02/cf148d/</guid><description>
http://codeforces.com/problemset/problem/148/D 题意：盒子里有w只白老鼠，b只黑老鼠，公主和魔王轮流取（公主先），先取到白老鼠的人获胜。魔王每次取完以后，盒子中的老鼠会因为吓尿了跑掉一只，跑掉的老鼠不算任何人取的。问公主获胜的概率。
思路：概率dp.. dp[i][j]表示有i只白老鼠，j只黑老鼠的时候公主获胜的概率。 转移方程 1. 公主抽到白老鼠（之后龙不必再抽） 胜率为i/(i+j)*1 2. 公主抽到黑老鼠，龙抽到黑老鼠，跳出一只黑老鼠，胜率为j/(i+j) * (j-1)/(i+j-1) * (j-2)/(i+j-2) * f[i][j-3] (j&amp;gt;=3) 3. 公主抽到黑老鼠，龙抽到黑老鼠，跳出一只白老鼠，胜率为j/(i+j) * (j-1)/(i+j-1) * (i/(i+j-2) * f[i-1][j-2] (j&amp;gt;=2) 4. 龙抽到白老鼠，胜率为0 /* *********************************************** Author :111qqz Created Time :2016年02月04日 星期四 02时44分23秒 File Name :code/cf/problem/148D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int w,b; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 107 B. Basketball Team</title><link>https://111qqz.com/2016/02/codeforces-107-b-basketball-team/</link><pubDate>Wed, 03 Feb 2016 10:43:16 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-107-b-basketball-team/</guid><description>
http://codeforces.com/problemset/problem/107/B
题意：有m个部门，每个部分s[i]个人，HW在第h部门，现在要从这m个部门中挑选包括HW在内的n个人去参加比赛，问被挑选的人中有HW的队友（同部门的人）的概率是多少。如果m个部分的人数不够组成n人的球队，输出-1. 思路：考虑一般情况。至少有一个队友的情况较多，应该从反面考虑，即没有一个队友的情况。选完HW以后面临的状态是：事件总数为从total(m个部门的人员之和)-1个人中选n-1个的方案数，包含的事件数目为从a(a=total-s[h])中选n-1个人包含的方案数。 可以看出分母相同，可以约掉。 然后对于边界情况，首先判断total是否比n小。然后，如果a&amp;lt;n-1,表示除去HW所在的h部分之外的人不可能组成n-1个人，也就是一定要选择HW的队友，概率为1.
/* *********************************************** Author :111qqz Created Time :2016年02月03日 星期三 17时56分30秒 File Name :code/cf/problem/107B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int M=1E3+7; int n ,m,h; int s[M]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 518 D. Ilya and Escalator</title><link>https://111qqz.com/2016/02/cf518/</link><pubDate>Tue, 02 Feb 2016 08:20:47 +0000</pubDate><guid>https://111qqz.com/2016/02/cf518/</guid><description>
http://codeforces.com/problemset/problem/518/D
题意：有n个人排队上一个电梯。。。在某一秒内，队首的人有p的概率上电梯，1-p的概率不动。每个人只有在队首的位置才可以上电梯（也就是每一秒内，最多只有一个人可以上电梯）。电梯无线长（也就是上了电梯就不会离开了），问在第t秒的时候，电梯上的人的个数的数学期望是多少。 思路：一开始推公式的我还是图样。这题是dp.其实也不难想。dp[i][j]表示第i秒时电梯上有j个人的概率。 当j==n的时候，也就是所以人都上了电梯以后。dp[i+1][j]+=dp[i][j],对于其他时刻 dp[i+1][j+1]+=dp[i][j]p,dp[i+1][j]+=dp[i][j](1-p). 初始化dp[0][0]=1,即0时刻电梯上有0个人的概率为1. /* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 15时57分06秒 File Name :code/cf/518D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,t; double p; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 312 B. Archer</title><link>https://111qqz.com/2016/02/cf312b/</link><pubDate>Tue, 02 Feb 2016 06:30:03 +0000</pubDate><guid>https://111qqz.com/2016/02/cf312b/</guid><description>
http://codeforces.com/problemset/problem/312/B 题意：两个人比赛射箭，先射的人射中的概率是a/b,后射的人射中的概率是c/d,问先射的人赢的概率。 思路：应该叫条件概率。。。？ 不过我们可以用古典概型的思维想。每射一次看成一个点，射中的点用白色表示，没有射中的用黑色表示。如果两个人第i次都没有射中，那么就要继续第i+1 轮，而第i+1轮和之前的每一轮是独立的。等于重复这个过程。所以古典概型的样本总量应该减去宝石两个人都没有射中的点的个数，为bd-(b-a)(d-c)，整理为bc+ad-a*c，设为n.要想第一个人赢，那么对于某一次，只要不是第一个人没射中，第二个人射中这种情况，就都是第一个人赢。而第一个人没射中的事件数为b-a,第二个人射中的事件数为c,总数为（b-a）*c，所以答案为(n-(b-a)*c)/n
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 15时57分06秒 File Name :code/cf/518D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,t; double p; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 453 A. Little Pony and Expected Maximum</title><link>https://111qqz.com/2016/02/cf543a/</link><pubDate>Mon, 01 Feb 2016 21:50:39 +0000</pubDate><guid>https://111qqz.com/2016/02/cf543a/</guid><description>
http://codeforces.com/problemset/problem/453/A 题意：m面筛子，每面点数出现的概率相同，连续投掷n次，问出现的最大值的数学期望。 思路：手写样例。。。发现答案为 。。。记得把（1/m）^n放进去。
观察答案，可以这样理解（我是用样例推出公式后理解。。。数学差的人心好累）：如果i为最大值，那么n次每次必须投掷出1..i的点数，概率为 (i/m)^n,但是要至少有一个投掷成i，也就是要减去所有的数都是1..i-1中的情况（概率 为((i-1)/m)^n），
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 05时17分24秒 File Name :code/cf/problem/453A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; double ans; int n ,m; double p1[N],p2[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 476 B. Dreamoon and WiFi</title><link>https://111qqz.com/2016/02/cf476b/</link><pubDate>Mon, 01 Feb 2016 20:07:58 +0000</pubDate><guid>https://111qqz.com/2016/02/cf476b/</guid><description>
http://codeforces.com/problemset/problem/476/B 题意：给出两个长度相等-且不超过10的字符串，串1只包含‘-’,'+‘。按照‘+’为1，‘-’为-1累加可以得到一个值。串2还包含若干‘？’，代表该处的值不确定，且为'+'和'-'的概率相等，都是0.5.问串2的值和串1相等的概率。 思路：我们可以扫一遍得到‘？’的个数和两个式子的差值。设问号个数为a,差值为b，那么在a个问号中需要有(a-b)/2个为‘+’（容易知道，a,b一定奇偶性相同，所以a-b一定能被2整除），根据超几何分布，概率为 c[a][(a-b)/2]*(1/2)^a; 写的时候可以先打个组合数的表。1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 03时32分39秒 File Name :code/cf/problem/476B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string s1,s2; int len; int c[20][20]; void pre() { ms(c,0); c[1][1] = 1; c[1][2] = 1; c[2][1] = 1; c[2][2] = 2; c[2][3] = 1; for ( int i =3 ; i &amp;lt;=15 ; i++) for ( int j = 0 ; j &amp;lt;= i ; j++) c[i][j+1] = c[i-1][j+1]+c[i-1][j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #341 div2 A. Die Roll</title><link>https://111qqz.com/2016/02/cf621a/</link><pubDate>Mon, 01 Feb 2016 12:56:14 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621a/</guid><description>
http://codeforces.com/contest/621/problem/A
A. Wet Shark and Odd and Even
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Today, Wet Shark is given n integers. Using any of these integers no more than once, Wet Shark wants to get maximum possible even (divisible by 2) sum. Please, calculate this value for Wet Shark.
Note, that if Wet Shark uses no integers from the n integers, the sum is an even integer 0.</description></item><item><title>codeforces #341 div 2 B. Wet Shark and Bishops</title><link>https://111qqz.com/2016/02/cf621b/</link><pubDate>Mon, 01 Feb 2016 12:53:03 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621b/</guid><description>
http://codeforces.com/contest/621/problem/B
B. Wet Shark and Bishops
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Today, Wet Shark is given n bishops on a 1000 by 1000 grid. Both rows and columns of the grid are numbered from 1 to 1000. Rows are numbered from top to bottom, while columns are numbered from left to right.
Wet Shark thinks that two bishops attack each other if they share the same diagonal.</description></item><item><title>codeforces #341 div2 C. Wet Shark and Flowers</title><link>https://111qqz.com/2016/02/cf341/</link><pubDate>Mon, 01 Feb 2016 11:55:49 +0000</pubDate><guid>https://111qqz.com/2016/02/cf341/</guid><description>
http://codeforces.com/contest/621/problem/C
C. Wet Shark and Flowers
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
There are n sharks who grow flowers for Wet Shark. They are all sitting around the table, such that sharks i and i + 1 are neighbours for all i from 1 to n - 1. Sharks n and 1 are neighbours too.
Each shark will grow some number of flowers s__i.</description></item><item><title>uva 10916 Factstone Benchmark</title><link>https://111qqz.com/2016/01/uva10916/</link><pubDate>Fri, 29 Jan 2016 12:53:01 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10916/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1857 题意：计算最大的n,满足n!/* *********************************************** Author :111qqz Created Time :2016年01月29日 星期五 19时49分25秒 File Name :code/uva/10916.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair
using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=150; int n; int f[N]; void pre() { f[0] = 3; int per = 2; for ( int i = 1 ; i &amp;lt;=25 ; i++) { f[i]=f[i-1]+per; per++; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 107 The Cat in the Hat</title><link>https://111qqz.com/2016/01/uva107/</link><pubDate>Thu, 28 Jan 2016 13:09:11 +0000</pubDate><guid>https://111qqz.com/2016/01/uva107/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=43 题意：其实就是给了两个式子。。。(N+1)^h=a,N^h=b,a,b已知，然后求关于N的两个式子.。。 思路：数学上这个方程貌似不可解。。？ 所以只能枚举一下==。。。注意精度问题把。。。
然后用换底公式求对数的时候要向上取整。
还有b为1的时候是特殊数据。
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 16时46分38秒 File Name :code/uva/107.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-12; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 846 Steps</title><link>https://111qqz.com/2016/01/uva846/</link><pubDate>Thu, 28 Jan 2016 13:03:14 +0000</pubDate><guid>https://111qqz.com/2016/01/uva846/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=787
题意：从x增加到y，第一步和最后一步步长只能是1，其他步一定可以是上一步减一，和上一步相等，或者上一步步长加一，三种情况，且步长恒为正。问从x到y最少需要的步数。
思路：首先可以知道，走的最快的方法是1+2+3+...+k+...+3+2+1.这个式子的结果是一个完全平方数，为k^2，式子的长度为2*k-1.即为答案。 我们可以知道k肯定不超过 ceil(sqrt(y-x)).但是中间的k是不一定要加的。再判断k^2减去k是否已经达到结果，如果是，就将答案减一。 注意对于这种做法x=y是特殊情况。。需要特判。。。。
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 19时57分44秒 File Name :code/uva/846.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int x,y; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10025 The ? 1 ? 2 ? ... ? n = k problem</title><link>https://111qqz.com/2016/01/uva-10025/</link><pubDate>Thu, 28 Jan 2016 13:02:48 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-10025/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=966 题意：?1?2?3?4...?n=k,把每个?替换成+或者-，找到最小的n使得式子成立。 题意：这道题最关键的一点是。如果s1=1+2+3+.,x+..+n&amp;gt;=k (所有数取正数）,那么一定有s2=1+2+3+..-x+..+n=k
非严格证明如下：
s1-s2 = 2x,s1-k=2x
一个数减去偶数，奇偶性不变。x是从1到n中的一个，2*x则包含了s1和s2相差的数所有可能性。
具体做法就是找到一个大于等于k的s1,且s1-k是偶数。
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 13时58分24秒 File Name :code/uva/10025.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int k; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 113 Power of Cryptography</title><link>https://111qqz.com/2016/01/uva113/</link><pubDate>Wed, 27 Jan 2016 19:16:01 +0000</pubDate><guid>https://111qqz.com/2016/01/uva113/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=49 题意：求p开n次方。保证结果为整数。 思路：p最大10的101次方。。。double最大10的308次方。。因为肯定是整数。。不存在精度问题。。所以可以用douible水过QAQ...
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 03时07分01秒 File Name :code/uva/113.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double n,p; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10785 The Mad Numerologist</title><link>https://111qqz.com/2016/01/uva10785/</link><pubDate>Wed, 27 Jan 2016 14:13:44 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10785/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1726 题意：给出26个大写字母的权值，要求构造一个长度为n（n不超过210）的字符串。并且满足奇数位置只能放元音字母，偶数位置只能放辅音字母，且每个元音字母最多放21次，每个辅音字母最多放5次，要求构造的字符串的权值之和最小，在权值最小的前提下字典序最小。
思路：贪心。一开始错误得以为不是完整得不能交换（也就是不完整的字母只能放在最后，这是错误的）。但实际上只要每个字母的数量不变，那么就不影响权值。所以做法是，奇数位置偶数位置分别搞，先把构成字符串的字母按次存入，然后排序一下，输出即可。
/* *********************************************** Author :111qqz Created Time :2016年01月26日 星期二 15时10分28秒 File Name :code/uva/10785.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char a[30],b[30]; char oddans[210],evenans[210]; int n; void pre() { a[1]='A'; a[2]='U'; a[3]='E'; a[4]='O'; a[5]='I'; b[1]='J'; b[2]='S'; b[3]='B'; b[4]='K'; b[5]='T'; b[6]='C'; b[7]='L'; b[8]='D'; b[9]='M'; b[10]='V'; b[11]='N'; b[12]='W'; b[13]='F'; b[14]='X'; b[15]='G'; b[16]='P'; b[17]='Y'; b[18]='H'; b[19]='Q'; b[20]='Z'; b[21]='R'; } void solve () { int odd = (n+1)/2; int even = n/2; int vowa = odd/21; int vowr = odd; int cona = even/5; int conr = even%5; int cnt = 0 ; for ( int i = 1 ; i &amp;lt;= vowa ; i++) { for ( int j =1 ; j &amp;lt;=21 ; j++) { cnt++; oddans[cnt] = a[i]; } } for ( int i = 1 ; i &amp;lt;=vowr ; i++) { cnt++; oddans[cnt]=a[vowa+1]; } cnt = 0 ; for ( int i = 1 ; i &amp;lt;= cona ; i++) { for ( int j = 1 ; j &amp;lt;= 5 ; j++) { cnt++; evenans[cnt]=b[i]; } } for ( int i = 1 ; i &amp;lt;=conr ; i++) { cnt++; evenans[cnt]=b[cona+1]; } sort(oddans+1,oddans+odd+1); sort(evenans+1,evenans+even+1); for ( int i = 1 ;i &amp;lt;= n ; i++) { if (i%2==1) { printf(&amp;quot;%c&amp;quot;,oddans[i/2+1]); } else { printf(&amp;quot;%c&amp;quot;,evenans[i/2]); } } puts(&amp;quot;&amp;quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10194 Football (aka Soccer)</title><link>https://111qqz.com/2016/01/uva10194/</link><pubDate>Wed, 27 Jan 2016 11:57:42 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10194/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1135 题意：给出球队的名字和比赛的信息，得出stanging 思路：字符串处理。需要注意的是多组数据记得初始化多次，以及比较字典序的时候team name是大小写补敏感的。
/* *********************************************** Author :111qqz Created Time :2016年01月26日 星期二 15时47分36秒 File Name :code/uva/10194.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+5; string game[N]; map&amp;lt;string,int&amp;gt;TeamToId; struct Team { string nam; string lowname; int a,b,c,d,e,f,g,h,i; bool operator&amp;lt;(Team p)const { if (b&amp;gt;p.</description></item><item><title>uva 156 - Ananagrams</title><link>https://111qqz.com/2016/01/uva156/</link><pubDate>Mon, 25 Jan 2016 09:19:56 +0000</pubDate><guid>https://111qqz.com/2016/01/uva156/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=92 题意：给出一段文字，包含若干个单词，以'#'结束。按照字典序输出所有的ananagrams。所谓ananagram，是指经过任意的重排后，不能得到这段文字中的另一个单词（不区分大小写） 思路：首先是字符串的读入...可以整行读入然后用空格分隔单词。由于补区分大小写，所以要都转化成小写...但是输出的时候要输出原始，所以还记得保留一份。而且要能够通过新的找到原始的（我用了一个toori的map&amp;lt;string,string&amp;gt;来实现） 然后最关键的部分是如何判断两个单词经过重排是否能一样...
我的做法是构造一个hash函数...一个单词的hash值等于对应字母的顺序的平方和...效果还不错？
单词和hash值一一对应...最大也就9E5,可以存的下。然后统计每个hash值出现的次数。对于那些只出现一次的，就是我们要的答案。
还要注意的是输出要按照原始单词的字典序，而不是都变成小写以后的字典序。
所以找到之后可以先找到对应的原始单词存到set里，最后再输出。
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 14时26分38秒 File Name :code/uva/156.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=9E5+7; string str; int a[N]; map&amp;lt;string,int&amp;gt;mp; map&amp;lt;string,int&amp;gt;::iterator it; map&amp;lt;string,string&amp;gt;toori; struct node { string ori; string nw; }st[1005]; set&amp;lt;string&amp;gt;ans; set&amp;lt;string&amp;gt;::iterator it2; int main() { mp.</description></item><item><title>uva 120 Stacks of Flapjacks</title><link>https://111qqz.com/2016/01/uva120/</link><pubDate>Mon, 25 Jan 2016 06:09:57 +0000</pubDate><guid>https://111qqz.com/2016/01/uva120/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=56
题意：给出一个长度为n的序列（无重复元素），询问经过多少次flip(i)操作，使得序列升序排列。定义flip(i)为将1到n-i+1的元素反转... 思路：先离散化，然后注意读入....
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 10时42分46秒 File Name :code/uva/120.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; string in; struct node { int value; int id; }q[N]; int pos[N]; bool cmp1(node a,node b) { return a.</description></item><item><title>uva 409 - Excuses, Excuses!</title><link>https://111qqz.com/2016/01/uva409/</link><pubDate>Sun, 24 Jan 2016 12:14:35 +0000</pubDate><guid>https://111qqz.com/2016/01/uva409/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=350 题意：给出k个key word,e个借口...找出包含key word最多的借口，即为最坏的借口。匹配补区分大小写&amp;amp;&amp;amp;同一个key word算多次。 思路：需要注意的是因为不区分大小写，需要都转化成大写或者小写。。但是输出的时候要输出原始的。。所以要另外存一份。
/* *********************************************** Author :111qqz Created Time :2016年01月22日 星期五 17时58分02秒 File Name :code/uva/409.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string str[50]; int k,e; int num[50]; set&amp;lt;string&amp;gt;se; struct node { string exc; string ori; int num; bool operator&amp;lt;(node b)const { return num&amp;gt;b.</description></item><item><title>hdu 5610 ||BC #69 div2 1001 Baby Ming and Weight lifting</title><link>https://111qqz.com/2016/01/hdu5610/</link><pubDate>Sat, 23 Jan 2016 14:51:03 +0000</pubDate><guid>https://111qqz.com/2016/01/hdu5610/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5610 题意：有重量为a,b两种铁圈每种无限多个...能能否组成一个重量为c且平衡杠铃（中间的杆的重量忽略不计） a,b,c都是整数。 思路：平衡的话。。就是两边重量一样。。那么c为奇数的时候显然不行。 由于有多组答案的时候输出铁圈数之和小的。。。那么我们枚举的话。应该把里面那层枚举的变量放置成重量较大的。。。。
/* *********************************************** Author :111qqz Created Time :2016年01月23日 星期六 18时56分38秒 File Name :code/bc/#69/1001.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b,c; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5611 || BC #69 div2 1002 Baby Ming and phone number</title><link>https://111qqz.com/2016/01/hdu5611/</link><pubDate>Sat, 23 Jan 2016 14:43:26 +0000</pubDate><guid>https://111qqz.com/2016/01/hdu5611/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5611 题意：给出n个电话号码（长度为11的字符串），满足特殊条件的价格为a，否则为b.特殊条件为最后5位数字一样，最后5位严格递增或者严格递减，最后8位是一个1980年1月一日到2016年12月31日的合法日期。问最后的价值。
思路：直接搞....结果死在cin了。。。原来3E6的cin就会TLE。。。。。q神说1E5有的也会tle.....
所以方案是，能不用cin就不要用cin...
如果要读string的话。。。一个解决办法是把数据流同步关掉（是叫这个名字吗。。）
std::ios::sync_with_stdio(false); 会快很多。。。
还有一个办法是先用scanf读 char[] 然后再转化？ 没试过== 哦哦还要注意要判闰年。 还有要开long long
/* *********************************************** Author :111qqz Created Time :2016年01月23日 星期六 18时58分10秒 File Name :code/bc/#69/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; string str; LL a,b; bool good1(string x) { int len = x.</description></item><item><title>uva 537 Artificial Intelligence?</title><link>https://111qqz.com/2016/01/uva537/</link><pubDate>Fri, 22 Jan 2016 07:14:34 +0000</pubDate><guid>https://111qqz.com/2016/01/uva537/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=478 题意：给出一段文字。。其中包含了 P,U,I（功率，电压，电流）中的两个。。求第三个。 思路：字符串处理。。第一次用vim复制整段代码。。命令模式下按v,然后光标扫过的区域都会选中，按y就就复制到剪贴板了。。 所以虽然代码写了300行但只有100行是需要写的。。200行复制改下就好== WA了两次。。一次是因为I写成了小写。。另一次是因为多组数据记得初始化多次。
/* *********************************************** Author :111qqz Created Time :2016年01月22日 星期五 03时25分16秒 File Name :code/uva/537.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string str; char cstr[20]; double i,p,u; int pu,pp; int pi; int pv,pw,pa; int beishu; string tmp; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10010 - Where's Waldorf?</title><link>https://111qqz.com/2016/01/uva-10010-wheres-waldorf/</link><pubDate>Thu, 21 Jan 2016 17:24:34 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-10010-wheres-waldorf/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=951 题意：给出一个由大小写字母组成的二维maze...给出k个询问。每个询问一个单词。问能否在maze中找到这个单词。不区分大小写。输出开头字母的坐标（从1开始）。如果有多组输出最上面的。如果还有多组，输出最左边的。数据保证至少有一组。 思路：直接找就好了。。。坑的地方是。。。格式。。数据组数之后会有一个空行。然后每两组读入数据之间会有一个空行。。输出的时候每两组数据之间也有一个空行。
我因为一直多输出了一个空行一直wa QAQ
=
/* *********************************************** Author :111qqz Created Time :2016年01月21日 星期四 14时52分51秒 File Name :code/uva/10010.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=80; int n,m; char maze[N][N]; string spa; int k; char target[100]; char nouse[55]; bool hang( int x,int y,char tar[]) { int len = strlen(tar); // cout&amp;lt;&amp;lt;&amp;quot;tar:&amp;quot;&amp;lt;&amp;lt;tar&amp;lt;&amp;lt;endl; if (y+len-1&amp;gt;=m) return false; int cnt = 0 ; for ( int j = y ; j &amp;lt; y+len; j++) { if (maze[x][j]!</description></item><item><title>uva 152 Tree's a Crowd</title><link>https://111qqz.com/2016/01/uva152/</link><pubDate>Thu, 21 Jan 2016 06:33:22 +0000</pubDate><guid>https://111qqz.com/2016/01/uva152/</guid><description>
题意：题意：给你一组三维空间中的点，每个点到其它点都有个距离，其中有个最小距离，如果这个最小距离小于10，就将对应的距离的点个数加１，最后输出距离为0,1,2...8,9的点的个数。（from 百度） 老实说，上面这题意也讲的不明不白，其实这题非常水，就是对每个点进行判断，找出和其他点最短的距离，在下标为该距离的数组上+1,最后输出数组下标0-9的数。 trick：其实最小距离大于9的就不用存放了，只要开个大小10的数组。（不会概括。。。抄的别人的）
好坑啊。。。最后要多一个换行。。不然会WA...题目中又木有说。。。WA到死了好么。。。。
/* *********************************************** Author :111qqz Created Time :2016年01月21日 星期四 00时08分50秒 File Name :uva/152.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;cassert&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E3+11; int n; int cnt; int ans[30]; int dblcmp( double d) { return d&amp;lt;-eps?</description></item><item><title>uva 401 Palindromes</title><link>https://111qqz.com/2016/01/uva-401-palindromes/</link><pubDate>Wed, 20 Jan 2016 15:53:21 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-401-palindromes/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=96&amp;amp;page=show_problem&amp;amp;problem=342 题意：问一个字符串是不是回文串，是不是镜像串。镜像串的意思是。。从镜子里看还一样。。给定了一些存在镜像的字母和数字。。 思路：回文串的判断用c++的string要更容易一些。。直接reverse一下。。判断是否相等就行。。。然后需要注意的是。。如果某个字符补存在镜像那么一定不是镜像串
如果某个字符不存在镜像那么一定不是镜像串！
如果某个字符不存在镜像那么一定不是镜像串！
蠢哭惹好么。。。。
* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 16时00分57秒 File Name :code/uva/401.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string a,b; char tmp[1000005]; map&amp;lt;char,char&amp;gt;mp; void init() { mp.</description></item><item><title>uva 10420 - List of Conquests</title><link>https://111qqz.com/2016/01/uva10420/</link><pubDate>Wed, 20 Jan 2016 11:47:32 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10420/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1361 题意：给n个带空格的字符串，第一个单词是国家，统计每个国家的字符串的个数。 思路：getline函数。。。find函数。。。substr函数。。。map.....
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 19时26分09秒 File Name :code/uva/10420.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string str; int len; map&amp;lt;string,int&amp;gt;mp; map&amp;lt;string,int&amp;gt;::iterator it; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>NYOJ 505 因子和阶乘</title><link>https://111qqz.com/2016/01/nyoj-505-/</link><pubDate>Wed, 20 Jan 2016 07:08:01 +0000</pubDate><guid>https://111qqz.com/2016/01/nyoj-505-/</guid><description>
http://acm.nyist.net/JudgeOnline/problem.php?pid=509 题意：中文题目。。。 思路：快速筛即可。。。妈蛋。。。这个oj不能用宏编译==。。。然后一直TLE...去掉了就好了。。sad
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 13时53分54秒 File Name :code/nyoj/509.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=10500; int n; int pri[N]={0}; int npri[N]={1,1}; int num[N]; int cnt; void pre() { cnt = 0 ; for ( int i = 2 ; i &amp;lt; N ; i++) { if (!</description></item><item><title>poj 1350 Cabric Number Problem</title><link>https://111qqz.com/2016/01/poj1350/</link><pubDate>Wed, 20 Jan 2016 05:29:46 +0000</pubDate><guid>https://111qqz.com/2016/01/poj1350/</guid><description>
http://poj.org/problem?id=1350
题意：6174问题。。。一个四位数。。四个数字重排。。。最大的减去最小的得到新的数字。最后一定能得到6174或者0.除非这个四位数的四个数字都一样。写出变化的过程。
思路：。。。可能不是不四位数。。略坑。然后写了下字符串和数字相互转化的两个函数。嗯。
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 12时51分41秒 File Name :code/poj/1350.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int cnt; int get_next( int x) { int a,b,len; char st[10]; sprintf(st,&amp;quot;%d&amp;quot;,x); len = strlen(st); // if (len&amp;lt;4) return -1; if (st[0]==st[1]&amp;amp;&amp;amp;st[1]==st[2]&amp;amp;&amp;amp;st[2]==st[3]&amp;amp;&amp;amp;st[3]==st[0]) return -1; for ( int i = 0 ; i &amp;lt; len ; i++) for ( int j = i+1 ; j &amp;lt; len ; j++) if (st[i]&amp;lt;st[j]) swap(st[i],st[j]); sscanf(st,&amp;quot;%d&amp;quot;,&amp;amp;a); // cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; for ( int i = 0 ;i &amp;lt; len/2 ; i++) swap(st[i],st[len-1-i]); // cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; sscanf(st,&amp;quot;%d&amp;quot;,&amp;amp;b); printf(&amp;quot;%d-%d=%d\n&amp;quot;,a,b,a-b); return a-b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>c语言中static的作用</title><link>https://111qqz.com/2016/01/cstatic/</link><pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate><guid>https://111qqz.com/2016/01/cstatic/</guid><description>
一般有两个
static int a; int b; void func(void) { static int c=0; int d; } 在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。 ** c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用(而不是初始值0，初始化只会在函数第一次被调用的时候执行)**</description></item><item><title>hdoj 5606 ||bc #68 div 2 B tree</title><link>https://111qqz.com/2016/01/hdoj5606/</link><pubDate>Sat, 02 Jan 2016 13:44:50 +0000</pubDate><guid>https://111qqz.com/2016/01/hdoj5606/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5606 题意：一棵树，边权为0或者1，问对于每个点，距离它最近的点（包括自身）的个数是多少。输出将所有点的答案异或后的值。 思路：由于包括自身，自己与自己距离为0，那么最近的点一定也距离为0，所以就是找对于每个点与它相连的边权为0 的点的个数**。建图的时候可以不管边权为1的点。。因为这样的点不会对任何点的答案有贡献。**正解貌似是冰茶几。。我就是dfs搞了下。。找到每一个联通快的点数。。然后把某个联通快的所有点的答案都更新成点的个数。。。
/* *********************************************** Author :111qqz Created Time :2016年01月02日 星期六 18时56分17秒 File Name :code/bc/#68/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; vector&amp;lt;int&amp;gt;Edge[N]; int cnt; bool vis[N]; int ans[N]; int sum[N]; int path[N]; void print() { for ( int i =1 ; i &amp;lt;= n ; i++) { cout&amp;lt;&amp;lt;Edge[i].</description></item><item><title>hdoj 5605 || bc #68 div 2 1001 geometry</title><link>https://111qqz.com/2016/01/hdoj5605/</link><pubDate>Sat, 02 Jan 2016 13:36:43 +0000</pubDate><guid>https://111qqz.com/2016/01/hdoj5605/</guid><description>
题意：geometry Accepts: 324 Submissions: 622 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) 问题描述 在平面直角坐标系上有一个点PP, 他的坐标是(x, y)(x,y). 有一条直线y = kx + by=kx+b经过了PP, 且分别交x, yx,y正半轴于A, BA,B. 求|PA| * |PB|∣PA∣∗∣PB∣的最小值. 输入描述 第一行一个TT, 表示数据组数. 接下来TT行每行两个正整数x,yx,y, 表示PP的坐标.
T=500, 0 &amp;lt; X, Y \leq 10000T=500,0/* *********************************************** Author :111qqz Created Time :2016年01月02日 星期六 18时56分10秒 File Name :code/bc/#68/1001.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair</description></item><item><title>codeforces goodbye 2015 A. New Year and Days</title><link>https://111qqz.com/2016/01/codeforces-goodbye-2015-a-new-year-and-days/</link><pubDate>Fri, 01 Jan 2016 13:06:32 +0000</pubDate><guid>https://111qqz.com/2016/01/codeforces-goodbye-2015-a-new-year-and-days/</guid><description>
http://codeforces.com/contest/611/problem/A 题意：两种查询，一种是 x of week,x为1.。7,对应输出2016年星期x有多少天。另一种为x of month ，对应输出2016年至少有x天的月份有多少天。 思路：直接搞。。。。竟然脑残被hack了。。。sad.
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int inf = 0x3f3f3f3f; int x; char st[25],nouse[33]; int main() { scanf(&amp;quot;%d %s %s&amp;quot;,&amp;amp;x,nouse,st); if (st[0]=='w') { if (x==6||x==5) { cout&amp;lt;&amp;lt;53&amp;lt;&amp;lt;endl; } else { cout&amp;lt;&amp;lt;52&amp;lt;&amp;lt;endl; } } else { if (x&amp;lt;=29) { puts(&amp;quot;12&amp;quot;); } else if (x&amp;lt;=30) { puts(&amp;quot;11&amp;quot;); } else { puts(&amp;quot;7&amp;quot;); } } return 0; }</description></item><item><title>cf 611 B ||codeforces goodbye 2015 B. New Year and Old Property (数学或者数位dp)</title><link>https://111qqz.com/2016/01/cf611b/</link><pubDate>Fri, 01 Jan 2016 13:03:22 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611b/</guid><description>
http://codeforces.com/contest/611/problem/B 题意：问a到b（1E18），二进制表示中只有一个0的数有多少个。 思路：这么大的数。。。不是有循环节就是math problems.  UD:20160318讲道理还有可能是数位dp好不好。。。 我们发现可以很容易得算出1到x的二进制表示中只有一个0 的数有多少个。
problem solved.
20160318update:学了数位dp后又看到这题。。。这题显然是数位dp啊。。。亏我找规律搞了出来2333.
后面附上数位dp方法AC的代码
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 22时49分02秒 File Name :code/cf/goodbye2015/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const int N=1E4+7; LL a,b; LL p[N]; LL c[N]; LL cal( LL x) { return ((x-1LL)*x)/2LL; } LL solve (LL x) { if (x==0LL) return 0; LL res= 0LL; LL cnt = 0LL; LL xx = x; while (xx) { cnt++; p[cnt] = xx%2LL; xx/=2LL; } ms(c,0); res+=cal(cnt-1LL); LL tmp = (1LL&amp;lt;&amp;lt;cnt)-1LL; for ( LL i = 0 ; i &amp;lt;cnt-1 ; i++) { LL happ = 1LL&amp;lt;&amp;lt;i; c[i]=tmp-happ; } sort(c,c+cnt-1); for ( LL i = 0 ; i&amp;lt; cnt -1 ; i++) { if (x&amp;gt;=c[i]) res++; } return res; } int main() { cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; LL ans = solve(b)-solve(a-1LL); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; } 数位dp的方法：</description></item><item><title>cf 611 A||codeforces goodbye 2015 C. New Year and Domino</title><link>https://111qqz.com/2016/01/cf611a/</link><pubDate>Fri, 01 Jan 2016 12:57:19 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611a/</guid><description>
http://codeforces.com/contest/611/problem/C 题意：给出一个n*m的地图，.表示可以空，#表示墙。一个东西需要占两个相邻的格子，问给定一个矩形，放一个东西的方案数。 思路：q很大。。应该是先预处理出来直接调用答案。。。计数问题累加性。。应该是前缀和之类。。需要做的就是怎么标记。。我的做法是竖着放和横着放的个数分开来存。从左往右从上往下，每次标记到后一个点。然后二维的前缀和。然后每次询问的时候，去掉最上边和最左边两条边界上对应的多加的点。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N=5E2+7; char maze[N][N]; int n,m; int q; int a[N][N],b[N][N]; int sum[N][N]; int sum2[N][N]; int main() { cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for ( int i = 0 ; i&amp;lt; n ;i++ ) scanf(&amp;quot;%s&amp;quot;,maze[i]); for ( int i = 1 ; i &amp;lt; n ; i++) { for (int j = 0 ; j&amp;lt; m ;j++) { if (maze[i][j]=='.</description></item><item><title>codeforces 22 C. System Administrator</title><link>https://111qqz.com/2015/12/cf22c/</link><pubDate>Wed, 30 Dec 2015 13:47:31 +0000</pubDate><guid>https://111qqz.com/2015/12/cf22c/</guid><description>
http://codeforces.com/contest/22/problem/C 题意：要求用n个点m条边构造一个不允许有重边的图，满足当去掉点v的时候，剩下的n-1个不联通。如果有答案输出任意，没答案输出-1. 思路：首先如果n个点要联通。。至少有n-1条边，此时为一棵树。但是是不是边越多越好呢？显然是不可以的。满足去掉一个点使得n-1个点不联通的情况为，存在一个点u只和v相连，不和任意任何其他点相连，那么当去掉v点，u点就变成不可到达了。边数最多的情况就是，除了v点以外的n-1个点，每个点的度都是n-2(去掉自身以及u点还有n-2个点)，，那么除去u点以外的n-1个点的度数就是（n-1）(n-2)，边数则为(n-1)(n-2)/2，再加一条连接u的边，所以图的最大边数为(n-1)*(n-2)/2+1，最小为n-1.
如果有解，那么接下来的问题是构造。
我是按照如下方式构造的：
先构造一条链，将u点放在第一个，v点放在第二个。不妨当v=1时令u=2,否则u=1;
m-=n-1,如果m还有剩余，那么从第二个点开始，一直到第n-2个点，每个点与至少隔1个点的其他点相连，直到边数没有剩余。
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 20时36分06秒 File Name :code/cf/problem/22C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m,v; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 29 C. Mail Stamps</title><link>https://111qqz.com/2015/12/cf29c/</link><pubDate>Wed, 30 Dec 2015 12:27:15 +0000</pubDate><guid>https://111qqz.com/2015/12/cf29c/</guid><description>
http://codeforces.com/contest/29/problem/C 题意：给出n个边的关系，保证可以构成一条链。正向或者反向输出这个链。 思路：由于下标很大(1E9)，而关系个数只有1E5..需要离散化。。而且离散化的同时不能丢失边的关系。。。实际上。。直接用vector+map就好了。。。 map &amp;gt;e;即可。然后找到一个度为1的点。。做个dfs...
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 19时55分15秒 File Name :code/cf/problem/29C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; map&amp;lt;int,vector&amp;lt;int&amp;gt; &amp;gt;e; map&amp;lt;int,bool&amp;gt;vis; map&amp;lt;int,int&amp;gt;in; map&amp;lt;int,int&amp;gt;::iterator it; int beg; int n ; void dfs( int x) { vis[x] = true; printf(&amp;quot;%d &amp;quot;,x); for ( int i = 0 ; i &amp;lt; e[x].</description></item><item><title>codeforces 31 C. Schedule</title><link>https://111qqz.com/2015/12/cf31c/</link><pubDate>Tue, 29 Dec 2015 14:35:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf31c/</guid><description>
http://codeforces.com/problemset/problem/31/C 题意：给出n个借用教室的时间安排，可能会有冲突。要求恰好去掉一个时间安排使得剩下的时间安排不冲突。问多多少种方案。 思路：首先一个直觉是。。除非初始就没有任何冲突。。不然这个答案不会很大。。
如果没有任何冲突，那么答案为n，直接输出一遍就好。
以l为第一关键字，r为第二关键字升序sort下。
如果有一个冲突，那么要看是否有包含关系，如果有，需要去掉大的这个，方案数为1.如果只是相交，那么可以去掉任意一个。方案数为2.
如果有两个冲突，我要看这两个冲突涉及到几个时间安排，如果涉及到4个或者时间安排，那么不可能全部解决，die掉。
如果这两个冲突涉及到三个时间安排，也就是说中间的和两段的相交，那么可以取消中间的这个时间安排来解决冲突。方案数为1.
需要注意的是输出的时候要按照原来的顺序。。所以存的时候记得存一下id.因为排序以后会打乱原有。输出之前还要sort下。 忘了这个。。WA#22/。因为按照id未必是从小到大输出的。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 21时37分11秒 File Name :code/cf/problem/31C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E3+7; int n ; int ans[N]; struct node { int fst,sec; int id; bool operator &amp;lt;(node b)const { if (fst&amp;lt;b.</description></item><item><title>codeforces 27 C. Unordered Subsequence</title><link>https://111qqz.com/2015/12/cf27c/</link><pubDate>Tue, 29 Dec 2015 12:06:06 +0000</pubDate><guid>https://111qqz.com/2015/12/cf27c/</guid><description>
http://codeforces.com/contest/27/problem/C 题意：给出一个序列，问是否存在一个disordered的子序列。。输出长度并输出组成子序列的下表（1..n）。如果有多组，输出任意一组。 disordered的意思是。。升序或者降序（不严格也可以)之外的情况。 思路： 首先我们可以知道，我们要找的子序列至少需要三个点。因为两个点怎么看都是有序的。而如果有k个点（k&amp;gt;3）组成的子序列存在。。那么机智得去掉其中一些点，可以只剩三个 ，同样满足题意。所以我们只需要找到三个点即可。如果把点以下标为横坐标，值为纵坐标花在坐标系上，就是找一个v型或者倒v型的三个点。
第二，我们可以将找三个点的问题转化成用第一个点+找两个点的问题。我们可以证明，如果解存在，那么包含第一个点的解也一定存在。我们可以用反证法证明，如果我们选了第1个点，然后从第2个点到第n个点。。我们找不到两个点与第一个点构成一个v型，那么整个序列一定是升序或者降序，无解，与前提矛盾。
**需要注意的，判断方向的时候我用了乘，可能会爆int,记得用long long **
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 19时36分55秒 File Name :code/cf/problem/27C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL a[N]; int n; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces 30 C. Shooting Gallery</title><link>https://111qqz.com/2015/12/codeforces-30-c-shooting-gallery/</link><pubDate>Tue, 29 Dec 2015 10:54:59 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-30-c-shooting-gallery/</guid><description>
http://codeforces.com/contest/30/problem/C 题意：给出n个target在一个二维平面上。给出每个target的坐标，出现的时间，以及击中的概率。target出现之后就会瞬间消失，枪移动的单位速度为1，射击不需要时间。问能击中的target的最大期望是多少。
思路：路径dp。。。按照时间升序排列。 dp[i]表示到第i个target出现的时候的期望。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 18时14分45秒 File Name :code/cf/problem/30C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n; double dp[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>codeforces 14 C. Four Segments</title><link>https://111qqz.com/2015/12/codeforces-14-c-four-segments/</link><pubDate>Tue, 29 Dec 2015 09:29:57 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-14-c-four-segments/</guid><description>
http://codeforces.com/problemset/problem/14/C 题意：给出四条边的坐标，问能否形成一个边与坐标轴平行的矩形。边可能退化成点。 思路：首先第一步，检查有没有边退化成点以及是否有不平行的边。
第二步，检查两个方向的边是否各有两条。。
第三步，将所有点的坐标排序。。然后看8个点是否会因为重合而变成4个.。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 16时28分28秒 File Name :code/cf/problem/14C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b,c,d; int l[10]; int cnt; struct point { int x,y; bool operator &amp;lt;(point p)const { if (x&amp;lt;p.</description></item><item><title>codeforces 18 C. Stripe</title><link>https://111qqz.com/2015/12/cf18c/</link><pubDate>Tue, 29 Dec 2015 08:22:45 +0000</pubDate><guid>https://111qqz.com/2015/12/cf18c/</guid><description>
http://codeforces.com/contest/18/problem/C 题意：将一个序列分成两个非空的部分，保证和相等，问有多少种方法。 思路：做过一个三部分的。。。两部分直接一个前缀和就好了把。。。有一个需要注意的是。。判断负数是否是奇数的时候需要加个绝对值。。。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 16时09分06秒 File Name :code/cf/problem/18C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int total; int sum[N]; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces 12 C. Fruits</title><link>https://111qqz.com/2015/12/cf12c/</link><pubDate>Tue, 29 Dec 2015 08:05:19 +0000</pubDate><guid>https://111qqz.com/2015/12/cf12c/</guid><description>
http://codeforces.com/contest/12/problem/C 题意：有n个价格价格，m个要买的东西（可能有相同的种类，设为k种），把n个标签中拿出k个给个贴上。。。问最大价钱和最少价钱分别是多少。 思路：贪心。不过要按照map的value排序。。然后发现其实不用排序。。因为map的key值其实不影响。
vector降序排列的话。。直接 sort(v.rbegin(),v.rend());就好。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 15时30分54秒 File Name :code/cf/problem/12C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; map&amp;lt;string,int&amp;gt;mp; int a[N]; map&amp;lt;string,int&amp;gt;::iterator it; vector&amp;lt;int &amp;gt;v; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 16 C. Monitor</title><link>https://111qqz.com/2015/12/codeforces-16-c-monitor/</link><pubDate>Tue, 29 Dec 2015 05:21:06 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-16-c-monitor/</guid><description>
http://codeforces.com/contest/16/problem/C 题意：给定长宽a,b和分辨率x:y,注意分辨率x:y未必是最简比。问将现有的size裁剪成比例为x:y，使得面积最大的长宽是多少。 思路：可以通过找 x,y能扩大的倍数为k，找到一个最大的k使得k*x&amp;lt;=a&amp;amp;&amp;amp;k;*y&amp;lt;=b。可以二分搞，但其实也可以不用。能扩大的最大的倍数其实就是 min(a/x,b/y). ps:收获了gcd更简单的一种写法。 直接 return b?gcd(b,a%b):a;
/* *********************************************** Author :111qqz Created Time :2015年12月28日 星期一 22时50分23秒 File Name :code/cf/problem/16C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,x,y; LL ax=0,ay=0; LL ans = -1; LL GCD; LL gcd(LL a,LL b) { if (a&amp;lt;b) return gcd(b,a); if (a%b==0) return b; return gcd(b,a%b); // return b?</description></item><item><title>linux mint gedit 中文乱码</title><link>https://111qqz.com/2015/12/linux-mint-gedit-/</link><pubDate>Mon, 28 Dec 2015 12:46:05 +0000</pubDate><guid>https://111qqz.com/2015/12/linux-mint-gedit-/</guid><description>
gconftool-2 --set --type=list --list-type=string /apps/gedit-2/preferences/encodings/auto_detected &amp;quot;[UTF-8,CURRENT,GB18030,ISO-8859-15,UTF-16]&amp;quot;</description></item><item><title>在linux mint 上安装 Oracle JDK 的方法</title><link>https://111qqz.com/2015/12/linux-mint--oracle-jdk-/</link><pubDate>Mon, 28 Dec 2015 08:17:03 +0000</pubDate><guid>https://111qqz.com/2015/12/linux-mint--oracle-jdk-/</guid><description>
Open up the Terminal (Alt + F2 &amp;gt; Terminal).
Remove OpenJDK installation.
sudo apt-get update &amp;amp;&amp;amp; apt-get remove openjdk*
Download Oracle JDK from here. You are looking for a linux version with tar.gz extension. Also choose the right version from 32-bit (x86) and 64bit (x64) one.
Change directory into one with downloaded tarball. In my case $HOME/Downloads.
cd ~/Downloads
Extract tarball.</description></item><item><title>codeforces 612 C. Replace To Make Regular Bracket Sequence</title><link>https://111qqz.com/2015/12/cf612c/</link><pubDate>Sun, 27 Dec 2015 09:55:30 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612c/</guid><description>
http://codeforces.com/contest/612/problem/C 题意：其实就是栈的基本操作。。水题。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 22时58分50秒 File Name :code/cf/edu4/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int len; char st[N]; int cost = 0 ; char a[N]; int n ; int which(char ch) { if (ch=='&amp;lt;'||ch=='{'||ch=='('||ch=='[') return 1; return 2; } int kin(char ch) { if (ch=='{'||ch=='}') return 1; if (ch=='['||ch==']') return 2; if (ch=='&amp;lt;'||ch=='&amp;gt;') return 3; if (ch=='('||ch==')') return 4; } bool ok(char x,char y) { int res = 0 ; if(x=='&amp;lt;'||x=='{'||x=='['||x=='(') res++; if (y=='&amp;gt;'||y=='}'||y==']'||y==')') res++; if (res==2) { if (kin(x)!</description></item><item><title>codeforces 612 B. HDD is Outdated Technology</title><link>https://111qqz.com/2015/12/cf612b/</link><pubDate>Sun, 27 Dec 2015 09:53:23 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612b/</guid><description>
http://codeforces.com/contest/612/problem/B 水。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 22时58分38秒 File Name :code/cf/edu4/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; struct node { int val; int id; bool operator &amp;lt;(node b)const { return val&amp;lt;b.</description></item><item><title>codeforces 612 A. The Text Splitting</title><link>https://111qqz.com/2015/12/cf612a/</link><pubDate>Sun, 27 Dec 2015 09:46:17 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612a/</guid><description>
http://codeforces.com/contest/612/problem/A 水题...直接枚举就好。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 22时58分26秒 File Name :code/cf/edu4/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,p,q; char st[N]; bool v[10005]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 612 D. The Union of k-Segments</title><link>https://111qqz.com/2015/12/cf612d/</link><pubDate>Sun, 27 Dec 2015 09:37:24 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612d/</guid><description>
http://codeforces.com/contest/612/problem/D
题意：给出n个线段信息，每个线段以l,r的形式给出。给定k。要求从作到右给出至少有k个线段覆盖的区间的信息。并使得区间数目尽可能少。
思路：很经典的一类问题...又想起了当年在tyvj上海洋兄给我的那个把线段比喻成公路，把两个端点比喻成收费站的比喻了。做法是把所有点的信息按照从小到大排序，并且记录点的类型信息，如果点相同，那么我们规定入口处的优先级高。用pair来搞的话。。可以把入口的type规定成-1，出口规定成1.然后从最左边的点开始扫，遇到-1的点厚度+1，遇到1的点厚度-1.当厚度为k的时候记录区间信息。
/* *********************************************** Author :111qqz Created Time :2015年12月26日 星期六 00时14分09秒 File Name :code/cf/edu4/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n ,k; vector&amp;lt; pi&amp;gt; v,ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #327 A. Flipping Game</title><link>https://111qqz.com/2015/12/cf327a/</link><pubDate>Fri, 25 Dec 2015 13:53:06 +0000</pubDate><guid>https://111qqz.com/2015/12/cf327a/</guid><description>
http://codeforces.com/contest/327/problem/A 题意：给定一段序列，只由0,1组成。要求选一段非空区间，做翻转操作（0变1,1变0），问变完之后1最多能有多少。 思路：最后的1个个数=初始的1的个数+变换区间的0的个数-变换区间的1的个数。初始的是常数。那么我们只要找到某一个区间内，0的个数-1的个数有最大值即可。如果a[i]==0的时候令b[i]=1，否则b[i]=0,那就是经典了最大连续区间和的问题了。dp的思想o(n)可以解决。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 21时35分22秒 File Name :code/cf/problem/327A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n ; int a[N],b[N]; int ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 456 C. Boredom</title><link>https://111qqz.com/2015/12/codeforces-456-c-boredom/</link><pubDate>Fri, 25 Dec 2015 10:53:05 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-456-c-boredom/</guid><description>
http://codeforces.com/contest/456/problem/C 题意：给出n(1E5)个数（1E5），每次可以选一个数a[k]并删掉a[k],a[k]-1,a[k]+1得到a[k]分，问最多能得到的分数。 思路：裸dp.f[i]表示选到数i的时候能达到的最大分数。开一个计数数组cnt[x]表示数字x出现的次数。那么显然有f[0]=0,f[1]=cnt[1],f[i(i&amp;gt;=2)] = max(f[i-1]，f[i-2]+f[i]*cnt[i]);答案为f[max(a[i])]，注意要开long long
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 18时17分05秒 File Name :code/cf/problem/455A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; int a[N]; LL cnt[N]; LL dp[N]; bool cmp( int a,int b) { return a&amp;gt;b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #336 div 2 B. Hamming Distance Sum</title><link>https://111qqz.com/2015/12/cf608b/</link><pubDate>Wed, 23 Dec 2015 18:52:28 +0000</pubDate><guid>https://111qqz.com/2015/12/cf608b/</guid><description>
http://codeforces.com/contest/608/problem/B 题意：给定两个字符串a,b，问b中的每个连续的长度为a的子串与a的哈密顿距离的和是多少。哈密顿距离是对应位置的字符的差的绝对值的和。由于是01串，也就是字符不同的位置数。 思路：类似前缀和。0和1分别搞。注意开long long
/* *********************************************** Author :111qqz Created Time :2015年12月24日 星期四 00时32分33秒 File Name :code/cf/#336/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int la,lb; char a[N],b[N]; int sum0[N],sum1[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #336 div 2 A. Saitama Destroys Hotel</title><link>https://111qqz.com/2015/12/cf608a/</link><pubDate>Wed, 23 Dec 2015 18:48:03 +0000</pubDate><guid>https://111qqz.com/2015/12/cf608a/</guid><description>
http://codeforces.com/contest/608/problem/A 题意：一个电梯，从s到0层，单项，给出n个人，每个人在某时间出现在某层，问要花多长时间把所有人运到0。初始电梯在s，每下一层话费时间1，上来人不花时间。 思路：由于电梯只能是单项，那么到达某一层的时候，一定要等到把这层中最晚来的那个接走。所以排序的时候按照楼层高到低为第一关键字，等待时间长到短为第二关键字。对于同一楼层出现的，只考虑第一个即可，也就是最后出现的。需要注意的是最后接完最后一个人以后把电梯运行道0层。
/* *********************************************** Author :111qqz Created Time :2015年12月24日 星期四 00时32分24秒 File Name :code/cf/#336/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int s; struct node { int f,t; bool operator &amp;lt;(node b)const { if (f&amp;gt;b.</description></item><item><title>codeforces #332 div 2 D. Spongebob and Squares</title><link>https://111qqz.com/2015/12/cf559d/</link><pubDate>Wed, 23 Dec 2015 08:57:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf559d/</guid><description>
http://codeforces.com/contest/599/problem/D 题意：给出总的方格数x，问有多少种不同尺寸的矩形满足题意，输出方案数和长宽（3,5和5,3算两种） 思路：比赛的时候gg了。。其实稍微在纸上推一下。就会得到对于n,m的矩形，一共会有-nnn+3nnm+n+3n*m的方格。数量级是n3。 我们可以实际跑一遍。发现对于x1E18的数量级，n不会超过1442550，1E6,可以搞。
需要注意的是，一个是会爆int,所以记得用long long
另一个是如果两个数相等，记得只输入一组，并且方案数-1
我是用set +pair存的答案。。反向遍历set的时候要用reserve_iterator...
/* *********************************************** Author :111qqz Created Time :2015年12月23日 星期三 15时54分37秒 File Name :code/cf/#332/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; LL ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL x; LL cur; const LL MAXN = 1442550; set&amp;lt;pi&amp;gt;se; LL cal( LL n,LL m) { LL res = -n*n*n+3*n*n*m+3*n*m+n; return res; } int square = -1; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #333 div 2 D. Lipshitz Sequence</title><link>https://111qqz.com/2015/12/codeforces-333-div-2-d-lipshitz-sequence/</link><pubDate>Wed, 23 Dec 2015 06:12:24 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-333-div-2-d-lipshitz-sequence/</guid><description>
http://codeforces.com/contest/602/problem/D 题意：见题目描述。 思路：我们很容易发现，l[h]函数其实就是在求区间斜率的最大值。哦不对，是斜率的绝对值的最大值。而且一个显而易见的结论是，斜率最大值一定是由相邻的点得到。画图可以很容易看出。
具体的证明见这里： In order to prove it properly, we'll consider three numbers A__i, A__j, A__k (i &amp;lt; j &amp;lt; k) and show that one of the numbers _L_1(i, j),_L_1(j, k) is ≥ _L_1(i, k). W.l.o.g., we may assume A__i ≤ A__k. There are 3 cases depending on the position of A__j relative to A__i, A__k:
* _A__j_ &amp;gt; _A__i_, _A__k_ — we can see that _L_1(_i_, _j_) &amp;gt; _L_1(_i_, _k_), since |_A__j_ - _A__i_| = _A__j_ - _A__i_ &amp;gt; _A__k_ - _A__i_ = |_A__k_ - _A__i_| and _j_ - _i_ &amp;lt; _k_ - _i_; we just need to divide those inequalities * _A__j_ &amp;lt; _A__i_, _A__k_ — this is similar to the previous case, we can prove that _L_1(_j_, _k_) &amp;gt; _L_1(_i_, _k_) in the same way * _A__i_ ≤ _A__j_ ≤ _A__k_ — this case requires more work: * we'll denote _d_1_y_ = _A__j_ - _A__i_, _d_2_y_ = _A__k_ - _A__j_, _d_1_x_ = _j_ - _i_, _d_2_x_ = _k_ - _j_ * then, _L_1(_i_, _j_) = _d_1_y_ / _d_1_x_, _L_1(_j_, _k_) = _d_2_y_ / _d_2_x_, _L_1(_i_, _k_) = (_d_1_y_ + _d_2_y_) / (_d_1_x_ + _d_2_x_) * let's prove it by contradiction: assume that _L_1(_i_, _j_), _L_1(_j_, _k_) &amp;lt; _L_1(_i_, _k_) * _d_1_y_ + _d_2_y_ = _L_1(_i_, _j_)_d_1_x_ + _L_1(_j_, _k_)_d_2_x_ &amp;lt; _L_1(_i_, _k_)_d_1_x_ + _L_1(_i_, _k_)_d_2_x_ = _L_1(_i_, _k_)(_d_1_x_ + _d_2_x_) = _d_1_y_ + _d_2_y_, which is a contradiction We've just proved that to any _L_1 computed for two elements A[i], A[k] with k &amp;gt; i + 1, we can replace one of i, j by a point _j_between them without decreasing _L_1; a sufficient amount of such operations will give us k = i + 1.</description></item><item><title>codeforces #333 div 2 C. The Two Routes</title><link>https://111qqz.com/2015/12/cf602c/</link><pubDate>Tue, 22 Dec 2015 09:01:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf602c/</guid><description>
http://codeforces.com/problemset/problem/602/C 题意：给出n个城镇，m条双向铁路，对于任意不同的x,y，如果x,y之间没有铁路，那么一定有双向公路。train只能走铁路，bus只能走公路。现在一辆火车和一辆bus同时从1出发，要到达n，处于安全考虑，bus和火车不能同时处在除了n以外的点。bus和train不要求同时到达。任意一段道路的时间花费都是1小时。问最少需要多久使得bus和train都到达n。如果存在某个不能到达，那么输出-1. 思路：n才400.一开始打算先按照rail和road建两个图。这两个图互为补。然后在floyd的时候加以判断。但是马上就发现。。不能同时到达同伙一个点这个条件其实不会影响。。因为按照题意，一定存在一条1到n的路，不是公路就是铁路。那么就让有路的花费1的代价到n，然后剩下的求一个一到n的最短路即可。由于n才400.。最短路怎么搞都行。。我偷懒就用floyd了。
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 16时28分59秒 File Name :code/cf/#333/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E2+7; int n ,m; int road[N][N]; int rail[N][N]; int floyd() { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (rail[i][j]&amp;gt;rail[i][k]+rail[k][j]) rail[i][j] = rail[i][k] + rail[k][j]; if (rail[1][n]==inf) return -1; else return rail[1][n]; } int floyd2() { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i =1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ;j++) road[i][j] = min(road[i][j],road[i][k]+road[k][j]); if (road[1][n]==inf) return -1; else return road[1][n]; } void init() { // for ( int i = 0 ; i &amp;lt;= 400 ; i++) // for ( int j = 0 ; j &amp;lt;= 400 ; j ++) // { // rail[i][j] = 99999; // road[i][j]= 99999; // } ms(rail,0x3f); ms(road,0x3f); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #333 div 2B. Approximating a Constant Range</title><link>https://111qqz.com/2015/12/cf602b/</link><pubDate>Tue, 22 Dec 2015 08:04:29 +0000</pubDate><guid>https://111qqz.com/2015/12/cf602b/</guid><description>
http://codeforces.com/contest/602/problem/B 题意：给定n个数，问最大连续区间长度，满足这段区间内最大值和最小值的差的绝对值小于等于1. 思路：尺取+set。尺取法，由于要时刻得到一段区间的最大值和最小值，而且可能有重复元素，所以用multiset.
需要注意的是，set里最小值是se.begin() ，最大值是se.rbegin()这样比较好。。不要用se.end()之类。。。
另一个需要注意的是，multiset里用erase的时候。如果se.erase(x)会把集合里所有的x都删除掉。如果指向删除一个，那么应该写成se.erase(se.find(x))
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 15时10分01秒 File Name :code/cf/#333/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; int a[N]; void ruler() { int head = 1; int tail = 1; int ans = -1; multiset&amp;lt;int&amp;gt;se; while (tail&amp;lt;=n) { se.</description></item><item><title>codeforces #334 div 2 E. Lieges of Legendre</title><link>https://111qqz.com/2015/12/cf603e/</link><pubDate>Tue, 22 Dec 2015 06:36:56 +0000</pubDate><guid>https://111qqz.com/2015/12/cf603e/</guid><description>
http://codeforces.com/contest/604/problem/E 题意：有两个人做游戏，游戏规则如下： 有n堆石子，每次可以对一堆石子进行操作，如果当前石子是偶数，那么可以选择将这2*x个石子分成k堆石子数为x的石子堆，还有一种没有前提的操作是取走当前堆的一个石子，问先手赢还是后手赢，先手和后手都足够聪明的情况下。 思路：博弈论。。不会做。。第一次接触sg函数。。转载一篇题解： http://m.blog.csdn.net/blog/qq_24451605/50154973
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 14时29分05秒 File Name :code/cf/#334/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,k,res; int pre[5]={0,1,0,1,2}; int grundy( int a) { if (k%2==0) { if (a==1) return 1; if (a==2) return 2; return (a%2)^1; } else { if (a&amp;lt;5) return pre[a]; if (a%2==1) return 0; return (grundy(a/2)==1?</description></item><item><title>codeforces #334 div 2 D.Moodular Arithmetic</title><link>https://111qqz.com/2015/12/cf604d/</link><pubDate>Tue, 22 Dec 2015 05:09:32 +0000</pubDate><guid>https://111qqz.com/2015/12/cf604d/</guid><description>
http://codeforces.com/contest/604/problem/D 题意：一个恒等式 f(kx%p)=kf(x)%p ,k,p为常数，且满足x对于定义域为0..p-1的p的整数，值域也在0..p-1范围（不一定一一对应）。问满足题意的f有多少个。 思路： f(0)=0,对于其他的值，当f（x）确定时，f（kx%p）也随之确定，那么把kx%p看做新的x,f（kkx%p）也随之确定...相当于【1，p-1】被分为r个小环，确定每个环可以任选一个数字，ans=p^r。环的个数可以用dfs跑一遍得到r. 注意当k=1的时候是特殊情况，f(x)恒等于f(x)那么答案应该有p的p次方种。因为对于p个f(0..p-1)，每一个都可以任意取p种值。
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 12时31分09秒 File Name :code/cf/#334/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD =1E9+7; const int N=1E6+7; LL p,k; LL ans; bool v[N]; void dfs( int x) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; v[x] = true; int y = (k*x)%p; if (!</description></item><item><title>hdu 1221 Rectangle and Circle</title><link>https://111qqz.com/2015/12/hdu-1221-rectangle-and-circle/</link><pubDate>Mon, 21 Dec 2015 13:59:05 +0000</pubDate><guid>https://111qqz.com/2015/12/hdu-1221-rectangle-and-circle/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1221 题意：问圆和矩形是否相交 思路：主要特殊的包含情况，然后判断与线段相交。
/* *********************************************** Author :111qqz Created Time :2015年12月21日 星期一 21时38分22秒 File Name :code/hdu/rr1221.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; #define eps 1e-8 using namespace std; struct point { double x; double y; }circle,a,b,c,d; double r; double dis(point &amp;amp;a,point &amp;amp;b) { return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } bool ok() { if(dis(a,circle)&amp;lt;r &amp;amp;&amp;amp; dis(b,circle) &amp;lt;r &amp;amp;&amp;amp; dis(c,circle)&amp;lt;r &amp;amp;&amp;amp; dis(d,circle) &amp;lt;r) return false; if(circle.x&amp;gt;=a.x &amp;amp;&amp;amp; circle.x&amp;lt;=b.x) { if(fabs(circle.y-a.y) &amp;lt;= r || fabs(circle.</description></item><item><title>poj 3687 Labeling Balls</title><link>https://111qqz.com/2015/12/poj3687/</link><pubDate>Sat, 19 Dec 2015 09:18:52 +0000</pubDate><guid>https://111qqz.com/2015/12/poj3687/</guid><description>
http://poj.org/problem?id=3687 题意：给定几个标签球的重量大小关系，求每个球是第几重的(即每个球在所有球的重量中由小到大排名是多少)。 （输出是每个球第几重，而不是几号球比几号球重！）。一开始理解错了QAQ 思路：反向拓扑+优先队列。因为正向不好用。。。所以我们连边的时候由重的指向轻的。。这样最先出队的就是最重的。。和上道题差不多？
/* *********************************************** Author :111qqz Created Time :2015年12月19日 星期六 16时32分59秒 File Name :code/poj/3687.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=203; int n,m; bool conc[N][N]; bool ok; int in[N]; int ans[N]; void topo() { priority_queue&amp;lt;int &amp;gt;q; for ( int i = 1 ; i &amp;lt;= n ; i++) if (in[i]==0) q.</description></item><item><title>poj 3660 Cow Contest (floyd,传递闭包)</title><link>https://111qqz.com/2015/12/poj3660/</link><pubDate>Thu, 17 Dec 2015 14:22:58 +0000</pubDate><guid>https://111qqz.com/2015/12/poj3660/</guid><description>
http://poj.org/problem?id=3660 题意：给定n个奶牛，m个奶牛的关系，a,b表示a比b强...问能确定多少个奶牛的排名。 思路：最重要的一点是。。能确定奶牛i的排名的条件是。。知道奶牛i和其他n-1个奶牛的关系。。不管是能打败奶牛i也好。。会被奶牛i打败也好。。只要不是不确定就行。。所以我们跑一遍floyd做传递闭包。得到任何两个点之间的联系。然后对于每一个点。看其他n-1个点是否和他有关系。
/* *********************************************** Author :111qqz Created Time :2015年12月17日 星期四 21时31分05秒 File Name :code/poj/3660.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n ,m; int v[N][N]; void init() { for ( int i = 0 ; i &amp;lt;= 100 ; i++) for ( int j = 0; j &amp;lt;= 100 ; j++) v[i][j]=i==j?</description></item><item><title>hdu 2647 rewards</title><link>https://111qqz.com/2015/12/hdu2647/</link><pubDate>Thu, 17 Dec 2015 13:24:25 +0000</pubDate><guid>https://111qqz.com/2015/12/hdu2647/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2647 题意：老板要给很多员工发奖金， 但是部分员工有个虚伪心态， 认为自己的奖金必须比某些人高才心理平衡； 但是老板很人道， 想满足所有人的要求， 并且很吝啬，想画的钱最少 输入若干个关系 a b a c c b 意味着a 的工资必须比b的工资高 同时a 的工资比c高； c的工资比b高
当出现环的时候输出-1
思路：因为点的个数比较多。。。用数组存点的关系存不下。。于是用set存边。。和用vector差不多。。。窝一开始的大思路错了。。以为会是一条链。。也就是没一个钱数只对应一个人。。。但实际上可以是889,888,888，这样。。。只要不矛盾。。然后要反向建图。。因为只知道最少的钱数是888，不知道最多的钱数是多少。。所以最先出来的，也就是入度为0的点应该为工资最少的。。。所以如果a应该比b工资高，那么连一条b指向a的边。
/* *********************************************** Author :111qqz Created Time :2015年12月09日 星期三 19时27分04秒 File Name :code/hdu/2647.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+1; int n,m; set&amp;lt;int&amp;gt;conc[N]; set&amp;lt;int&amp;gt;::iterator it; int in[N]; int val[N]; void topo() { queue&amp;lt;int&amp;gt;q; for ( int i = 1 ; i &amp;lt;= n ; i++) if (in[i]==0) q.</description></item><item><title>hdu 3342 Legal or Not</title><link>https://111qqz.com/2015/12/hdoj3342/</link><pubDate>Thu, 17 Dec 2015 11:48:42 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj3342/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=3342 裸题。 注意有重边。
/* *********************************************** Author :111qqz Created Time :2015年12月17日 星期四 19时29分00秒 File Name :code/hdoj/3342.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n,m; bool v[N][N]; int in[N]; void topo() { queue&amp;lt;int&amp;gt;q; for ( int i = 0 ; i &amp;lt; n ; i++) { if (in[i]==0) q.</description></item><item><title>hdoj 2795 Billboard</title><link>https://111qqz.com/2015/12/hdoj2795/</link><pubDate>Thu, 17 Dec 2015 09:03:02 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj2795/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2795 题意：一个尺寸为wh的方格。要按顺序放放n个尺寸为1wi的纸条。问每一个纸条回被放在哪里。如果有多个，放在最上面（编号小） 思路：把没横行能放的最大长度看做一个序列建树。由于h比n大很多。。多出来的没用。。直接取较小值就行。
/* *********************************************** Author :111qqz Created Time :2015年12月17日 星期四 15时04分52秒 File Name :code/hdu/2785.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int h,w,n; struct SegTree //将每个横格能放置的最大长度看做一个序列，建树。 { int mx; }tree[4*N]; void build ( int l,int r,int rt) { // cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; tree[rt].</description></item><item><title>codeforces 466 C. Number of Ways</title><link>https://111qqz.com/2015/12/cf466c/</link><pubDate>Tue, 15 Dec 2015 13:24:50 +0000</pubDate><guid>https://111qqz.com/2015/12/cf466c/</guid><description>
http://codeforces.com/problemset/problem/466/C 题意：给定一个序列。要将序列分成三个非零的连续部分，使得三部分的和相等。问有多少中分法。 思路：首先可以知道，如果是序列的和不为3的倍数，那么一定无解，输出0.设序列的和为sum,那么每一部分的和就应该为sum/3。我们可以预处理出从1开始的和为sum/3的点（我开了数组表示前缀和。。想了下其实不用。。我只需要点的信息。。所以用一个变量表示即可），将点的下标存在p[i]里。对于每一个p[i]，我想要知道比p[i]大且补与p[i]相邻的点中，有多少个j，使得从j到n的和为sum/3。因为如果有两部分的和都为sum/3，那么剩下的那部分也一定为sum/3.然后要知道有多少个满足题意的j,我们可以从后往前扫一遍，标记从n开始往前扫，和为sum/3的点，可以用一个0,1数组表示。如果和为sum/3，那么标记为1，否则为0.然后再用一个类似前缀和的思路。再开一个数组c记录从j到n有的和为多少，也就是从j到n有多少个点满足该点到n的和为sum/3.
预处理完这些之后。只需要从前往后扫一遍p[i]，然后ans+=c[p[i]+2]即可。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 20时28分44秒 File Name :code/cf/problem/466C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int n; int a[N]; LL sum[N],rsum[N]; int p[N],rp[N]; int cnt,rcnt; int b[N]; int c[N]; LL ans; LL solve() { LL total = sum[n]; if (total%3!</description></item><item><title>codeforces 279 B books</title><link>https://111qqz.com/2015/12/cf279b/</link><pubDate>Tue, 15 Dec 2015 12:23:32 +0000</pubDate><guid>https://111qqz.com/2015/12/cf279b/</guid><description>
http://codeforces.com/problemset/problem/279/B 题意：给定一个序列，问一段连续的序列的和小于等于t的最长的序列的长度。 思路：尺取法。三个月前学习的了。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 20时08分16秒 File Name :code/cf/problem/279B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int t; int a[N]; void solve() { int head = 1; int tail = 1; int sum = 0 ; int ans = 0 ; while (tail&amp;lt;=n) { // cout&amp;lt;&amp;lt;&amp;quot;aaaaa?</description></item><item><title>hdoj4391 Paint The Wall</title><link>https://111qqz.com/2015/12/hdoj4391/</link><pubDate>Tue, 15 Dec 2015 08:52:37 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj4391/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4391 题意：有 n 个点，每个点有一种颜色（可能相同），两种操作：1、将区间 [a,b] 染成颜色 c ; 2、询问区间 [a,b] 中颜色为 c 的点有多少个。 思路：因为颜色种类很多。。。没办法通过建很多棵线段树解决。我们用分块的办法。。。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 15时00分34秒 File Name :code/hdoj/4391.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; //sqrt(n),n最大100000 int n,q,c[N]; int len ,cnt; struct HashBlock{ int siz; //块的大小，因为最后一个快的长度可能不足len, int col;//整块的颜色。当快没有被标记成统一的颜色的时候，为-1 map&amp;lt;int,int&amp;gt;mp; }a[400]; void init() { len = (int)sqrt(n*1.</description></item><item><title>hdoj 1754 I hate it</title><link>https://111qqz.com/2015/12/hdoj1754/</link><pubDate>Tue, 15 Dec 2015 05:55:54 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj1754/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1754 题意：给定一个区间，有m组操作，操作可以是改变单点，或者查询区间最大值。对于每组查询，输出。 思路：分块。这篇博客说得很不错。http://www.cnblogs.com/sweetsc/archive/2012/08/15/2639395.html
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 11时25分17秒 File Name :code/hdu/1754.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N]; int mx[N]; int n ,m; int magic; void pre() { magic = int(sqrt(n)); ms(mx,-1); //把i%magic去掉试试。 for ( int i = 0 ; i &amp;lt;n ; i++ ) //从0开始比较方便。 { // if (a[i]&amp;gt;mx[i/magic]) // mx[i/magic] = a[i]; mx[i/magic] = max(mx[i/magic],a[i]); } } int query( int l,int r) { int ret = a[l]; for ( int j = l ; j &amp;lt;= r;) { if (j%magic==0&amp;amp;&amp;amp;j+magic-1&amp;lt;=r) { ret = max(ret,mx[j/magic]); // if (mx[j/magic]&amp;gt;ret) ret= mx[j/magic]; j+= magic; } else //首尾两段不够magic的部分直接暴力 { ret = max(a[j],ret); //if (a[j]&amp;gt;ret) ret = a[j]; j++; } } return ret; } void update( int x,int delta) { a[x] = delta; int l = x/magic*magic; int r = l+magic; //找到x对应的哪个块。 for ( int i = l ; i &amp;lt; r ; i++) { // if (i%magic==0||a[i]&amp;gt;mx[i/magic]) mx[i/magic] = a[i]; mx[i/magic] = max(mx[i/magic],a[i]); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 519 C. A and B and Team Training</title><link>https://111qqz.com/2015/12/cf519c/</link><pubDate>Mon, 14 Dec 2015 10:53:21 +0000</pubDate><guid>https://111qqz.com/2015/12/cf519c/</guid><description>
http://codeforces.com/problemset/problem/519/C 题意：两种组队方式，3人一组，1个大牛+2个蒟蒻或者1个蒟蒻+2个大牛。给定大牛和蒟蒻的个数。问最多能组多少队。 思路：线性规划。设两种队分别有x,y个即可。 突然发现这题以前做过。。。比当时的代码简单了一些。还不错。
/* *********************************************** Author :111qqz Created Time :2015年12月14日 星期一 18时31分10秒 File Name :code/cf/problem/519C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces 522 A. Vanya and Table</title><link>https://111qqz.com/2015/12/cf552a/</link><pubDate>Mon, 14 Dec 2015 06:44:28 +0000</pubDate><guid>https://111qqz.com/2015/12/cf552a/</guid><description>
http://codeforces.com/problemset/problem/552/A 题意：一个100*100的网格。然后给n个矩形。每个格子中填上包含这个格子的矩形的个数。最后问所有格子的和。 思路：树状数组搞得...然而..直接求所有矩形面积的和就可以啊喂。。o(n)。。。111qqz你个炒鸡大菜鸡。
/* *********************************************** Author :111qqz Created Time :2015年12月14日 星期一 14时01分14秒 File Name :code/cf/problem/552A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n; int c[N][N]; struct Point { int x1,y1,x2,y2; void input() { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x1,&amp;amp;y1); scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x2,&amp;amp;y2); } }p[N]; int lowbit( int x) { return x&amp;amp;(-x); } void update( int x,int y,int delta) { for ( int i = x ; i &amp;lt;= 105 ; i += lowbit(i)) { for ( int j = y ; j &amp;lt;= 105 ; j +=lowbit(j)) { c[i][j] +=delta; } } } int sum ( int x,int y) { int res = 0 ; for ( int i = x; i&amp;gt;= 1 ; i-=lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j-=lowbit(j)) { res += c[i][j]; // cout&amp;lt;&amp;lt;&amp;quot;res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; } } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 1 B. Spreadsheets</title><link>https://111qqz.com/2015/12/cf1b/</link><pubDate>Mon, 14 Dec 2015 05:33:07 +0000</pubDate><guid>https://111qqz.com/2015/12/cf1b/</guid><description>
http://codeforces.com/problemset/problem/1/B 题意：给出了两种表格的表示方法。要求互相转化。 思路：直接模拟即可。注意和一般的进制转化不同的是，26进制对应的是1到26而不是0到25，所以要记得处理下借位。
/* *********************************************** Author :111qqz Created Time :2015年12月13日 星期日 19时46分09秒 File Name :code/cf/problem/1B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char st[100]; int a26[100]; int a10[100]; void pre() { a26[0]=1; for ( int i = 1 ;i&amp;lt;=5; i++) { a26[i] = a26[i-1]*26; // cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;a26[i]&amp;lt;&amp;lt;endl; } a10[0] = 1; for ( int i = 1 ; i&amp;lt;=7 ; i++) { a10[i] = a10[i-1]*10; } } void solve() { cin&amp;gt;&amp;gt;st; int len = strlen(st); int p1=-1,p2=-1; for ( int i = 0 ; i &amp;lt; len ; i++) { char ch = st[i]; if (ch&amp;gt;='A'&amp;amp;&amp;amp;ch&amp;lt;='Z') { if (p1==-1) { p1 = i ; } else { p2 = i; break; } } } if (p2-p1==1||p2==-1) { int dig = 0 ; int alp = 0; int sum = 0 ; int sum2 = 0 ; for ( int i = len -1 ; i&amp;gt;= 0 ; i--) { char ch = st[i]; if (!</description></item><item><title>codeforces 526 B Om Nom and Dark Park</title><link>https://111qqz.com/2015/12/codeforces-526-b-om-nom-and-dark-park/</link><pubDate>Fri, 11 Dec 2015 09:08:45 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-526-b-om-nom-and-dark-park/</guid><description>
http://codeforces.com/contest/526/problem/B 题意：有一棵完全二叉树。每条边上有一定数量的路灯。问最少需要添加多少个路灯。使得根节点道叶子节点的每一条路径上的路灯数量一样。 思路：同叶子节点网上更新即可。
/* *********************************************** Author :111qqz Created Time :2015年12月11日 星期五 16时57分27秒 File Name :code/cf/problem/526B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E3+7; int n; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 574B Bear and Three Musketeers</title><link>https://111qqz.com/2015/12/cf-574b/</link><pubDate>Fri, 11 Dec 2015 06:43:54 +0000</pubDate><guid>https://111qqz.com/2015/12/cf-574b/</guid><description>
http://codeforces.com/problemset/problem/574/B 题意：给定一个无相图。选出三个点，使得这三个点之间互相有边相连，且三个点的度数之和最小。 思路：暴力出奇迹。复杂度o(n2+n*m)
/* *********************************************** Author :111qqz Created Time :2015年12月09日 星期三 21时33分28秒 File Name :code/cf/problem/574B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E3+7; int n ,m; vector&amp;lt;int&amp;gt;edge[N]; int ans; bool conc[N][N]; int d[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 510 C. Fox And Names</title><link>https://111qqz.com/2015/12/cf510c/</link><pubDate>Wed, 09 Dec 2015 13:27:17 +0000</pubDate><guid>https://111qqz.com/2015/12/cf510c/</guid><description>
http://codeforces.com/contest/510/problem/C
题意：给定n个字符串。问是否存在一种字母顺序，使得这n个字符串的顺序满足字典序（自定义的）。如果有多种顺序，输出字典序（标准的）最小的。
思路：将字符串的关系处理成边的关系。每次对于第i个和第i+1个字符串，从前往后扫，直到不相等的那一位，设为k,然后连边，指向i+1。表明第i个字符串的第k位大于第i+1个字符串的第k位。如果没有不想等的。说明其中一个是另一个的字串。如果前者是后者的字串，那么不影响。如果后者是前者的字串，则不存在满足条件的字典序。然后做拓扑排序。由于有多种输出字典序（标准的）最小的方案。所以存点的时候用优先队列存。
/* *********************************************** Author :111qqz Created Time :2015年12月06日 星期日 15时16分50秒 File Name :code/cf/problem/510C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; char st[N][N]; int p[30]; int offset[30]; bool conc[30][30]; int in[N]; int ans[N]; struct node { int x; node(int xx) { x=xx; } bool operator &amp;lt;(const node a)const{ return x&amp;gt;a.</description></item><item><title>hdu 2094 产生冠军</title><link>https://111qqz.com/2015/12/hdu2094/</link><pubDate>Wed, 09 Dec 2015 10:38:35 +0000</pubDate><guid>https://111qqz.com/2015/12/hdu2094/</guid><description>
题意：给定n组u关系。每组表示a战胜b。。问根据这些关系能否确定冠军。 思路：如果a战胜b就从a连一条指向b的边。那么能确定冠军的条件就变成了，有且只有一个入度为0的点。翻译过来就是，有一个人没有被任何人战胜过。且，这样的人只有一个。一开始想用map来搞。。但是比较麻烦。。其实用set比较好。。开两个set,一个存所有的人，一个存输过的人。出度为0的点只有一个等价为，有且只有一个人没有输过。也就是两个set的元素差个数为1.
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 21时11分20秒 File Name :code/hdu/2094.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N= 1E3+7; int n; set&amp;lt;string&amp;gt;all; set&amp;lt;string&amp;gt;loser; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdoj 1285 确定比赛名次</title><link>https://111qqz.com/2015/12/hdoj1285/</link><pubDate>Tue, 08 Dec 2015 13:06:06 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj1285/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1285 题意：
有N个比赛队（1&amp;lt;=N&amp;lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。
Input
输入有若干组，每组中的第一行为二个数N（1&amp;lt;=N&amp;lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。
拓扑排序模板题。刷dfs的时候遇到的。干脆来学习下。
注意可能有重边。
由于要求输出顺序按照序号从小到达，所以这里用了优先队列。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 20时43分24秒 File Name :code/hdu/1285.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; int n,m; int in[N]; bool con[N][N]; priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt; &amp;gt; q; void toporder() { for ( int i = 1 ; i &amp;lt;= n ; i++) if (in[i]==0) q.</description></item><item><title>cf 596 B. Wilbur and Array</title><link>https://111qqz.com/2015/12/cf596b/</link><pubDate>Tue, 08 Dec 2015 10:06:44 +0000</pubDate><guid>https://111qqz.com/2015/12/cf596b/</guid><description>
http://codeforces.com/problemset/problem/596/B 题意：初始序列全为0，问经过多少次变换，能变成序列b。一次变换是指，选定一个i，从i一直到最后每个元素都增加1，或者每个元素都减少1. 思路：很容易发现。后面的变换补影响前面的变换。每一个数字可以唯一由之前的增加和减少次数决定。所以我们用两个变量，记录之前做的增加和减少变换的次数。然后扫一遍即可。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 17时53分58秒 File Name :code/cf/problem/596B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; LL a[N],b[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 600 C. Make Palindrome</title><link>https://111qqz.com/2015/12/cf600c/</link><pubDate>Tue, 08 Dec 2015 09:44:29 +0000</pubDate><guid>https://111qqz.com/2015/12/cf600c/</guid><description>
http://codeforces.com/problemset/problem/600/C 题意：给定一个字符串。要求用最少的变换得到一个回文串。且在变换次数相同时要字典序最小的。输出变换后的字符串。 思路：对不能构成会文串有影响的是出现奇数次的字母。所以我们先统计每个字母出现的次数。然后按照出现奇数次的字母的个数分奇偶分别搞。偶数的话直接把后面一半变成前面一半。奇数的话，也是这样。输出的时候按照字母从a扫到z，如果有就输出一半。然后再倒着扫一遍。 输出另一半。这样可以保证是字典序最小。需要注意的是奇数的时候的输出情况。不要忘记中间那个字母。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 16时39分56秒 File Name :code/cf/problem/600C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char st[N]; int len; int cnt[30]; int odd[30]; int k; int mappd[30]; char ans[N]; void solve() { // cout&amp;lt;&amp;lt;&amp;quot;k:&amp;quot;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl; if (k==0) { for ( int i = 0 ; i &amp;lt; 26 ; i++) { for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } for ( int i = 25 ; i &amp;gt;= 0 ; i--) for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); return ; } if (k%2==0) { for ( int i = 1 ; i &amp;lt;= k/2 ; i++) { cnt[odd[i]]++; cnt[odd[i+k/2]]--; } int num = 0; for ( int i = 0 ; i &amp;lt; 26 ; i++) { for ( int j = 0 ; j &amp;lt; cnt[i]/2; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } for ( int i = 25 ; i &amp;gt;=0 ; i--) { for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } printf(&amp;quot;\n&amp;quot;); } if (k%2==1) { // cout&amp;lt;&amp;lt;&amp;quot;what the fuck?</description></item><item><title>codeforces 505 B. Mr. Kitayuta's Colorful Graph</title><link>https://111qqz.com/2015/12/cf505b/</link><pubDate>Mon, 07 Dec 2015 03:11:13 +0000</pubDate><guid>https://111qqz.com/2015/12/cf505b/</guid><description>
http://codeforces.com/contest/505/problem/B 题意；给一个图，边有颜色。给q个查询，每个查询一对点x,y。问只经过某种颜色的边使得x能到y颜色数目。 思路：存颜色的时候卡了下。。本来打算开一个二维的set用来存颜色。。。没想明白。。后来发现。。还是用vecotr就好啊。。。多开一维度vector。。或者。。vector 用 pair 都是可以的。。。因为颜色数不多。。可以暴力枚举每种颜色做一遍dfs 看只走有这条颜色的边x能否到y。。
/* *********************************************** Author :111qqz Created Time :2015年12月07日 星期一 09时52分33秒 File Name :code/cf/problem/505B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) #define pi pair&amp;lt;int ,int &amp;gt; typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m,q; vector&amp;lt;pi&amp;gt;edge[N]; bool vis[N]; void dfs (int x,int y,int col) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; col:&amp;quot;&amp;lt;&amp;lt;col&amp;lt;&amp;lt;endl; vis[x] = true; if (x==y) return; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 475 B. Strongly Connected City</title><link>https://111qqz.com/2015/12/cf475b/</link><pubDate>Mon, 07 Dec 2015 01:38:26 +0000</pubDate><guid>https://111qqz.com/2015/12/cf475b/</guid><description>
http://codeforces.com/problemset/status 题意：n行m列的道路网络。共n*m条道路。每条道路都是单向的.问从任何一个路口出发能否到达其他的任何一个路口。
思路：需要注意的是。我从A点能到达B点，不代表B也能到达A.也就是说，某些点满足可以遍历所有点是不够的，只有当所有点都满足才可以。
/* *********************************************** Author :111qqz Created Time :2015年12月07日 星期一 08时55分48秒 File Name :code/cf/problem/475B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=25; int n,m; bool vis[N][N]; char hor[N],ver[N]; bool direrror (char ch,int d) { if (ch=='v'&amp;amp;&amp;amp;d==3) return true; if (ch=='^'&amp;amp;&amp;amp;d==0) return true; if (ch=='&amp;lt;'&amp;amp;&amp;amp;d==2) return true; if (ch=='&amp;gt;'&amp;amp;&amp;amp;d==1) return true; return false; } bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m&amp;amp;&amp;amp;!</description></item><item><title>codeforces 158 B. Taxi</title><link>https://111qqz.com/2015/12/158b/</link><pubDate>Sun, 06 Dec 2015 12:46:06 +0000</pubDate><guid>https://111qqz.com/2015/12/158b/</guid><description>
http://codeforces.com/problemset/problem/158/B 题意：n组人，每组有si个（1&amp;lt;=si&amp;lt;=4），每辆车能装4个人。问最少需要多少辆车装下所有人并且保证同一组的人在一辆车里。 思路：统计人数分别为1,2,3,4的人数。对于4的直接加到答案。贪心的思路是：优先用人数少的去填人数多的。
/* *********************************************** Author :111qqz Created Time :2015年12月06日 星期日 17时34分21秒 File Name :code/cf/problem/158B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int s[N]; int ans; int cnt[5]; void print() { printf(&amp;quot;%d %d %d %d %d\n&amp;quot;,cnt[1],cnt[2],cnt[3],cnt[4],ans); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 510 B. Fox And Two Dots</title><link>https://111qqz.com/2015/12/cf510b/</link><pubDate>Sun, 06 Dec 2015 07:10:27 +0000</pubDate><guid>https://111qqz.com/2015/12/cf510b/</guid><description>
http://codeforces.com/contest/510/problem/B 题意：给定一个maze,用不同的字母代表不同的颜色。问能否找到一个颜色相同的环（失少四个点组成） 思路：dfs一遍，如果遇到之前已经访问过的点，说明成环。需要注意的是，要注意由一个点向某方向移动，然后由反方向移动到该点所造成的误判。所以dfs除了要知道当前的坐标x,y，还要记录之前的坐标px,py.
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 21时35分07秒 File Name :code/cf/problem/510B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n,m; char maze[N][N]; bool vis[N][N]; bool flag; bool inmaze( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m) return true; return false; } void dfs( int x,int y,int px,int py) //要记录当前的x,y是由哪里来的。把因为由px,py到x,y再回到px,py引起的误判剔除。 { //判cycle方式为：到达一个之前已经到达过的点。 vis[x][y] = true; // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; if (flag) return; for ( int i = 0 ; i &amp;lt; 4 ; i++) { int nx = x + dx4[i] ; int ny = y + dy4[i] ; if (nx==px&amp;amp;&amp;amp;ny==py) continue; if (inmaze(nx,ny)&amp;amp;&amp;amp;maze[nx][ny]==maze[x][y]) { if (!</description></item><item><title>codeforces 277 A. Learning Languages</title><link>https://111qqz.com/2015/12/cf277a/</link><pubDate>Sat, 05 Dec 2015 13:28:36 +0000</pubDate><guid>https://111qqz.com/2015/12/cf277a/</guid><description>
http://codeforces.com/contest/277/problem/A
题意：有n个人，每个人会一定数目的语言（可能为0），一个人学一门语言的代价为1，人和人之间沟通可以通过任意个中间人翻译。问最少的代价使得这n个人可以相互沟通。
思路：建图方式如下：第i个人会语言j，那么连上i和j+n。然后跑一遍dfs,使得1..n这n个点都被访问过。
结果wa4...觉得算法没问题。。看了官方题解。。发现果然有情况没有考虑到。如果所有的人都什么语言都不会的话，那么答案是不能-1的。。因为。。语言和语言之间不能连边。。改了之后A了。。有点开心。。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 20时55分14秒 File Name :code/cf/problem/277A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E2+5; int n,m; vector&amp;lt;int&amp;gt;edge[N]; bool vis[N]; void dfs( int x) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; vis[x] = true; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 217A ice skating</title><link>https://111qqz.com/2015/12/cf217a/</link><pubDate>Sat, 05 Dec 2015 12:34:50 +0000</pubDate><guid>https://111qqz.com/2015/12/cf217a/</guid><description>
http://codeforces.com/problemset/problem/217/A 题意：有n个雪漂（那是啥？，从某个雪漂出发走直线，只有到达另一个雪飘才能停下来。问最少需要添加多少个雪漂，才能使得可以到达任何一个雪漂。 思路：横坐标相同或者纵坐标相同的两个点之间是可以到达的。先O(N2)扫一遍建图。记录这个森林中数的个数为cnt,cnt-1即为答案。因为对于任意两个不能相互到达的点。我们只需要再来一个雪漂就可以使得这两个点相互到达。
一遍AC，有点爽。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 20时18分23秒 File Name :code/problem/217A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; bool vis[N]; int x[N],y[N]; vector&amp;lt;int&amp;gt;edge[N]; void dfs( int x) { vis[x] = true; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 445 B. DZY Loves Chemistry</title><link>https://111qqz.com/2015/12/cf445b/</link><pubDate>Sat, 05 Dec 2015 10:26:11 +0000</pubDate><guid>https://111qqz.com/2015/12/cf445b/</guid><description>
http://codeforces.com/contest/445/problem/B
题意：一共有n种化学药品。m对关系，每对关系表示为x,y表示x和y相互反应。初始容器的danger值为1，当向容器中加入一个化学药品A,如果容器中存在化学药品和A反应，那么容器的danger值翻倍。否则不变。问一个最优的放置药品的顺序。
思路：容易发现。如果两个药品相互反应就连一条边。实际上这些药品构成了一个森林。而一个节点只要不是树的根节点，那么它在任何位置，对答案的贡献度都是*2.反过来说。所有的节点，只有根节点是对答案没有贡献的。那实际上，我们只需要dfs一遍，得到树的数目，用n减去树的数目，就是对答案有贡献的点的数目。
要注意开long long 。。。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 17时13分51秒 File Name :code/cf/problem/445/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; bool vis[N]; int n,m; vector&amp;lt;int&amp;gt;edge[N]; LL ans; LL tree_num; void dfs( int cur) { vis[cur] = true; for ( int i = 0 ; i &amp;lt; edge[cur].</description></item><item><title>codeforces 522 A. Reposts</title><link>https://111qqz.com/2015/12/cf522a/</link><pubDate>Sat, 05 Dec 2015 09:08:16 +0000</pubDate><guid>https://111qqz.com/2015/12/cf522a/</guid><description>
http://codeforces.com/problemset/problem/522/A 题意：给定某条消息的传播路径。问最远传播的距离。。 思路：其实就是问树的深度。。直接dfs就行了。。
存的时候用map&amp;lt;string,vector &amp;gt; mp;的方式存即可。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 16时41分41秒 File Name :code/cf/problem/522A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E2+7; map&amp;lt;string,vector&amp;lt;string&amp;gt; &amp;gt; mp; map&amp;lt;string,bool&amp;gt;vis; string from,to,nouse; int ans; int n; void dfs(string cur,int depth) { // cout&amp;lt;&amp;lt;&amp;quot;cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; depth:&amp;quot;&amp;lt;&amp;lt;depth&amp;lt;&amp;lt;endl; vis[cur] = true; ans = max(ans,depth); for ( int i = 0 ; i &amp;lt; mp[cur].</description></item><item><title>codeforces 500 B. New Year Permutation</title><link>https://111qqz.com/2015/12/cf500b/</link><pubDate>Sat, 05 Dec 2015 07:35:09 +0000</pubDate><guid>https://111qqz.com/2015/12/cf500b/</guid><description>
http://codeforces.com/contest/500/problem/B
题意：给定一个1至n的数的一种排列。给定一个n*n的矩阵，a[i][j]==0代表pi,pj不可以交换，a[i][j]为1代表p[i],p[j]可以交换。 问字典序最小的排列。。
思路：把矩阵看成图的关系。。反正n很小。。跑一遍floyd..得到可以间接交换的点。。然后冒泡排序就好。。只有p[i]&amp;gt;p[j]并且a[i][j]的时候交换。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 15时00分14秒 File Name :code/cf/problem/500B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; char ok[N][N]; int p[N]; int n; int a[N][N]; void print() { for ( int i = 0 ; i &amp;lt; n ;i++) printf(&amp;quot;%d &amp;quot;,p[i]); } void floyd() { for ( int k = 0 ; k &amp;lt; n ;k ++) for ( int i = 0 ; i &amp;lt; n ; i++) for ( int j = 0 ; j &amp;lt; n ; j++) if (a[i][j]==-1&amp;amp;&amp;amp;a[i][k]==1&amp;amp;&amp;amp;a[k][j]==1) a[i][j] = 1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 377 A maze</title><link>https://111qqz.com/2015/12/cf377a/</link><pubDate>Sat, 05 Dec 2015 06:34:40 +0000</pubDate><guid>https://111qqz.com/2015/12/cf377a/</guid><description>
http://codeforces.com/contest/377/problem/A 题意：给定一个n*m的maze. ‘.’代表空，‘#’代表墙。要求构造一种方案，使得将k个空格填成墙壁后不影响当前的连通性（即没有被填充的空格之间可以相互到达） 思路：一开始想从上往下从左往右构造。错误的认为四个角一定是可以变成墙的。
但其实只要是可能在某条路径上的点，就都不一定可以变成墙。。而四个角显然可以被某条路径经过。
正确的解法很巧妙。以任意一个空格开始跑一遍dfs，设空格一共有sum个，那么就dfs到(sum-k)个。可以做好标记。通过dfs得到的这（sum-k）之间一定是联通的。那么只要填充剩下的就可以了。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 14时06分54秒 File Name :code/cf/problem/377A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; char maze[N][N]; bool vis[N][N]; int n,m,k; int sx,sy; int sum; int num; bool flag = false; bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;=n-1&amp;amp;&amp;amp;y&amp;lt;=m-1&amp;amp;&amp;amp;maze[x][y]=='.</description></item><item><title>codeforces 129 B. Students and Shoelaces</title><link>https://111qqz.com/2015/12/cf129b/</link><pubDate>Sat, 05 Dec 2015 04:02:36 +0000</pubDate><guid>https://111qqz.com/2015/12/cf129b/</guid><description>
http://codeforces.com/contest/129/problem/B 题意：n个点。m条边。每一次会将图中度为1的点加入到等待队列中。然后一起删掉，记为一次操作。当删掉一个点的时候，与它相连的边也全部删掉。问一共做进行多少次操作。使得图中不再有度为1的点。 思路：重点是用开一个数组deg[i]记录点i的度。这样比用.size()高明太多。。因为我们并不需要知道具体删了哪条边。我们只要知道与点i相连的点的边数因为点i被删除而减少了1.
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 10时55分46秒 File Name :code/cf/problem/129B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; vector&amp;lt;int&amp;gt;edge[N]; int deg[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 580 C. Kefa and Park</title><link>https://111qqz.com/2015/12/cf580c/</link><pubDate>Sat, 05 Dec 2015 02:40:03 +0000</pubDate><guid>https://111qqz.com/2015/12/cf580c/</guid><description>
http://codeforces.com/contest/580/problem/C
题意：给出一棵树。每个叶子节点上有一个饭店。某些节点上有cat.现在问从根节点出发可以到达多少个饭店，保证在到达饭店的路径中补连续遇到m个以上的cat.
思路：建图，然后dfs..判断为叶子节点（饭店）的方法是某个点的叶子节点数为0.
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 10时17分01秒 File Name :580C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int m,n; bool vis[N]; vector&amp;lt;int&amp;gt;edge[N]; int hascat[N]; int ans; void dfs( int cur,int num) { vis[cur] = true; if (hascat[cur]) num++; else num = 0 ; // cout&amp;lt;&amp;lt;&amp;quot;cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; num:&amp;quot;&amp;lt;&amp;lt;num&amp;lt;&amp;lt;endl; if (num&amp;gt;m) return; int leafnum = 0; for ( int i = 0 ; i &amp;lt;edge[cur].</description></item><item><title>codeforces 115A A. Party</title><link>https://111qqz.com/2015/12/cf115a/</link><pubDate>Sat, 05 Dec 2015 01:56:30 +0000</pubDate><guid>https://111qqz.com/2015/12/cf115a/</guid><description>
http://codeforces.com/problemset/problem/115/A 题意：给出n个人之间的上级下级关系。问如何分得最少的组，使得没一组中的人不存在上下级关系。 思路：用树的观点来考虑会很容易。可以看成给了一棵森冷。对于不同的树的相同层的点，不存在上下级关系，可以放在一个group.对于同一棵树，每一层要单独放一个group.所以答案是所有树的深度的最大值。
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 21时31分38秒 File Name :code/cf/problem/115A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int p[N]; int f[N]; int n; int ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #327 B Rebranding</title><link>https://111qqz.com/2015/12/codeforces-327-b-rebranding/</link><pubDate>Fri, 04 Dec 2015 13:25:05 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-327-b-rebranding/</guid><description>
http://codeforces.com/contest/591/problem/B
题意：给定一个字符串。给出m组替换。对于某一组替换，给出x,y。将字符串中所有的字符x换成y，所有的字符y换成x. 字符串仅包含英文小写字母。
思路： 可以用一个char 到 char 的map 初始映射本身。。 然后进行m次修改。。需要注意的是，每一次修改要修改全部。。因为当进行完i次修改而要进行i+1次修改的时候。。value值为x的可能不止一个。。所以要从a到z都扫一遍。。
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 19时13分12秒 File Name :code/cf/#327/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char st[N]; int n,m; char x,y; map&amp;lt;char,char&amp;gt;mp; int main() { freopen(&amp;quot;code/in.</description></item><item><title>codeforces #327 A. Wizards' Duel</title><link>https://111qqz.com/2015/12/codeforces-327-a-wizards-duel/</link><pubDate>Fri, 04 Dec 2015 13:18:18 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-327-a-wizards-duel/</guid><description>
题意：一个长度为l的走廊。两个人站在两端点。互相向对方发射某种魔法。A的魔法速度为p米/秒，B的魔法速度为q米/s,魔法相遇以后会反射。反射会发射人那里会再次发射。问两种魔法第二次相遇的时候距离A的距离。 思路：由于每种魔法的速度保持肯定不变。。所以不管第几次相遇。相遇点都是同一个。。。ans=p*(p+q)/l;
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 19时12分56秒 File Name :code/cf/#327/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double p,q,l; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces edu1 D. Igor In the Museum</title><link>https://111qqz.com/2015/12/codeforces-edu1-d-igor-in-the-museum/</link><pubDate>Fri, 04 Dec 2015 08:29:50 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-edu1-d-igor-in-the-museum/</guid><description>
http://codeforces.com/contest/598/problem/D
题意：给第一个地图。 ‘.’是能走的，‘’是不能走的。**每个‘.’和''之间有一幅画，**给出k个起点，问对于每组起点，最多能观察到多少副画。
思路：dfs.要注意即使只有一个‘*’，从不同方向访问仍然算不同的画。这样就不用标记画是否访问过了。一开始直接暴力dfs..TLE 10
然后发现，如果是在同一个联通快内，能看到的画的最大值是确定的。。如果之前有同一个联通快内的其他点dfs过得到过答案，那么下次就不用再dfs了。。。记得把之前的记过保存下来。。
我具体的写法是把某一次dfs进过的点的恒纵坐标都存起来。。。然后dfs结束后把更新这些沿途中经过的点的答案。。结果还是TLE 10
果然是记忆化写残了。。也不是写残了。。看了几个别人的代码。。。记忆化存的时候是按照某一次来存答案。。而我是按照某个点的坐标。。来存答案。果然还是要提高姿势水平啊。。。SAD
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 15时08分22秒 File Name :code/cf/edu1/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+3; int n,m,k; char maze[N][N]; bool pic[N][N]; int v[N][N]; int ans[N*N]; int res; int cnt = 0 ; bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m&amp;amp;&amp;amp;v[x][y]==-1) return true; return false; } int dfs ( int x,int y,int kk) { if (!</description></item><item><title>codeforces edu1 B Queries on a String</title><link>https://111qqz.com/2015/12/codeforces-edu1-b-queries-on-a-string/</link><pubDate>Fri, 04 Dec 2015 06:54:38 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-edu1-b-queries-on-a-string/</guid><description>
题意：给一个字符串（1E4），然后给m次操作（m&amp;lt;=300），每次操作是给定一个区间l,r，然后进行k次（k&amp;lt;=1E6）cyclic shift (rotation) 变换。
One operation of a cyclic shift (rotation) is equivalent to moving the last character to the position of the first character and shifting all other characters one position to the right. For example, if the string s is abacaba and the query is _l_1 = 3, _r_1 = 6, _k_1 = 1 then the answer is abbacaa. If after that we would process the query _l_2 = 1, _r_2 = 4, _k_2 = 2 then we would get the string baabcaa.</description></item><item><title>codeforces #edu 1 A tricky sum</title><link>https://111qqz.com/2015/12/codeforces-edu-1-a-tricky-sum/</link><pubDate>Fri, 04 Dec 2015 06:11:13 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-edu-1-a-tricky-sum/</guid><description>
题意：求1+2+..+n的和。。但是对于是2的整数幂的项数。。符号是-。。
思路：可以先当做正数。(n+1)*n/2; 然后减去二倍的2的整数次幂的项的和。
坑点： 妈蛋第三次了。。。我想求小于等于n的最大是2的几次幂。。。取整的时候用int又会迷之错误。。。为什么说是迷之错误。。因为我WA的点的数据拿下来在本地跑是没有问题的。。。一交上去就错。。。不明觉厉。。。下次遇到double类型是数一点要小心小心再小心。。。第一次遇到是pow的返回类型是double，然后答案莫名奇妙的差1.第二次是#334 div2 的A题。。一道傻逼算分数的题我WA了一个小时。。。第三次是这个。。向下取整不要用（int）的强制转换。。而用floor吧。。233
/* *********************************************** Author :111qqz Created Time :2015年12月03日 星期四 16时46分46秒 File Name :code/cf/edu/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>有了这个列表，程序员不愁没练手的小项目了</title><link>https://111qqz.com/2015/12/</link><pubDate>Thu, 03 Dec 2015 10:44:00 +0000</pubDate><guid>https://111qqz.com/2015/12/</guid><description>
我经常看有人发帖问关于项目点子的事，也看到了很多回帖，我自己也回了一些常见的项目。不过我觉得只列出三两个是远远不够的，因此就收集并这个项目列表，大家要找简单的编程项目学习练手的话，可以收藏并扩散本文。这些项目并不是论文级别的，只是想抛砖引玉让大家能从中受些启发。
下面你们会看到 120 多个个项目构思，都是我通过头脑风暴得来的。我将其根据主题分成了10 个分类，但有些项目其实涵盖了不止一个主题。
更新：如果你喜欢这些构思的话，你也可以读一下我做的电子书（伯乐在线注：需梯子）。该书有100多页，包含了200个构思，有很多有用的内容和链接。每个构思都包含一个难度评分，实现该构思的提示以及复杂版的构思。要比下面这些更有深度。另外也请大家阅读下我的另一本书《编码生存手册：习惯和陷阱》，免费的哟。
文本操作
逆转字符串——输入一个字符串，将其逆转并输出。 拉丁猪文字游戏——这是一个英语语言游戏。基本规则是将一个英语单词的第一个辅音音素的字母移动到词尾并且加上后缀-ay（譬如“banana”会变成“anana-bay”）。可以在维基百科上了解更多内容。 统计元音字母——输入一个字符串，统计处其中元音字母的数量。更复杂点的话统计出每个元音字母的数量。 判断是否为回文——判断用户输入的字符串是否为回文。回文是指正反拼写形式都是一样的词，譬如“racecar”。 统计字符串中的单词数目——统计字符串中单词的数目，更复杂的话从一个文本中读出字符串并生成单词数目统计结果。 文本编辑器——记事本类型的应用，可以打开、编辑、保存文本文档。可以增加单词高亮和其它的一些特性。 RSS源创建器——可以从其它来源读取文本并将其以RSS或者Atom的格式发布出去。 实时股价——可以查询股票当前价格。用户可以设定数据刷新频率，程序会用绿色和红色的箭头表示股价走势。 访客留言簿/日志——允许人们添加评论或者日记，可以设置开启/关闭评论，并且可以记录下每一条目的时间。也可以做成喊话器。 新闻和比分播报器——一个桌面应用，可以从网上收集新闻和比赛分数，将结果在屏幕上滚动播出。 占星罗盘——用占星术来预测每天的运程。 密码短信——可以将数据加密解密，并能将其发送给朋友。 帮你挑礼物——输入一堆你可能会送的礼物，当有人过生日时，该程序会随机选择一样礼物。也可以加上一个额外功能，可以告知哪里可以弄到这个礼物。 HTML生成器——将 TEXT 文档转换成HTML文件，对制作网页HTML文档很有用。 CD-Key生成器——利用某种算法生成一个唯一的key。软件开发者可以用它来作为软件的激活器。 正则表达式查询工具——用户可以输入一段文本，在另外的控件里输入一个正则表达式。运行以后会返回匹配的内容或者正则表达式中的错误。 网络
FTP工具——与远程网络服务器交互文件。 原子钟校时——从网上同步原子钟时间。全世界有很多原子钟，可以把它们都列出来。 聊天应用（IRC或者MSN风格的）——像IRC那样的聊天室软件或者MSN那样的实时聊天软件。更复杂一点的话，可以为聊天制定一套你自己的传输协议。 获取当前天气——获取某个地区当前的天气情况。 P2P文件共享应用——像LimeWire、FrostWire、Bearshare或者torrent风格的应用。 端口扫描器——输入某个ip地址和端口区间，程序会逐个尝试区间内的端口，如果能成功连接的话就将该端口标记为open。 邮件检查工具（POP3/IMAP）——用户输入一些账号信息，包括服务器、ip、协议类型（POP3或者IMAP），应用每隔一段时间就会检查下该账号下的邮箱。 数据包嗅探器——侦测电脑上进出的数据包，获取诸如目的地和大小之类的信息。 IP注册地查询——输入ip地址，查询该ip是在哪注册的。 Whois查询工具——输入一个ip或者主机地址，通过whois查询并将结果返回。 邮编查询——输入邮编，返回使用该邮编的地区名称。 远程登入——远程登入桌面类型的应用，可以查看和控制远程电脑（假如你已经获得权限）。可能需要你自己的网络和两台电脑来进行测试。 网站定时检查器——每隔一段时间或者在预定的时间尝试连接某个网站或者服务器，来检查它是否可以连上，如果连不上了会通过邮件或者桌面通知来告知你。 小型网页服务器——简易版的网页服务器，可以存放包含Javascript和其它形式代码的HTML文件。复杂一点的话可以尝试流媒体视频、创建一种服务器端语言或者其它类型的流媒体。 网络蜘蛛——一个可以自动执行网页上各种任务的程序，任务包括网站检查、页面抓取、数据摘要以及网络邮务。 类
产品库存管理——创建一个管理产品库存的应用。建立一个产品类，包含价格、id、库存数量。然后建立一个库存类，记录各种产品并能计算库存的总价值。 电影商店——管理录像带租借，记录借出时间、到期时间、逾期费用。复杂一点可以生成逾期用户的账号报告。 航空/酒店预订系统——创建一套预订航班或酒店的预订系统。不同的航班座位和酒店房间收费不一样。譬如头等舱要比经济舱贵。带阁楼的套间要更贵些。记录下何时有空房可供预订。 学生成绩管理器——记录一个班级的学生（创建一个Student类，记录他们的名字、平均分和考试分数）和他们的成绩等级。根据学生的测验和作业的分数计算出平均分和成绩等级。复杂一点可以将数据画在贝尔曲线上。 银行账户管家——创建一个名为“Account”的抽象类，有三个为“CheckingAccount”、“SavingsAccount”和“BusinessAccount”的子类。通过类似ATM的程序来管理这些账户的借贷。 馆藏目录——创建一个图书类，记录书名、页数、国际标准书号、是否借出。用它来管理各种书籍，允许用户进行借出和归还操作。复杂一点的话，可以生成逾期图书和逾期费用的报告。也可以让用户进行预约操作。 线程处理
下载进度条——创建一个表示下载进度的进度条。进度条由独立的线程操作，通过委托来和主线程进行通讯。 下载管理器——允许程序同时下载数个文件，每个都用单独的线程进行背景下载。主线程会关注下载进度并且在下载完成时通知用户。 聊天软件（远程聊天）——做一个聊天软件，允许你通过ip直接连接到另一台电脑，也允许你的“服务器”程序处理多个请求连接。 批量缩略图生成器——在进行图片转换的处理时会需要很多时间，尤其是图片很大时。做一个图片处理程序，能让你在做其它事的时候在后台线程里将数百张图片转换成某个大小的图片。复杂一点的话可以用一个线程来缩放，用另一个线程来为缩略图重命名。 Web应用
所见即所得编辑器——创建一个在线编辑器，允许用户移动元素、创建表格、书写文本、设置颜色，而用户不必懂HTML。就像Dreamweaver或者FrontPage。如果需要例子的话，可以参看DIC。 分页浏览器——创建一个可以分页的小型网页浏览器，可以同时浏览几个网页。简化一点的话不要考虑Javascript或者其它客户端代码。 文件下载器——该程序可以从网页上下载各种资源，包括视频和其它文件。用于有很多下载链接的网页。 远程登录——创建一个远程登录的应用，可以通过网络登录服务器并能执行一些基本命令。 在线白板——做一个在线白板程序，你和朋友们可以一起在白板上进行一些操作，画图、写字等等。 带宽监视器——这个小工具可以记录你已经在网上上传和下载多少数据流量了。可以试着做份报告或者图表来展示各时段的使用情况。 书签搜集管理器——该程序可以让用户上传书签并将它们排序，去掉重复的，并能生成书签文件以供Firefox/IE/Safari等使用。复杂一点的话可以试着将书签整理进不同的文件夹。 密码保险箱——用来记录各种密码，并且将它们加密，这样别人就看不到了。 iGoogle媒体播放器小部件——做一个iGoogle小部件，可以用来播放本地音乐列表，也可以每天分享一首歌。也许还可以让别人看到你最近听了些什么歌。 基于文本的游戏——做一个像Utopia那样的文本RPG，游戏中，你可以创建一个文明、收集资源、共铸联盟、施放法术、回合制系统。看看是否能够统一王国。 定时自动登录——做一个程序可以在预定的时间登录进某个指定的网页并且执行特定的动作，然后在登出。可以用来检查邮箱、发布常规内容、为其它程序获取信息。 电子卡片生成器——可以让用户制作自己的电子卡片并发送给其他人。可以使用flash也可以不用。可以使用图片库，也可以加上深刻的格言警句。 内容管理系统——像Joomala、Drupal、PHP Nuke这样的内容管理系统。从简单的做起，慢慢增加其它功能。 模板制作器——该网站应用允许用户输入各种颜色代码、元素、尺寸，来为PHPBB、Invision Board、MySpace之类的应用创建模板文件。 验证码生成器——应该在登录时见过有数字有字母的验证码图片吧？这可以防止自动登录和垃圾广告。试着自己做一个，如果使用PHP的话，看下GD的图片函数。 文件</description></item><item><title>codeforces #334 div 2 C. Alternative Thinking</title><link>https://111qqz.com/2015/12/codeforces-334-div-2-c-alternative-thinking/</link><pubDate>Wed, 02 Dec 2015 08:54:38 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-334-div-2-c-alternative-thinking/</guid><description>
题意：给定一个01串。要进行一次变换：选一段连续的非空的字串，将这段串的0和1反转（0变成1,1变成0） 然后问能得到的最长的0,1交替的序列的长度是多少（不一定连续）
比赛的时候想出来两种会将答案增加的可能情况。一种是10000001 中间有大于等于3个的连续字符，这样可以把中间反转一下，答案会+2 另外一种是 1001001 这样。。有至少两段的连续两个以上的相同字符被另一个字符隔开的情况。只要将1001001变成1010101。答案还是会+2。。。然后发现这两种情况实际上可以统一起来。即：有至少两段的连续相同字符。 注意000 也算有两段。 如果有两段或者以上，那么答案+2.
/* *********************************************** Author :111qqz Created Time :2015年12月02日 星期三 00时36分47秒 File Name :code/cf/#334/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N]; int n; char tow(char ch) { if (ch=='0') return '1'; if (ch=='1') return '0'; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #334 div 2 B. More Cowbell</title><link>https://111qqz.com/2015/12/codeforces-334-div-2-b-more-cowbell/</link><pubDate>Wed, 02 Dec 2015 08:27:12 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-334-div-2-b-more-cowbell/</guid><description>
题意是说。给n个balls,k个箱子。保证（n&amp;lt;=2*k） 一个箱子中中最多放两个balls，size为两个balls的size之和。 所有的箱子的size都要一样。 问size最小是多少。
只要让最大的size尽可能小即可。 容易想到一组贪心策略。 可以先看有几个多出来的位置 （2*k-n） 然后把最大的几个size的ball装在多余的位置里。。更新答案。 然后对于剩下的。。。最小的和最大的一组状进去。。。扫一遍更新答案。
/* *********************************************** Author :111qqz Created Time :2015年12月02日 星期三 00时00分22秒 File Name :code/cf/#334/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,k; int s[N]; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #334 div2 A. Uncowed Forces</title><link>https://111qqz.com/2015/12/cf604a/</link><pubDate>Wed, 02 Dec 2015 08:10:21 +0000</pubDate><guid>https://111qqz.com/2015/12/cf604a/</guid><description>
题意是说，给定一个计算规则，求最终分数。
又傻逼了QAQ
遇到double类型一定要小心小心小心！
虽然我觉得0.3*x一定是整数..这样子应该没问题的吧。。但还是跪了。下次有double型的数据即使是整数，可以这样写 int(x+0.5)
/* *********************************************** Author :111qqz Created Time :2015年12月01日 星期二 23时20分45秒 File Name :code/cf/#334/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=10; int m[N]; int w[10]; int hs,hu; int s[10]={500,1000,1500,2000,2500}; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>vim在acm-icpc中的配置（转自kuangbin巨巨）</title><link>https://111qqz.com/2015/12/vimacm-icpckuangbin/</link><pubDate>Tue, 01 Dec 2015 07:09:38 +0000</pubDate><guid>https://111qqz.com/2015/12/vimacm-icpckuangbin/</guid><description>
vim在ACM/ICPC中的使用 Posted on 2014年11月22日 by kuangbin Vim大法好！
应大家的要求，写一篇博客来介绍下vim在ACM中的简单使用。
写本文的目的，只是为了给广大acmer一个入门vim的指导。不喜勿喷！ 不想看到的请远离！
vim大法好，远离sublime、cb保平安！
从13年开始，平时写程序和比赛都是用的vim，也一直在推荐大家使用vim，至于为何要用vim，原因很多。
为何要使用vim？1) 可以装逼，vim显得高端大气上档次，现场赛你打开的是丑陋的CB，别人打开的是VIM，高下立判。 2) 用vim可以明显提高写代码的感觉，加快代码速度。3) vim大法好。
当然，前面纯粹个人胡扯，要用啥都是个人偏好而已。
下面简单介绍VIM的使用。
比赛篇 首先介绍vim在比赛使用的使用。
先大致介绍现场赛vim的配置方法。
现场赛比赛系统是ubuntu， 都是安装好了vim的。
ubuntu系统下打开终端（终端一般在左侧有了，没有就按Ctrl+Alt+T启动，然后可以锁定在左侧），打开终端输入vim就进入vim了。
配置方法是输入 vim ~/.vimrc (这样是用vim编辑配置文件，或者用 gedit ~/.vimrc 就是用gedit编辑了)
配置的话，按照自己习惯加几句配置文件就可以使用了。
我一般配置下面几个：
syntax on set nu set tabstop=4 set shiftwidth=4 colo evening set mouse=a set cin 上面这几个配置的具体含义可以去百度下，有的也是可以不要的。
然后配置以后保存。VIM的配置就结束了。
然后在终端里面 输入 vim A.cpp 然后就开始写代码了。
编译运行的话，可以另外打开一个终端（就是左侧右击，然后new一个出来），就可以一边编辑，一遍保存了。
但是注意在代码编译以后，一定要 :w 来保存下，然后进行编译运行。
编译可以输入 g++ A.cpp -o A
如果没有错就可以了。
然后输入 ./A 来运行，然后输入数据啥的，退出的话是 按 Ctrl+C</description></item><item><title>test</title><link>https://111qqz.com/2015/12/test/</link><pubDate>Tue, 01 Dec 2015 07:04:19 +0000</pubDate><guid>https://111qqz.com/2015/12/test/</guid><description>
应大家的要求，写一篇博客来介绍下vim在ACM中的简单使用。
写本文的目的，只是为了给广大acmer一个入门vim的指导。不喜勿喷！ 不想看到的请远离！
vim大法好，远离sublime、cb保平安！
从13年开始，平时写程序和比赛都是用的vim，也一直在推荐大家使用vim，至于为何要用vim，原因很多。
为何要使用vim？1) 可以装逼，vim显得高端大气上档次，现场赛你打开的是丑陋的CB，别人打开的是VIM，高下立判。 2) 用vim可以明显提高写代码的感觉，加快代码速度。3) vim大法好。
当然，前面纯粹个人胡扯，要用啥都是个人偏好而已。
下面简单介绍VIM的使用。
比赛篇 首先介绍vim在比赛使用的使用。
先大致介绍现场赛vim的配置方法。
现场赛比赛系统是ubuntu， 都是安装好了vim的。
ubuntu系统下打开终端（终端一般在左侧有了，没有就按Ctrl+Alt+T启动，然后可以锁定在左侧），打开终端输入vim就进入vim了。
配置方法是输入 vim ~/.vimrc (这样是用vim编辑配置文件，或者用 gedit ~/.vimrc 就是用gedit编辑了)
配置的话，按照自己习惯加几句配置文件就可以使用了。
我一般配置下面几个：
C++
syntax on set nu set tabstop=4 set shiftwidth=4 colo evening set mouse=a set cin
&amp;lt;table class=&amp;quot;crayon-table&amp;quot; &amp;gt; &amp;lt;tr class=&amp;quot;crayon-row&amp;quot; &amp;gt; 1
2
3
4
5
6
7
syntax on
set nu
set tabstop=4
set shiftwidth=4
colo evening
set mouse=a</description></item><item><title>atom在linux下安装插件失败的解决方案</title><link>https://111qqz.com/2015/12/atomlinux/</link><pubDate>Mon, 30 Nov 2015 17:27:17 +0000</pubDate><guid>https://111qqz.com/2015/12/atomlinux/</guid><description>
gyp info it worked if it ends with ok gyp info using node-gyp@2.0.2 gyp info using node@0.10.40 | linux | x64 gyp http GET https://atom.io/download/atom-shell/v0.34.0/node-v0.34.0.tar.gz gyp WARN install got an error, rolling back install gyp ERR! install error gyp ERR! stack Error: This is most likely not a problem with node-gyp or the package itself and gyp ERR! stack is related to network connectivity. In most cases you are behind a proxy or have bad gyp ERR!</description></item><item><title>wordpress无法创建目录/没有写权限的解决方案</title><link>https://111qqz.com/2015/11/wordpress/</link><pubDate>Mon, 30 Nov 2015 02:44:19 +0000</pubDate><guid>https://111qqz.com/2015/11/wordpress/</guid><description>
终于解决了。
的确是权限问题。
但是由于初始化的时候，我错误的设置了数据库目录。应该为/alidata/www/serve/mysql ，而我设置成了/home/mysql
之前一直是在改alidata下的权限...现在可以了QAQ</description></item><item><title>博客算是搭好了？</title><link>https://111qqz.com/2015/11/</link><pubDate>Sun, 29 Nov 2015 11:18:01 +0000</pubDate><guid>https://111qqz.com/2015/11/</guid><description>
然而不能上传...
插件也是。在线安装也不可以。
google遍了只看到说是权限问题。
然而wp-content整个目录都已经chmod 777了...依然不可以。
日了狗了。</description></item><item><title>世界，您好！</title><link>https://111qqz.com/2015/11/hello-world/</link><pubDate>Sun, 29 Nov 2015 08:13:34 +0000</pubDate><guid>https://111qqz.com/2015/11/hello-world/</guid><description>
欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</description></item><item><title>数学专题 by kuangbin</title><link>https://111qqz.com/2015/11/bykuangbin/</link><pubDate>Sun, 29 Nov 2015 01:54:00 +0000</pubDate><guid>https://111qqz.com/2015/11/bykuangbin/</guid><description>
从放暑假前周sir给我讲了一个用polya计数法和burnside定理做的题目（pku2409）后，突然觉得组合数学挺有意思，然后从那时起到现在几乎都在做这类的题目。
做到现在感觉这类题目的一些基本知识点都差不多有所了解了，水题也刷了不少，但还有很多难题自己实在是做不动，所以准备把这类题目先放一放，然后把前段时间做的水题整理一下（供以后的初学者参考，大牛就不要看了哈，都是水题）。剩下的比较难的题目就慢慢来吧，以后做出来再不上，这个小结会不断地更新。也希望大家有好的题目可以推荐一下，分享一下哈。
感谢：周sir，J_factory和福州大学神牛aekdycoin，大连理工大学神牛czyuan。
不扯了，进入主题：
1.burnside定理，polya计数法
这个专题我单独写了个小结，大家可以简单参考一下：polya 计数法，burnside定理小结
2.置换，置换的运算
置换的概念还是比较好理解的，《组合数学》里面有讲。对于置换的幂运算大家可以参考一下潘震皓的那篇《置换群快速幂运算研究与探讨》，写的很好。
*简单题：（应该理解概念就可以了）
pku3270 Cow Sorting
http://acm.pku.edu.cn/JudgeOnline/problem?id=3270
pku1026 Cipher
http://acm.pku.edu.cn/JudgeOnline/problem?id=1026
*置换幂运算：
pku1721 CARDS
http://162.105.81.212/JudgeOnline/problem?id=1721
pku3128 Leonardo's Notebook
http://162.105.81.212/JudgeOnline/problem?id=3128
*推荐：（不错的应用）
pku3590 The shuffle Problem
http://162.105.81.212/JudgeOnline/problem?id=3590
3.素数，整数分解，欧拉函数
素数是可能数论里最永恒，最经典的问题了（我们的队名就叫PrimeMusic^-^）。素数的判断，筛法求素数，大素数的判断···还有很多其他问题都会用到素数。
*最水最水的：（心情不爽时用来解闷吧）
pku1365 Prime Land
pku2034 Anti-prime Sequences
pku2739 Sum of Consecutive Prime Numbers
pku3518 Prime Gap
pku3126 Prime Path
pku1595 Prime Cuts
pku3641 Pseudoprime numbers
pku2191 Mersenne Composite Numbers
pku1730 Perfect Pth Powers
pku2262 Goldbach's Conjecture
pku2909 Goldbach's Conjecture</description></item><item><title>uva 6692 Lucky Number</title><link>https://111qqz.com/2015/11/luckynumber/</link><pubDate>Mon, 23 Nov 2015 14:59:00 +0000</pubDate><guid>https://111qqz.com/2015/11/luckynumber/</guid><description>
https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=4704
题目大意是说，定义一个数的lucky number是距离i最远的j且满足（a[i]&amp;lt;a[j] i&amp;lt;j）。
问对所有数最大的lucky number是什么。
不必线段树。
我们可以先处理出a[i]的最远点。倒着扫一遍即可。
然后可以处理出大于等于a[i]的最远位置。
/************************************************************************* &amp;gt; File Name: code/hust/20151115/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年11月23日 星期一 22时13分15秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int N=1E5+6; typedef long long LL; int a[N]; int n; int p[N]; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces #332 div 2 C. Day at the Beach</title><link>https://111qqz.com/2015/11/codeforces332div2c-dayatthebeach/</link><pubDate>Fri, 20 Nov 2015 19:33:00 +0000</pubDate><guid>https://111qqz.com/2015/11/codeforces332div2c-dayatthebeach/</guid><description>
C. Day at the Beach
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
One day Squidward, Spongebob and Patrick decided to go to the beach. Unfortunately, the weather was bad, so the friends were unable to ride waves. However, they decided to spent their time building sand castles.
At the end of the day there were n castles built by friends.</description></item><item><title>codeforces #332 div 2 B. Spongebob and Joke</title><link>https://111qqz.com/2015/11/codeforces332div2b-spongebobandjoke/</link><pubDate>Fri, 20 Nov 2015 19:32:00 +0000</pubDate><guid>https://111qqz.com/2015/11/codeforces332div2b-spongebobandjoke/</guid><description>
B. Spongebob and Joke
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
While Patrick was gone shopping, Spongebob decided to play a little trick on his friend. The naughty Sponge browsed through Patrick's personal stuff and found a sequence _a_1, _a_2, ..., a__m of length m, consisting of integers from 1 to n, not necessarily distinct. Then he picked some sequence _f_1, _f_2, .</description></item><item><title>codeforces #332 div 2 A. Patrick and Shopping</title><link>https://111qqz.com/2015/11/codeforces332div2a-patrickandshopping/</link><pubDate>Fri, 20 Nov 2015 19:30:00 +0000</pubDate><guid>https://111qqz.com/2015/11/codeforces332div2a-patrickandshopping/</guid><description>
&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 1&amp;lt;/span&amp;gt; #include &amp;lt;cstdio&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 2&amp;lt;/span&amp;gt; #include &amp;lt;iostream&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 3&amp;lt;/span&amp;gt; #include &amp;lt;cmath&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 4&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;using&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;namespace&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; std; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 5&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;long&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;long&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; d1,d2,d3; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 6&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; main() &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 7&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;{ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 8&amp;lt;/span&amp;gt; cin&amp;gt;&amp;gt;d1&amp;gt;&amp;gt;d2&amp;gt;&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;d3; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 9&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;long&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;long&amp;lt;/span&amp;gt; ans = &amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;999999999999&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;10&amp;lt;/span&amp;gt; ans = min(ans,d1+d2+&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;d3); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;11&amp;lt;/span&amp;gt; ans = min (ans,d1*&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;+d2*&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;12&amp;lt;/span&amp;gt; ans = min (ans,d1*&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;+&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;*&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;d3); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;13&amp;lt;/span&amp;gt; ans = min(ans,d2*&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;+&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;*&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;d3); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;14&amp;lt;/span&amp;gt; cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;endl; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;15&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;16&amp;lt;/span&amp;gt; } View Code</description></item><item><title>2015亚洲区域赛北京站总结</title><link>https://111qqz.com/2015/11/2015-icpc-beijing-regional-onsite/</link><pubDate>Mon, 16 Nov 2015 09:38:00 +0000</pubDate><guid>https://111qqz.com/2015/11/2015-icpc-beijing-regional-onsite/</guid><description>
热身赛的时候发现没有codeblocks瞬间爆炸...我从暑假开始用的vim还好...不过两个队友平常用codeblocks的。。
还好有热身赛。。然后cch晚上强行学emacs。。。最后现场赛的时候我用vim写。。队友用emacs写2333
键盘有些别扭。。。上面是日文还是注音。。。看不懂==
总按错。。。
然后竟然有201个队。。。 才90个牌子。。。尼玛竟然不按比例来。。。55%的打铁率是闹哪样。。。
当得知这个消息的时候。。我们的内心真的是崩溃的。。。没有常用的cb其实已经够不爽的了（可以现学其他，但是总归是不熟练呀）
本来就觉得自己没底。。。这样更感觉要打铁了。。。
当时我们已经相互安慰了好么。。。。尽力就好尽力就好2333
** **
比赛开始以后先是zcy和cch读题。。。我先配了一发vim环境。。。写了几个常用的。。。然后把编译和运行设置成了快捷键。。
弄好了之后cch发现j可以写。。。然后就写了j..
然后我看了G。。。发现是个水。。几乎是原题？ 白书上那个是三个矩形。。。这个是四选三。。。
不过抱着看到熟悉的题更要细心的精神。。。我又仔细读了遍题。。。发现确实水，貌似G才是签到？（然而并不是
这时候cch写完了J不过在调。。。
*然后我就在草稿纸上把G仔细列了下。。。好像一共（8+12）4种情况的样子。。。
这时候CCH交了一发J。。。竟然WA了。。。然后我表示把代码打出来吧我要写G。。。
然后大概写到一半...? cch表示找到写错的地方了。。。于是改J。。
又WA。。。有点方啊。。。然后在机器上debug一会。。。还是有问题。。。
我表示让我先过了G再说吧。。。
然后我大概花了10分钟写完了G。。。交。。卧槽竟然交成了gcc，幸好CE不算罚时。
再交，A了。。
然后CCH发现J题意理解错了（J我没读。。。不过后来发现好多人吐槽J题题意不清而且不好理解。。。朝鲜队WA了好多发）
然后改，再交，终于A了。。。这时候大概过了一个小时？ 不那么慌了。。。
然后继续开新题。。。我看了F。。计算几何。。。因为赛前一直在刷计算几何。。结果想了半小时的样子...?发现好难。。放弃了。。
这个时候CCH和 ZCY在讨论D？（我不确定2333） 然后我看了下通过题目。。发现K题有人过。。就去看K了。。。CCH去看了A。。。
这个时候ZCY写了一发D。。。写完之后发现好像想错了QAQ..
看了一会CCH说A就是个二维树状数组，可以搞。 然后他就开始写A。。。
**好像因为树状数组的sum函数忘了 return 而WA了一发。。。? 再交，过了。。。 **
这时候大概是十一点半。。通过三题。。排名大概在80+？
大家一起吃午餐时间，kfc有点良心
然后可以搞的题貌似是K和I。。。
于是我开始搞I。。。
一个构造题。。。
大概弄了二十分钟..? 搞出来了。
感觉剩下的题没有很好搞得...
决定剩下的时间就搞I。。四题应该能稳。。
然后我拿着草稿纸把我的构造方法和CCH讨论了下。。。他表示好像很有道理的样子2333
觉得I可以撸。。。。我问CCH你写我写，我细节题有点虚。。他说他写吧。。。毕竟CCH是我们队实力最强的。。这种时候还是求稳比较好。。。
然后中间好像调了好久。。。 不过反正不方！因为我们剩下的题并没有明显可以搞得。。。于是剩下的时间可以都用来搞I。。。
大概1:35的时候吧。。。I终于调对了（1到10的数据检验了下），交，过了，爽！
然后最后25分钟。。。大家一起搞K。。各种打表试图找规律。。。然并卵。。。因为那是道数位Dp2333 并不会。
当时大概预感到能拿Cu了。。。
不过说真的。。能不能拿Cu我都炒鸡开心。。。
因为并不是抱大腿了。。。我真的特别不喜欢那种抱大腿的感觉。。。
最后72名Cu.. 虽然只是块Cu吧。。但是真的炒鸡开心。。。
因为基本上。。我们会的题都做出来了。。。我们想了的但是没有成型思路的题最后发现思路根本就不对。。。
还有几何那道题。。怎么处理交点我实在没想出。。。。。
杜宇飞讲题的时候说“你们都懂得的四道题我就不说了”hhh，我们就是做出了那四道。。。
其实原本打算北京之后就退役的。。。
但是这块Cu真的给我了很大的鼓舞。。不仅仅是ACM。。对于课程内的东西也是鼓舞。。。
这周要忙着应付考试。。。
下个期待大概是十二月份的华师校赛</description></item><item><title>幻方....</title><link>https://111qqz.com/2015/11/</link><pubDate>Wed, 11 Nov 2015 12:49:00 +0000</pubDate><guid>https://111qqz.com/2015/11/</guid><description>
c语言上机。。。。
c写的幻方。
&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 1&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;/*&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;************************************************************************ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 2&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; File Name: code/class/7.c &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 3&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; Author: 111qqz &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 4&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; Email: rkz2013@126.com &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 5&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; Created Time: 2015年11月11日 星期三 19时31分50秒 &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 6&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; ***********************************************************************&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;*/&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 7&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 8&amp;lt;/span&amp;gt; #include&amp;lt;stdio.</description></item><item><title>codeforces #320 div 2 C. A Problem about Polyline(计算几何？数学)</title><link>https://111qqz.com/2015/11/codeforces320div2c-aproblemaboutpolyline/</link><pubDate>Wed, 11 Nov 2015 07:58:00 +0000</pubDate><guid>https://111qqz.com/2015/11/codeforces320div2c-aproblemaboutpolyline/</guid><description>
C. A Problem about Polyline
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
There is a polyline going through points (0, 0) - (x, x) - (2_x_, 0) - (3_x_, x) - (4_x_, 0) - ... - (2_kx_, 0) - (2_kx_ + x, x) - ....
We know that the polyline passes through the point (a, b). Find minimum positive value x such that it is true or determine that there is no such x.</description></item><item><title>cf #320 B. Finding Team Member（优先队列）</title><link>https://111qqz.com/2015/11/cf320b-findingteammember/</link><pubDate>Tue, 10 Nov 2015 08:12:00 +0000</pubDate><guid>https://111qqz.com/2015/11/cf320b-findingteammember/</guid><description/></item><item><title>poj 1113 Wall (凸包模板题）</title><link>https://111qqz.com/2015/11/poj1113wall/</link><pubDate>Tue, 10 Nov 2015 03:22:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj1113wall/</guid><description/></item><item><title>hdu 3532 Max Angle(atan2的使用)</title><link>https://111qqz.com/2015/11/hdu3532maxangleatan2/</link><pubDate>Mon, 09 Nov 2015 03:09:00 +0000</pubDate><guid>https://111qqz.com/2015/11/hdu3532maxangleatan2/</guid><description>
Max Angle **Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 678 Accepted Submission(s): 238
**
Problem Description
Given many points in a plane, two players are playing an interesting game.
Player1 selects one point A as the vertex of an angle. Then player2 selects other two points B and C. A, B and C are different with each other. Now they get an angle B-A-C.
Player1 wants to make the angle as large as possible, while player2 wants to make the angle as small as possible.</description></item><item><title>poj 1106 Transmitters (计算几何，叉积||极角排序)</title><link>https://111qqz.com/2015/11/poj1106transmitters/</link><pubDate>Mon, 09 Nov 2015 01:59:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj1106transmitters/</guid><description>
Transmitters
**Time Limit:** 1000MS **Memory Limit:** 10000K **Total Submissions:** 4817 **Accepted:** 2576 Description
In a wireless network with multiple transmitters sending on the same frequencies, it is often a requirement that signals don't overlap, or at least that they don't conflict. One way of accomplishing this is to restrict a transmitter's coverage area. This problem uses a shielded transmitter that only broadcasts in a semicircle.</description></item><item><title>poj 2007 Scrambled Polygon （极角排序模板题）</title><link>https://111qqz.com/2015/11/poj2007scrambledpolygon/</link><pubDate>Sun, 08 Nov 2015 12:09:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj2007scrambledpolygon/</guid><description/></item><item><title>极角排序的几种常见的方式</title><link>https://111qqz.com/2015/11/</link><pubDate>Sun, 08 Nov 2015 08:56:00 +0000</pubDate><guid>https://111qqz.com/2015/11/</guid><description>
20190211update:工作的时候看同事ocr的代码，发现有一段就是极角排序orz...所以说算法还是有用的...
先介绍几种极角排序：
1.利用叉积的正负来作cmp.(即是按逆时针排序).此题就是用这种方法
bool cmp(const point &amp;amp;a, const point &amp;amp;b)//逆时针排序 { point origin; origin.x = origin.y = 0; return cross(origin,b,origin,a) &amp;lt; 0; } 2.利用complex的内建函数。
#include #define x real() #define y imag() #include using namespace std; bool cmp(const Point&amp;amp; p1, const Point&amp;amp; p2) { return arg(p1) &amp;lt; arg(p2); } 3.利用arctan计算极角大小。（范围『-180，180』）
bool cmp(const Point&amp;amp; p1, const Point&amp;amp; p2) { return atan2(p1.y, p1.x) &amp;lt; atan2(p2.y, p2.x); } 4.</description></item><item><title>poj 2318 TOYS (计算几何）</title><link>https://111qqz.com/2015/11/poj2318toys/</link><pubDate>Sun, 08 Nov 2015 07:34:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj2318toys/</guid><description/></item><item><title>poj 2074 Line of Sight (计算几何，细节题)</title><link>https://111qqz.com/2015/11/poj2074lineofsight/</link><pubDate>Sun, 08 Nov 2015 07:30:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj2074lineofsight/</guid><description/></item><item><title>poj 2826 An Easy Problem?! (线段相交问题终极版...并不easy)</title><link>https://111qqz.com/2015/11/poj2826aneasyproblem-easy/</link><pubDate>Sat, 07 Nov 2015 09:49:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj2826aneasyproblem-easy/</guid><description/></item><item><title>hdu 3264 Open-air shopping malls(求圆相交的面积，二分）</title><link>https://111qqz.com/2015/11/hdu3264open-airshoppingmalls/</link><pubDate>Fri, 06 Nov 2015 07:39:00 +0000</pubDate><guid>https://111qqz.com/2015/11/hdu3264open-airshoppingmalls/</guid><description/></item><item><title>hdu 1086 A - You can Solve a Geometry Problem too （线段的规范相交&amp;&amp;非规范相交）</title><link>https://111qqz.com/2015/11/hdu1086a-youcansolveageometryproblemtoo/</link><pubDate>Fri, 06 Nov 2015 06:41:00 +0000</pubDate><guid>https://111qqz.com/2015/11/hdu1086a-youcansolveageometryproblemtoo/</guid><description>
A - You can Solve a Geometry Problem too
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Many geometry（几何）problems were designed in the ACM/ICPC. And now, I also prepare a geometry problem for this final exam. According to the experience of many ACMers, geometry problems are always much trouble, but this problem is very easy, after all we are now attending an exam, not a contest :)</description></item><item><title>hdoj 2036 (计算几何，叉积求面积)</title><link>https://111qqz.com/2015/11/hdoj2036/</link><pubDate>Fri, 06 Nov 2015 05:38:00 +0000</pubDate><guid>https://111qqz.com/2015/11/hdoj2036/</guid><description>
改革春风吹满地 **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 24179 Accepted Submission(s): 12504
**
Problem Description
&amp;quot; 改革春风吹满地,
不会AC没关系;
实在不行回老家，
还有一亩三分地。
谢谢!（乐队奏乐）&amp;quot;
话说部分学生心态极好，每天就知道游戏，这次考试如此简单的题目，也是云里雾里，而且，还竟然来这么几句打油诗。
好呀，老师的责任就是帮你解决问题，既然想种田，那就分你一块。
这块田位于浙江省温州市苍南县灵溪镇林家铺子村，多边形形状的一块地，原本是linle 的，现在就准备送给你了。不过，任何事情都没有那么简单，你必须首先告诉我这块地到底有多少面积，如果回答正确才能真正得到这块地。
发愁了吧？就是要让你知道，种地也是需要AC知识的！以后还是好好练吧...
Input
输入数据包含多个测试实例，每个测试实例占一行，每行的开始是一个整数n(3&amp;lt;=n&amp;lt;=100)，它表示多边形的边数（当然也是顶点数），然后是按照逆时针顺序给出的n个顶点的坐标（x1, y1, x2, y2... xn, yn）,为了简化问题，这里的所有坐标都用整数表示。
输入数据中所有的整数都在32位整数范围内，n=0表示数据的结束，不做处理。
Output
对于每个测试实例，请输出对应的多边形面积，结果精确到小数点后一位小数。
每个实例的输出占一行。
Sample Input
3 0 0 1 0 0 1 4 1 0 0 1 -1 0 0 -1 0
Sample Output
0.5 2.0
Author
lcy
Source
ACM程序设计期末考试（2006/06/07）
一个多边形。</description></item><item><title>poj 1269 Intersecting Lines (计算几何)</title><link>https://111qqz.com/2015/11/poj1269intersectinglines/</link><pubDate>Fri, 06 Nov 2015 03:56:00 +0000</pubDate><guid>https://111qqz.com/2015/11/poj1269intersectinglines/</guid><description/></item><item><title>codeforces #329 div 2 B. Anton and Lines(几何）</title><link>https://111qqz.com/2015/11/codeforces329div2b-antonandlines/</link><pubDate>Thu, 05 Nov 2015 10:54:00 +0000</pubDate><guid>https://111qqz.com/2015/11/codeforces329div2b-antonandlines/</guid><description>
B. Anton and Lines
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
The teacher gave Anton a large geometry homework, but he didn't do it (as usual) as he participated in a regular round on Codeforces. In the task he was given a set of n lines defined by the equations y = k__i*x + b__i. It was necessary to determine whether there is at least one point of intersection of two of these lines, that lays strictly inside the strip between _x_1 &amp;lt; _x_2.</description></item><item><title>codeforces #329 div 2 A. 2Char (暴力)</title><link>https://111qqz.com/2015/11/codeforces329div2a-2char/</link><pubDate>Thu, 05 Nov 2015 10:42:00 +0000</pubDate><guid>https://111qqz.com/2015/11/codeforces329div2a-2char/</guid><description>
A. 2Char
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Andrew often reads articles in his favorite magazine 2Char. The main feature of these articles is that each of them uses at most two distinct letters. Andrew decided to send an article to the magazine, but as he hasn't written any article, he just decided to take a random one from magazine 26Char.</description></item><item><title>hdu 1394 Minimum Inversion Number (树状数组 逆序对)</title><link>https://111qqz.com/2015/10/hdu1394/</link><pubDate>Wed, 28 Oct 2015 14:00:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu1394/</guid><description>
题目链接
题意：
这题是问一个长度为n的循环数组中，逆序对最少的个数。。。
我们可以先用树状数组求出初始的数列的逆序对。。。
然后其他的可以通过递推得到。。。。
当a[i]从处于位置1而被放到最后的时候。。。
cnt = cnt -a[i]+n-a[i]+1;
然后取所有cnt的最大值就行。
/************************************************************************* &amp;gt; File Name: code/hud/1394.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年10月28日 星期三 21时16分47秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) using namespace std; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E3+7; int c[N]; int n,a[N]; int lowbit( int x) { return x&amp;amp;(-x); } void update ( int x,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) c[i] = c[i] + delta; } int Sum( int x) { int res = 0 ; for ( int i = x ;i &amp;gt;= 1; i = i - lowbit(i)) { res = res + c[i]; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>hdu 1754 I Hate It (线段树)</title><link>https://111qqz.com/2015/10/hdu1754ihateit/</link><pubDate>Wed, 28 Oct 2015 13:14:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu1754ihateit/</guid><description>
I Hate It **Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 53991 Accepted Submission(s): 21180
**
Problem Description
很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。
这让很多学生很反感。
不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。
Input
本题目包含多组测试，请处理到文件结束。
在每个测试的第一行，有两个正整数 N 和 M ( 0学生ID编号分别从1编到N。
第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。
接下来有M行。每一行有一个字符 C (只取'Q'或'U') ，和两个正整数A，B。
当C为'Q'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。
当C为'U'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。
Output
对于每一次询问操作，在一行里面输出最高成绩。
Sample Input
5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5
Sample Output</description></item><item><title>codeforces 589 G - Hiring(模拟？)</title><link>https://111qqz.com/2015/10/codeforces589g-hiring/</link><pubDate>Tue, 27 Oct 2015 13:10:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces589g-hiring/</guid><description/></item><item><title>codeforces 589H - Tourist Guide（dfs）</title><link>https://111qqz.com/2015/10/codeforces589h-touristguidedfs/</link><pubDate>Tue, 27 Oct 2015 13:04:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces589h-touristguidedfs/</guid><description/></item><item><title>codeforces 589 B - Layer Cake</title><link>https://111qqz.com/2015/10/codeforces589b-layercake/</link><pubDate>Tue, 27 Oct 2015 06:54:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces589b-layercake/</guid><description>
B - Layer Cake
**Time Limit:**6000MS **Memory Limit:**524288KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status Practice CodeForces 589B
Description
Dasha decided to bake a big and tasty layer cake. In order to do that she went shopping and bought n rectangular cake layers. The length and the width of the i-th cake layer were a__i and b__i respectively, while the height of each cake layer was equal to one.
From a cooking book Dasha learned that a cake must have a form of a rectangular parallelepiped constructed from cake layers of the same sizes.</description></item><item><title>zoj 3627 F - Treasure Hunt II(贪心)</title><link>https://111qqz.com/2015/10/zoj3627f-treasurehuntii/</link><pubDate>Tue, 27 Oct 2015 06:13:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3627f-treasurehuntii/</guid><description/></item><item><title>zoj 3629 Treasure Hunt IV(找规律)</title><link>https://111qqz.com/2015/10/zoj3629treasurehuntiv/</link><pubDate>Tue, 27 Oct 2015 06:06:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3629treasurehuntiv/</guid><description/></item><item><title>zoj 3634 Bounty hunter(dp，已经想明白)</title><link>https://111qqz.com/2015/10/zoj3634bountyhunterdp/</link><pubDate>Tue, 27 Oct 2015 06:02:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3634bountyhunterdp/</guid><description>
M - Bounty hunter
**Time Limit:**5000MS **Memory Limit:**65536KB 64bit IO Format:%lld &amp;amp; %llu
Submit Status
Description
Bounty hunter is a hero who always moves along cities to earn money by his power. One day he decides to N cities one by one
At the beginning ,Bounty hunter has X money and Y points of Attack force. At day 1, he will goes to city 1, then city 2 at day 2, city 3 at day 3, .</description></item><item><title>codeforcres 589 J - Cleaner Robot(暴力)</title><link>https://111qqz.com/2015/10/codeforcres589j-cleanerrobot/</link><pubDate>Mon, 26 Oct 2015 15:14:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforcres589j-cleanerrobot/</guid><description/></item><item><title>codeforces 589 I - Lottery(水）</title><link>https://111qqz.com/2015/10/codeforces589i-lottery/</link><pubDate>Mon, 26 Oct 2015 14:56:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces589i-lottery/</guid><description>
I - Lottery
**Time Limit:**2000MS **Memory Limit:**524288KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status Practice CodeForces 589I
Description
Today Berland holds a lottery with a prize -- a huge sum of money! There are k persons, who attend the lottery. Each of them will receive a unique integer from 1 to k.
The organizers bought n balls to organize the lottery, each of them is painted some color, the colors are numbered from 1 to k.</description></item><item><title>codeforces 589 D - Boulevard</title><link>https://111qqz.com/2015/10/codeforces589d-boulevard/</link><pubDate>Mon, 26 Oct 2015 13:55:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces589d-boulevard/</guid><description/></item><item><title>POJ 2253 - Frogger (floyd)</title><link>https://111qqz.com/2015/10/poj2253-froggerfloyd/</link><pubDate>Thu, 22 Oct 2015 15:41:00 +0000</pubDate><guid>https://111qqz.com/2015/10/poj2253-froggerfloyd/</guid><description>
A - Frogger
**Time Limit:**1000MS **Memory Limit:**65536KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists' sunscreen, he wants to avoid swimming and instead reach her by jumping.
Unfortunately Fiona's stone is out of his jump range.</description></item><item><title>codeforces #326 div 2 A. Duff and Meat(水）</title><link>https://111qqz.com/2015/10/codeforces326div2a-duffandmeat/</link><pubDate>Thu, 22 Oct 2015 12:17:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces326div2a-duffandmeat/</guid><description>
A. Duff and Meat
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Duff is addicted to meat! Malek wants to keep her happy for n days. In order to be happy in i-th day, she needs to eat exactly a__i kilograms of meat.
There is a big shop uptown and Malek wants to buy meat for her from there. In i-th day, they sell meat for p__i dollars per kilogram.</description></item><item><title>zoj 3633 - Alice's present(暴力？set)</title><link>https://111qqz.com/2015/10/zoj3633-alicespresentset/</link><pubDate>Thu, 22 Oct 2015 11:12:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3633-alicespresentset/</guid><description/></item><item><title>zoj 3635 Cinema in Akiba (树状数组求第K大)</title><link>https://111qqz.com/2015/10/zoj3635cinemainakibak/</link><pubDate>Thu, 22 Oct 2015 02:54:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3635cinemainakibak/</guid><description>
Cinema in Akiba
Cinema in Akiba (CIA) is a small but very popular cinema in Akihabara. Every night the cinema is full of people. The layout of CIA is very interesting, as there is only one row so that every audience can enjoy the wonderful movies without any annoyance by other audiences sitting in front of him/her.
The ticket for CIA is strange, too. There are n seats in CIA and they are numbered from 1 to n in order.</description></item><item><title>zoj 3625 D - Geek's Collection(正项无穷级数，麦克劳林展开式，2015年10月AC)</title><link>https://111qqz.com/2015/10/zoj3625d-geekscollection201510ac/</link><pubDate>Thu, 22 Oct 2015 02:02:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3625d-geekscollection201510ac/</guid><description>
D - Geek's Collection
**Time Limit:**2000MS **Memory Limit:**65536KB 64bit IO Format:%lld &amp;amp; %llu
Submit Status
Description
The word geek is a slang term, with different meanings ranging from &amp;quot;a computer expert or enthusiast&amp;quot; to &amp;quot;a carnival performer who performs sensationally morbid or disgusting acts&amp;quot;, with a general pejorative meaning of &amp;quot;a peculiar or otherwise dislikable person, especially one who is perceived to be overly intellectual&amp;quot;.
The definition of geek has changed considerably over time, and there is no longer a definitive meaning.</description></item><item><title>zoj 3624(lucas定理)</title><link>https://111qqz.com/2015/10/zoj3624lucas/</link><pubDate>Mon, 19 Oct 2015 23:54:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3624lucas/</guid><description/></item><item><title>zoj 3631 J - Watashi's BG (双向暴力)</title><link>https://111qqz.com/2015/10/zoj3631j-watashisbg/</link><pubDate>Mon, 19 Oct 2015 13:28:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3631j-watashisbg/</guid><description/></item><item><title>51nod 1106 质数检测(miller rabin 素数测试.)</title><link>https://111qqz.com/2015/10/51nod1106millerrabin-/</link><pubDate>Mon, 19 Oct 2015 10:56:00 +0000</pubDate><guid>https://111qqz.com/2015/10/51nod1106millerrabin-/</guid><description>
1106 质数检测 基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题
收藏
关注
给出N个正整数，检测每个数是否为质数。如果是，输出&amp;quot;Yes&amp;quot;，否则输出&amp;quot;No&amp;quot;。
Input
第1行：一个数N，表示正整数的数量。(1 &amp;lt;= N &amp;lt;= 1000) 第2 - N + 1行：每行1个数(2 &amp;lt;= S[i] &amp;lt;= 10^9) Output
输出共N行，每行为 Yes 或 No。 Input示例
5 2 3 4 5 6 Output示例
Yes Yes No Yes No&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;miller rabin 素数测试... &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 1&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;/*&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;************************************************************************ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 2&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; File Name: code/51nod/1106.</description></item><item><title>51nod 1001 数组中和等于k的数对（单调性优化）</title><link>https://111qqz.com/2015/10/51nod1001k/</link><pubDate>Mon, 19 Oct 2015 10:47:00 +0000</pubDate><guid>https://111qqz.com/2015/10/51nod1001k/</guid><description/></item><item><title>zoj 3623 B - Battle Ships (完全背包？泛化背包？)</title><link>https://111qqz.com/2015/10/zoj3623b-battleships/</link><pubDate>Mon, 19 Oct 2015 10:25:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3623b-battleships/</guid><description/></item><item><title>zoj 3622 Magic Number （构造？）</title><link>https://111qqz.com/2015/10/zoj3622magicnumber/</link><pubDate>Mon, 19 Oct 2015 05:20:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3622magicnumber/</guid><description/></item><item><title>zoj 3903 Ant(推公式，逆元）</title><link>https://111qqz.com/2015/10/zoj3903ant/</link><pubDate>Sun, 18 Oct 2015 14:22:00 +0000</pubDate><guid>https://111qqz.com/2015/10/zoj3903ant/</guid><description/></item><item><title>hdu 2531 Catch him (bfs)</title><link>https://111qqz.com/2015/10/hdu2531catchhimbfs/</link><pubDate>Mon, 12 Oct 2015 05:12:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu2531catchhimbfs/</guid><description>
Catch him **Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 664 Accepted Submission(s): 307
**
Problem Description
在美式足球中，四分卫负责指挥整只球队的进攻战术和跑位，以及给接球员传球的任务。四分卫是一只球队进攻组最重要的球员，而且一般身体都相对比较弱小，所以通常球队会安排5-7名大汉来保护他，其中站在四分卫前方、排成一线的5名球员称为进攻锋线，他们通常都是135公斤左右的壮汉。
对防守方来说，攻击对手的四分卫当然是最直接的限制对手进攻的方法。如果效果好，就可以在对方四分卫传球之前将其按翻在地，称之为擒杀。擒杀是最好的鼓舞防守队士气的方法，因为对方连传球的机会都没有，进攻就结束了，还必须倒退一些距离开球。凶狠的擒杀甚至能够将对方的四分卫弄伤，从而迫使对方更换这个进攻核心。
在本题中，输入给出准备擒杀四分卫的防守球员的位置、对方每个进攻锋线球员的位置以及对方四分卫的位置，你的任务是求出这名准备擒杀的防守球员至少要移动多少步，才能够擒杀对方四分卫。
假设对方进攻锋线和四分卫在这个过程中都不会移动。只有1名防守球员，防守球员只要碰到对方四分卫就算擒杀。
所有的球员都是一块连续的、不中空的2维区域。防守球员不可以从进攻锋线的身体上穿过，也不可以从界外穿过(只能走空地)。
防守队员不可以转动身体，只能平移。防守队员的身体所有部分向同一个方向(上、下、左、右)移动1格的过程叫做1步。
Input
输入包含多组数据。每组数据第一行都是两个整数H，W(0输入保证符合上面的条件。防守球员的身体总共不超过20格。
Output
对每组数据，输出包含擒杀所需最少步数的一行。如果不能擒杀，输出带'Impossible'的一行。
Sample Input
6 6 .Q.... QQ..OO .OO..O ...O.O OO.O.. ....DD 7 7 .Q..... QQ.OOO. ...O... O...... OO..OO. .O..... .....DD 0 0
Sample Output
Impossible 9
这题最开始昨天晚上看到直接懵了．．．
人的身体有多部分＝＝　还不规则．．怎么搞．．．
然后昨天睡觉的时候灵光一现（大雾
今天起来搞搞搞...
竟然1A．．．．爽坏了
其实很简单．
就是只考虑一个点．
其他点存与最初这个点的相对位移．
然后只做这第一个点的bfs
只不过判断条件的时候要判断所有点的
以及是否摸（？）到四分卫的时候也要判断多个点的就好了．
&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 1&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;/*&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;************************************************************************ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 2&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; File Name: code/hdu/2531.</description></item><item><title>codeforces #324 div 2 A. Olesya and Rodion</title><link>https://111qqz.com/2015/10/codeforces324div2a-olesyaandrodion/</link><pubDate>Sun, 11 Oct 2015 15:53:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces324div2a-olesyaandrodion/</guid><description>
A. Olesya and Rodion
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Olesya loves numbers consisting of n digits, and Rodion only likes numbers that are divisible by t. Find some number that satisfies both of them.
Your task is: given the n and t print an integer strictly larger than zero consisting of n digits that is divisible by t.</description></item><item><title>51nod_learn_greedy_独木舟问题</title><link>https://111qqz.com/2015/10/51nod_learn_greedy_/</link><pubDate>Mon, 05 Oct 2015 11:53:00 +0000</pubDate><guid>https://111qqz.com/2015/10/51nod_learn_greedy_/</guid><description/></item><item><title>51nod_learn_greedy_活动安排2</title><link>https://111qqz.com/2015/10/51nod_learn_greedy_2/</link><pubDate>Mon, 05 Oct 2015 11:35:00 +0000</pubDate><guid>https://111qqz.com/2015/10/51nod_learn_greedy_2/</guid><description>
有若干个活动，第i个开始时间和结束时间是[Si,fi)，同一个教室安排的活动之间不能交叠，求要安排所有活动，最少需要几个教室？
第一行一个正整数n (n &amp;lt;= 10000)代表活动的个数。 第二行到第(n + 1)行包含n个开始时间和结束时间。 开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 输出
一行包含一个整数表示最少教室的个数。 输入示例
3 1 2 3 4 2 9 输出示例
2&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;其实就是求某个时间点的最大厚度...&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;一开始傻逼了...&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;想着什么从１开始推过去...必然tle．．就没写＝＝&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;然后今天再开...我只要把开始时间和结束时间放在一起排序...从小到大&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;然后用一个boolean做好标记就好...&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;有点像海洋兄的收费站的比喻？ &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 1&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;/*&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;************************************************************************ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 2&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; File Name: code/51nod/learn/greedy/2.cpp &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 3&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; Author: 111qqz &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 4&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; Email: rkz2013@126.com &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 5&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; &amp;gt; Created Time: 2015年10月05日 星期一 19时24分32秒 &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 6&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; ***********************************************************************&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;*/&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 7&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 8&amp;lt;/span&amp;gt; #include&amp;lt;iostream&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt; 9&amp;lt;/span&amp;gt; #include&amp;lt;iomanip&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;10&amp;lt;/span&amp;gt; #include&amp;lt;cstdio&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;11&amp;lt;/span&amp;gt; #include&amp;lt;algorithm&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;12&amp;lt;/span&amp;gt; #include&amp;lt;cmath&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;13&amp;lt;/span&amp;gt; #include&amp;lt;cstring&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;14&amp;lt;/span&amp;gt; #include&amp;lt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;string&amp;lt;/span&amp;gt;&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;15&amp;lt;/span&amp;gt; #include&amp;lt;map&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;16&amp;lt;/span&amp;gt; #include&amp;lt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;set&amp;lt;/span&amp;gt;&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;17&amp;lt;/span&amp;gt; #include&amp;lt;queue&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;18&amp;lt;/span&amp;gt; #include&amp;lt;vector&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;19&amp;lt;/span&amp;gt; #include&amp;lt;stack&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;20&amp;lt;/span&amp;gt; #include&amp;lt;cctype&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;21&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;22&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;#define&amp;lt;/span&amp;gt; yn hez111qqz &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;23&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;#define&amp;lt;/span&amp;gt; j1 cute111qqz &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;24&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;#define&amp;lt;/span&amp;gt; ms(a,x) memset(a,x,sizeof(a)) &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;25&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;using&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;namespace&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; std; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;26&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; dx4[&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;4&amp;lt;/span&amp;gt;]={&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;,&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;,&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;,-&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;}; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;27&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; dy4[&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;4&amp;lt;/span&amp;gt;]={&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;,-&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;,&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;,&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;}; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;28&amp;lt;/span&amp;gt; typedef &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;long&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;long&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; LL; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;29&amp;lt;/span&amp;gt; typedef &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;double&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; DB; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;30&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; inf = &amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;0x3f3f3f3f&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;31&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; N=1E4+&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;5&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;32&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; n; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;33&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; Q &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;34&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;{ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;35&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; t; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;36&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;bool&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; sta; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;37&amp;lt;/span&amp;gt; }q[&amp;lt;span style=&amp;quot;color: #800080;&amp;quot;&amp;gt;2&amp;lt;/span&amp;gt;*&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;N]; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;38&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;39&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;bool&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; cmp(Q a,Q b) &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;40&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;{ &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #008080;&amp;quot;&amp;gt;41&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; a.</description></item><item><title>hdu 1240 Asteroids! (bfs)</title><link>https://111qqz.com/2015/10/hdu1240asteroidsbfs/</link><pubDate>Mon, 05 Oct 2015 11:10:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu1240asteroidsbfs/</guid><description/></item><item><title>hdu 1072 Nightmare(bfs)</title><link>https://111qqz.com/2015/10/hdu1072nightmarebfs/</link><pubDate>Sun, 04 Oct 2015 09:33:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu1072nightmarebfs/</guid><description/></item><item><title>codeforces #323 div 2 B. Robot's Task(又是暴力？</title><link>https://111qqz.com/2015/10/codeforces323div2b-robotstask/</link><pubDate>Sun, 04 Oct 2015 08:33:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces323div2b-robotstask/</guid><description/></item><item><title>codeforces #323 div 2 A. Asphalting Roads(暴力</title><link>https://111qqz.com/2015/10/codeforces323div2a-asphaltingroads/</link><pubDate>Sun, 04 Oct 2015 08:23:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces323div2a-asphaltingroads/</guid><description/></item><item><title>codeforces #323 div 2 C. GCD Table (暴力？)</title><link>https://111qqz.com/2015/10/codeforces323div2c-gcdtable/</link><pubDate>Sun, 04 Oct 2015 08:16:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces323div2c-gcdtable/</guid><description>
C. GCD Table
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
The GCD table G of size n × n for an array of positive integers a of length n is defined by formula
Let us remind you that the greatest common divisor (GCD) of two positive integers x and y is the greatest integer that is divisor of both x and y, it is denoted as .</description></item><item><title>有一种板刷poj的冲动</title><link>https://111qqz.com/2015/10/poj/</link><pubDate>Sat, 03 Oct 2015 19:12:00 +0000</pubDate><guid>https://111qqz.com/2015/10/poj/</guid><description>
sigh</description></item><item><title>hdu 1242 Rescue(bfs+优先队列)</title><link>https://111qqz.com/2015/10/hdu1242rescuebfs/</link><pubDate>Sat, 03 Oct 2015 14:44:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu1242rescuebfs/</guid><description/></item><item><title>hdu 1195 Open the Lock(bfs)</title><link>https://111qqz.com/2015/10/hdu1195openthelockbfs/</link><pubDate>Fri, 02 Oct 2015 08:49:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu1195openthelockbfs/</guid><description/></item><item><title>好虚啊.</title><link>https://111qqz.com/2015/10/</link><pubDate>Fri, 02 Oct 2015 06:30:00 +0000</pubDate><guid>https://111qqz.com/2015/10/</guid><description>
也许今年不该参赛的....
因为暑假才刚刚调整好心态...
上学期基本废掉了...
感觉就是虚得不行，什么都不会的感觉....
．．．
倒是每天做题都能把自己搞得excited
大概越是弱的人越容易exicted吧．</description></item><item><title>hdu 2102 A计划( bfs)</title><link>https://111qqz.com/2015/10/hdu2102abfs/</link><pubDate>Fri, 02 Oct 2015 06:20:00 +0000</pubDate><guid>https://111qqz.com/2015/10/hdu2102abfs/</guid><description/></item><item><title>poj 1067||hdu 1527 取石子游戏（博弈论，Wythoff Game）</title><link>https://111qqz.com/2015/10/poj1067hdu1527wythoffgame/</link><pubDate>Thu, 01 Oct 2015 12:39:00 +0000</pubDate><guid>https://111qqz.com/2015/10/poj1067hdu1527wythoffgame/</guid><description/></item><item><title>codeforces #306 div 2 A - Two Substrings(随便搞)</title><link>https://111qqz.com/2015/10/codeforces306div2a-twosubstrings/</link><pubDate>Thu, 01 Oct 2015 11:40:00 +0000</pubDate><guid>https://111qqz.com/2015/10/codeforces306div2a-twosubstrings/</guid><description/></item><item><title>codeforces #322 div 2　D. Three Logos (枚举)</title><link>https://111qqz.com/2015/09/codeforces322div2d-threelogos/</link><pubDate>Wed, 30 Sep 2015 17:41:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces322div2d-threelogos/</guid><description>
D. Three Logos
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Three companies decided to order a billboard with pictures of their logos. A billboard is a big square board. A logo of each company is a rectangle of a non-zero area.
Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left.</description></item><item><title>hdu 5481||bestcoder #57 div 2 C Desiderium (概率)</title><link>https://111qqz.com/2015/09/hdu5481bestcoder57div2cdesiderium/</link><pubDate>Wed, 30 Sep 2015 03:37:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu5481bestcoder57div2cdesiderium/</guid><description>
Desiderium **Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 427 Accepted Submission(s): 167 **
Problem Description
There is a set of intervals, the size of this set is n.
If we select a subset of this set with equal probability, how many the expected length of intervals' union of this subset is?
We assume that the length of empty set's union is 0, and we want the answer multiply 2n modulo 109+7.</description></item><item><title>codeforces #322 div 2 C. Developing Skills(乱搞)</title><link>https://111qqz.com/2015/09/codeforces322div2c-developingskills/</link><pubDate>Wed, 30 Sep 2015 02:38:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces322div2c-developingskills/</guid><description>
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Petya loves computer games. Finally a game that he's been waiting for so long came out!
The main character of this game has n different skills, each of which is characterized by an integer a__i from 0 to 100. The higher the number_a__i_ is, the higher is the i-th skill of the character.</description></item><item><title>codeforces #322 div 2 B. Luxurious Houses (思路)</title><link>https://111qqz.com/2015/09/codeforces322div2b-luxurioushouses/</link><pubDate>Mon, 28 Sep 2015 17:07:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces322div2b-luxurioushouses/</guid><description>
B. Luxurious Houses
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
The capital of Berland has n multifloor buildings. The architect who built up the capital was very creative, so all the houses were built in one row.
Let's enumerate all the houses from left to right, starting with one. A house is considered to be luxurious if the number of floors in it is strictly greater than in all the houses with larger numbers.</description></item><item><title>codeforces #322 div 2 A. Vasya the Hipster(纱布题)</title><link>https://111qqz.com/2015/09/codeforces322div2a-vasyathehipster/</link><pubDate>Mon, 28 Sep 2015 17:05:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces322div2a-vasyathehipster/</guid><description>
A. Vasya the Hipster
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.
According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.</description></item><item><title>[转自codeforces] How to come up with the solutions: techniques</title><link>https://111qqz.com/2015/09/codeforceshowtocomeupwiththesolutionstechniques/</link><pubDate>Mon, 28 Sep 2015 16:04:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforceshowtocomeupwiththesolutionstechniques/</guid><description>
As I work with students I often face the situation when if a problem doesn't seem clear to a student at the first sight, it makes them unable to solve it. Indeed, you always hear about specific methods and techniques. But you don't hear about how to think in order to apply them. In this note I'll try to sum up my experience of solving programming contest problems. However, some pieces of advice will also be applicable for olympiads in mathematics and your first steps in academic research.</description></item><item><title>uva 489</title><link>https://111qqz.com/2015/09/uva489/</link><pubDate>Mon, 28 Sep 2015 10:25:00 +0000</pubDate><guid>https://111qqz.com/2015/09/uva489/</guid><description>
In ``Hangman Judge,'' you are to write a program that judges a series of Hangman games. For each game, the answer to the puzzle is given as well as the guesses. Rules are the same as the classic game of hangman, and are given as follows:
1. The contestant tries to solve to puzzle by guessing one letter at a time. 2. Every time a guess is correct, all the characters in the word that match the guess will be ``turned over.</description></item><item><title>hdoj 5479 || bestcoder #57 div 2 A Scaena Felix(模拟)</title><link>https://111qqz.com/2015/09/hdoj5479/</link><pubDate>Sat, 26 Sep 2015 17:25:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdoj5479/</guid><description>
模拟．
直接搞...
并不明白坑在哪里．．．
排在我前面被hack了１００多人...
/************************************************************************* &amp;gt; File Name: code/bc/#57/1001.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月26日 星期六 19时04分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E3+7; char str[N]; int len; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>hdu 5480|| bestcoder 　　＃５７　div 2　Conturbatio（前缀和｜｜树状数组）</title><link>https://111qqz.com/2015/09/hdu5480/</link><pubDate>Sat, 26 Sep 2015 17:20:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu5480/</guid><description>
比较水．
唯一一点需要注意的是...
可能有重复元素...
因为我的思路是用两棵一维树状数组搞..
每个点标记为1
然后看矩形的两个方向中是否至少有一个方向上和等于长度...
所以这样如果有重复元素的话，不处理会出错..　但实际上又没修改..直接前缀和就好了．．．
树状数组个毛线．．．
不过看到还有人线段树搞得233333
/************************************************************************* &amp;gt; File Name: code/bc/#57/1002.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月26日 星期六 19时31分10秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E5+7; int c[N],d[N]; int n,m,K,Q; bool vx[N],vy[N]; int lowbit(int x) { return x&amp;amp;(-x); } void update ( int x,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) { c[i] = c[i] + delta; } } LL sum ( int x) { LL res = 0 ; for ( int i = x ; i &amp;gt;= 1 ; i = i - lowbit(i)) { res = res + c[i]; } return res; } void update2( int y,int delta) { for ( int i = y ; i &amp;lt;= m ; i = i + lowbit(i)) { d[i] = d[i] + delta; } } LL sum2( int y) { LL res = 0 ; for ( int i = y ; i &amp;gt;= 1 ; i = i - lowbit(i)) { res = res + d[i]; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces #321 div 2 B. Kefa and Company(尺取法)</title><link>https://111qqz.com/2015/09/codeforces321div2b-kefaandcompany/</link><pubDate>Fri, 25 Sep 2015 14:46:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces321div2b-kefaandcompany/</guid><description>
B. Kefa and Company
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company.
Kefa has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa.</description></item><item><title>poj 2739 Sum of Consecutive Prime Numbers (尺取法)</title><link>https://111qqz.com/2015/09/poj2739/</link><pubDate>Fri, 25 Sep 2015 05:27:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2739/</guid><description>
一开始迷之wa...
先找出素数下标的上界就可以A...
然后纠结了２０分钟．．．
然后发现是预处理的素数少了一个素数．．
我预处理是处理到＜１０００５的素数．．．
最大数１００００,而超过１００００的第一个素数是１０００７
这样判断终止条件就会死循环...
sad
/************************************************************************* &amp;gt; File Name: code/poj/2739.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月25日 星期五 01时32分43秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; int pri[10005]; int n ; int mx; bool prime ( int n) { if (n&amp;lt;=3) return true; for ( int i = 2 ; i*i&amp;lt;= n ; i++) { if (n%i==0) return false; } return true; } void solve() { int head = 1; int tail = 1; int sum = 0 ; int ans = 0 ; while (pri[tail]&amp;lt;=n) { cout&amp;lt;&amp;lt;&amp;quot;asd&amp;quot;&amp;lt;&amp;lt;endl; sum = sum + pri[tail]; if (sum&amp;gt;=n) { while (sum&amp;gt;n) { sum = sum - pri[head]; head++; } if (sum==n) { ans++; } } tail++; } printf(&amp;quot;%d\n&amp;quot;,ans); } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;in.</description></item><item><title>poj 2100 Graveyard Design (two pointers ，尺取法)</title><link>https://111qqz.com/2015/09/poj2100/</link><pubDate>Thu, 24 Sep 2015 17:29:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2100/</guid><description>
不多说，直接代码。
/************************************************************************* &amp;gt; File Name: code/poj/2100.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月25日 星期五 00时42分49秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; LL n; LL maxn; vector&amp;lt;LL&amp;gt;ans; void solve() { LL head = 1,tail = 1; LL sum = 0 ; while (tail&amp;lt;=maxn) { sum = sum + tail*tail; if (sum&amp;gt;=n) { while (sum&amp;gt;n)//主要是while，因为可能要减掉多个才能小于n { sum -= head*head; head++; } if (sum==n) {//因为要先输出答案个数.</description></item><item><title>poj 2566 Bound Found (前缀和，尺取法（two pointer）)</title><link>https://111qqz.com/2015/09/poj2566/</link><pubDate>Thu, 24 Sep 2015 16:26:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2566/</guid><description>
题意　：给定一个长度为n的区间．然后给k次询问，每次一个数t,求一个区间[l,r]使得这个区间和的绝对值最接近t
没办法直接尺取.
先预处理出来前缀和
如果要找一对区间的和的绝对值最最近t
等价于找到两个数i和j,使得sum[i]-sum[j]的绝对值最接近t,且i&amp;lt;&amp;gt;j
那么对前缀和排序...然后尺取
因为答案要输出下标
所以之前先存一下下标．
然后对于i，j
所对应的区间为[min(pre[i].id,pre[j].id)+1,max(pre[i],id,pre[j].id)];
/************************************************************************* &amp;gt; File Name: code/poj/2566.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月24日 星期四 22时10分08秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int N=1E5+7; const int inf = 0x3f3f3f3f; int a[N]; int n ,k; struct Q { int id; int sum; }pre[N]; bool cmp(Q a,Q b) { if (a.</description></item><item><title>poj 3320 Jessica's Reading Problem (尺取法)</title><link>https://111qqz.com/2015/09/poj3320jessicasreadingproblem/</link><pubDate>Thu, 24 Sep 2015 13:37:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj3320jessicasreadingproblem/</guid><description>
Jessica's Reading Problem
**Time Limit:** 1000MS **Memory Limit:** 65536K **Total Submissions:** 8787 **Accepted:** 2824 Description
Jessica's a very lovely girl wooed by lots of boys. Recently she has a problem. The final exam is coming, yet she has spent little time on it. If she wants to pass it, she has to master all ideas included in a very thick text book.</description></item><item><title>迟取法</title><link>https://111qqz.com/2015/09/</link><pubDate>Thu, 24 Sep 2015 11:02:00 +0000</pubDate><guid>https://111qqz.com/2015/09/</guid><description/></item><item><title>poj 2159 Ancient Cipher(水)</title><link>https://111qqz.com/2015/09/poj2159/</link><pubDate>Wed, 23 Sep 2015 11:33:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2159/</guid><description>
由于顺序是可以改变的． 所以考虑是否可以映射．只要存在字母对应出现的次数都相同．那么就可以通过映射得到． 具体是开一个数组记录每个字母出现的次数... 然后sort
/************************************************************************* &amp;gt; File Name: code/poj/2159.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月23日 星期三 19时04分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=30; string st1,st2; int len; int a[N],b[N]; bool cmp( int a,int b) { if (a&amp;gt;b) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>hdu 1849Rabbit and Grass(一维nim游戏,sg函数)</title><link>https://111qqz.com/2015/09/hdu1849/</link><pubDate>Tue, 22 Sep 2015 12:47:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu1849/</guid><description>
Rabbit and Grass **Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3058 Accepted Submission(s): 2261 **
Problem Description
大学时光是浪漫的，女生是浪漫的，圣诞更是浪漫的，但是Rabbit和Grass这两个大学女生在今年的圣诞节却表现得一点都不浪漫：不去逛商场，不去逛公园，不去和AC男约会，两个人竟然猫在寝食下棋…… 说是下棋，其实只是一个简单的小游戏而已，游戏的规则是这样的： 1、棋盘包含1*n个方格，方格从左到右分别编号为0，1，2，…，n-1； 2、m个棋子放在棋盘的方格上，方格可以为空，也可以放多于一个的棋子； 3、双方轮流走棋； 4、每一步可以选择任意一个棋子向左移动到任意的位置（可以多个棋子位于同一个方格），当然，任何棋子不能超出棋盘边界； 5、如果所有的棋子都位于最左边（即编号为0的位置），则游戏结束，并且规定最后走棋的一方为胜者。
对于本题，你不需要考虑n的大小（我们可以假设在初始状态，棋子总是位于棋盘的适当位置）。下面的示意图即为一个1*15的棋盘，共有6个棋子，其中，编号8的位置有两个棋子。
大家知道，虽然偶尔不够浪漫，但是Rabbit和Grass都是冰雪聪明的女生，如果每次都是Rabbit先走棋，请输出最后的结果。
Input
输入数据包含多组测试用例，每个测试用例占二行，首先一行包含一个整数m（0&amp;lt;=m&amp;lt;=1000），表示本测试用例的棋子数目，紧跟着的一行包含m个整数Ki(i=1…m; 0&amp;lt;=Ki&amp;lt;=1000)，分别表示m个棋子初始的位置，m=0则结束输入。
Output
如果Rabbit能赢的话，请输出“Rabbit Win!”，否则请输出“Grass Win!”，每个实例的输出占一行。
Sample Input
2 3 5 3 3 5 6 0
Sample Output
Rabbit Win! Grass Win!
Author
lcy
Source
ACM Short Term Exam_2007/12/13
是一个略有变形的nim游戏模型
如果在i位置上有 k个棋子
我们可以看做有k堆数量为i的堆
可以向左移动1~i步
就可以看做每次从数量为i的堆中拿走数量１～i
这样就是nim游戏．
而nim游戏的结论是．．异或和为０必败．</description></item><item><title>hdu 2149Public Sale(博弈论　巴什博奕)</title><link>https://111qqz.com/2015/09/hdu2149/</link><pubDate>Tue, 22 Sep 2015 12:26:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu2149/</guid><description>
hdu 2149题目链接
题意＆思路：巴什博奕，点m是n点。。。然后往前画即可。。。
/************************************************************************* &amp;gt; File Name: code/hdu/2149.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 20时18分02秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>hdu 2188 悼念512汶川大地震遇难同胞——选拔志愿者 (巴什博奕)</title><link>https://111qqz.com/2015/09/hdu2188/</link><pubDate>Tue, 22 Sep 2015 12:14:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu2188/</guid><description>
题目链接：hdu 2188题目链接
题意＆思路：巴什博奕。。画n点p点。。。
/************************************************************************* &amp;gt; File Name: code/hdu/2188.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 20时08分08秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; void solve() { int n,m; scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m); if (n%(m+1)!</description></item><item><title>acm博弈论</title><link>https://111qqz.com/2015/09/acm/</link><pubDate>Tue, 22 Sep 2015 10:48:00 +0000</pubDate><guid>https://111qqz.com/2015/09/acm/</guid><description>
**序：**博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 寻找必败态即为针对此类试题给出一种解题思路。
此类问题一般有如下特点：
1、博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利。
2、博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负。
3、公平博弈。即两人进行决策所遵循的规则相同。
理论铺垫：
1、定义P-position和N-position：其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是&amp;quot;先手必败&amp;quot;，现在轮到move的人有必胜策略的局面是N-position，也就是&amp;quot;先手可保证必胜&amp;quot;。
（1）.无法进行任何移动的局面（也就是terminal position）是P-position；
（2）.可以移动到P-position的局面是N-position；
（3）.所有移动都导致N-position的局面是P-position。
2、P/N状态有如下性质：
（1）、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 （2）、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 （3）、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态 3、P点： 即必败点，某玩家位于此点，只要对方无失误，则必败；
N点： 即必胜点，某玩家位于此点，只要自己无失误，则必胜。
4、取石子游戏算法实现
步骤1:将所有终结位置标记为必败点（P点）；
步骤2: 将所有一步操作能进入必败点（P点）的位置标记为必胜点（N点）
步骤3:如果从某个点开始的所有一步操作都只能进入必胜点（N点） ，则将该点标记为必败点（P点） ；</description></item><item><title>uva 1587 Box（思路）</title><link>https://111qqz.com/2015/09/uva1587/</link><pubDate>Tue, 22 Sep 2015 08:49:00 +0000</pubDate><guid>https://111qqz.com/2015/09/uva1587/</guid><description>
给６个矩形的长和宽（或者宽和长），问这六个矩形能否组成一个长方体．
思路比较简单，不过需要注意的地方有点多．
首先由于长和宽的顺序为止，所以要处理一下（一开始只处理了后来读入的五组，没有处理单独读入的第一组，差评）
然后要判断能否分成两两相同的三组．
如果能，枚举８种可能的相等的情况．
/************************************************************************* &amp;gt; File Name: code/uva/1587.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 12时20分58秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; struct Q { int w,h; }a,b,c,q[10]; bool ok ( int i) { if (q[i].</description></item><item><title>bestcoder #56 div 2 C Clarke and puzzle (nim游戏　树状数组)</title><link>https://111qqz.com/2015/09/bestcoder56div2cclarkeandpuzzlenim/</link><pubDate>Tue, 22 Sep 2015 03:32:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bestcoder56div2cclarkeandpuzzlenim/</guid><description>
比赛的时候没过．还以为是树状数组写残了． 但实际上是有自己不知道的东西． 这种博弈叫　nim游戏 所以这是一个二维的nim游戏． **nim游戏的性质是xor 和为0必败，否则必胜． xor和也有前缀和性质，所以可以用树状数组维护．
/************************************************************************* &amp;gt; File Name: code/bc/#56/r1003.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 11时10分06秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E2+5; int c[N][N]; int a[N][N]; int n,m,q; int lowbit ( int x) { return x&amp;amp;(-x); } void update (int x,int y,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) { for ( int j = y ; j &amp;lt;= m ; j = j + lowbit(j)) { c[i][j]^=delta; } } } int sum( int x,int y) { int res = 0; for ( int i = x; i &amp;gt;= 1 ; i = i - lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j = j - lowbit(j)) { res ^= c[i][j]; } } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>nim遊戲的必勝策略（博弈論）</title><link>https://111qqz.com/2015/09/nim/</link><pubDate>Tue, 22 Sep 2015 03:06:00 +0000</pubDate><guid>https://111qqz.com/2015/09/nim/</guid><description>
假设有n堆石子，每堆石子的个数分别如下
a1, a2, a3, ... an
定义nim-sum为a1^a2^a3...an
可以证明
1. 若a1^a2^a3...an != 0
则经过一次合法的移动之后必定可变成
a1^a2....an = 0
此时留下的局面为必胜。
2. 若a1^a2^a3...an = 0
则经过一次合法的移动，局面必定成为
a1^a2^a3...an != 0
3. 只要在某回合中留下a1,a2...an
使a1^a2^a3...an = 0，此时局面必胜
证明1：假设a1^a2^a3...an != 0 = k
则查看k的最高位，假设是在第x位上，则此位上有a1x^a2x^a3x....anx = 1 (a1x表示a1写成二进制，取a1的第x位)
必然可以寻找到一个ai（至少一个），其aix = 1
此时有ai^k &amp;lt; ai
改变ai这堆石子使其成为ai^k
列出式子
a1^a2^a3..^ai^...an = k
则有
a1^a2^a3..^(ai^k)^...an = a1^a2^a3..^ai^...an^k = (a1^a2^a3..^ai^...an)^k = k^k = 0 即得证
证明2：使用反证法，
假设移动了ai堆石头使其成为ai'
有a1^a2^a3..ai..an = 0
即(a1^a2...a(i-1)^a(i+1)...an)^ai = 0 可得</description></item><item><title>bestcoder #56 div 2 B Clarke and problem(dp)</title><link>https://111qqz.com/2015/09/bestcoder56div2bclarkeandproblemdp/</link><pubDate>Tue, 22 Sep 2015 03:02:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bestcoder56div2bclarkeandproblemdp/</guid><description>
果然dp還是弱項啊啊啊啊．． 不過比最開始的完全無從下手強了不少應該．．．
至少dp狀態表示相對了．．．．轉移方程沒想出來嗚嗚嗚
官方題解：设d(i, j)d(i,j)表示前ii个数，模pp为jj的方案数，则容易得到d(0, 0)=1, d(i, j)=d(i-1, j)+sum_{j=0}^{p-1} d(i-1, (j-a[i]) mod p)d(0,0)=1,d(i,j)=d(i−1,j)+∑​j=0​p−1​​d(i−1,(j−a[i]) mod p)，很多人没1a是因为没注意|a_i| le 10^9∣a​i​​∣≤10​9​​
/************************************************************************* &amp;gt; File Name: code/bc/#56/1002.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 10时47分20秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N = 1E3+5; const int MOD = 1E9+7; LL a[N],dp[N][N]; int n,p; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>best coder #56 div 2 A　Clarke and minecraft（贪心）</title><link>https://111qqz.com/2015/09/bestcoder56div2aclarkeandminecraft/</link><pubDate>Tue, 22 Sep 2015 02:39:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bestcoder56div2aclarkeandminecraft/</guid><description>
贪心．．尽量把一样的材料放在一起．．． 然后写蠢了．．妈蛋．．． 详情见代码
/************************************************************************* &amp;gt; File Name: code/bc/#56/1001.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月19日 星期六 18时55分49秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E2+7; int a[N],b[N]; int ans,cnt; int p[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces #320 div 2A - Raising Bacteria (位运算）</title><link>https://111qqz.com/2015/09/codeforces320div2a-raisingbacteria/</link><pubDate>Fri, 18 Sep 2015 15:28:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces320div2a-raisingbacteria/</guid><description>
x的二进制表示中1的个数即为答案．
原因是，每天晚上糖果数量翻倍，相当于左移１位,这时候二进制表示中1的数量不变
也就是说，二进制表示中的所有的1，一定都是添加进去的
而且也只有二进制表示中的1是添加进去的
所以二进制表示中1的数量，就是添加的糖果数．
/************************************************************************* &amp;gt; File Name: code/cf/#320/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月18日 星期五 23时18分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE #endif int x; cin&amp;gt;&amp;gt;x; int ans = 0 ; while (x) { if (x%2==1) ans++; x = x / 2; } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; }</description></item><item><title>codeforces #319 div 2 E C. Points on Plane (分块)</title><link>https://111qqz.com/2015/09/codeforces319div2ec-pointsonplane/</link><pubDate>Fri, 18 Sep 2015 14:16:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces319div2ec-pointsonplane/</guid><description>
初识分快.
引一段题解：
Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.
Let's calculate the maximum length of such a way.</description></item><item><title>codeforces #319 C - Vasya and Petya's Game (数学)</title><link>https://111qqz.com/2015/09/codeforces319c-vasyaandpetyasgame/</link><pubDate>Fri, 18 Sep 2015 12:46:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces319c-vasyaandpetyasgame/</guid><description>
因为每一个正整数可以唯一分解质因数...
要看能猜多少次，只要知道不大于n的质因子数有多少个即可（相同的算多
由于n才是１０００．所以素数表随便搞就好....不用筛也行...
/************************************************************************* &amp;gt; File Name: code/cf/#319/C.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月18日 星期五 20时29分00秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E3+5; int pri[N]; int cnt; int n; int ans[N]; bool prime( int x) { if (x&amp;lt;=3) return true; for ( int i = 2 ; i *i &amp;lt;= x ; i++) { if (x%i==0) return false; } return true; } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;in.</description></item><item><title>codeforces #319 B - Modulo Sum (抽屉原理，dp)</title><link>https://111qqz.com/2015/09/codeforces319b-modulosumdp/</link><pubDate>Wed, 16 Sep 2015 03:24:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces319b-modulosumdp/</guid><description>
背包还是理解的不够透彻．．
因为每次都是用那个一维形式的．
这道题的做法类似01背包.
此外还可以有一个优化...
当n&amp;gt;m的时候．．．根绝抽屉原理．．一定为yes..
复杂度可以从o(nm)优到　o(m^2)
/************************************************************************* &amp;gt; File Name: code/cf/#319/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月15日 星期二 19时54分44秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; int a[N]; int dp[N]; void OneZeroPack(int cost,int value) { for ( int v = m ; v--; v &amp;gt;=cost) { dp[v] = max(dp[v],dp[v-cost]+value); } } int main() { #ifndef ONLINE_JUDGE #endif cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; if (n&amp;gt;=m) { puts(&amp;quot;YES&amp;quot;); return 0; } int k = 0; for ( int i = 0 ; i &amp;lt; n ; i++) { int x; scanf(&amp;quot;%d&amp;quot;,&amp;amp;x); if (x&amp;gt;m) continue; //大于背包容量的肯定直接舍去 k++; a[k] = x; } // for ( int i = 1 ; i &amp;lt;= k ; i++) cout&amp;lt;&amp;lt;&amp;quot;a[i]:&amp;quot;&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl; for ( int i = 0 ; i &amp;lt;= m ; i++) dp[i] = -inf; dp[0] = 0 ; for ( int i = 1 ; i &amp;lt;= k ; i++) { OneZeroPack(a[i],a[i]); } for ( int i = 0 ; i &amp;lt;= m ; i++) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;dp[i]&amp;lt;&amp;lt;endl; if (dp[m]==-inf) { puts(&amp;quot;NO&amp;quot;); } else { puts(&amp;quot;YES&amp;quot;); } #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; }</description></item><item><title>uva 1584 Circular Sequence (字符串处理)</title><link>https://111qqz.com/2015/09/uva1584circularsequence/</link><pubDate>Tue, 15 Sep 2015 11:39:00 +0000</pubDate><guid>https://111qqz.com/2015/09/uva1584circularsequence/</guid><description/></item><item><title>uva 1583 B - Digit Generator　(暴力)</title><link>https://111qqz.com/2015/09/uva1583b-digitgenerator/</link><pubDate>Tue, 15 Sep 2015 09:28:00 +0000</pubDate><guid>https://111qqz.com/2015/09/uva1583b-digitgenerator/</guid><description/></item><item><title>uva 340 A - Master-Mind Hints (暴力)</title><link>https://111qqz.com/2015/09/uva340a-master-mindhints/</link><pubDate>Tue, 15 Sep 2015 09:25:00 +0000</pubDate><guid>https://111qqz.com/2015/09/uva340a-master-mindhints/</guid><description/></item><item><title>codeforces #519 A A. Multiplication Table (暴力)</title><link>https://111qqz.com/2015/09/codeforces519aa-multiplicationtable/</link><pubDate>Mon, 14 Sep 2015 12:22:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces519aa-multiplicationtable/</guid><description>
A. Multiplication Table
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Let's consider a table consisting of n rows and n columns. The cell located at the intersection of i-th row and j-th column contains number i × j. The rows and columns are numbered starting from 1.
You are given a positive integer x. Your task is to count the number of cells in a table that contain number x.</description></item><item><title>bc #54 A problem of sorting</title><link>https://111qqz.com/2015/09/bc54aproblemofsorting/</link><pubDate>Sat, 05 Sep 2015 12:54:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bc54aproblemofsorting/</guid><description/></item><item><title>心情流+2015暑假总结？+期望？</title><link>https://111qqz.com/2015/09/2015/</link><pubDate>Wed, 02 Sep 2015 15:30:00 +0000</pubDate><guid>https://111qqz.com/2015/09/2015/</guid><description>
其实不应该在博客上写这种心情流的东西。。。。。。
显得好矫情啊。。。。。
心里好烦。。。。
妈蛋。。。。
到底要怎么办怎么办怎么办
从来都处理不好感情的事。。。
啊，虽然过了这么久。。
but....天天上课见啊。。。
暑假集训还要见啊。。。。见啊。。。见啊。。。。
一堆共同群啊喂。。。。。。
嗯。。。我知道这个博客会有队里的同学。。。或者学长偶尔也会看。。。。but总不能在空间人人朋友圈之类的乱说一通吧。。。求你们看见当没看见。。。谢谢。。。。
写出来是因为不写出来太难受。。。。心里好憋屈。。。。
其实只做错了一件事。。。。就是和她的事。。。。
我真的不知道怎么处理了。。。。
天天见面。。。。天天见面。。。。。天天见面。。。。。
天天见面。。。。天天见面。。。。。天天见面。。。。。
我又不是那种会处理感情的人。。。。唯一处理这种事情的经验就是长时间不见面&amp;gt;_&amp;lt;
然后又天天见面天天见面天天见面。。。。。
又不能因为这样的事情就不去搞ACM吧。。。。
在队群里连话都不想说。。。嘛，不过我这么弱，好像也没什么好说的（？
不过问问题啊喂。。。。请教学长都觉得好别扭。。。。。
求问我心里阴影面积怎么算。。。。
不过还好还可以请教其他群的大神。。。不过总归是不如请教自己的直系学长方便呀。。。。sigh....
真是sad....我觉得我三年五年之内是不会再对妹子感兴趣了。。。。。。
哦对。。。ACM。。。。其实后期暑假很多集训都没去。。。。因为真的是不想见。。。。。。。。。
然后还被虐。。。。天天被她踩。。。。。。。。。。。。。。。。。。。
然后自己刷了点专题。。。清了十多场BC和十多场CF的题。。。感觉还是挺有收货的？
vj最近上不去。。。。忽然忘记自己假期都干过什么了。。。sad...
大概刷了个基础搜索？ 然后学了树状数组？带花样的树状数组还是做了些的。。。。
然后。。。。好像就都是比较零散的了？ 来一个做一个的样子。。。。
不过确实感觉有进步吧。。。虽然还是挺弱的。。。。 cf 认真一点打（不要听音乐！不要听音乐！不要听音乐！）还是在涨的。。。。。我又注册了个小号==
不过进步的的确有点慢。。。都不好意思和适牛说话啦。。。。
感觉这样学起来有些太零散啦。。。。
大概应该多看看书？
貌似那种不看书直接刷题的套路noip骗个省一什么的倒是没问题。。。
不过果然还是不怎么系统吧。。。。。
心态什么的还是好了挺多吧。。。感觉自己沉下来了。。。。不那么浮躁了。。。。大概是死生有命富贵在天？2333333
虽然感觉一边是自己最喜欢的味道，而另一边的会让自己过敏。。。
正如ACM和某妹子。。。。2333333
这学期要填各种坑。。。。转专业的坑+上学期作的死。。。。
但愿能活过这学期吧。。。。
最后。。。。 orz Pacedect？</description></item><item><title>vimrc备份</title><link>https://111qqz.com/2015/08/vimrc/</link><pubDate>Sun, 23 Aug 2015 16:20:00 +0000</pubDate><guid>https://111qqz.com/2015/08/vimrc/</guid><description>
map &amp;lt;F9&amp;gt; :call SaveInputData()&amp;lt;CR&amp;gt; func! SaveInputData() exec &amp;quot;tabnew&amp;quot; exec 'normal &amp;quot;+gP' exec &amp;quot;w! code/in.txt&amp;quot; endfunc &amp;quot;colorscheme torte &amp;quot; colorscheme murphy colorscheme elflord &amp;quot; colorscheme molokai &amp;quot;colorscheme elisex &amp;quot;colorscheme colorer &amp;quot;colorscheme blacklight &amp;quot;colorscheme blue &amp;quot;colorscheme darkblue &amp;quot;colorscheme evening &amp;quot;colorscheme shine &amp;quot;set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936 &amp;quot;set termencoding=utf-8 &amp;quot;set encoding=utf-8 &amp;quot;set fileencodings=ucs-bom,utf-8,cp936 &amp;quot;set fileencoding=utf-8 &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot; 显示相关 &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;set shortmess=atI &amp;quot; 启动的时候不显示那个援助乌干达儿童的提示 &amp;quot;winpos 5 5 &amp;quot; 设定窗口位置 &amp;quot;set lines=40 columns=155 &amp;quot; 设定窗口大小 set go= &amp;quot; 不要图形按钮 &amp;quot;color asmanian2 &amp;quot; 设置背景主题 &amp;quot;set guifont=Courier_New:h10:cANSI &amp;quot; 设置字体 syntax on &amp;quot; 语法高亮 autocmd InsertLeave * se nocul &amp;quot; 用浅色高亮当前行 autocmd InsertEnter * se cul &amp;quot; 用浅色高亮当前行 &amp;quot;set ruler &amp;quot; 显示标尺 set showcmd &amp;quot; 输入的命令显示出来，看的清楚些 &amp;quot;set cmdheight=1 &amp;quot; 命令行（在状态行下）的高度，设置为1 &amp;quot;set whichwrap+=&amp;lt;,&amp;gt;,h,l &amp;quot; 允许backspace和光标键跨越行边界(不建议) &amp;quot;set scrolloff=3 &amp;quot; 光标移动到buffer的顶部和底部时保持3行距离 set novisualbell &amp;quot; 不要闪烁(不明白) set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&amp;quot;%d/%m/%y\ -\ %H:%M\&amp;quot;)} &amp;quot;状态行显示的内容 set laststatus=1 &amp;quot; 启动显示状态行(1),总是显示状态行(2) &amp;quot;set foldenable &amp;quot; 允许折叠 set foldmethod=manual &amp;quot; 手动折叠 &amp;quot;set background=dark &amp;quot;背景使用黑色 set nocompatible &amp;quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限 &amp;quot; 显示中文帮助 if version &amp;gt;= 603 set helplang=cn set encoding=utf-8 endif &amp;quot; 设置配色方案 &amp;quot;colorscheme murphy &amp;quot;字体 &amp;quot;if (has(&amp;quot;gui_running&amp;quot;)) &amp;quot; set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 &amp;quot;endif &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;新文件标题 &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; &amp;quot;新建.</description></item><item><title>codeforces # 317 div 2 B. Order Book（模拟）</title><link>https://111qqz.com/2015/08/codeforces317div2b-orderbook/</link><pubDate>Sun, 23 Aug 2015 08:13:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces317div2b-orderbook/</guid><description>
B. Order Book
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
In this task you need to process a set of stock exchange orders and use them to create order book.
An order is an instruction of some participant to buy or sell stocks on stock exchange. The order number i has price p__i, direction d__i -- buy or sell, and integer q__i.</description></item><item><title>codeforces #317 div2 A. Arrays (水)</title><link>https://111qqz.com/2015/08/codeforces317div2a-arrays/</link><pubDate>Sun, 23 Aug 2015 08:06:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces317div2a-arrays/</guid><description>
应该３分钟过的题。。。
结果花了８分钟。。。ssssad
/************************************************************************* &amp;gt; File Name: code/cf/#317/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月23日 星期日 00时29分47秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E5+7; int na,nb,k,m; int a[N],b[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>bc #52 div 2 A ||hdoj5417 Victor and Machine (模拟)</title><link>https://111qqz.com/2015/08/hdoj5417/</link><pubDate>Sat, 22 Aug 2015 15:19:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdoj5417/</guid><description>
傻逼模拟题
我做了半小时....
sssssad
/************************************************************************* &amp;gt; File Name: code/bc/#52/1001.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月22日 星期六 18时51分44秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E6+7; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>bc #52 div 2 B || hdoj 5418 Victor and World(tsp问题,状压dp)</title><link>https://111qqz.com/2015/08/hdoj5418/</link><pubDate>Sat, 22 Aug 2015 15:09:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdoj5418/</guid><description>
比赛的时候一看,tsp么
前些天好像刚写过一个clean robot什么的
然后发现n才16,而m很大..
应该有很多重复的.
那么我们取油费最少的.
然后先做一遍 floyd
之后我写了一个dfs...TLE 了...sad
正解是状压dp
虽然没写过状压dp
但是之前写过一道状态压缩的bfs
所以理解起来没有问题.
这道题的做法是:
用dp[i][j]表示当前访问国家的状态为s,要访问的国家为j的时候的最小费用.i是二进制,i的第p位为1表示第p个国家已经访问过了,否则表示没有访问过.
那么状态转移方程则为:dp[i|(1&amp;lt;
初始化的时候d[i][i] =0,其他为inf
dp[0][0] 表示要访问第一个国家且没有访问国人国家的时候的状态,此时花费为0
然后先枚举访问国家的状态,再枚举访问的国家.
/************************************************************************* &amp;gt; File Name: code/bc/#52/rrr1002.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月22日 星期六 22时33分20秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=17; int d[N][N]; int n,m; int dp[(1&amp;lt;&amp;lt;16)+5][N]; void floyd(){ For(k,n){ For(i,n){ For (j,n){ d[i][j] = min ( d[i][j] , d[i][k]+d[k][j]); } } } } void solve() { dp[0][0] = 0; for ( int i = 0 ; i &amp;lt;(1&amp;lt;&amp;lt;n) ; i ++){ for ( int j = 0 ; j &amp;lt; n ;j++){ if (dp[i][j]!</description></item><item><title>acm输出输出技巧（提交oj不需要改变）</title><link>https://111qqz.com/2015/08/acmoj/</link><pubDate>Sat, 22 Aug 2015 10:41:00 +0000</pubDate><guid>https://111qqz.com/2015/08/acmoj/</guid><description>
int main() { int a,b; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); #endif // int a,b; while (scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b)!=EOF){ cout&amp;lt;&amp;lt;a+b&amp;lt;&amp;lt;endl; } #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; } 这样写比较爽
交OJ什么都不用改
，妈妈再也不用担心我累死在输入样例＆调试上了。。。</description></item><item><title>关于ACM的输入输出（一）</title><link>https://111qqz.com/2015/08/acm/</link><pubDate>Sat, 22 Aug 2015 10:13:00 +0000</pubDate><guid>https://111qqz.com/2015/08/acm/</guid><description>
关于ACM的输入输出（一）
写给第一次参加现场赛的同学们
一般来说ACM的现场赛会规定输入输出
或者是文件输入标准输出
也可能是文件输入文件输出
如果没有规定的话那么一般就是标准的输入输出了
那说一下输入输出的重定向
一般用下面两种方法
c++常用:
#include
ifstream filein(&amp;quot;data.in&amp;quot;); // 定义一个文件输入流
ofstream fileout(&amp;quot;data.out&amp;quot;); //cout&amp;lt;&amp;lt; --&amp;gt; fileout&amp;lt;&amp;lt;
filein.eof() //文件到末尾,返回非零值
data.in表示输入的数据文件
本地测试的话本来输入的数据就要在这个文件里面测试了
建一个本地的文本data.in,可以用记事本的方式打开
注意:文件输入的话,以后的cin&amp;gt;&amp;gt;都要改成filein&amp;gt;&amp;gt;, cout&amp;lt;&amp;lt;都要改成fileout&amp;lt;&amp;lt;
c语言常用:
freopen(&amp;quot;date.in&amp;quot;,&amp;quot;r&amp;quot;,stdin); //重定向所有标准的输入为文件输入
freopen(&amp;quot;date.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);//重定向所有标准的输出为文件输出
fclose(stdout);//输出结束
freopen(&amp;quot;date.in&amp;quot;,&amp;quot;r&amp;quot;,stdin); //重定向所有标准的输入为文件输入
freopen(&amp;quot;date.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);//重定向所有标准的输出为文件输出
fclose(stdout);//输出结束
第一句的意思就是文件输入,以&amp;quot;读状态&amp;quot;,去替换标准的输入
以上如果只是规定用文件输入输出 的某一种,那么就只用其中的一种
关于ACM的输入输出（二）
ACM题目特点: 由于ACM竞赛题目的输入数据和输出数据一般有多组（不定），并且格式多种多样，所以，如何处理题目的输入输出是对大家的一项最基本的要求。这也是困扰初学者的一大问题。 ACM的输入输出要求严格按照规定来，所以你不需要输出像&amp;quot;Please input the data&amp;quot;这类的提示语。否则将会被判Wrong Answer。
1、输入
初学者一般有个误区：如果题目包含多组测试数据，他们就会把输入的内容全部保存起来，然后再依次处理。
其实程序的输入/输出是相互独立的，因此，每当处理完一组测试数据，就应当按题目要求进行相应的输出操作。而不必将所有结果储存起来一起输出。
下面来介绍一下ACM中常见的一些输入情况。
只有一组测试数据
这类题目是最简单的，比如第1000题。参考代码：
#include
int main(void)
{
int a, b;
scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a;, &amp;amp;b;);
printf(&amp;quot;%d/n&amp;quot;, a + b);
return 0;
}</description></item><item><title>poj 2909 Goldbach's Conjecture （哥德巴赫猜想）</title><link>https://111qqz.com/2015/08/poj2909/</link><pubDate>Sat, 22 Aug 2015 06:43:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2909/</guid><description>
水题
写一遍的目的是。。。复习一下快速筛的写法　喵呜
/************************************************************************* &amp;gt; File Name: code/poj/2909.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月22日 星期六 14时25分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x3f3f3f3f; const int N=1&amp;lt;&amp;lt;16; bool not_prime[N]; int prime[N]; int prime_num; int n; void init(){ not_prime[0] = true; not_prime[1] = true; for ( int i =2 ; i &amp;lt; N ; i++){ if (!</description></item><item><title>poj 1305 (毕达哥拉斯三元组，构造勾股数)</title><link>https://111qqz.com/2015/08/poj1305/</link><pubDate>Sat, 22 Aug 2015 06:18:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj1305/</guid><description>
题意是说，能构造多少本元勾股数和勾股数，要求构造的数&amp;lt;=n
所谓本元勾股数，就是三个勾股数没有公因数，两两互质。
由本元勾股数扩大k倍，就可以得到其他勾股数。
而构造本元勾股数的方法如下：
***a=st,b=(s^2-t^2)/2,c=(s^2+t^2)/2
其中s&amp;gt;t&amp;gt;=1是任意没有公因数的奇数！
引用一段构造正确性的证明：
本原勾股数组（PPT)是一个三元组（a，b，c),其中a，b，c无公因数，且满足a² +b² =c²。
很明显存在无穷多个勾股数组（abc同乘以n），下面研究abc没有公因数的情况，先写出一些本原勾股数组：
case:(3,4,5) (5,12,13) (8,15,17) (7,24,25) (20,21,29)(9,40,41)(12,35,37)(11,60,61)(28,45,53) (33,56,65) (16,63,65)
观察可以看出a，b奇偶性不同且c总是奇数。（用一点技巧可以证明这是正确的）
3² = 5² - 4² = (5-4)(5+4) = 1 × 9
15² = 17²-8² = (17-8)(17+8) = 9 ×25
35² = 37² - 12² = (37-12)(37+12) = 25 ×49
......
很神奇的是似乎c-b与c+b总是平方数，并且c-b与c+b木有公因数。证明一下下：假设有公因数，设d是c-b与c+b的公因数，则d也整除(c+b)+(c-b)=2c, (c+b)-(c-b) = 2b,所以d整除2c，2b，但是b，c木有公因数，又假设了（a，b，c)是本原勾股数组，从而d等于1或2，又因为d整除（c-b)(c+b)=a².</description></item><item><title>POJ【数论/组合/博弈论】题目列表</title><link>https://111qqz.com/2015/08/poj/</link><pubDate>Fri, 21 Aug 2015 23:27:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj/</guid><description>
转载自：http://www.cnblogs.com/vongang/archive/2013/03/10/2952978.html
POJ【数论/组合/博弈论】题目列表
原来的列表比较水，今天换了一个难一些的列表，重新开始做~
博弈论
POJ 2234 Matches Game
POJ 2975 Nim
POJ 2505 A multiplication game
POJ 1067 取石子游戏　威佐夫博弈，奇异局势（必败局）为ak = [k*(1 + sqrt(5))/2], bk = ak + k;
POJ 2484 A Funny Game　这题真欢乐
POJ 2425 A Chess Game
POJ 2960 S-Nim sg函数
POJ 1704 Georgia and Bob 阶梯博弈转化成Nim，当N为奇数时将p[1]与0绑定
POJ 1740 A New Stone Game
POJ 2068 Nim
POJ 3480 John Anti-SG问题 贾志豪的论文Chapter2
POJ 2348 Euclid's Game
POJ 3710 Christmas Game</description></item><item><title>poj 3370 Halloween treats (剩余类,抽屉原理)</title><link>https://111qqz.com/2015/08/poj3370halloweentreats/</link><pubDate>Fri, 21 Aug 2015 05:36:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3370halloweentreats/</guid><description>
昨天那道签到的数学题没搞出来不开心.
是时候刷一波数学了
这题题意是说,从n个数中任选m个,使得m个的和为c的倍数.
如果有解,输出选的数的下标,否则输出无解字符串.
抽屉原理的原始描述是,如果有n+1个物品,有n个抽屉,那么至少有一个抽屉有2个物品.
由抽屉原理我们可以退出一个结论,对于任意 n个自然数,一定有连续的一段和为n的倍数.
证明如下:
　设这n个自然数分别为a1,a2,a3,a4....an
　处理一个前缀和sum[i] = (sum[i-1] + a[i])%n
　因为n的剩余类有n种,分别为0,1,2...n-1
　所以sum[1],sum[2],sum[3]..sum[n]
　那么sum[1],sum[2],sum[3]...sum[n]最多也有n种.
　我们分情况讨论:
　(1)sum[1],sum[2],sum[3]...sum[n]互不相同,那么一定存在sum[i]=0,也就是前i个数的和为n的倍数.
　(2)情况(1)的反面,也就是存在sum[i]==sum[j] (i&amp;lt;j),那么 从a[i+1] 到 a[j]的和就是n的倍数.
因为题目中的数据 c&amp;lt;=n ,所以解一定存在.
具体做法就是处理出来一个前缀和%c
然后如果有0,则为解,输出.
否则记录sum[i]%d出现的位置,存在一个数组里
如果sum[i]%d第二次出现,就输出这段下标.
嘛,大括号换风格了....
都写开代码太长了==
/************************************************************************* &amp;gt; File Name: code/poj/3370.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月21日 星期五 13时06分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N]; LL sum[N]; int p[N]; int n,c; int main() { while (~scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;c,&amp;amp;n)){ if (c==0&amp;amp;&amp;amp;n==0) break; sum[0] = 0; for ( int i = 1 ; i &amp;lt;= n ;i++){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]); a[i] = a[i] % c; sum[i] = (sum[i-1] + a[i])%c; } memset(p,0,sizeof(p)); for ( int i = 1 ; i &amp;lt;= n ; i++ ){ if (sum[i]==0){ for ( int j = 1 ; j &amp;lt;= i ; j++){ cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;quot; &amp;quot;; // cout&amp;lt;&amp;lt;&amp;quot;wang wang wang !</description></item><item><title>HUST team contest #E A Mountain Road||poj 3846 (dp)</title><link>https://111qqz.com/2015/08/poj3846/</link><pubDate>Thu, 20 Aug 2015 19:57:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3846/</guid><description>
比赛的时候以为是贪心...
想了好久.
不过最后没敢写,因为没办法证明正确性,只是直觉==
最后剩下的时间给队友改另一道题了..
果然明智...
蠢的人的直觉真心不靠谱..
这题是dp
我们可以把车按照方向的不同分为A车和B车
dp[i][j][0..1]表示已经经过了a方向的i辆车,经过了b方向的j辆车,并且最后一辆车是a/b方向的情况的离开道路的时间.
似乎问题不大.
然后就一直wa...
wa到怀疑人生好么!!!
最后发现
问题出在!
dp数组初始化赋值成正无穷的时候,溢出啦!
然后我搜了下,发现0x7fffffff果然不是什么好东西!
以后正无穷用0x3f3f3f3f
这东西&amp;gt;1E9,相加不超过int
而且最重要的是,如果定义 inf = 0x3f3f3f3f
0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))
不要使用0x7fffffff!
不要使用0x7fffffff!
不要使用0x7fffffff!
/************************************************************************* &amp;gt; File Name: code/2015summer/0821/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月21日 星期五 01时28分23秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E2+7; int dp[N][N][2]; int cntA,cntB; struct Q{ int beg,t; char dir; }q[N],a[N],b[N]; void init(){ int n; int beg,time; char dir; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); cntA = 0 ; cntB = 0 ; for ( int i = 0 ; i &amp;lt; n ;i++){ cin&amp;gt;&amp;gt;q[i].</description></item><item><title>0x3f3f3f3f...编程中无穷大常量的设置技巧</title><link>https://111qqz.com/2015/08/0x3f3f3f3f-/</link><pubDate>Thu, 20 Aug 2015 19:48:00 +0000</pubDate><guid>https://111qqz.com/2015/08/0x3f3f3f3f-/</guid><description>
如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况下，0x7fffffff并不是一个好的选择。
很多时候我们并不只是单纯拿无穷大来作比较，而是会运算后再做比较，例如在大部分最短路径算法中都会使用的松弛操作：
if (d[u]+w[u][v]我们知道如果u,v之间没有边，那么w[u][v]=INF，如果我们的INF取0x7fffffff，那么d[u]+w[u][v]会溢出而变成负数，我们的松弛操作便出错了，更一般的说，0x7fffffff不能满足&amp;quot;无穷大加一个有穷的数依然是无穷大&amp;quot;，它变成了一个很小的负数。 除了要满足加上一个常数依然是无穷大之外，我们的常量还应该满足&amp;quot;无穷大加无穷大依然是无穷大&amp;quot;，至少两个无穷大相加不应该出现灾难性的错误，这一点上0x7fffffff依然不能满足我们。 所以我们需要一个更好的家伙来顶替0x7fffffff，最严谨的办法当然是对无穷大进行特别处理而不是找一个很大很大的常量来代替它（或者说模拟它），但是这样会让我们的编程过程变得很麻烦。在我读过的代码中，最精巧的无穷大常量取值是0x3f3f3f3f，我不知道是谁最先开始使用这个精妙的常量来做无穷大，不过我的确是从一位不认识的ACMer(ID:Staginner)的博客上学到的，他/她的很多代码中都使用了这个常量，于是我自己也尝试了一下，发现非常好用，而当我对这个常量做更深入的分析时，就发现它真的是非常精巧了。
0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了&amp;quot;无穷大加一个有穷的数依然是无穷大&amp;quot;），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们&amp;quot;无穷大加无穷大还是无穷大&amp;quot;的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。 所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择。</description></item><item><title>HUST team contest #2 C Divisible Subsequences ||poj 3844 (剩余类)</title><link>https://111qqz.com/2015/08/poj3844/</link><pubDate>Thu, 20 Aug 2015 17:11:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3844/</guid><description>
算是签到帖，竟然卡住了。
我数学还是太差了。。
然后去找题解。。竟然看不懂！
我数学真的有这么差嘛。。。
然后多亏了队友 @zcy 妹子的讲解。。
其实很好理解啊。。。
不过数到底还是数学太差了==
今天七夕，废话有点多==
这道题的题意是，找序列中连续的一段，使得和 可以整除d
我们观察到数列中的数的范围是1..1 000 000 000 的
而d只有1 000 000
我们考虑余数相同，读入的时候就可以直接先 % 掉 d
因为只会和余数有关。
我们可以先处理出来一个前缀和数组sum[i]，表示前i个元素的和。
如果有一段序列从a[i] 到 a[j] 满足题意
根据题意那么这段序列的和一定%d=0
a[i] 到 a[j]的和为 sum[j]-sum[i-1]
也就是(sum[j]-sum[i-1] )%d==0
也就是sum[j] 和 sum[i-1] 关于 d 同余
如果我们在处理得到前缀和的时候就%dshuxue
那么就是sum[j]==sum[i-1]
所以我只要对于d的每一个剩余类有多少个统计出来。
然后对于每个剩余类，只需要任意取出两个，就是一种答案。
需要注意的是如果只有一个0，也是一种答案。
我们可以定义sum[i] = 0
还有一个需要注意的是要开long long
/* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 21时20分01秒 File Name :code/poj/3844.cpp ************************************************ */ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E6+7; int sum[50005]; LL p[N]; void solve () { int d,n; int x; memset(p,0,sizeof(p)); sum[0] = 0; p [0] = 1; for ( int i = 1 ; i &amp;lt;= n ; i++){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;x); sum[i] = (sum[i-1] + x) % d; p[sum[i]]++; } LL ans = 0 ; for ( int i = 0 ; i &amp;lt; d ; i++){ if (p[i]&amp;gt;0){ ans = ans + p[i]*(p[i]-1)/2; } } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; } int main() { int T; cin&amp;gt;&amp;gt;T; while (T--){ solve(); } return 0; }</description></item><item><title>HUST team contest #2 A An Industrial Spy ||poj 3842 (筛)</title><link>https://111qqz.com/2015/08/poj3842/</link><pubDate>Thu, 20 Aug 2015 15:28:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3842/</guid><description>
蠢了。
这道题显然可以搜。。
然后自己搜索的姿势果然还是不怎么地。。
最后是蔡大神过掉的。
他的思路是枚举素数，然后把素数的各位拆开，看这些数字是否在给出的字符串中出现过。
一开始TLE掉了。
后来又预处理出来一个标记数组，如果字符串中没有数字2，那么20w+的素数就可以直接跳过去，然后A掉了。
其实因为数字的位数最多才7位。。
暴力也不是不可以。。。。
STL中求全排列的那个函数我也不是没用过。。。比赛的时候怎么就没想到==
再开个map判重
然后素数打表部分。
队友是打了个30000+行的表。。。。
说起来。。。我好像还没用C++写过筛法求素数。。。
说来惭愧啊。。。。
pascal的时候倒是写过几次呢。
再复习下。。。
http://blog.csdn.net/dinosoft/article/details/5829550
写的是快速筛。
/************************************************************************* &amp;gt; File Name: code/2015summer/0821/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月20日 星期四 22时17分14秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E7+7; using namespace std; bool not_prime[N]; int prime[N],pri_num; map&amp;lt;int,bool&amp;gt; mp; int a[N]; int ans; map&amp;lt;int,bool&amp;gt;::iterator it; char st[15]; int len; void init() { not_prime[0] =true; not_prime[1] = true; for(int i = 2;i &amp;lt; N; ++i) { if(!</description></item><item><title>筛法求素数（转载）</title><link>https://111qqz.com/2015/08/</link><pubDate>Thu, 20 Aug 2015 15:17:00 +0000</pubDate><guid>https://111qqz.com/2015/08/</guid><description>
TAG 素数 数论
素数总是一个比较常涉及到的内容，掌握求素数的方法是一项基本功。
基本原则就是题目如果只需要判断少量数字是否为素数，直接枚举因子2 。。N^(0.5) ，看看能否整除N。
如果需要判断的次数较多，则先用下面介绍的办法预处理。
一般的线性筛法 首先先介绍一般的线性筛法求素数
[cpp] view plaincopy
void make_prime() { memset(prime, 1, sizeof(prime)); prime[0]=false; prime[1]=false; int N=31700; for (int i=2; i if (prime[i]) { primes[++cnt ]=i; for (int k=i*i; k prime[k]=false; } return; } 这种方法比较好理解，初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数(注意上面的 ii , 比 i2 要快点 )，把这些合数都筛掉，即算法名字的由来。
但仔细分析能发现，这种方法会造成重复筛除合数，影响效率。比如10，在i=2的时候，k=215筛了一次；在i=5，k=56 的时候又筛了一次。所以，也就有了快速线性筛法。
快速线性筛法 快速线性筛法没有冗余，不会重复筛除一个数，所以&amp;quot;几乎&amp;quot;是线性的，虽然从代码上分析，时间复杂度并不是O(n)。先上代码
[cpp] view plaincopy
#include using namespace std; const long N = 200000; long prime[N] = {0},num_prime = 0; int isNotPrime[N] = {1, 1}; int main() { for(long i = 2 ; i &amp;lt; N ; i ++) { if(!</description></item><item><title>.虚</title><link>https://111qqz.com/2015/08/</link><pubDate>Thu, 20 Aug 2015 13:19:00 +0000</pubDate><guid>https://111qqz.com/2015/08/</guid><description>
。</description></item><item><title>codeforces 560 E. Gerald and Giant Chess (dp+lucas定理,求大组合数 mod p,p为质数)</title><link>https://111qqz.com/2015/08/codeforces560e-geraldandgiantchessdplucasmodpp/</link><pubDate>Tue, 18 Aug 2015 11:36:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces560e-geraldandgiantchessdplucasmodpp/</guid><description>
dp方程想错了.果然还是欠练啊.
如果我们不考虑坏点,那么从 (0,0)到(x,y)的方案数是c(x+y,x)或者c(x+y,y)
因为有坏点的存在,我们可以逆向思维,先求出总数,然后减去那些由于坏点的影响不能走的方案数.
由于存在黑点i(x,y)，从左上到该黑点的方案数sum[i] = C(x+y,x)，其中如果在黑点i的左上还有黑点j(u,v)，那么应该减去sum[j]*C(x-u+y-v)(y-u)
然后可以把坏点按照x为第一关键字,y为第二关键字排序.
从左上出发,往右下扫黑点.
还有一个考点是大组合数的求法
因为太大,递推也不行.
可以用欧拉公式求逆元的方法求解.
或者是lucas定理.
记得拿到骑士(1,1)到(n,m)的题和这道题很像.
也是从坐上到右下,中间有些坏点,不过骑士的走法并不是向下或者想有1步,而是向右p步,向下q步,或者向又q步,向下p步.
而且那道题的n和m是 10^9的数量级...
那道题的话就只能用lucas定理了貌似
这道题算是那道题的弱化版本,在此orz zhangk,果然厉害
所以我还是决定写lucas定理的解法
lucas定理适用于 求C(n,m)%p,p为素数 且n,m很大的情况.
引用一段题解:
题意，给一个n * m 的网格，其只有一些点是坏的不能走，要求从0，0点起到n,m的总方案数。 设dp[i] 表示到达第i个坏点且不经过其他坏点的总方案数。增加一个点(n-1,m-1),则dp[k]即为答案。 壮态转移方程 dp[i] = C[x[i]+y[i],x[i]) - sum(dp[j] * C(x[i] - x[j] + y[i] - y[j],x[i] - x[j]),j表示，所有在i之前的坏点，由于这里的dp[i]都是不经过别的坏点，不会有重复的路径，所以减去以前的坏点到达i的路径就是答案。 先排序，就可以得到每个点的先后顺序，这样在更新状态的时候，可以从小到大枚举。总的复杂度为 o(k * k); 现在剩下的问题 就是要求c(n,m),由于n,m很大，一般求组合数的方法是n * m，这样复杂度太高，即使用递推o(n)的复杂度，也是太高的。这里引入了 定理Lucas，这个就是专门求大组合数的一种方法。 Lucas(n,m,p)=c(n%p,m%p)*Lucas(n/p,m/p,p) 设 aa = n % p,bb = m % p;这里可以看出来把n,m很大的数转化了相对比较小的aa,bb, 这个公式把n - n/p m - m/p,这样可以递归解决。求c(aa,bb)就可以直接用组合公式aa!</description></item><item><title>codeforces 560 D. Equivalent Strings(分治)</title><link>https://111qqz.com/2015/08/codeforces560d-equivalentstrings/</link><pubDate>Mon, 17 Aug 2015 01:24:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces560d-equivalentstrings/</guid><description>
问两个长度相同的字符串是否等价．
相等的条件是，两个字符串相等，或者两个偶数长度（因为要分成长度相同的两段，所以一定是偶数长度才可分）字符串平均分成两部分，每部分对应相等(不考虑顺序)
一开始有一点没想清楚.
如果字符串a分成相等长度的两部分a1,a2,字符串b分成相等的两部分b1,b2
我错误得以为,如果a1和a2等价&amp;amp;&amp;amp;b1;和b2等价,那么a 和 b 就相等了(a和b一定等价,但不一定相等),于是只判断了 equal(a1,b2)&amp;amp;&amp;amp;equal;(a2,b1)
wa了一次.
&amp;lt;
/************************************************************************* &amp;gt; File Name: code/cf/#313/D.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 08时42分25秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E5+7; string a,b; int len; bool equal( string x,string y,int len) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&amp;quot; len:&amp;quot;&amp;lt;&amp;lt;len&amp;lt;&amp;lt;endl; if (x==y) return true; string x1,x2,y1,y2; x1 = x.</description></item><item><title>codeforces 560 C. Gerald's Hexagon (思维，几何)</title><link>https://111qqz.com/2015/08/codeforces560c-geraldshexagon/</link><pubDate>Sun, 16 Aug 2015 23:28:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces560c-geraldshexagon/</guid><description>
题意：给定一个六边形的六条边的长，问能分割成多少个单位正三角形．
分割不好办，那我们就反着来，先补成一个包含这个六边形的正三角形．
对于边长为a的正三角形，显然我们可以分割成a*a个单位正三角形
大正三角形的边长为连续的三条边的和
而要减掉的三个小三角形的边长为与之前连续的三条边的起始边的序号的奇偶性相同的三条边．
就是说如果求和的时候求的是前三条边，那么三个要减掉的小三角形的边长就是第一，三，五条边．
如果求和的时候求的是后三条边，那么三个要减掉的小三角形的边长就是第二，第四，第六条边．
/************************************************************************* &amp;gt; File Name: code/#313/C.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 07时13分54秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; int main() { int a[10]; int b[5]; for ( int i = 1 ; i &amp;lt;= 6 ; i++) { cin&amp;gt;&amp;gt;a[i]; } memset(b,0,sizeof(b)); for ( int i = 1 ; i &amp;lt;= 6 ; i++) { if (i&amp;lt;=3) { b[0] = b[0] + a[i] ; } if (i%2==1) { b[i/2+1] = a[i]; } } int ans; ans = b[0]*b[0]-b[1]*b[1]-b[2]*b[2]-b[3]*b[3]; cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>codeforces 560 B. Gerald is into Art　（模拟）</title><link>https://111qqz.com/2015/08/codeforces560b-geraldisintoart/</link><pubDate>Sun, 16 Aug 2015 22:53:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces560b-geraldisintoart/</guid><description>
/************************************************************************* &amp;gt; File Name: code/cf/#313/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: Wed 22 Jul 2015 09:52:54 PM CST ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; int a1,b1,a2,b2,a3,b3; bool judge (int x2,int y2,int x3,int y3) { if (x2&amp;lt;=a1&amp;amp;&amp;amp;x3&amp;lt;=a1&amp;amp;&amp;amp;y2+y3&amp;lt;=b1) return true; if (y2&amp;lt;=b1&amp;amp;&amp;amp;y3&amp;lt;=b1&amp;amp;&amp;amp;x2+x3&amp;lt;=a1) return true; return false; } int main() { cin&amp;gt;&amp;gt;a1&amp;gt;&amp;gt;b1&amp;gt;&amp;gt;a2&amp;gt;&amp;gt;b2&amp;gt;&amp;gt;a3&amp;gt;&amp;gt;b3; if (judge(a2,b2,a3,b3)||judge(b2,a2,a3,b3)||judge(b2,a2,b3,a3)||judge(a2,b2,b3,a3)) { puts(&amp;quot;YES&amp;quot;); } else { puts(&amp;quot;NO&amp;quot;); } return 0; }</description></item><item><title>codeforces 520 B. Two Buttons (bfs)</title><link>https://111qqz.com/2015/08/codeforces520b-twobuttonsbfs/</link><pubDate>Sun, 16 Aug 2015 20:34:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces520b-twobuttonsbfs/</guid><description>
做过一道类似的题
因为是问最短，很容易想到是bfs
对于点x，可以到达点x-1,和点2*x
需要注意的是上界限。
并不是max(m,n)
因为可能先达到比m大，之后再减回来的情况是更优的。
max(2m,2n)肯定是足够的
/************************************************************************* &amp;gt; File Name: code/cf/#295/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 04时16分51秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E4+7; int n,m; int d[N]; int mx; void bfs() { memset(d,-1,sizeof(d)); d[n] = 0 ; queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>codeforces 520 A. Pangram (暴力)</title><link>https://111qqz.com/2015/08/codeforces520a-pangram/</link><pubDate>Sun, 16 Aug 2015 20:15:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces520a-pangram/</guid><description>
给一个字符串，问这个字符串中是否26个字母都出现过（大小写只出现一个就算出现过） 开个布尔数组，扫一遍即可。 嘛，做两道水题放松下== 反正也是要清的。
/************************************************************************* &amp;gt; File Name: code/cf/#295/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 04时05分12秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; bool v[30]; int main() { int n; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); memset(v,false,sizeof(v)); string st; cin&amp;gt;&amp;gt;st; for ( int i = 0 ; i &amp;lt; n ; i ++) { if (islower(st[i])) { v[st[i]-'a'] = true; } else { v[st[i]-'A'] = true; } } for ( int i = 0 ; i &amp;lt; 26 ; i++) { if (!</description></item><item><title>将博客搬至CSDN</title><link>https://111qqz.com/2015/08/csdn/</link><pubDate>Sun, 16 Aug 2015 19:33:00 +0000</pubDate><guid>https://111qqz.com/2015/08/csdn/</guid><description>
将博客搬至CSDN</description></item><item><title>codeforces 567 E President and Roads (优先队列＋迪杰斯特拉＋tarjan)</title><link>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</link><pubDate>Sun, 16 Aug 2015 19:26:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</guid><description>
题意是说，给定一个有向图，对于每一条边，问是否是s到t的最短路上一定会经过的边．
如果是就输出yes
如果不是，问能否通过减少这条边的权值（减少的权值就是修理费用），使得这条边成为新的最短路上的边．
对于一条边是否一定是最短路上的边，我们可以从s做一遍最短路，然后反响建边，从t再做一遍最短路．
得到两个d1,d2数组
如果一条边d1[u] + d2[v] + w(u, v) = 最短路，那这条边在最短路上的边．但是未必不能缺少．
我们还要判断这条边是否是不能缺少的．
不能缺少的意思是说，如果没有这条边，就不能构成最短路．
那么这条边一定是桥．
我们可以用tarjan算法求桥．
据说是水题，不过图论还没怎么刷，所以对我来说还是很有难度的．
只是基本懂了
下面的代码是我仿照其他人的代码写出来的....求不鄙视　＞＜
/************************************************************************* &amp;gt; File Name: code/cf/#314/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 03时09分39秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef pair&amp;lt;LL,LL&amp;gt; P; const int maxn = 200005; const LL mod1 = 1e9 + 7; const LL mod2 = 99999991; const LL inf = 1e15; struct Nod{ LL b,val,next,idx; void init(LL b,LL val,LL next,LL idx){ this-&amp;gt;b=b;this-&amp;gt;val=val;this-&amp;gt;next=next;this-&amp;gt;idx=idx; } }buf[2][maxn]; LL len[2],E[2][maxn]; LL n,m,s,t; LL dis[2][maxn],cnt[2][2][maxn],ans1[maxn],ans2[maxn]; priority_queue&amp;lt;P,vector&amp;lt;P&amp;gt;,greater&amp;lt;P&amp;gt; &amp;gt; q; void init() { memset(E,-1,sizeof(E)); memset(cnt,0,sizeof(cnt)); len[0] = len[1] = 0; } void add_edge(LL a,LL b,LL val,LL idx) { buf[0][len[0]].</description></item><item><title>codeforces 567 F. Mausoleum (dp)</title><link>https://111qqz.com/2015/08/codeforces567f/</link><pubDate>Sun, 16 Aug 2015 07:09:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces567f/</guid><description>
很容易看出来是dp
我们左右一起，一对一对放．
对于每一对，有三种方法，分别是两左，一左一右，两右．
初始区间长度为２n，每次放完后缩小区间长度 ，最后一定是放２个n，这个时候区间长度缩小为２，表明一种满足题意的情况．
状态转移的时候需要分别判断三个状态是否满足题目中给出的k组限制条件．
细节见注释．
/************************************************************************* &amp;gt; File Name: code/cf/#314/F.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 14时37分15秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N = 1E2+7; int n, k, a[N], b[N]; LL dp[N][N]; string sign[N]; int L, R, F, S; enum { OLD, CUR, NEW }; int get_type(int i) { if (i &amp;lt; L || i &amp;gt; R) return OLD; if (i == F || i == S) return CUR; return NEW; } bool compare(int a, int b, string s) { if (s == &amp;quot;=&amp;quot;) return a == b; if (s == &amp;quot;&amp;gt;&amp;quot;) return a &amp;gt; b; if (s == &amp;quot;&amp;lt;&amp;quot;) return a &amp;lt; b; if (s == &amp;quot;&amp;gt;=&amp;quot;) return a &amp;gt;= b; if (s == &amp;quot;&amp;lt;=&amp;quot;) return a &amp;lt;= b; } bool check(int l, int r, int f, int s) { L = l, R = r; F = f, S = s; for (int i = 0; i &amp;lt; k; i++) { int lf = get_type(a[i]); // 判断对于当前要添加的位置，是否有题目中给出限制的位置，如果是，判断是否满足限制． //如果有一个限制条件不满足就不成立，所有限制条件都满足才成立． int rg = get_type(b[i]); if (lf !</description></item><item><title>高级搜索专题</title><link>https://111qqz.com/2015/08/</link><pubDate>Sun, 16 Aug 2015 05:45:00 +0000</pubDate><guid>https://111qqz.com/2015/08/</guid><description>
基础的搜索BFS和DFS,自己找题切吧...
高级搜索的题集就在下面,自己看着办吧...
努力爆搜,努力剪枝吧~~~
【Level 1】
HDOJ-1429 胜利大逃亡(续)　HDOJ-1885 Key Task
HDOJ-1226 超级密码
HDOJ-1664 Different Digits
HDOJ-2821 Pusher
HDOJ-2128 Tempter of the Bone II
HDOJ-3533 Escape
HDOJ-4101 Ali and Baba
HDOJ-3839 Ancient Messages
HDOJ-1685 Booksort
HDOJ-2614 Beat
HDOJ-3309 Roll The Cube
HDOJ-1067 Gap
HDOJ-2181 哈密顿绕行世界问题
HDOJ-2437 Jerboas
HDOJ-2102 A计划
HDOJ-1195 Open the Lock
HDOJ-3295 An interesting mobile game
HDOJ-2259 Continuous Same Game(2)
HDOJ-3681 Prison Break
HDOJ-3085 Nightmare Ⅱ
【Level 2】</description></item><item><title>poj 2688 Cleaning Robot (tsp问题)</title><link>https://111qqz.com/2015/08/poj2688/</link><pubDate>Sat, 15 Aug 2015 20:16:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2688/</guid><description>
＿＿＿＿＿＿
好蠢，竟然没看出来这道题的不同之处，以为就是个搜
然后样例什么的都过了．．．
结果显然wa...
然后才发现，这道题应该是tsp问题．
解法是先跑一遍bfs,
对于所有的脏点和起点，得到没两个点之间的距离．
然后跑一遍dfs，枚举出所有的组合，同时更新答案．
晚安．
/************************************************************************* &amp;gt; File Name: code/poj/rr2688.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 03时39分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=25; int w,h; char maze[N][N]; int dist[N][N]; int cnt;//机器人与脏地的个数 int tag[N][N];//标记 bool vist[N][N]; struct node { int x,y; int step; bool ok () { if (x&amp;lt;1||x&amp;gt;h||y&amp;lt;1||y&amp;gt;w||vist[x][y]||maze[x][y]=='x') return false; return true; } }pos[N*N]; node robot; int dir[4][2]={0,-1,0,1,-1,0,1,0}; void bfs(node p,int po) { vist[p.</description></item><item><title>codeforces 314 D One-Dimensional Battle Ships (模拟)</title><link>https://111qqz.com/2015/08/codeforces314/</link><pubDate>Sat, 15 Aug 2015 17:02:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces314/</guid><description>
比赛的时候没搞出来，really sad. 其实这题很容易啊．．．． 首先，对于lie 的判断应该基于能放的船的个数． 能放的船的个数是随着射的点数的增加而减少的． 射完每个点后更新能放的船的个数，如果这个时候已经无法放下k条船了，说明lie了． 如果所有都射完也没发生，那么就-1.
由于船与串不能相邻，除了最后一条船，每条船实际占的size 应该为a+1 那么很容易知道对于长度为l的区间，能放的船的个数为（l+1）/(a+1) 这是初始能放的船的个数，为最大值． 当射了点b之后，破坏的是b所在的一段最大的没有被射过点的区间的连续性． 做法是找到距离b点最近的左端和右端的被射过的点． 可以用set 搞，找的时候upper_bound 记得初始化的时候把　0点和　n+1 点当成射过的．
/************************************************************************* &amp;gt; File Name: code/cf/#314/D.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 00时27分54秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; set&amp;lt;int&amp;gt; se; int n,k,a,m,b; set&amp;lt;int&amp;gt;::iterator it; int cal (int x,int y) //cal 函数计算出当射了b之后，因此减少的能放船的个数． { int res; res = (y-x)/(a+1)-(y-b)/(a+1)-(b-x)/(a+1);//由于射了b点，相当于之前连续的区间(x,y)被分成了（x,b）和（b,y) //(x,y)区间能放的船的数量由之前变成了被分成的两个小区间能放的船的数量的和． return res; } int main() { scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;a); scanf(&amp;quot;%d&amp;quot;,&amp;amp;m); se.</description></item><item><title>codeforces 569 E. New Language (2-sat)</title><link>https://111qqz.com/2015/08/codeforces569e/</link><pubDate>Sat, 15 Aug 2015 07:10:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces569e/</guid><description>
/************************************************************************* &amp;gt; File Name: code/cf/#315/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月15日 星期六 13时48分36秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=5E2+7; int flag[N],flag2[N]; int f[N][N]; int a[N]; char s[N]; int ans[N]; int len,n,m; char s1[13],s2[13]; int p1,p2,q1,q2,dq1,dq2; void add(int p,int q,int flag[]) { int dq = q * n + p;//找到元辅音状态为q，第p的点的下标 for (int i=1;i&amp;lt;=2*n;++i) { if (f[dq][i]==0) continue; flag[i]=1;//找到所有由dp出发的边指向的点，表示选了dp点一定要选的点。 } } bool check(int flag[]) { for (int i=1;i&amp;lt;=n;++i) if (flag[i]==1&amp;amp;&amp;amp;flag[i+n]==1) return false; //判断是否存在矛盾 //（选了j点后，既要选择某点k的元音，也要选择某点k的辅音）　return true; } bool dfs(int pos,int x) { if (pos&amp;gt;n) return true;//如果能形成一个长度为n的单词，说明这种语言有word bool g[2]; g[0]=g[1]=false; for (int i=x;i&amp;lt;=len;++i)//从当前字母x往后枚举 { for (int j=1;j&amp;lt;=2*n;++j) flag2[j]=flag[j];//为了不影响原始数组，复制一个布尔数组出来。 add(pos,a[i],flag2);//找到所有选了pos点一定要选的点 if (check(flag2)&amp;amp;&amp;amp;(!</description></item><item><title>【2-SAT问题】（转自kuangbin的博客）</title><link>https://111qqz.com/2015/08/2-satkuangbin/</link><pubDate>Sat, 15 Aug 2015 04:59:00 +0000</pubDate><guid>https://111qqz.com/2015/08/2-satkuangbin/</guid><description>
【2-SAT问题】
现有一个由N个布尔值组成的序列A，给出一些限制关系，比如A[x] AND A[y]=0、A[x] OR A[y] OR A[z]=1等，要确定A[0..N-1]的值，使得其满足所有限制关系。这个称为SAT问题，特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。
由于在2-SAT问题中，最多只对两个元素进行限制，所以可能的限制关系共有11种：
A[x]
NOT A[x]
A[x] AND A[y]
A[x] AND NOT A[y]
A[x] OR A[y]
A[x] OR NOT A[y]
NOT (A[x] AND A[y])
NOT (A[x] OR A[y])
A[x] XOR A[y]
NOT (A[x] XOR A[y])
A[x] XOR NOT A[y]
进一步，A[x] AND A[y]相当于(A[x]) AND (A[y])（也就是可以拆分成A[x]与A[y]两个限制关系），NOT(A[x] OR A[y])相当于NOT A[x] AND NOT A[y]（也就是可以拆分成NOT A[x]与NOT A[y]两个限制关系）。因此，可能的限制关系最多只有9种。
在实际问题中，2-SAT问题在大多数时候表现成以下形式：有N对物品，每对物品中必须选取一个，也只能选取一个，并且它们之间存在某些限制关系（如某两个物品不能都选，某两个物品不能都不选，某两个物品必须且只能选一个，某个物品必选）等，这时，可以将每对物品当成一个布尔值（选取第一个物品相当于0，选取第二个相当于1），如果所有的限制关系最多只对两个物品进行限制，则它们都可以转化成9种基本限制关系，从而转化为2-SAT模型。
【建模】
其实2-SAT问题的建模是和实际问题非常相似的。
建立一个2N阶的有向图，其中的点分为N对，每对点表示布尔序列A的一个元素的0、1取值（以下将代表A[i]的0取值的点称为i，代表A[i]的1取值的点称为i'）。显然每对点必须且只能选取一个。然后，图中的边具有特定含义。若图中存在边，则表示若选了i必须选j。可以发现，上面的9种限制关系中，后7种二元限制关系都可以用连边实现，比如NOT(A[x] AND A[y])需要连两条边和，A[x] OR A[y]需要连两条边和。而前两种一元关系，对于A[x]（即x必选），可以通过连边来实现，而NOT A[x]（即x不能选），可以通过连边来实现。
【O(NM)算法：求字典序最小的解】
根据2-SAT建成的图中边的定义可以发现，若图中i到j有路径，则若i选，则j也要选；或者说，若j不选，则i也不能选；
因此得到一个很直观的算法：</description></item><item><title>codeforces 569 D. Symmetric and Transitive (组合数学　第二类斯特林数　贝尔数)</title><link>https://111qqz.com/2015/08/codeforces569d/</link><pubDate>Fri, 14 Aug 2015 22:20:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces569d/</guid><description>
D. Symmetric and Transitive
time limit per test
1.5 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Little Johnny has recently learned about set theory. Now he is studying binary relations. You've probably heard the term &amp;quot;equivalence relation&amp;quot;. These relations are very important in many areas of mathematics. For example, the equality of the two numbers is an equivalence relation.
A set ρ of pairs (a, b) of elements of some set A is called a binary relation on set A.</description></item><item><title>斯特林数</title><link>https://111qqz.com/2015/08/</link><pubDate>Fri, 14 Aug 2015 21:54:00 +0000</pubDate><guid>https://111qqz.com/2015/08/</guid><description>
http://baike.baidu.com/link?url=nsN1-rcs3Gs0jNurWLSDk6AJ9jmhl_3pfkQmYK7vZoe7BsoTij48Si3It9XeNM4uA7gST-1ITQsAx0bv5si9_q</description></item><item><title>贝尔数(集合的划分数目)</title><link>https://111qqz.com/2015/08/</link><pubDate>Fri, 14 Aug 2015 21:53:00 +0000</pubDate><guid>https://111qqz.com/2015/08/</guid><description>
http://baike.baidu.com/link?url=kw5Kxe3nSvRJR0TpJUpMrORcQL8fyZFpJlT9_o0RlGYOy0bKFobabPPSj3LxGfy7o1qGVycrYK4Iags3hMFq0a
在组合数合里，贝尔数给出了集合划分的数目，以数学家埃里克·坦普尔·贝尔（Eric Temple Bell）命名，是组合数学中的一组整数数列。[1]
以B0= B1=1为始， 首几项的贝尔数为：1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975, …（OEIS的A000110数列）
_B__n_是基数为_n_的集合划分数目。集合S_的一个划分是定义为_S_的两两不相交的非空子集的族，它们的并是_S。例如_B_3 = 5因为3个元素的集合{a, b, c}有5种不同的划分方法：
* {{a}, {b}, {c}} *
{{a}, {b, c}} *
{{b}, {a, c}} *
{{c}, {a, b}} *
{{a, b, c}}
_B_0是1因为空集
正好有1种划分方法。划分的定义要求空集的划分中的每个成员都是非空集合，而它们的并是
本身。所以
是它自身的唯一划分。（这是定义所允许的因为
）
2公式编辑 贝尔数适合递推公式：
它们也适合“Dobinski公式”：
期望值为1的泊松分布的''n''次矩。
它们也适合“Touchard同余”：若p是任意质数，那么
每个贝尔数都是&amp;quot;第二类Stirling数&amp;quot;的和
Stirling数S（n, k）是把基数为n的集划分为正好k个非空集的方法的数目。
把任一概率分布的n次矩以首n个累积量表示的多项式，其系数和正是第n个贝尔数。这种数划分的方法不像用Stirling数那个方法粗糙。
贝尔数的指数母函数是
3贝尔三角形编辑 用以下方法建构一个三角矩阵（形式类似杨辉三角形）：</description></item><item><title>codeforces 569 C Primes or Palindromes? (暴力)</title><link>https://111qqz.com/2015/08/codeforces569/</link><pubDate>Fri, 14 Aug 2015 21:41:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces569/</guid><description>
先预处理出来比小于等于n的素数的个数和回文数的个数...
素数不筛竟然也可以过
然后暴力就好.
需要注意的是,比值并不单调,找最大的n,可能之前某个数开始不满足条件,之后又有满足条件的了.
我们可以倒着扫来找,第一个满足条件的就是最大的.
/************************************************************************* &amp;gt; File Name: code/cf/#315/C.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月11日 星期二 00时54分13秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E6+5; int f[N],g[N]; bool prime( int x) { if (x==1) return false; if (x&amp;lt;=3) return true; for ( int i = 2 ; i*i&amp;lt;=x ; i ++) { if (x%i==0) return false; } return true; } bool pal( int x) { int a[100]; int len=0; while(x) { len++; a[len]=x; x = x/ 10; } for ( int i = 1 ;i &amp;lt;= len/2 ; i++) { if (a[i]!</description></item><item><title>codeforces 570 E. Pig and Palindromes (dp)</title><link>https://111qqz.com/2015/08/codeforces570e-pigandpalindromesdp/</link><pubDate>Fri, 14 Aug 2015 20:33:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces570e-pigandpalindromesdp/</guid><description>
比赛的时候想到了是dp搞...
不过dp废.....
可能更多的是心理上...
这道题并不怎么难想,但是以觉得是dp,就给了自己一种暗示...这题我搞不出来...
实际上,我把cA掉的时候应该还有一个小时十分钟左右的样子...
d题没啥思路,所以我有大概一个小时的时间可以搞e...未必就搞不出来.
还有因为答案很大要取模,感觉一般取模的题,要么是数学,要么是像dp这种有递推式子的.
这道题的思路是:
因为要形成回文串,我们可以从两边往中间走,保证每一步都相同.
dp[i][x1][x2] 表示路径长度为i,左上角出发到达x坐标为x1,又下角出发到达x坐标为x2,且两条路径上对应的字母都相同的方案数.
然后判断当前格子的字母是否一样,如果一样,则考虑转移.
由于从左上角出发可以往下往右,从右下角出发可以往上往左,排列组合,所以当前状态和之前的四种状态有关.
由因为这步的状态只和上以步的四种状态有关,所以路径长度那以维要滚动掉不然会MLE
dp方程为 dp[cur][x1][x2]=(dp[cur^1][x1][x2],dp[cur^1][x1-1][x2],dp[cur^1][x1][x2+1],dp[cur^1][x1-1][x2+1])%MOD;
然后注意由于(m+n) 的奇偶性,答案会有所不同.
根据奇偶性判断从两端出发是到两个相邻的格子还是到同一个格子.
初始化的话如果(1,1)和{n,m}点的字母一样那么 dp[0][1][n] 为1,否则为0.
其他点显然都为0
/************************************************************************* &amp;gt; File Name: code/cf/#316/EE.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月15日 星期六 04时10分13秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int MOD=1E9+7; const int N=5E2+7; int n,m; char st[N][N]; int dp[2][N][N]; int main() { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m); for ( int i = 1 ; i &amp;lt;= n ; i++) { scanf(&amp;quot;%s&amp;quot;,&amp;amp;st[i][1]); } // dp[0][1][n]= st[1][1]==st[n][m]; if (st[1][1]==st[n][m]) { dp[0][1][n]=1; } else { dp[0][1][n]=0; } int cur = 0; int mx = (m+n-2)/2; for ( int step = 1 ; step &amp;lt;= mx ; step++) { cur = cur ^ 1; for (int i = 1 ; i&amp;lt;= n ; i++) { for ( int j = 1 ; j &amp;lt;= n ; j++ ) { dp[cur][i][j] =0 ; } } for ( int x1 = 1 ; x1 &amp;lt;= n&amp;amp;&amp;amp;x1-1&amp;lt;=step ;x1++) { for ( int x2 = n ; x2&amp;gt;=1 &amp;amp;&amp;amp;n-x2&amp;lt;=step ;x2--) { int y1 = 1+step-(x1-1); int y2 = m-step+(n-x2); //由x1,x2 可以计算出y1,y2 if (st[x1][y1]==st[x2][y2]) { dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1][x2])%MOD; dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1][x2+1])%MOD; dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1-1][x2])%MOD; dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1-1][x2+1])%MOD; }//只有当前pic 相同的时候才转移 } } } int ans = 0; for ( int i = 1 ; i&amp;lt;= n ; i++ ) { ans = (ans + dp[cur][i][i]) % MOD; } if ((m+n)%2) { for ( int i = 1 ; i&amp;lt;= n-1 ; i++) { ans = (ans + dp[cur][i][i+1])%MOD; } } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>codeforces 570 D. Tree Requests (dfs序)</title><link>https://111qqz.com/2015/08/codeforces570d-treerequestsdfs/</link><pubDate>Fri, 14 Aug 2015 19:50:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces570d-treerequestsdfs/</guid><description>
因为字母的排列顺序是任意的,所以判断能否形成回文串的条件就成了出现次数为奇数的字母的个数是否大于1个,如果是,那么一定不能形成回文串,否则一定可以.
为了找到以节点v为根的 subtree 中深度为h的后代,需要求出dfs序列,并且记录每个节点初次访问的时间戳和离开它的时间戳,然后二分.
貌似也可以用树状数组做?
/************************************************************************* &amp;gt; File Name: code/cf/#316/D.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月15日 星期六 02时55分55秒 ************************************************************************/ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int N=5E5+7; int n,m; vector&amp;lt;int&amp;gt; adj[N]; char S[N]; vector&amp;lt;int&amp;gt; occ[N][26]; int in[N], out[N], now; void dfs(int u, int depth) { occ[depth][S[u]-'a'].push_back(++now); in[u]=now; vector&amp;lt;int&amp;gt;::iterator it; for (it=adj[u].begin();it!=adj[u].end();it++) { dfs(*it,depth+1); } out[u]=now; } int main() { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m); for(int i=2; i&amp;lt;=n; i++) { int a; scanf(&amp;quot;%d&amp;quot;,&amp;amp;a); adj[a].</description></item><item><title>poj 2157 Maze (bfs)</title><link>https://111qqz.com/2015/08/poj2157mazebfs/</link><pubDate>Fri, 14 Aug 2015 13:31:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2157mazebfs/</guid><description/></item><item><title>cf 570 C. Replacement (暴力)</title><link>https://111qqz.com/2015/08/cf570c-replacement/</link><pubDate>Thu, 13 Aug 2015 22:55:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf570c-replacement/</guid><description>
C. Replacement
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Daniel has a string s, consisting of lowercase English letters and period signs (characters '.'). Let's define the operation of replacement as the following sequence of steps: find a substring &amp;quot;..&amp;quot; (two consecutive periods) in string s, of all occurrences of the substring let's choose the first one, and replace this substring with string &amp;quot;.</description></item><item><title>cf 570B B. Simple Game(构造)</title><link>https://111qqz.com/2015/08/cf570bb-simplegame/</link><pubDate>Thu, 13 Aug 2015 22:53:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf570bb-simplegame/</guid><description/></item><item><title>cf 570 A. Elections</title><link>https://111qqz.com/2015/08/cf570a-elections/</link><pubDate>Thu, 13 Aug 2015 22:46:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf570a-elections/</guid><description/></item><item><title>hdu 1429胜利大逃亡(续) (bfs+状态压缩)</title><link>https://111qqz.com/2015/08/hdu1429bfs/</link><pubDate>Thu, 13 Aug 2015 12:55:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu1429bfs/</guid><description/></item><item><title>Fibonacci number’s ratio (the hard version)</title><link>https://111qqz.com/2015/08/fibonaccinumbersratiothehardversion/</link><pubDate>Wed, 12 Aug 2015 13:11:00 +0000</pubDate><guid>https://111qqz.com/2015/08/fibonaccinumbersratiothehardversion/</guid><description/></item><item><title>cf 569B. Inventory （模拟？）</title><link>https://111qqz.com/2015/08/cf569b-inventory/</link><pubDate>Wed, 12 Aug 2015 04:23:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf569b-inventory/</guid><description/></item><item><title>cf 569A. Music (暴力)</title><link>https://111qqz.com/2015/08/cf569a-music/</link><pubDate>Wed, 12 Aug 2015 04:20:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf569a-music/</guid><description/></item><item><title>light oj 1066- Gathering Food (bfs)</title><link>https://111qqz.com/2015/08/lightoj1066-gatheringfoodbfs/</link><pubDate>Tue, 11 Aug 2015 15:44:00 +0000</pubDate><guid>https://111qqz.com/2015/08/lightoj1066-gatheringfoodbfs/</guid><description/></item><item><title>hdu 4630 No Pain No Game(树状数组）</title><link>https://111qqz.com/2015/08/hdu4630nopainnogame/</link><pubDate>Tue, 11 Aug 2015 10:19:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu4630nopainnogame/</guid><description/></item><item><title>whust #0.2 J Jailbreak (未AC)</title><link>https://111qqz.com/2015/08/whust0-2jjailbreakac/</link><pubDate>Sun, 09 Aug 2015 12:29:00 +0000</pubDate><guid>https://111qqz.com/2015/08/whust0-2jjailbreakac/</guid><description/></item><item><title>whust #0.2 I Incognito</title><link>https://111qqz.com/2015/08/whust0-2iincognito/</link><pubDate>Sun, 09 Aug 2015 11:55:00 +0000</pubDate><guid>https://111qqz.com/2015/08/whust0-2iincognito/</guid><description/></item><item><title>whust #0.1 I - Laughing Out Loud</title><link>https://111qqz.com/2015/08/whust0-1i-laughingoutloud/</link><pubDate>Sun, 09 Aug 2015 08:13:00 +0000</pubDate><guid>https://111qqz.com/2015/08/whust0-1i-laughingoutloud/</guid><description/></item><item><title>hdu 5365 (bc #50 1002 )Run</title><link>https://111qqz.com/2015/08/hdu5365bc501002run/</link><pubDate>Sun, 09 Aug 2015 07:55:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu5365bc501002run/</guid><description/></item><item><title>hdu 5366 (bc #50 1003) The mook jong</title><link>https://111qqz.com/2015/08/hdu5366bc501003themookjong/</link><pubDate>Sun, 09 Aug 2015 07:34:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu5366bc501003themookjong/</guid><description/></item><item><title>hdu 5364 (bc#50 1001) Distribution money</title><link>https://111qqz.com/2015/08/hdu5364bc501001distributionmoney/</link><pubDate>Sun, 09 Aug 2015 07:32:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu5364bc501001distributionmoney/</guid><description/></item><item><title>啥都不会肿么办</title><link>https://111qqz.com/2015/08/</link><pubDate>Fri, 07 Aug 2015 20:38:00 +0000</pubDate><guid>https://111qqz.com/2015/08/</guid><description>
啊啊啊，为什么这么弱
啥都不会呜呜呜
肿么办肿么办肿么办
不会的好多啊。。。。。
啊啊啊</description></item><item><title>hdu 3874 Necklace (树状数组+离线操作)</title><link>https://111qqz.com/2015/08/hdu3874necklace/</link><pubDate>Fri, 07 Aug 2015 18:47:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu3874necklace/</guid><description/></item><item><title>hdu 3333 Turing Tree (求区间中不相同数的和，离线+线段树/树状数组)</title><link>https://111qqz.com/2015/08/hdu3333/</link><pubDate>Fri, 07 Aug 2015 18:42:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu3333/</guid><description>
题目链接
喵呜，离散树状数组。
这道题由于相同的值加和的时候只算一次，所以比较伤脑筋==
怎么办呢？
我们发现对于一个值，由于相同的只算一次，所以在任意时间内，这个值只需要出现一次。
如果我们从作往右将原数组更新到树状数组，如果某个值之前出现过，那么我在更新当前的时候，还需要删掉之前那个。
这样就可以保证当前的序列中一个值只出现了一次，而且位置更新成最后出现的位置。
如果只出现一次的话那就又是我们喜闻乐见的那个熟悉的树状数组了呢 喵呜！
但是这样删掉前面出现的元素真心大丈夫？ 万一之后又查询了之前你删掉的点岂不是整个人都萌萌哒了？
所以我们可以按照查询区间的又断点排序，保证前面删掉的点以后不会再被查询。
也就是按照顺序，从左往右，边查询，边更新原数组到树状数组。
由于查询区间是无序的，按照右端点排序之后打乱了原来的查询顺序，所以要离线操作。
由于查询区间是无序的，按照右端点排序之后打乱了原来的查询顺序，所以要离线操作。
由于查询区间是无序的，按照右端点排序之后打乱了原来的查询顺序，所以要离线操作。
** **重要的事情说三遍。
所谓离线操作，就是查询的时候不直接输出答案，而是将答案存起来，然后最后一起输出。
 我们需要开一个数组pre [x] 记录x这个数的上一个位置，初始为-1
由 x的范围太大，数组存不下，所以要离散化。
离散化是为了记录一个数上次出现的位置！
注意要开LL 。
/************************************************************************* &amp;gt; File Name: code/hdu/3333.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月07日 星期五 17时04分07秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=3E4+3; LL c[N]; LL n,m,qur; LL ref[N]; LL pre[N]; LL ori[N]; struct Q { LL val,id; }q[N]; struct S { LL x,y; LL id,ans; }s[100005]; bool cmp( Q a,Q b) { if (a.</description></item><item><title>2015 多校 #5 1007 MZL's simple problem</title><link>https://111qqz.com/2015/08/201551007mzlssimpleproblem/</link><pubDate>Fri, 07 Aug 2015 10:24:00 +0000</pubDate><guid>https://111qqz.com/2015/08/201551007mzlssimpleproblem/</guid><description/></item><item><title>2015 多校 #5 1005 MZL's chemistry</title><link>https://111qqz.com/2015/08/201551005mzlschemistry/</link><pubDate>Fri, 07 Aug 2015 10:20:00 +0000</pubDate><guid>https://111qqz.com/2015/08/201551005mzlschemistry/</guid><description/></item><item><title>2015多校 #5 1002 MZL's xor</title><link>https://111qqz.com/2015/08/201551002mzlsxor/</link><pubDate>Fri, 07 Aug 2015 10:17:00 +0000</pubDate><guid>https://111qqz.com/2015/08/201551002mzlsxor/</guid><description/></item><item><title>hdu 4267/poj 3468 A Simple Problem with Integers （分状态的树状数组）</title><link>https://111qqz.com/2015/08/hdu4267/</link><pubDate>Fri, 07 Aug 2015 08:28:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu4267/</guid><description>
树状数组，更新区间，查询单点，区别是加了一个a%k==0的条件限制.... 我们观察到k很小，于是按照k分类.... 每一类再按照余数分类，一共55棵树（1+2+3+...+10）
然后写完交上去，竟然MLE了。。。 13×1350007 我一开始也想到了是开大了。。。然后改成了111150004，结果还是mle.. 然后我就把代码贴到群里问了。。。。 然后就被打脸了。。。 被这顿嘲讽啊。。。 由于我的vim不知道什么原因，要复制两次才能复制上去。。。 就是说，改成了111150004的代码并没有提交上去，第二次mle还是1313*50007。。 不过也算一个经验：对于低维度（一维）数组，稍微开大点对空间影响不会很大... 但是高维，稍微开大一点，就会极大的影响空间....因为是乘起来的。 因为之前很少遇到高维，而且数组比较大的情况，所以没有太注意。 也说明把数组开大一点就好，一点点。
代码是按照hdu 4267 写的 poj 3468和这个差不多，就是读入顺序和op的写法不太一样。 另：某博客看到的tips，虽然我也知道这个，但我觉得他表达得比较清楚... Tips：
树状数组的优势是方便动态求值和更新..
可惜树状数组是单点更新
倒是有个方法可以快速成段更新
就是在区间【a, b】内更新+x就在a的位置+x 然后在b+1的位置-x
求某点a的值就是求数组中1~a的和..
可惜这道题还不是成段更新..而是隔开几个数来更新..
所以就可以多建几棵树..然后就可以转换为成段更新了~~
1 2/****....********************************************************************* 3&amp;gt; File Name: code/hdu/4267.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年08月07日 星期五 14时27分58秒 7************************************************************************/ 8 9#include&amp;lt;iostream&amp;gt;10#include&amp;lt;iomanip&amp;gt;11#include&amp;lt;cstdio&amp;gt;12#include&amp;lt;algorithm&amp;gt;13#include&amp;lt;cmath&amp;gt;14#include&amp;lt;cstring&amp;gt;15#include&amp;lt;string&amp;gt;16#include&amp;lt;map&amp;gt;17#include&amp;lt;set&amp;gt;18#include&amp;lt;queue&amp;gt;19#include&amp;lt;vector&amp;gt;20#include&amp;lt;stack&amp;gt;21#define y0 abc111qqz 22#define y1 hust111qqz 23#define yn hez111qqz 24#define j1 cute111qqz 25#define tm crazy111qqz 26#define lr dying111qqz 27using namespace std; 28#define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 29typedef long long LL; 30typedef unsigned long long ULL; 31const int inf = 0x7fffffff; 32const int N=5E4+3; 33int c[N][11][11]; 34int a[N]; 35int n,m,k,del,x,q,y; 36bool flag; 37int lowbit( int x) 38{ 39 return x&amp;amp;(-x); 40} 41void update ( int a,int b,int x, int delta) 42{ 43 for ( int i = x; i &amp;lt;= n ; i = i + lowbit (i)) 44 { 45 c[i][a][b] += delta; 46 } 47} 48int sum ( int a,int b,int x) 49{ 50 int res = 0; 51 for ( int i = x; i &amp;gt;= 1; i = i - lowbit (i)) 52 { 53 res = res + c[i][a][b]; 54 } 55 return res; 56} 57int main() 58{ 59 while (scanf(&amp;#34;%d&amp;#34;,&amp;amp;n)!</description></item><item><title>hdu 3584 Cube （三维树状数组，更新区间，查询单点）</title><link>https://111qqz.com/2015/08/hdu3584/</link><pubDate>Fri, 07 Aug 2015 06:20:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu3584/</guid><description>
三维树状数组
容斥那里注意一下。
多组数据因为忘记清空c数组而wa了1次，细心！
/************************************************************************* &amp;gt; File Name: code/hdu/3584.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月07日 星期五 14时01分53秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E2+5; int c[N][N][N]; int n,m; int x1,y1,z1,x2,y2,z2; int lowbit( int x) { return x&amp;amp;(-x); } void update ( int x,int y,int z,int delta) { for ( int i = x; i &amp;lt;= n ; i = i + lowbit(i)) { for ( int j = y ; j &amp;lt;= n ; j = j + lowbit(j)) { for ( int k = z ; k &amp;lt;= n ; k = k + lowbit(k)) { c[i][j][k] += delta; } } } } int sum (int x,int y,int z) { int res = 0; for ( int i = x; i &amp;gt;= 1 ; i -= lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j -= lowbit(j)) { for ( int k = z ; k &amp;gt;= 1 ; k -= lowbit(k)) { res = res + c[i][j][k]; } } } return res; } int main() { int op; while (scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m)!</description></item><item><title>poj 2155- Matrix (树状数组，二维，更新区间，查询单点)</title><link>https://111qqz.com/2015/08/poj2155/</link><pubDate>Thu, 06 Aug 2015 18:41:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2155/</guid><description>
1
和上一道类似，也是更新区间，查询单点。
用到了容斥原理。
/************************************************************************* &amp;gt; File Name: code/poj/2155.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月07日 星期五 00时42分38秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E3+7; int c[N][N]; int n,m,x1,x2,y1,y2,x,y,t; int lowbit ( int x) { return x&amp;amp;(-x); } void update ( int x,int y ,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) { for ( int j = y; j &amp;lt;= n ; j = j + lowbit(j)) { c[i][j] = c[i][j] + delta; } } } int sum ( int x,int y) { int res = 0; for ( int i = x; i &amp;gt;= 1 ; i = i - lowbit (i)) { for ( int j = y ; j &amp;gt;= 1 ; j = j - lowbit (j)) { res = res + c[i][j]; } } return res; } int main() { int T; cin&amp;gt;&amp;gt;T; while (T--) { memset(c,0,sizeof(c)); scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;t); for ( int i = 1; i &amp;lt;= t; i ++ ) { char cmd; cin&amp;gt;&amp;gt;cmd; if (cmd=='C') { scanf(&amp;quot;%d %d %d %d&amp;quot;,&amp;amp;x1,&amp;amp;y1,&amp;amp;x2,&amp;amp;y2); // cout&amp;lt;&amp;lt;&amp;quot;*******&amp;quot;&amp;lt;&amp;lt;c[2][1]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;c[2][2]&amp;lt;&amp;lt;endl; update (x1,y1,1); update (x2+1,y1,1); update (x1,y2+1,1); update (x2+1,y2+1,1); // cout&amp;lt;&amp;lt;&amp;quot;*******&amp;quot;&amp;lt;&amp;lt;c[2][1]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;c[2][2]&amp;lt;&amp;lt;endl; } else { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y); int tmp; // cout&amp;lt;&amp;lt;&amp;quot;sum(x)(y):&amp;quot;&amp;lt;&amp;lt;sum(x,y)&amp;lt;&amp;lt;endl; // cout&amp;lt;&amp;lt;&amp;quot;sum(x-1,y-1):&amp;quot;&amp;lt;&amp;lt;sum(x-1,y-1)&amp;lt;&amp;lt;endl; // cout&amp;lt;&amp;lt;&amp;quot;sum(x-1,y):&amp;quot;&amp;lt;&amp;lt;sum(x-1,y)&amp;lt;&amp;lt;endl; // cout&amp;lt;&amp;lt;&amp;quot;sum(x,y-1):&amp;quot;&amp;lt;&amp;lt;sum(x,y-1)&amp;lt;&amp;lt;endl; tmp =sum(x,y)+sum(x-1,y-1)-sum(x-1,y)-sum(x,y-1); // cout&amp;lt;&amp;lt;&amp;quot;tmp:&amp;quot;&amp;lt;&amp;lt;tmp&amp;lt;&amp;lt;endl; if (sum(x,y)%2==0) cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;1&amp;lt;&amp;lt;endl; } // cout&amp;lt;&amp;lt;&amp;quot;*****************&amp;quot;&amp;lt;&amp;lt;endl; // for ( int ii = 1 ; ii &amp;lt;= n ; ii++) // { // for ( int jj = 1 ; jj &amp;lt;= n ; jj++ ) // { // cout&amp;lt;&amp;lt;c[ii][jj]&amp;lt;&amp;lt;&amp;quot; &amp;quot;; // } // cout&amp;lt;&amp;lt;endl; // } // cout&amp;lt;&amp;lt;&amp;quot;*************************&amp;quot;&amp;lt;&amp;lt;endl; // } cout&amp;lt;&amp;lt;endl; } return 0; }</description></item><item><title>hdu 1556Color the ball （树状数组，更新区间，查询单点）</title><link>https://111qqz.com/2015/08/hdu1556/</link><pubDate>Thu, 06 Aug 2015 18:33:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu1556/</guid><description>
这道题和之前做的树状数组略有不同。
以前的都是更新单点，查询区间，这次反了过来。
做法差不多。
如果更新区间【x,y】增加１
那么只要 update (x,1),update (y+1,-1)
问单点的时候，sum(i)就是i点的值，而不是1..i的和。
可以看做告诉公路收费口的比喻，update (x,1)相当于入口
update (y+1,-1)相当于出口。
而sum(i)就相当于被几个告诉公路穿过，或者说i点属于几个高速公路，所以是求和
还记得noip2012的时候在tyvj上遇到了一道线段数的题，被＠Ocean　海洋兄用了一个高速公路的神奇比喻解法A掉了。
现在回想，原来是用了树状数组。
/************************************************************************* &amp;gt; File Name: code/hdu/1556.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月07日 星期五 01时56分51秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E6+7; int n; int c[N]; int lowbit( int x) { return x&amp;amp;(-x); } void update ( int x,int delta) { for ( int i = x; i &amp;lt;= N ; i = i + lowbit (i)) { c[i] = c[i] + delta; } } int sum ( int x) { int res = 0; for ( int i = x ; i &amp;gt;= 1 ; i = i - lowbit (i)) { res = res + c[i]; } return res; } int main() { while (scanf(&amp;quot;%d&amp;quot;,&amp;amp;n)!</description></item><item><title>sgu 180 - Inversions （离散化+树状数组）</title><link>https://111qqz.com/2015/08/sgu180/</link><pubDate>Thu, 06 Aug 2015 09:09:00 +0000</pubDate><guid>https://111qqz.com/2015/08/sgu180/</guid><description>
Inversions **Time Limit:**250MS **Memory Limit:**4096KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
180. Inversions time limit per test: 0.25 sec.
memory limit per test: 4096 KB
input: standard
output: standard
There are N integers (1&amp;lt;=N&amp;lt;=65537) A1, A2,.. AN (0&amp;lt;=Ai&amp;lt;=10^9). You need to find amount of such pairs (i, j) that 1&amp;lt;=iA[j].
Input
The first line of the input contains the number N. The second line contains N numbers A1.</description></item><item><title>poj 1195 Mobile phones （二维树状数组）</title><link>https://111qqz.com/2015/08/poj1195mobilephones/</link><pubDate>Thu, 06 Aug 2015 08:20:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj1195mobilephones/</guid><description/></item><item><title>cf 567 C. Geometric Progression</title><link>https://111qqz.com/2015/08/cf567c-geometricprogression/</link><pubDate>Thu, 06 Aug 2015 07:29:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf567c-geometricprogression/</guid><description/></item><item><title>sssssad</title><link>https://111qqz.com/2015/08/sssssad/</link><pubDate>Wed, 05 Aug 2015 19:16:00 +0000</pubDate><guid>https://111qqz.com/2015/08/sssssad/</guid><description>
依然对算法，对acm充满热情。
只是比赛，组队赛。
心里满满的都是阴影，再也没有什么热情与感动。
连起队名这种事情我都不愿意想了。
起得再棒有什么用。
pacedect 这名字。
说起来好像有一个学期没和某妹子说话了。。。。。。。。
sssssad.
真是是坟墓般的荒芜
不是痛，只是不允许任何人触碰2333
算了，自己开心就好
我发现，当我刷题，当我学习新算法，打比赛就算被虐，我也是开心的。
可是如果是组队赛，就会想起pacedect 的那些美好与痛苦，想起恩怨情仇...
所以那段时间不搞acm，完全不记得这些，我也是开心的。
组队什么的随它去吧。
真的真的无所谓。
我是真的怕了，怕投入太多感情，到头来却........
所以说acm要是一个人的比赛就好了呢。
晚安。</description></item><item><title>cf #314 B. Berland National Library (模拟)</title><link>https://111qqz.com/2015/08/cf314b-berlandnationallibrary/</link><pubDate>Wed, 05 Aug 2015 19:00:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf314b-berlandnationallibrary/</guid><description>
给出一个图书馆人员进出情况，问图书馆满足题意的最小容量是多少。
注意在初始之前图书馆里面可能就有人了，也就是说不是所有进入图书馆的人都会被给出。
我的做法是先统计出图书馆里面初始的人数，开一个布尔数组，初始全为false,如果一个人标记为 false 而且从 图书馆里出来了，就说明这个人初始是在图书馆里的。
然后就正常模拟，图书馆的人数由初始的和后来的两部分组成。
/************************************************************************* &amp;gt; File Name: code/cf/#314/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月06日 星期四 00时23分26秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E2+5;moni int n; int r[N]; bool vis[1000060]; char ch[N]; int main() { cin&amp;gt;&amp;gt;n; char cmd; int mx = -1; int cur = 0; int beforein = 0; memset(vis,false,sizeof(vis)); for ( int i = 0 ; i &amp;lt; n ; i++) { cin&amp;gt;&amp;gt;ch[i]&amp;gt;&amp;gt;r[i]; if (ch[i]=='+') { vis[r[i]] = true; } if (ch[i]=='-') { if (!</description></item><item><title>codeforces #314 A. Lineland Mail</title><link>https://111qqz.com/2015/08/cf314a/</link><pubDate>Wed, 05 Aug 2015 18:51:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf314a/</guid><description>
给一个有序序列，问对于没一个数，和它相差最少和最多的数的位置。
/************************************************************************* &amp;gt; File Name: code/cf/#314/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月06日 星期四 00时01分51秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E5+7; LL a[N]; int main() { int n; cin&amp;gt;&amp;gt;n; a[0]=-inf; a[n+1]=inf; for ( int i = 1 ; i &amp;lt;= n ; i ++ ) { cin&amp;gt;&amp;gt;a[i]; } int mx = -1; int mi = inf; cout&amp;lt;&amp;lt;a[2]-a[1]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;a[n]-a[1]&amp;lt;&amp;lt;endl; for ( int i = 2 ; i &amp;lt;= n-1 ; i++ ) { cout&amp;lt;&amp;lt;min(abs(a[i]-a[i-1]),abs(a[i+1]-a[i]))&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;max(abs(a[i]-a[1]),abs(a[n]-a[i]))&amp;lt;&amp;lt;endl; } cout&amp;lt;&amp;lt;a[n]-a[n-1]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;a[n]-a[1]&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>hdu 5305 Friends　（dfs）</title><link>https://111qqz.com/2015/08/hdu5305/</link><pubDate>Wed, 05 Aug 2015 15:36:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu5305/</guid><description>
dfs 1A
/************************************************************************* &amp;gt; File Name: code/whust/#9/K.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月05日 星期三 15时02分30秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; int n ,m,ans; int d[50]; int on[50],off[50]; int u[50],v[50]; bool ok(int x,int y) { if ( !</description></item><item><title>poj 2299 Ultra-QuickSort （树状数组＋离散化）</title><link>https://111qqz.com/2015/08/poj2299/</link><pubDate>Tue, 04 Aug 2015 13:13:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2299/</guid><description>
这道题可以总结的地方不少。
１：对于一组乱序数列，每次只能交换相邻元素，达到有序交换的次数就是原数列中你逆序对的个数。
　cf上好像总喜欢出这个题。。。我印象中就出现三次了。。。。。
２：原始数组a[i]和树状数组的t[i]的对应问题（？？？存在疑问。。。应该只是这道题，而不是一般规律！）
　这道题n是５０００００，如果直接开数组是可以开得下的，不需要离散化。**但是树状数组的下标对应的是原始数组的值！**也就是t[i]的下表最大可能为９９９，９９９，９９９　！　显然存不下，需要离散化。
**３：学习了离散化的又一种写法。 **
/************************************************************************* &amp;gt; File Name: code/poj/2299.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月04日 星期二 12时27分32秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=5E5+7; int n; int t[N]; int ref[N]; struct Q { int val,id; }q[N]; bool cmp(Q a,Q b) { if (a.</description></item><item><title>poj 3067 Japan（树状数组）</title><link>https://111qqz.com/2015/08/poj3067japan/</link><pubDate>Tue, 04 Aug 2015 04:08:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3067japan/</guid><description/></item><item><title>poj 2481 Cows(树状数组||线段树)</title><link>https://111qqz.com/2015/08/poj2481/</link><pubDate>Mon, 03 Aug 2015 19:32:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2481/</guid><description>
poj 2481 题目链接
题意：给定n个区间，问对于每个区间，有多少个区间真包含该区间（真包含的意思是说，两个区间不能完全重合）
思路：
下面是一年前用树状数组过掉的时候写的题解： 和 star那道题差不多。 需要注意的是star那道题读入的时候已经排好了序，而这道题没有排序
由于答案是按照下表输出，排序的时候下标会被打乱，所以要存一下下表到结构体里。
另一个区别是，star那道题星星不会重复，就是说一个位置不会有多颗星星。
而这道题却可能，而且题目中说，如果区间的长度差为0（就是后面的那个不等式），那么不计数。
因为区间下标可能为0，但是树状数组的下表必须从1开始，所以下表要+1，但是由于下表可能有所重复，所以 不能用++,而是用+1
不然会增加多次（我就是这么w a了两次。。。）
树状数组ac代码：
/************************************************************************* &amp;gt; File Name: code/poj/2481.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月04日 星期二 02时06分05秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E5+7; int n; int a[N],t[N]; struct Q { int s,e,id; }q[N]; bool cmp (Q a,Q b) { if (a.</description></item><item><title>poj 2352 Stars （树状数组||线段树）</title><link>https://111qqz.com/2015/08/poj2352/</link><pubDate>Mon, 03 Aug 2015 17:29:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2352/</guid><description>
poj 2352题目链接
题意：给出n个星星的位置，一个星星的level定义为其左下角（不严格）星星的数量。
要求统计0到n-1 level的星星各有多少个。
下面是一年前写的树状数组的题解：
依然想不通，智商是硬伤，绝望的想哭，真的想哭。 更新于2015年08月04日01:47:18：
好像有点明白了.....详情看注释
树状数组ac代码：
/************************************************************************* &amp;gt; File Name: code/poj/2352.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月04日 星期二 00时33分52秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=4E4+7; int a[N]; int t[N]; int x,y; int n; int lowbit (int x) { return x&amp;amp;(-x); } void update(int x,int c) { int i; for ( int i = x ; i &amp;lt;= 32001 ; i = i + lowbit(i)) { t[i] = t[i] + c; } } int sum( int x) { int i; int res = 0; for ( int i = x ; i &amp;gt;= 1 ; i = i-lowbit(i)) { res = res + t[i]; } // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; return res; } int main() { scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for ( int i = 0 ; i &amp;lt; n ; i ++ ) { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y); a[sum(++x)]++; // ++x是因为坐标是从0 开始，而树状数组的下标一定是从1开始，不然会TLE // sum(++x)是求 ++x 的level // // update(x,1); //向上更新，对于每一个比x大的位置，由于x的存在，那些位置的点的level都会增加1 //比如对于星3，因为星1的读入，我向上更新了星2,星3,星4,星5，这时候他们的level都是1 //之后读入星2，更新了星3和星5，星3的level是2，星5的level也是2，之后由于星4，星5的level又加1，为5.</description></item><item><title>hdu 4349</title><link>https://111qqz.com/2015/08/hdu4349/</link><pubDate>Mon, 03 Aug 2015 07:35:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu4349/</guid><description/></item><item><title>cf #309a A - Kyoya and Photobooks</title><link>https://111qqz.com/2015/08/cf309aa-kyoyaandphotobooks/</link><pubDate>Sun, 02 Aug 2015 10:44:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf309aa-kyoyaandphotobooks/</guid><description/></item><item><title>hdu 5234 (bc #42 C)Happy birthday(dp)</title><link>https://111qqz.com/2015/08/hdu5234bc42chappybirthdaydp/</link><pubDate>Sat, 01 Aug 2015 03:21:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu5234bc42chappybirthdaydp/</guid><description/></item><item><title>hdu 4022 Bombing (离散化)</title><link>https://111qqz.com/2015/08/hdu4022/</link><pubDate>Sat, 01 Aug 2015 02:12:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu4022/</guid><description>
wa了两次，原因是在同一个点可能有多个基地。。。
所以用set 是错误的，应该用multiset
然后因为这道题看到了map+set实现离散化的另外一种写法
我的代码：
/************************************************************************* &amp;gt; File Name: code/hdoj/4022.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月01日 星期六 04时37分20秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int N=2E5+7; const int inf = 0x7fffffff; map&amp;lt;int,int&amp;gt;xmap,ymap; multiset&amp;lt;int&amp;gt;x[N]; multiset&amp;lt;int&amp;gt;y[N]; int main() { int n,m; while (scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m)!</description></item><item><title>hdoj 2436 Collision Detection</title><link>https://111qqz.com/2015/07/hdoj2436/</link><pubDate>Fri, 31 Jul 2015 20:16:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdoj2436/</guid><description>
Collision Detection **Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1207 Accepted Submission(s): 367 **
Problem Description
 In physical simulations, video games and computational geometry, collision detection involves algorithms for checking for collision, i.e. intersection, of two given objects. Collision detection algorithms are a basic component of 3D video games. Without them, characters could go through walls and other obstacles. Here comes an interesting problem, given a ball and a cuboid, you need to detect whether they collide.</description></item><item><title>hdu 5233 Gunner II (bc #42 B) （离散化）</title><link>https://111qqz.com/2015/07/hdu5233/</link><pubDate>Fri, 31 Jul 2015 19:04:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5233/</guid><description>
Gunner II **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1433 Accepted Submission(s): 540 **
Problem Description
Long long ago, there was a gunner whose name is Jack. He likes to go hunting very much. One day he go to the grove. There are n birds and n trees. The i-th bird stands on the top of the i-th tree. The trees stand in straight line from left to the right.</description></item><item><title>bc #43(hdu 5265) pog loves szh II （单调性优化）</title><link>https://111qqz.com/2015/07/hdu5265/</link><pubDate>Fri, 31 Jul 2015 09:10:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5265/</guid><description>
pog loves szh II **Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 2115 Accepted Submission(s): 609
**
Problem Description
Pog and Szh are playing games.There is a sequence with n numbers, Pog will choose a number A from the sequence. Szh will choose an another number named B from the rest in the sequence. Then the score will be (A+B) mod p.They hope to get the largest score.</description></item><item><title>sgu 455. Sequence analysis （floyd 判圈算法，O(1)空间复杂度求循环节）</title><link>https://111qqz.com/2015/07/sgu455/</link><pubDate>Thu, 30 Jul 2015 13:19:00 +0000</pubDate><guid>https://111qqz.com/2015/07/sgu455/</guid><description>
455. Sequence analysis 比赛的时候逗了，往看空间限制了....
直接开了个set判重。。。显然MLE 了。。。
然后这道题的正解是 floyd判圈算法（也叫龟兔算法？）
http://www.cnblogs.com/oyking/p/4286916.html 这份题解讲得很详细
1 /************************************************************************* 2&amp;gt; File Name: code/2015summer/#5/CC.cpp 3&amp;gt; Author: 111qqz 4&amp;gt; Email: rkz2013@126.com 5&amp;gt; Created Time: 2015年07月30日 星期四 21时02分17秒 6************************************************************************/ 7 #include&amp;lt;iostream&amp;gt;8 #include&amp;lt;iomanip&amp;gt;9 #include&amp;lt;cstdio&amp;gt;10 #include&amp;lt;algorithm&amp;gt;11 #include&amp;lt;cmath&amp;gt;12 #include&amp;lt;cstring&amp;gt;13 #include&amp;lt;string&amp;gt;14 #include&amp;lt;map&amp;gt;15 #include&amp;lt;set&amp;gt;16 #include&amp;lt;queue&amp;gt;17 #include&amp;lt;vector&amp;gt;18 #include&amp;lt;stack&amp;gt;19 #define y0 abc111qqz 20 #define y1 hust111qqz 21 #define yn hez111qqz 22 #define j1 cute111qqz 23 #define tm crazy111qqz 24 #define lr dying111qqz 25 using namespace std; 26 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 27 typedef long long LL; 28 typedef unsigned long long ULL; 29 const int inf = 0x7fffffff; 30 const int LIM = 2E6; 31 LL a,b,c; 32 LL next (LL x) 33 { 34 return (a*x+x%b)%c; 35 } 36 int main() 37 { 38 cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c; 39 LL x = next(1); 40 LL y = next(next(1)); 41 int v = 1; 42 while (v&amp;lt;=LIM &amp;amp;&amp;amp;x!</description></item><item><title>sgu 463 - Walking around Berhattan</title><link>https://111qqz.com/2015/07/sgu463/</link><pubDate>Thu, 30 Jul 2015 12:04:00 +0000</pubDate><guid>https://111qqz.com/2015/07/sgu463/</guid><description>
简单模拟,n,m貌似给反了(两个地方给的不一致 ) 害我wa了两发
1 2 /************************************************************************* 3&amp;gt; File Name: code/2015summer/#5/K.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月30日 星期四 14时00分56秒 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 #define y0 abc111qqz 22 #define y1 hust111qqz 23 #define yn hez111qqz 24 #define j1 cute111qqz 25 #define tm crazy111qqz 26 #define lr dying111qqz 27 using namespace std; 28 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 29 typedef long long LL; 30 typedef unsigned long long ULL; 31 const int inf = 0x7fffffff; 32 const int N=1e2+5; 33 int b[N][N]; 34 int n,m; 35 char cmd[505]; 36 bool vis[N][N]; 37 int nx,ny; 38 int dx[4]={-1,0,1,0}; 39 int dy[4]={0,1,-0,-1}; 40 char ch[N][N]; 41 int main() 42 { 43 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; 44 nx = 0; 45 ny = 0; 46 for ( int i = 0 ; i &amp;lt; n ; i++) 47 cin&amp;gt;&amp;gt;ch[i]; 48 for ( int i = 0 ; i &amp;lt;n ; i++ ) 49 { 50 for ( int j = 0 ; j &amp;lt; m ; j++ ) 51 { 52 b[i+1][j+1]=(int)(ch[i][j]-&amp;#39;0&amp;#39;); 53 } 54 } 55 int ans = 0; 56 memset(vis,false,sizeof(vis)); 57 int dir = 1; 58 cin&amp;gt;&amp;gt;cmd; 59 int len = strlen(cmd); 60 for ( int i = 0 ; i &amp;lt; len ; i ++ ) 61 { 62 // cout&amp;lt;&amp;lt;&amp;#34;ans:&amp;#34;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 63 // cout&amp;lt;&amp;lt;&amp;#34;nx:&amp;#34;&amp;lt;&amp;lt;nx&amp;lt;&amp;lt;&amp;#34; ny:&amp;#34;&amp;lt;&amp;lt;ny&amp;lt;&amp;lt;endl; 64 if (cmd[i]==&amp;#39;L&amp;#39;) 65 { 66 dir = (dir+3)%4; 67 } 68 if (cmd[i]==&amp;#39;R&amp;#39;) 69 { 70 dir = (dir+1)%4; 71 } 72 if (cmd[i]==&amp;#39;M&amp;#39;) 73 { 74 if (dir==0) 75 { 76 if (vis[nx][ny]) 77 { 78 ans = ans + b[nx][ny]/2; 79 } 80 else 81 { 82 ans = ans + b[nx][ny]; 83 } 84 if (vis[nx][ny+1]) 85 { 86 ans = ans + b[nx][ny+1]/2; 87 } 88 else 89 { 90 ans = ans + b[nx][ny+1]; 91 } 92 vis[nx][ny]=true; 93 vis[nx][ny+1]=true; 94 nx = nx +dx[dir]; 95 ny = ny +dy[dir]; 96 } 97 if (dir==2) 98 { 99 nx = nx + dx[dir]; 100 ny = ny + dy[dir]; 101 if (vis[nx][ny]) 102 { 103 ans = ans + b[nx][ny]/2; 104 } 105 else 106 { 107 ans = ans + b[nx][ny]; 108 } 109 if (vis[nx][ny+1]) 110 { 111 ans = ans + b[nx][ny+1]/2; 112 } 113 else 114 { 115 ans = ans + b[nx][ny+1]; 116 } 117 vis[nx][ny]=true; 118 vis[nx][ny+1]=true; 119 } 120 if (dir==1) 121 { 122 nx = nx + dx[dir]; 123 ny = ny + dy[dir]; 124 if (vis[nx][ny]) 125 { 126 ans = ans + b[nx][ny]/2; 127 } 128 else 129 { 130 ans = ans + b[nx][ny]; 131 } 132 if (vis[nx+1][ny]) 133 { 134 ans = ans + b[nx+1][ny]/2; 135 } 136 else 137 { 138 ans = ans + b[nx+1][ny]; 139 } 140 vis[nx][ny]=true; 141 vis[nx+1][ny]=true; 142 143 } 144 if (dir==3) 145 { 146 147 if (vis[nx][ny]) 148 { 149 ans = ans + b[nx][ny]/2; 150 } 151 else 152 { 153 ans = ans + b[nx][ny]; 154 } 155 if (vis[nx+1][ny]) 156 { 157 ans = ans + b[nx+1][ny]/2; 158 } 159 else 160 { 161 ans = ans + b[nx+1][ny]; 162 } 163 vis[nx][ny]=true; 164 vis[nx+1][ny]=true; 165 nx = nx +dx[dir]; 166 ny = ny +dy[dir]; 167 } 168 } 169 170 } 171 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 172 173 return 0; 174 } 175 176</description></item><item><title>SGU 456 Annuity Payment Scheme</title><link>https://111qqz.com/2015/07/sgu456/</link><pubDate>Thu, 30 Jul 2015 12:02:00 +0000</pubDate><guid>https://111qqz.com/2015/07/sgu456/</guid><description>
水题,推个公式出来,注意精度...一遍A
1 2 /************************************************************************* 3&amp;gt; File Name: code/2015summer/#5/D.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月30日 星期四 13时17分26秒 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 #define y0 abc111qqz 22 #define y1 hust111qqz 23 #define yn hez111qqz 24 #define j1 cute111qqz 25 #define tm crazy111qqz 26 #define lr dying111qqz 27 using namespace std; 28 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 29 typedef long long LL; 30 typedef unsigned long long ULL; 31 const int inf = 0x7fffffff; 32 int s,m,p; 33 double ans; 34 35 double cal(double x,int n) 36 { 37 double res = 1.</description></item><item><title>SPOJ AMR10F Cookies Piles</title><link>https://111qqz.com/2015/07/spojamr10fcookiespiles/</link><pubDate>Wed, 29 Jul 2015 13:51:00 +0000</pubDate><guid>https://111qqz.com/2015/07/spojamr10fcookiespiles/</guid><description>
AMR10F - Cookies Piles 水.
1 2 3 /************************************************************************* 4&amp;gt; File Name: code/2015summer/#4/F.cpp 5&amp;gt; Author: 111qqz 6&amp;gt; Email: rkz2013@126.com 7&amp;gt; Created Time: 2015年07月29日 星期三 21时47分23秒 8************************************************************************/ 9 10 #include&amp;lt;iostream&amp;gt;11 #include&amp;lt;iomanip&amp;gt;12 #include&amp;lt;cstdio&amp;gt;13 #include&amp;lt;algorithm&amp;gt;14 #include&amp;lt;cmath&amp;gt;15 #include&amp;lt;cstring&amp;gt;16 #include&amp;lt;string&amp;gt;17 #include&amp;lt;map&amp;gt;18 #include&amp;lt;set&amp;gt;19 #include&amp;lt;queue&amp;gt;20 #include&amp;lt;vector&amp;gt;21 #include&amp;lt;stack&amp;gt;22 #define y0 abc111qqz 23 #define y1 hust111qqz 24 #define yn hez111qqz 25 #define j1 cute111qqz 26 #define tm crazy111qqz 27 #define lr dying111qqz 28 using namespace std; 29 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 30 typedef long long LL; 31 typedef unsigned long long ULL; 32 const int inf = 0x7fffffff; 33 int main() 34 { 35 int T; 36 int n,a,d; 37 cin&amp;gt;&amp;gt;T; 38 while (T--) 39 { 40 scanf(&amp;#34;%d %d %d&amp;#34;,&amp;amp;n,&amp;amp;a,&amp;amp;d); 41 cout&amp;lt;&amp;lt;n*a+n*(n-1)/2*d&amp;lt;&amp;lt;endl; 42 } 43 44 return 0; 45 } 46 47 48</description></item><item><title>poj 2823 Sliding Window (单调队列)</title><link>https://111qqz.com/2015/07/poj2823/</link><pubDate>Wed, 29 Jul 2015 13:03:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj2823/</guid><description>
Sliding Window
看这个问题：An array of size n ≤ 106 is given to you. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves rightwards by one position.Your task is to determine the maximum and minimum values in the sliding window at each position.</description></item><item><title>(bc #45) A - Dylans loves numbers (hdu 5272)</title><link>https://111qqz.com/2015/07/bc45a-dylanslovesnumbershdu5272/</link><pubDate>Wed, 29 Jul 2015 06:28:00 +0000</pubDate><guid>https://111qqz.com/2015/07/bc45a-dylanslovesnumbershdu5272/</guid><description>
快要炸了..
tle成狗
因为是tle,看了下自己没有写cin cout,估计就是算法的问题...
我是先存了二进制的每一位到数组,然后扫一遍...
嗯,这都tle...
那我不存不扫,直接记录当前二进制位和之前二进制位..
logn的复杂度总可以了吧啊?
还TLE..........
嗯,其实已经发现 n是小于等于1e18的,没开long long
但是一位没开long long 会是wa...就没理...
之后实在黔驴技穷,改了下,竟然过了...
然后想明白了.
因为存二进制的时候有一个while
没开long long 的话就炸了,不知道读进去的是什么,while就出不来,于是就tle了.T T
果然太年轻.
1 2 3 4 /************************************************************************* 5&amp;gt; File Name: code/bc/#45/1001.cpp 6&amp;gt; Author: 111qqz 7&amp;gt; Email: rkz2013@126.com 8&amp;gt; Created Time: 2015年07月29日 星期三 13时25分01秒 9************************************************************************/ 10 11 #include&amp;lt;iostream&amp;gt;12 #include&amp;lt;iomanip&amp;gt;13 #include&amp;lt;cstdio&amp;gt;14 #include&amp;lt;algorithm&amp;gt;15 #include&amp;lt;cmath&amp;gt;16 #include&amp;lt;cstring&amp;gt;17 #include&amp;lt;string&amp;gt;18 #include&amp;lt;map&amp;gt;19 #include&amp;lt;set&amp;gt;20 #include&amp;lt;queue&amp;gt;21 #include&amp;lt;vector&amp;gt;22 #include&amp;lt;stack&amp;gt;23 #define y0 abc111qqz 24 #define y1 hust111qqz 25 #define yn hez111qqz 26 #define j1 cute111qqz 27 #define tm crazy111qqz 28 #define lr dying111qqz 29 using namespace std; 30 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 31 typedef long long LL; 32 typedef unsigned long long ULL; 33 const int inf = 0x7fffffff; 34 const int N=1E3+5; 35 int a[N]; 36 LL n,nn; 37 int main() 38 { 39 int T; 40 cin&amp;gt;&amp;gt;T; 41 while (T--) 42 { 43 scanf(&amp;#34;%lld&amp;#34;,&amp;amp;n); 44 nn = n ; 45 int k = 0; 46 while (nn) 47 { 48 k++; 49 a[k]=nn&amp;amp;1; 50 nn = nn &amp;gt;&amp;gt;1; 51 } 52 int ans = 0; 53 // for ( int i = 1 ; i &amp;lt;= k ; i++ ) 54 // cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl; 55 for ( int i = 1 ; i &amp;lt;= k ; i++ ) 56 { 57 if (a[i]==1&amp;amp;&amp;amp;a[i-1]==0) 58 ans++; 59 } 60 printf(&amp;#34;%d\n&amp;#34;,ans); 61 } 62 return 0; 63 } 64 65 66</description></item><item><title>codeforces 442C. Artem and Array</title><link>https://111qqz.com/2015/07/cf442c/</link><pubDate>Tue, 28 Jul 2015 20:45:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf442c/</guid><description>
C. Artem and Array
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Artem has an array of n positive integers. Artem decided to play with it. The game consists of n moves. Each move goes like this. Artem chooses some element of the array and removes it. For that, he gets min(a, b) points, where a and b are numbers that were adjacent with the removed number.</description></item><item><title>cf 442B Andrey and Problem</title><link>https://111qqz.com/2015/07/cf442b/</link><pubDate>Tue, 28 Jul 2015 18:18:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf442b/</guid><description>
B. Andrey and Problem
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Andrey needs one more problem to conduct a programming contest. He has n friends who are always willing to help. He can ask some of them to come up with a contest problem. Andrey knows one value for each of his fiends -- the probability that this friend will come up with a problem if Andrey asks him.</description></item><item><title>cf 443B Kolya and Tandem Repeat</title><link>https://111qqz.com/2015/07/cf443b/</link><pubDate>Tue, 28 Jul 2015 16:07:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf443b/</guid><description>
B. Kolya and Tandem Repeat
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Kolya got string s for his birthday, the string consists of small English letters. He immediately added k more characters to the right of the string.
Then Borya came and said that the new string contained a tandem repeat of length l as a substring. How large could l be?</description></item><item><title>(BC 一周年) hdu 5312 Sequence</title><link>https://111qqz.com/2015/07/hdu5312/</link><pubDate>Tue, 28 Jul 2015 15:48:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5312/</guid><description>
比赛的时候没做出来.这道题需要用到的一个重要的性质是,任意一个自然数可以表示成至多三个三角形数(1,3,6,10,15.....)的和(orz高斯)然后也有推广到任意自然数可以表示成k个k角形数的和的结论(费马提出了猜想,柯西给了证明)然后官方题解说的比较好:
**这个题看上去是一个贪心, 但是这个贪心显然是错的. 事实上这道题目很简单, 先判断1个是否可以, 然后判断2个是否可以. 之后找到最小的k (k 2)k(k2), 使得(m - k) mod 6 = 0(m−k)mod6=0即可.** 证明如下: 3n(n-1)+1 = 6(n(n-1)/2)+13n(n−1)+1=6(n∗(n−1)/2)+1, 注意到n(n-1)/2n∗(n−1)/2是三角形数, 任意一个自然数最多只需要3个三角形数即可表示. 枚举需要kk个, 那么显然m=6(km=6(k个三角形数的和)+k)+k, 由于k ge 3k≥3, 只要m-km−k是6的倍数就一定是有解的.**
事实上, 打个表应该也能发现规律.
另外还有一点,特判一个和两个的情况时,一个的好判断,扫一遍就好了
两个的话,由于这个数列是递增的,我们可以从两边往中间,算是一个不错的优化,具体见代码.
1 /************************************************************************* 2&amp;gt; File Name: code/nv/#ann/1003.cpp 3&amp;gt; Author: 111qqz 4&amp;gt; Email: rkz2013@126.com 5&amp;gt; Created Time: 2015年07月28日 星期二 23时03分09秒 6************************************************************************/ 7 8 #include&amp;lt;iostream&amp;gt;9 #include&amp;lt;iomanip&amp;gt;10 #include&amp;lt;cstdio&amp;gt;11 #include&amp;lt;algorithm&amp;gt;12 #include&amp;lt;cmath&amp;gt;13 #include&amp;lt;cstring&amp;gt;14 #include&amp;lt;string&amp;gt;15 #include&amp;lt;map&amp;gt;16 #include&amp;lt;set&amp;gt;17 #include&amp;lt;queue&amp;gt;18 #include&amp;lt;vector&amp;gt;19 #include&amp;lt;stack&amp;gt;20 #define y0 abc111qqz 21 #define y1 hust111qqz 22 #define yn hez111qqz 23 #define j1 cute111qqz 24 #define tm crazy111qqz 25 #define lr dying111qqz 26 using namespace std; 27 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 28 typedef long long LL; 29 typedef unsigned long long ULL; 30 const int inf = 0x7fffffff; 31 const int N=1E5+7; 32 int k,m,f[N]; 33 void init() 34 { 35 for ( int i = 1 ; i &amp;lt;N; i++) 36 { 37 f[i]=3*i*(i-1)+1; 38 if (f[i]&amp;gt;1000000000) 39 { 40 k = i-1; 41 break; 42 } 43 } 44 } 45 int solve (int x) 46 { 47 for ( int i = 1 ; f[i]&amp;lt;=x ; i++ ) 48 { 49 if (x==f[i]) 50 return 1; 51 } 52 int j = k; 53 for ( int i = 1 ; i &amp;lt;= k-1&amp;amp;&amp;amp;f[i]&amp;lt;x ; i++) 54 { 55 while(f[i]+f[j]&amp;gt;x) j--; 56 if (f[i]+f[j]==x) return 2; 57 } 58 for ( int i = 3 ; i &amp;lt;= m ; i++ ) 59 { 60 if ((m-i)%6==0) 61 return i; 62 } 63 } 64 int main() 65 { 66 int T; 67 init(); 68 cin&amp;gt;&amp;gt;T; 69 int ans; 70 while (T--) 71 { 72 73 scanf(&amp;#34;%d&amp;#34;,&amp;amp;m); 74 cout&amp;lt;&amp;lt;solve(m)&amp;lt;&amp;lt;endl; 75 76 } 77 78 return 0; 79 } 80 81 82</description></item><item><title>三角形数_百度百科</title><link>https://111qqz.com/2015/07/Triangle-number/</link><pubDate>Tue, 28 Jul 2015 14:30:00 +0000</pubDate><guid>https://111qqz.com/2015/07/Triangle-number/</guid><description>
它有一定的规律性，排列如下(构成图)，像上面的1、3、6、10、15等等这些能够表示成三角形的形状的总数量的数，叫做三角形数。
一定数目的点或圆在等距离的排列下可以形成一个等边三角形，这样的数被称为三角形数。比如10个点可以组成一个等边三角形，因此10是一个三角形数：
x
x　x
x　x　x
x　x　x　x
x　x　x　x x
开始个18个三角形数是1、3、6、10、15、21、28、36、45、55、66、78、91、105、120、136、153、171……（OEIS中的数列A000217）
第n个三角形数的公式是
或者
第n个三角形数是开始的n个自然数的和。
所有大于3的三角形数都不是质数。
开始的n个立方数的和是第n个三角形数的平方（举例：1 + 8 + 27 + 64 = 100 =102）
所有三角形数的倒数之和是2。
任何三角形数乘以8再加1是一个平方数。
一部分三角形数（3、10、21、36、55、78……）可以用以下这个公式来表示：n × (2n + 1)；而剩下的另一部分（1、6、15、28、45、66……）则可以用n × (2n - 1)来表示。
一种检验正整数x是否三角形数的方法，是计算：
如果n是整数，那么x就是第n个三角形数。如果n不是整数，那么x不是三角形数。这个检验法是基于恒等式8Tn + 1 = S2n + 1.
特殊的三角形数
55、5,050、500,500、50,005,000……都是三角形数。
第11个三角形数（66）、第1111个三角形数（617,716）、第111,111个三角形数（6,172,882,716）、第11,111,111个三角形数（61,728,399,382,716）都是回文式的三角形数，但第111个、第11,111个和第1,111,111个三角形数不是。
和其他数的关系
四面体数是三角形数在立体的推广。
两个相继的三角形数之和是平方数。
三角平方数是同时为三角形数和平方数的数。
三角形数属於一种多边形数。
所有偶完美数都是三角形数。
任何自然数是最多三个三角形数的和。高斯发现了这个规律。他在1796年7月10日在日记中写道：EYPHKA! num = Δ + Δ + Δ</description></item><item><title>(BC 一周年)hdu 5311 Hidden String</title><link>https://111qqz.com/2015/07/hdu5311/</link><pubDate>Tue, 28 Jul 2015 14:22:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5311/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5311 题意：问能否从一个给定的字符串中拿出三个不相交的字串（原串可以有剩余），组成字符串“anniversary” 思路：暴力。
比赛的时候没做出来,sad 我发现我有一个问题,就是不敢跑暴力 有不少题其实正解就是暴力 或者有的题,暴力不是标解,但是绝对可A,可我就不敢写... 就觉得不会是这样.. 说到底还是不自信吧...
思路是枚举两个间隔点,将 string tar=&amp;quot;anniversary&amp;quot;分成三个不为空的部分 然后在给的字符串中按顺序查找这三部分 如果都能找到,直接YES 如果任何一种间隔的分段都无法YES 就NO...
妈蛋,if语句后面多写了个分号,调了半个多小时才发现(为啥总是这种傻逼错误....) 还有一点,因为是多组数据,而对于每组数据,将tar拆分的方法都是一样的,可以先预处理一下存到数组里.
1 2 #define yn hez111qqz 3 #define j1 cute111qqz 4 #define tm crazy111qqz 5 #define lr dying111qqz 6 using namespace std; 7 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 8 typedef long long LL; 9 typedef unsigned long long ULL; 10 const int N=1E2+5; 11 int d[N]; 12 int len; 13 string st,tar,s1,s2,s3; 14 bool flag; 15 16 void solve (string x,string y,string z) 17 { 18 int lx = x.</description></item><item><title>(BC 一周年)hdu 5310 Souvenir</title><link>https://111qqz.com/2015/07/hdu5310/</link><pubDate>Tue, 28 Jul 2015 12:11:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5310/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5310 水。 不要用cin.
1 2 /************************************************************************* 3&amp;gt; File Name: code/bc/#ann/1001.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月25日 星期六 18时54分24秒 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 #define y0 abc111qqz 22 #define y1 hust111qqz 23 #define yn hez111qqz 24 #define j1 cute111qqz 25 #define tm crazy111qqz 26 #define lr dying111qqz 27 using namespace std; 28 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 29 typedef long long LL; 30 typedef unsigned long long ULL; 31 int n,m,p,q; 32 int main() 33 { 34 int T; 35 cin&amp;gt;&amp;gt;T; 36 int ans = 0; 37 while (T--) 38 { 39 // scanf(&amp;#34;%d %d %d %d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;p,&amp;amp;q); 40 scanf(&amp;#34;%d %d %d %d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;p,&amp;amp;q); 41 ans = n*p; 42 ans = min(ans,n/m*q+n%m*p); 43 ans = min(ans,((n-1)/m+1)*q); 44 printf(&amp;#34;%d\n&amp;#34;,ans); 45 } 46 47 return 0; 48 } 49 50 51</description></item><item><title>uva 12442 . Forwarding Emails</title><link>https://111qqz.com/2015/07/uva12442/</link><pubDate>Tue, 28 Jul 2015 07:51:00 +0000</pubDate><guid>https://111qqz.com/2015/07/uva12442/</guid><description>
&amp;quot;... so forward this to ten other people, to prove that you believe the emperor has
题意是说发短信,每个人只会给一个人发,问从哪个人开始发,能传到的人最多
思路是每个人开始做一遍dfs...
毫无意外的TLE了
一个容易想到的剪枝是,如果在第i次之前的路径上的点,在之后以它作为起点遍历一定不优.
我们可以用一个数组vis标记上(注意不要和为了dfs的标记数组vis2混淆,vis2标记的主要作用是判断是否成环)
sad,看来还是要提高自己的搜索姿势啊....
1 2 3 4 /************************************************************************* 5&amp;gt; File Name: code/2015summer/sea#2/B.cpp 6&amp;gt; Author: 111qqz 7&amp;gt; Email: rkz2013@126.com 8&amp;gt; Created Time: 2015年07月28日 星期二 14时59分16秒 9************************************************************************/ 10 11 #include&amp;lt;iostream&amp;gt;12 #include&amp;lt;iomanip&amp;gt;13 #include&amp;lt;cstdio&amp;gt;14 #include&amp;lt;algorithm&amp;gt;15 #include&amp;lt;cmath&amp;gt;16 #include&amp;lt;cstring&amp;gt;17 #include&amp;lt;string&amp;gt;18 #include&amp;lt;map&amp;gt;19 #include&amp;lt;set&amp;gt;20 #include&amp;lt;queue&amp;gt;21 #include&amp;lt;vector&amp;gt;22 #include&amp;lt;stack&amp;gt;23 #define y0 abc111qqz 24 #define y1 hust111qqz 25 #define yn hez111qqz 26 #define j1 cute111qqz 27 #define tm crazy111qqz 28 #define lr dying111qqz 29 using namespace std; 30 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 31 typedef long long LL; 32 typedef unsigned long long ULL; 33 const int N=5E4+7; 34 int a[N]; 35 bool vis[N],vis2[N]; 36 int u,v,n; 37 int dfs(int x) 38 { 39 int res=0; 40 vis2[x]=true; 41 int tmp = a[x]; 42 if (!</description></item><item><title>I - Fire Game (两个点开始的bfs)</title><link>https://111qqz.com/2015/07/i-firegamebfs/</link><pubDate>Mon, 27 Jul 2015 11:01:00 +0000</pubDate><guid>https://111qqz.com/2015/07/i-firegamebfs/</guid><description>
http://acm.hust.edu.cn/vjudge/contest/view.action?cid=83084#problem/I
I - Fire Game
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire.</description></item><item><title>poj 3414 pots (bfs+路径记录)</title><link>https://111qqz.com/2015/07/poj3414/</link><pubDate>Mon, 27 Jul 2015 08:44:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3414/</guid><description>
好爽,一遍ac
1 2 3 /************************************************************************* 4&amp;gt; File Name: code/2015summer/searching/H.cpp 5&amp;gt; Author: 111qqz 6&amp;gt; Email: rkz2013@126.com 7&amp;gt; Created Time: 2015年07月27日 星期一 09时11分28秒 8************************************************************************/ 9 10 #include&amp;lt;iostream&amp;gt;11 #include&amp;lt;iomanip&amp;gt;12 #include&amp;lt;cstdio&amp;gt;13 #include&amp;lt;algorithm&amp;gt;14 #include&amp;lt;cmath&amp;gt;15 #include&amp;lt;cstring&amp;gt;16 #include&amp;lt;string&amp;gt;17 #include&amp;lt;map&amp;gt;18 #include&amp;lt;set&amp;gt;19 #include&amp;lt;queue&amp;gt;20 #include&amp;lt;vector&amp;gt;21 #include&amp;lt;stack&amp;gt;22 #define y0 abc111qqz 23 #define y1 hust111qqz 24 #define yn hez111qqz 25 #define j1 cute111qqz 26 #define tm crazy111qqz 27 #define lr dying111qqz 28 using namespace std; 29 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 30 typedef long long LL; 31 typedef unsigned long long ULL; 32 const int N=1E2+5; 33 int A,B,C; 34 int d[N][N]; 35 bool flag; 36 struct node 37 { 38 int d,opt,par,prea,preb; 39 }q[N][N]; 40 41 void print(int x,int y) 42 { 43 // cout&amp;lt;&amp;lt;&amp;#34;x:&amp;#34;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;#34;y:&amp;#34;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; 44 if (q[x][y].</description></item><item><title>hdoj 1495 非常可乐(bfs)</title><link>https://111qqz.com/2015/07/hdoj1495/</link><pubDate>Sun, 26 Jul 2015 14:59:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdoj1495/</guid><description>
非常可乐 **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 7194 Accepted Submission(s): 2865
**
Problem Description
大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&amp;lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出&amp;quot;NO&amp;quot;。
Input
三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以&amp;quot;0 0 0&amp;quot;结束。
Output
如果能平分的话请输出最少要倒的次数，否则输出&amp;quot;NO&amp;quot;。
Sample Input
7 4 3 4 1 3 0 0 0
Sample Output
NO 3
平分可乐,不能剩.
奇数的话直接no
偶数的话bfs
妈蛋写了140+行,简直令人感动.
然后一直WA
郁闷了好久,结果今天一看,竟然已经A了...
是测评傲娇了嘛2333
1 2 3 4 /************************************************************************* 5&amp;gt; File Name: code/2015summer/searching/M.</description></item><item><title>hdoj 1241 Oil Deposits (dfs)</title><link>https://111qqz.com/2015/07/hdoj-1241/</link><pubDate>Sat, 25 Jul 2015 07:47:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdoj-1241/</guid><description>
Oil Deposits **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 17683 Accepted Submission(s): 10172
**
Problem Description
The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil.</description></item><item><title>hdoj 2612 find a way (两次bfs)</title><link>https://111qqz.com/2015/07/hdoj2612/</link><pubDate>Sat, 25 Jul 2015 07:01:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdoj2612/</guid><description>
Find a way ****Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 6221 Accepted Submission(s): 2070
**
**
Problem Description
Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.
Yifenfei's home is at the countryside, but Merceki's home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC.</description></item><item><title>poj 3984 迷宫问题</title><link>https://111qqz.com/2015/07/poj3984/</link><pubDate>Sat, 25 Jul 2015 05:53:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3984/</guid><description>
迷宫问题
1 2 3 4 /************************************************************************* 5&amp;gt; File Name: code/2015summer/searching/KK.cpp 6&amp;gt; Author: 111qqz 7&amp;gt; Email: rkz2013@126.com 8&amp;gt; Created Time: 2015年07月25日 星期六 13时33分00秒 9************************************************************************/ 10 11 #include&amp;lt;iostream&amp;gt;12 #include&amp;lt;iomanip&amp;gt;13 #include&amp;lt;cstdio&amp;gt;14 #include&amp;lt;algorithm&amp;gt;15 #include&amp;lt;cmath&amp;gt;16 #include&amp;lt;cstring&amp;gt;17 #include&amp;lt;string&amp;gt;18 #include&amp;lt;map&amp;gt;19 #include&amp;lt;set&amp;gt;20 #include&amp;lt;queue&amp;gt;21 #include&amp;lt;vector&amp;gt;22 #include&amp;lt;stack&amp;gt;23 #define y0 abc111qqz 24 #define y1 hust111qqz 25 #define yn hez111qqz 26 #define j1 cute111qqz 27 #define tm crazy111qqz 28 #define lr dying111qqz 29 using namespace std; 30 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 31 typedef long long LL; 32 typedef unsigned long long ULL; 33 int a[10][10]; 34 int head = 0; 35 int tail = 1; 36 int dirx[2]={1,0}; 37 int diry[2]={0,1}; 38 struct node 39 { 40 int x,y,pre; 41 }q[10]; 42 43 void print(int x) 44 { 45 if (q[x].</description></item><item><title>poj 3087 Shuffle'm Up (bfs)</title><link>https://111qqz.com/2015/07/poj3087/</link><pubDate>Fri, 24 Jul 2015 16:12:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3087/</guid><description>
http://poj.org/problem?id=3087
用bfs写的，但是其实就是个模拟啊喂！
只有一种操作，何谈最短？　一直往下写就行了．
有一点疑惑，就是map的初始值
比如我定义的　map&amp;lt;string,int&amp;gt;d;它的初始的value是什么？随机值？０？还是什么，百度了下，没找到，求指教．
1 2 #include&amp;lt;iostream&amp;gt;3 #include&amp;lt;iomanip&amp;gt;4 #include&amp;lt;cstdio&amp;gt;5 #include&amp;lt;algorithm&amp;gt;6 #include&amp;lt;cmath&amp;gt;7 #include&amp;lt;cstring&amp;gt;8 #include&amp;lt;string&amp;gt;9 #include&amp;lt;map&amp;gt;10 #include&amp;lt;set&amp;gt;11 #include&amp;lt;queue&amp;gt;12 #include&amp;lt;vector&amp;gt;13 #include&amp;lt;stack&amp;gt;14 #define y0 abc111qqz 15 #define y1 hust111qqz 16 #define yn hez111qqz 17 #define j1 cute111qqz 18 #define tm crazy111qqz 19 #define lr dying111qqz 20 using namespace std; 21 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 22 typedef long long LL; 23 typedef unsigned long long ULL; 24 map&amp;lt;string,int&amp;gt;d; 25 string st1,st2,tar; 26 int n; 27 bool flag; 28 string add(string a,string b) 29 { 30 string res=&amp;#34;&amp;#34;; 31 int len = a.</description></item><item><title>poj 3126 Prime Path (bfs)</title><link>https://111qqz.com/2015/07/poj3126/</link><pubDate>Fri, 24 Jul 2015 12:53:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3126/</guid><description>
http://poj.org/problem?id=3126
题意是说,给定两个四位素数a b 问从a变换到b,最少需要变换几次. 变换的要求是,每次只能改变一个数字,而且中间过程得到的四位数也必须为素数. 因为提到最少变换几次,容易想到bfs,bfs第一次搜到的一定是最短步数.
先打个素数表 然后写个函数判断两个四位数有几位数字不同,如果只有一位,返回true,否则返回false 然后竟然wa了两次! 下表写错! pri[k++]=i;是先给pri[k]赋值,再k++; pri[++k]=i;才是先增加,再赋值.这个搞错了.所以wa了....sad
1 2 /************************************************************************* 3&amp;gt; File Name: code/poj/3126.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: Fri 24 Jul 2015 01:16:23 AM CST 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 #define y0 abc111qqz 22 #define y1 hust111qqz 23 #define yn hez111qqz 24 #define j1 cute111qqz 25 #define tm crazy111qqz 26 #define lr dying111qqz 27 using namespace std; 28 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 29 typedef long long LL; 30 typedef unsigned long long ULL; 31 const int N =1E4+5; 32 int pri[N],which[N]; 33 int a,b,k; 34 bool flag; 35 int d[N]; 36 bool prime(int x) 37 { 38 for ( int i = 2 ; i*i&amp;lt;=x ;i++ ) 39 { 40 if (x %i==0) return false; 41 } 42 return true; 43 } 44 45 bool ok (int x,int y) 46 { 47 if (d[y]!</description></item><item><title>poj 3279 Fliptile (搜索..暴力？)</title><link>https://111qqz.com/2015/07/poj3279/</link><pubDate>Thu, 23 Jul 2015 14:56:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3279/</guid><description>
http://poj.org/problem?id=3279
反转类问题.
有N*M个方格,每个上面有数字0或者1
操作一个方格,这个方格即其相邻的四个方格(有公共边)会改变状态(由0变1或者由1变0)
问至少需要多少次操作,所有的状态都为0
如果有多组,输出字典序小的那一组.
跟开关灯的那题相似.
因为每个开关灯的动作还影响其他相邻灯的状态.所以对于这种题,一般思路是,先定住一部分,再由已知定住的这部分去确定其他部分.
对于这道题而言
首先我们可以很容易发现,操作数为偶数和为0是等价的.
操作数为1和为奇数是等价的.
对于这道题而言,我们可以首先枚举第一行的状态,一共有 2&amp;lt;
然后如果 a[i-1][j]为1,因为i-1行的状态已经确定,无法改变,所以能影响到a[i-1][j]的只有a[i][j]
那么a[i][j]一定要操作一次
最后判断最后一行是否都为0,如果为0,表示这种情况是合法的
然后找到操作数最小的一组.
字典序的话,只要是枚举的时候按照数的大小顺序就可以保证.
学会了用memcpy函数.
1 2 #include&amp;lt;iostream&amp;gt;3 #include&amp;lt;iomanip&amp;gt;4 #include&amp;lt;cstdio&amp;gt;5 #include&amp;lt;algorithm&amp;gt;6 #include&amp;lt;cmath&amp;gt;7 #include&amp;lt;cstring&amp;gt;8 #include&amp;lt;string&amp;gt;9 #include&amp;lt;map&amp;gt;10 #include&amp;lt;set&amp;gt;11 #include&amp;lt;queue&amp;gt;12 #include&amp;lt;vector&amp;gt;13 #include&amp;lt;stack&amp;gt;14 #define y0 abc111qqz 15 #define y1 hust111qqz 16 #define yn hez111qqz 17 #define j1 cute111qqz 18 #define tm crazy111qqz 19 #define lr dying111qqz 20 using namespace std; 21 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 22 typedef long long LL; 23 typedef unsigned long long ULL; 24 const int N=20; 25 int a[N][N],ans[N][N],op[N][N]; 26 int m,n; 27 int dirx[10]={0,0,0,-1,1}; 28 int diry[10]={0,1,-1,0,0}; 29 int rec[N][N]; 30 void solve(int x,int y) 31 { 32 for ( int i = 0 ; i &amp;lt; 5 ; i++ ) 33 { 34 int newx = x + dirx[i]; 35 int newy = y + diry[i]; 36 if (newx&amp;gt;=1&amp;amp;&amp;amp;newx&amp;lt;=m&amp;amp;&amp;amp;newy&amp;gt;=1&amp;amp;&amp;amp;newy&amp;lt;=n) 37 { 38 a[newx][newy]=a[newx][newy]^1; 39 } 40 } 41 } 42 bool on (int x,int y) 43 { 44 int res = a[x][y]; 45 for ( int i = 0 ; i &amp;lt; 5 ; i++ ) 46 { 47 int newx = x + dirx[i]; 48 int newy = y + diry[i]; 49 if (newx&amp;gt;=1&amp;amp;&amp;amp;newx&amp;lt;=m&amp;amp;&amp;amp;newy&amp;gt;=1&amp;amp;&amp;amp;newy&amp;lt;=n) 50 { 51 res = res+op[newx][newy]; 52 } 53 54 } 55 return res&amp;amp;1; 56 } 57 int main() 58 { 59 cin&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n; 60 int mi = 9999999; 61 memset(rec,0,sizeof(rec)); 62 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 63 { 64 for (int j = 1 ; j &amp;lt;= n ; j++) 65 { 66 cin&amp;gt;&amp;gt;a[i][j]; 67 } 68 } 69 bool flag = false; 70 for ( int i = 0 ; i &amp;lt; (1&amp;lt;&amp;lt;n); i++ ) //枚举第一行的好改变情况 71 { 72 int tmp=i; 73 int num=0; 74 memset(op,0,sizeof(op)); 75 memset(ans,0,sizeof(ans)); 76 int k = n; 77 while (tmp) 78 { 79 op[1][k]=tmp%2; 80 if (op[1][k]==1) num++; 81 tmp = tmp / 2; 82 k--; 83 } 84 // cout&amp;lt;&amp;lt;&amp;#34;********************&amp;#34;&amp;lt;&amp;lt;endl; 85 // for ( int i = 1 ; i &amp;lt;= n ; i++) 86 // { 87 // cout&amp;lt;&amp;lt;op[1][i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; 88 // } 89 // cout&amp;lt;&amp;lt;endl; 90 // cout&amp;lt;&amp;lt;&amp;#34;*************************&amp;#34;&amp;lt;&amp;lt;endl; 91 92 93 for ( int j = 2 ; j &amp;lt;= m ; j++ ) 94 { 95 for ( int k = 1 ; k &amp;lt;= n ; k++ ) 96 { 97 if (on(j-1,k)) 98 { 99 op[j][k]=1; 100 num++; 101 } 102 } 103 } 104 bool ok = true; 105 for ( int j = 1 ; j &amp;lt;= n ; j++ ) 106 { 107 if (on(m,j)) 108 { 109 ok=false; 110 break; 111 } 112 } 113 if (ok) 114 { 115 flag = true; 116 if (num&amp;lt;mi) 117 { 118 mi = num; 119 memcpy(rec,op,sizeof(op)); 120 // for ( int j = 1 ; j &amp;lt;= m ; j ++ ) 121 // { 122 // for ( int k = 1 ; k &amp;lt;= n ; k++ ) 123 // { 124 // rec[j][k]=ans[j][k]; 125 // } 126 // } 127 } 128 } 129 } 130 if (flag) 131 { 132 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 133 { 134 cout&amp;lt;&amp;lt;rec[i][1]; 135 for ( int j = 2 ; j &amp;lt;= n ; j++ ) 136 { 137 cout&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;rec[i][j]; 138 } 139 cout&amp;lt;&amp;lt;endl; 140 } 141 } 142 else 143 { 144 printf(&amp;#34;IMPOSSIBLE\n&amp;#34;); 145 } 146 147 return 0; 148 } 149</description></item><item><title>hdu 4082 I Hou Yi's secret （计算几何）</title><link>https://111qqz.com/2015/07/hdu4082/</link><pubDate>Wed, 22 Jul 2015 08:53:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu4082/</guid><description>
http://acm.hust.edu.cn/vjudge/contest/view.action?cid=83295#problem/I
最多18个点，选3个点，能够成的三角形不超过1000个，O(n2)暴力就可以。
思路就是枚举三个点点，对于每一个构成的三角形，把这个三角形的最小角和次小角存起来。
然后枚举三角形，判断是否有两个三角形的最小角和次小角分别对应相等。
需要注意的是题目中问的是相似三角形的最大个数
如果A B 相似 C D 相似，但是B C 不相似，答案应该是2.
还有三角形自身和自身是相似的。
一开始求角度的时候只求了cos值，忘了求下acos了。
需要注意的是，枚举的到时候，三个点可能共线，这个还挺好，题目中说的是“** you may get a triangle**”
may算是提示了
如果共线，就不能构成三角形，何谈相似？
我共线的判断是用斜率搞的，特判下斜率不存在的情况（三个点的横坐标都相同）
然后又交，又WA....妈蛋。。。
然后想，会不会是他射到了同一个点上？
不管多少次射到同一个点上，就只会出现一个hole，也就算作一个点。
于是判重。
判重还没写全。
一开始只把因为重复而不能构成三角形的情况给cut掉了
就是枚举的三个点有至少两个一样，这个时候实际上只有两个点，所以不能够成三角形。
但是马上就发现，对于能构成的三角形的情况，一个点重复了几次，就算了几次，而实际上应该只算一次。
所以改在枚举之前判重。
至于精度问题，我是没遇到。。。
相等都是写成&amp;lt;=eqs 的形式了。。。
注意是fabs而不是abs
最后终于A了。
1 2 3 4 /* *********************************************** 5Author :111qqz 6Created Time :2016年03月03日 星期四 14时43分22秒 7File Name :code/hdu/4082.cpp 8************************************************ */ 9 10 #include&amp;lt;iostream&amp;gt;11 #include&amp;lt;iomanip&amp;gt;12 #include&amp;lt;cstdio&amp;gt;13 #include&amp;lt;algorithm&amp;gt;14 #include&amp;lt;cmath&amp;gt;15 #include&amp;lt;cstring&amp;gt;16 #include&amp;lt;string&amp;gt;17 #include&amp;lt;map&amp;gt;18 #include&amp;lt;set&amp;gt;19 #include&amp;lt;queue&amp;gt;20 #include&amp;lt;vector&amp;gt;21 #include&amp;lt;stack&amp;gt;22 #define y0 abc111qqz 23 #define y1 hust111qqz 24 #define yn hez111qqz 25 #define j1 cute111qqz 26 #define tm crazy111qqz 27 #define lr dying111qqz 28 using namespace std; 29 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 30 typedef long long LL; 31 typedef unsigned long long ULL; 32 const double eqs = 1E-6; 33 const int N = 25; 34 const int inf = 0x7fffffff; 35 int x[N],y[N]; 36 int n; 37 double an[2000][5]; 38 struct Q 39 { 40 int xx,yy; 41 }q[N]; 42 double dis(int a,int b) 43 { 44 double res; 45 res = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]); 46 res = sqrt(res); 47 return res; 48 } 49 double angle(double a,double b,double c) 50 { 51 double res; 52 res = (b*b+c*c-a*a)/(2*b*c); 53 // cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;c&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; 54 res = acos(res); 55 return res; 56 } 57 58 bool cmp(Q a,Q b) 59 { 60 if (a.</description></item><item><title>poj 2398 Toy Storage (计算几何,判断点和线段关系)</title><link>https://111qqz.com/2015/07/poj2398/</link><pubDate>Tue, 21 Jul 2015 13:13:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj2398/</guid><description>
http://poj.org/problem?id=2398
题意大概是说将一个盒子用n个board分成n+1 部分
然后往里面放toy,给定盒子,board,和toy的坐标
问所有的toy放完后,有多少部分中有t个toy;
简单计算几何
需要判断的是点和直线的关系.
判断 某一点在直线左右侧
左右方向是相对前进方向的,只要指定了前进方向就可以知道左右(比如指定前进方向是从直线的起点到终点).判断点在直线的左侧还是右侧是计算几何里面的一个最基本算法.使用矢量来判断.
定义：平面上的三点P1(x1,y1),P2(x2,y2),P3(x3,y3)的面积量：
**
S(P1,P2,P3)=|y1 y2 y3|= (x1-x3)(y2-y3)-(y1-y3)(x2-x3)
当P1P2P3逆时针时S为正的，当P1P2P3顺时针时S为负的。
令矢量的起点为A，终点为B，判断的点为C，
如果S（A，B，C）为正数，则C在矢量AB的左侧；
如果S（A，B，C）为负数，则C在矢量AB的右侧；
如果S（A，B，C）为0，则C在直线AB上。**
1 2 3 4 5 6 /************************************************************************* 7&amp;gt; File Name: code/poj/2398.cpp 8&amp;gt; Author: 111qqz 9&amp;gt; Email: rkz2013@126.com 10&amp;gt; Created Time: 2015年11月08日 星期日 10时04分32秒 11************************************************************************/ 12 #include&amp;lt;iostream&amp;gt;13 #include&amp;lt;iomanip&amp;gt;14 #include&amp;lt;cstdio&amp;gt;15 #include&amp;lt;algorithm&amp;gt;16 #include&amp;lt;cmath&amp;gt;17 #include&amp;lt;cstring&amp;gt;18 #include&amp;lt;string&amp;gt;19 #include&amp;lt;map&amp;gt;20 #include&amp;lt;set&amp;gt;21 #include&amp;lt;queue&amp;gt;22 #include&amp;lt;vector&amp;gt;23 #include&amp;lt;stack&amp;gt;24 using namespace std; 25 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 26 typedef long long LL; 27 typedef unsigned long long ULL; 28 const int N=2E3+5; 29 struct node 30 { 31 int x,y; 32 }; 33 struct node rec,rec2; 34 struct node par[N],par2[N]; 35 struct node toy[N]; 36 int ans[N],cnt[N]; 37 int n,m; 38 bool judge(node p1,node p2,node p3) //判断点是否在直线的[右侧!</description></item><item><title>poj 2251 Dungeon Master (三维bfs)</title><link>https://111qqz.com/2015/07/poj2251/</link><pubDate>Tue, 21 Jul 2015 05:02:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj2251/</guid><description>
http://poj.org/problem?id=2251
简单bfs，只不过是三维的。。。
唯一的坑点在输出上...
Escaped in %d minute(s) 这意思是答案为1输出minute,不为1输出minutes还是说是不是1都输出minute(s)? 试了下，答案是后者。
另：终于找到了好的读地图的方法。。。而不用担心回车符。
就是先读成字符串。
具体见代码
1 2 3 /************************************************************************* 4&amp;gt; File Name: code/2015summer/searching/B.cpp 5&amp;gt; Author: 111qqz 6&amp;gt; Email: rkz2013@126.com 7&amp;gt; Created Time: 2015年07月17日 星期五 16时47分46秒 8************************************************************************/ 9 10 #include&amp;lt;iostream&amp;gt;11 #include&amp;lt;iomanip&amp;gt;12 #include&amp;lt;cstdio&amp;gt;13 #include&amp;lt;algorithm&amp;gt;14 #include&amp;lt;cmath&amp;gt;15 #include&amp;lt;cstring&amp;gt;16 #include&amp;lt;string&amp;gt;17 #include&amp;lt;map&amp;gt;18 #include&amp;lt;set&amp;gt;19 #include&amp;lt;queue&amp;gt;20 #include&amp;lt;vector&amp;gt;21 #include&amp;lt;stack&amp;gt;22 using namespace std; 23 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 24 typedef long long LL; 25 typedef unsigned long long ULL; 26 const int N=40; 27 char st[N][N][N]; 28 int d[N][N][N]; 29 int l,r,c; 30 int sx,sy,sz,tx,ty,tz; 31 int dirx[6]={1,-1,0,0,0,0}; 32 int diry[6]={0,0,-1,1,0,0}; 33 int dirz[6]={0,0,0,0,1,-1}; 34 35 bool ok(int x,int y,int z) 36 { 37 if (z&amp;gt;=0&amp;amp;&amp;amp;z&amp;lt;l&amp;amp;&amp;amp;x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;r&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;c&amp;amp;&amp;amp;d[z][x][y]==-1&amp;amp;&amp;amp;st[z][x][y]!</description></item><item><title>codeforces 558c Amr and Chemistry (贪心)</title><link>https://111qqz.com/2015/07/cf558c/</link><pubDate>Tue, 21 Jul 2015 03:00:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf558c/</guid><description>
http://codeforces.com/contest/558/problem/C
题目大意是说，给定N个数，可以对任意数进行任意次两种操作，×2，和/2（整除）
问最少操作多少次，可以让所有数相等。
嘛，前半个小时A掉了前两个提，d E貌似都是线段树。。并不会。。。就一直搞C。。。。
然而并没有做出来。位运算是什么神奇的黑魔法。
转载一份题解：http://blog.csdn.net/qq_24451605/article/details/46906813
思路是声明两个数组，一个数组表示到达i的步数，另一个数组表示n个数中能够达到i的数的个数（包括本身）
1 2 /************************************************************************* 3&amp;gt; File Name: code/#312C.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: Mon 20 Jul 2015 11:36:50 PM CST 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 using namespace std; 22 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 23 typedef long long LL; 24 typedef unsigned long long ULL; 25 const int N= 1E5+7; 26 const int inf = 0x7fffffff; 27 int a[N]; 28 int vis[N],step[N]; 29 bool cmp (int a,int b) 30 { 31 if (a&amp;gt;b) return true; 32 return false; 33 } 34 int main() 35 { 36 int n; 37 cin&amp;gt;&amp;gt;n; 38 int mx = -1; 39 memset(vis,0,sizeof(vis)); 40 memset(step,0,sizeof(step)); 41 42 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 43 { 44 cin&amp;gt;&amp;gt;a[i]; 45 if (a[i]&amp;gt;mx) 46 mx = a[i]; 47 } 48 for ( int i = 1 ; i &amp;lt;= n ; i++ )f 49 { 50 int tmp = a[i]; 51 int num = 0; 52 while (tmp&amp;lt;=mx) 53 { 54 step[tmp]+=num; //到达tmp需要的操作数是之前的数到达tmo的操作数加上当前 55 vis[tmp]++; //能够到达i的数的个数存在vis数组 56 num++; 57 tmp = tmp &amp;lt;&amp;lt; 1; 58 } 59 num = 0; 60 int tmpa = a[i]; 61 while (tmpa) 62 { 63 if (tmpa&amp;amp;1&amp;amp;&amp;amp;tmpa!</description></item><item><title>POJ 1564 Sum It Up (DFS+剪枝）</title><link>https://111qqz.com/2015/07/poj1564/</link><pubDate>Fri, 17 Jul 2015 07:17:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1564/</guid><description>
http://poj.org/problem?id=1564
dfs
三个参数 x,sum,k, x表示开始的坐标,sum表示当前的和,k表示这是一组答案中的第几个数,是用来记录路径的...
调了好久没写出来...我写完之后答案会有重复.一开始想开一个boolean数组记录,这样第一组样例的3+1就只会输出一遍,但是这样,2+2就不会被记录到答案中了.
然后看了下别人的代码...
卧槽,只是加了个判断...当前的数和上一个如果不同,就继续dfs....
我为何就没想到...这特么是判断重复的直译啊....
1 2 /************************************************************************* 3&amp;gt; File Name: code/2015summer/0714/K.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月16日 星期四 01时03分01秒 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 using namespace std; 22 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 23 typedef long long LL; 24 typedef unsigned long long ULL; 25 const int N=20; 26 int n,t; 27 int a[N]; 28 int ans; 29 int k; 30 int rec[N]; 31 bool vis[105]; 32 bool ok; 33 void dfs(int x,int sum,int k) 34 { 35 if (sum==t) 36 { 37 ok=true; 38 for ( int i = 0 ; i &amp;lt; k ; i++) 39 { 40 if (i) 41 { 42 printf(&amp;#34;+%d&amp;#34;,rec[i]); 43 } 44 else 45 { 46 printf(&amp;#34;%d&amp;#34;,rec[i]); 47 } 48 } 49 printf(&amp;#34;\n&amp;#34;); 50 return; 51 } 52 int pre = -1; 53 for ( int i = x ; i &amp;lt; n ; i++) 54 { 55 if (sum+a[i]&amp;lt;=t&amp;amp;&amp;amp;a[i]!</description></item><item><title>hust2015暑假集训 0713 A a dangerous trip</title><link>https://111qqz.com/2015/07/hust20150713/</link><pubDate>Mon, 13 Jul 2015 09:36:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hust20150713/</guid><description>
http://acm.hust.edu.cn/vjudge/contest/view.action?cid=82557#problem/A
Zk的解法：拆点，把每一个点存成两份，r[i]和r[n+i]
连边的时候如果u和v相连，我们就分别连 u&amp;amp;&amp;amp;v; 和 u+n&amp;amp;&amp;amp;v;+n 和 u&amp;amp;&amp;amp;v;+n 其中最后一个存法是要使用魔法的情况...
最后求从1到n+n的最短路径即可
如图 斜着的边表示使用魔法的情况。
由1到n+n，只经过一次斜边，这是与题干中只使用一次魔法相对应的....
由于权值变成一半可能出现浮点数...
我们不妨先 权值先整体*2
最后结果的时候再/2
zk好聪明（逃）
然后还有一种是鲍佳学长的dp思想的算法.....
http://www.cnblogs.com/chensunrise/p/3721427.html
然而dp渣.....</description></item><item><title>cf 556C Case of Matryoshkas</title><link>https://111qqz.com/2015/07/cf556/</link><pubDate>Sun, 12 Jul 2015 03:39:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf556/</guid><description>
http://codeforces.com/contest/556/problem/C
果然一晚上不睡觉会导致读错题么...
需要注意的是 如果有一个是 1 2 4 6 那么 1,2是不必拆开的....
然后我们发现,只有以1为开始且连续的套娃不必拆开....
可以先假设所有都需要拆开,那么一共需要 2*n-k-1次
然后如果有以1为开始连续的,拆的时候少拆一次,装的时候少装一次,所以ans=ans-2
但是需要注意的是....如果只有一个1,比如1 3 5 也算成了长度为1的以1开始连续的,但是这并没有什么卵用....所以最后答案记得ans+2
1 2/************************************************************************* 3&amp;gt; File Name: code/cf/556C.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月12日 星期日 10时24分54秒 7************************************************************************/ 8 9#include&amp;lt;iostream&amp;gt;10#include&amp;lt;iomanip&amp;gt;11#include&amp;lt;cstdio&amp;gt;12#include&amp;lt;algorithm&amp;gt;13#include&amp;lt;cmath&amp;gt;14#include&amp;lt;cstring&amp;gt;15#include&amp;lt;string&amp;gt;16#include&amp;lt;map&amp;gt;17#include&amp;lt;set&amp;gt;18#include&amp;lt;queue&amp;gt;19#include&amp;lt;vector&amp;gt;20#include&amp;lt;stack&amp;gt;21using namespace std; 22typedef long long LL; 23typedef unsigned long long ULL; 24const int N=1E5+7; 25int a[N],m[N]; 26LL n,k,ans; 27int main() 28{ 29 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k; 30 ans = 2*n-k+1; 31 for (int i = 0 ; i &amp;lt; k ; i++ ) 32 { 33 scanf(&amp;#34;%d&amp;#34;,&amp;amp;m[i]); 34 for (int j = 0 ; j &amp;lt; m[i];j++) 35 { 36 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[j]); 37 if (a[j]==j+1) 38 ans = ans -2; 39 40 } 41 } 42 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 43 return 0; 44} 45</description></item><item><title>最大连续区间和的算法总结</title><link>https://111qqz.com/2015/07/Maximum-interval-continuous-sum/</link><pubDate>Sat, 11 Jul 2015 21:17:00 +0000</pubDate><guid>https://111qqz.com/2015/07/Maximum-interval-continuous-sum/</guid><description>
最大连续区间和是一个经典的问题。给定一个长度为 n 的序列 a[1],a[2]...a[n-1],a[n]，求一个连续的子序列 a[i],a[i+1]...a[j-1],a[j]，使得 a[i]+a[i+1]...a[j-1]+a[j]最大。
① 最简单最容易想到的就是根据定义来枚举。
枚举上下界{i,j | 0&amp;lt;=i&amp;lt;=j&amp;lt;=n}，维护一个 max 值即可。
其中枚举上下界的时间复杂度为 O(n^2)，求区间和的复杂度为 O(n)，所以总时间复杂度为 O(n^3)。
1for ( i = 1 ; i &amp;lt;= n ; i++ ) 2for ( j = i ; j &amp;lt;= n ; j++ ) 3ans = max(ans,accumulate(a+i,a+j+1,0)); ② 其实就是第一种方法的优化。
这里有个很容易想到的优化，即预处理出前缀和 sum[i]=a[0]+a[1]+...+a[i-1]+a[i]，算区间和的时候即可将求区间和的复杂度降到 O(1)，枚举上下界的复杂度不变，所以总时间复杂度为 O(n^2)。
1for ( i = 1 ; i &amp;lt;= n ; i++ ) 2sum[i]=sum[i-1]+a[i]; 3for ( i = 1 ; i &amp;lt;= n ; i++ ) 4for ( j = i ; j &amp;lt;= n ; j++ ) 5ans = max(ans,sum[j]-sum[i-1]); 6 ③ 可以利用动态规划的思维来继续优化，得到一个线性的算法，也是最大连续区间和的标准算法</description></item><item><title>poj 3278 catch that cow</title><link>https://111qqz.com/2015/07/poj3278/</link><pubDate>Wed, 08 Jul 2015 02:25:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3278/</guid><description>
http://poj.org/problem?id=3278
bfs,用到了stl的queue
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时45分05秒 6File Name :3278.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 #include &amp;lt;stack&amp;gt;17 #include &amp;lt;queue&amp;gt;18 19 using namespace std; 20 typedef long long LL; 21 const int inf = 8E8; 22 const int N=2E5+7; 23 int d[N]; 24 int n,k; 25 void bfs() 26 { 27 queue&amp;lt;int&amp;gt; q; 28 memset(d,-1,sizeof(d)); 29 q.</description></item><item><title>POJ 1028 Web Navigation</title><link>https://111qqz.com/2015/07/poj1028/</link><pubDate>Wed, 08 Jul 2015 02:08:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1028/</guid><description>
http://poj.org/problem?id=1028
1 2 3 4 /* *********************************************** 5Author :111qqz 6Created Time :2016年02月19日 星期五 15时45分01秒 7File Name :1028.cpp 8************************************************ */ 9 10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstdio&amp;gt;12 #include &amp;lt;iostream&amp;gt;13 #include &amp;lt;cstring&amp;gt;14 #include &amp;lt;string&amp;gt;15 #include &amp;lt;cmath&amp;gt;16 #include &amp;lt;map&amp;gt;17 #include &amp;lt;stack&amp;gt;18 #include &amp;lt;queue&amp;gt;19 20 using namespace std; 21 typedef long long LL; 22 const int inf = 8E8; 23 stack&amp;lt;string&amp;gt; backstack; 24 stack&amp;lt;string&amp;gt; forwardstack; 25 string cur; 26 string cmd; 27 int main() 28 { 29 cur =&amp;#34;http://www.</description></item><item><title>poj 2643 election</title><link>https://111qqz.com/2015/07/poj2643/</link><pubDate>Wed, 08 Jul 2015 01:27:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj2643/</guid><description>
题目链接：http://poj.org/problem?id=2643
在考stl的map...
我是定义了一个string 指向string的，表示参选人和党派的关系，和一个string 指向int的，表示某个党派被投票的次数。
需要注意的是！！！
需要注意的是！！！
需要注意的是！！！
字符串读入部分...
在输入n和m之后，会有一个回车符没读进去...(大概是这样？)
如果不处理一下的话，后面的字符串就会少读入一个...(sad)
解决的办法是在读完n和m之后写一个getchar(); 把回车符读掉。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时44分55秒 6File Name :2643.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 #include &amp;lt;stack&amp;gt;17 #include &amp;lt;queue&amp;gt;18 19 using namespace std; 20 typedef long long LL; 21 const int inf = 8E8; 22 int n,m; 23 string ans; 24 map&amp;lt;string,string&amp;gt;m1; 25 map&amp;lt;string,int&amp;gt;m2; 26 string c_name,p_name; 27 char ch; 28 int main() 29 { 30 cin&amp;gt;&amp;gt;n; 31 getchar(); 32 for ( int i = 1 ; i &amp;lt;= n ; ++i ) 33 { 34 getline(cin,c_name); 35 36 getline(cin,p_name); 37 m1[c_name]=p_name; 38 } 39 cin&amp;gt;&amp;gt;m; 40 getchar(); 41 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 42 { 43 getline(cin,c_name); 44 m2[c_name]++; 45 } 46 map&amp;lt;string,int&amp;gt;::iterator it; 47 int mmax=-1; 48 for (it=m2.</description></item><item><title>poj 3481 double queues</title><link>https://111qqz.com/2015/07/poj3481/</link><pubDate>Fri, 03 Jul 2015 04:10:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3481/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1908
看到有两个优先级，然后题目中又有queue。。。就想到了优先队列。。。
但是优先队列的cmp函数没搞懂，因为比较的是结构体，好像要重载&amp;lt; 什么的。
然而并不会。
其实用map就可以做。。。
map在插入的时候可以自动按关键字排序，简直好评如潮！
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时44分06秒 6File Name :3481.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 #include &amp;lt;stack&amp;gt;17 #include &amp;lt;queue&amp;gt;18 19 using namespace std; 20 typedef long long LL; 21 const int inf = 8E8; 22 23 24 25 int cmd; 26 map&amp;lt;int,int&amp;gt;a; 27 int p,k; 28 29 int main() 30 { 31 32 while (scanf(&amp;#34;%d&amp;#34;,&amp;amp;cmd)!</description></item><item><title>poj 1833 排列</title><link>https://111qqz.com/2015/07/poj1833/</link><pubDate>Thu, 02 Jul 2015 19:21:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1833/</guid><description>
http://poj.org/problem?id=1833
还是next_permutation.
这次是Int类型的
需要注意的是next_permutation是先判断时候有后继，返回一个bool值，如果为true，就转化到后继。
而next_permutation函数本书不考虑其值，就具有转化成后继的作用。
而且默认最后一个排列的下一个排列是第一个排列。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时43分58秒 6File Name :1833.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 17 using namespace std; 18 const int N=3E3+5; 19 int n ,m,k; 20 int a[N],b[N]; 21 22 int main() 23 { 24 cin&amp;gt;&amp;gt;m; 25 while (m--) 26 { 27 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k; 28 // k = k % n; 29 30 for ( int i = 0;i &amp;lt; n ; i++ ) 31 { 32 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); 33 } 34 while (k--) 35 { 36 next_permutation(a,a+n); 37 } 38 for ( int i = 0 ; i &amp;lt; n ; i++ ) 39 { 40 printf(&amp;#34;%d &amp;#34;,a[i]); 41 } 42 printf(&amp;#34;\n&amp;#34;); 43 44 45 } 46 47 48 return 0; 49 } 50 51</description></item><item><title>poj 1256 Anagram</title><link>https://111qqz.com/2015/07/poj1256/</link><pubDate>Thu, 02 Jul 2015 18:41:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1256/</guid><description>
http://poj.org/problem?id=1256
题意是说求出一个字符串的全排列，按字典序
需要注意的是字典序和传统意义上的字典序不同
重新定义了,A
需要自己重写cmp函数。
next_permutation好神....直接求出全排列.....
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时43分31秒 6File Name :code/poj/1256.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 17 using namespace std; 18 bool cmp(char a,char b) 19 { 20 char x = tolower(a); 21 char y = tolower(b); 22 if (x==y) 23 { 24 return a&amp;lt;b; 25 } 26 else return x&amp;lt;y; 27 } 28 int n; 29 string st; 30 31 int main() 32 { 33 cin&amp;gt;&amp;gt;n; 34 while (n--) 35 { 36 37 cin&amp;gt;&amp;gt;st; 38 sort(st.</description></item><item><title>codeforces 548B Mike and Fun</title><link>https://111qqz.com/2015/05/cf548b/</link><pubDate>Wed, 27 May 2015 14:45:00 +0000</pubDate><guid>https://111qqz.com/2015/05/cf548b/</guid><description>
http://codeforces.com/problemset/problem/548/B
比赛的时候不懂为什么就没做出来.... 其实很容易想到一个o(q*(n+m))的做法... 就是每次更新，要同时更新当前更新行的最大连续和....O（m）可以完成...然后在O（n）扫一遍，找到所有行中的最大值。 然后需要注意的是，在第一次更改之前就要把每个行的最大值处理出来l.. 然后cf机器真是够快，O(nmq)的1.2S过。。。。
1 2 3 4 5 6 7 8 /* *********************************************** 9Author :111qqz 10Created Time :2016年02月19日 星期五 17时01分58秒 11File Name :code/cf/problem/548B.cpp 12************************************************ */ 13 14 #include &amp;lt;algorithm&amp;gt;15 #include &amp;lt;cstdio&amp;gt;16 #include &amp;lt;iostream&amp;gt;17 #include &amp;lt;cstring&amp;gt;18 #include &amp;lt;string&amp;gt;19 #include &amp;lt;cmath&amp;gt;20 #include &amp;lt;map&amp;gt;21 22 using namespace std; 23 const int N=5E2+5; 24 int a[N][N]; 25 int fans; 26 int n,m,q,x,y,cur,ans[N]; 27 int main() 28 { 29 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;q; 30 for (int i = 1 ; i &amp;lt;= n;i++ ) 31 { 32 for (int j = 1; j &amp;lt;= m ; j++ ) 33 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i][j]); 34 cur = 0; 35 for (int j = 1; j &amp;lt;=m ;j++ ) 36 if (a[i][j]==1) 37 { 38 cur++; 39 ans[i]=max(cur,ans[i]); 40 } 41 else 42 { 43 cur = 0; 44 } 45 } 46 for ( int i = 1 ; i &amp;lt;= q; i++ ) 47 { 48 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;x,&amp;amp;y); 49 a[x][y]=a[x][y]^1; 50 // if (i==3) cout&amp;lt;&amp;lt;a[x][y]&amp;lt;&amp;lt;&amp;#34;sadsadasd&amp;#34;&amp;lt;&amp;lt;endl; 51 cur = 0; 52 ans[x]=0; 53 for (int j = 1; j &amp;lt;=m ;j++ ) 54 if (a[x][j]==1) 55 { 56 cur++; 57 ans[x]=max(cur,ans[x]); 58 } 59 else 60 { 61 cur = 0; 62 } 63 fans=-1; 64 for (int j = 1;j &amp;lt;= n ; j++ ) 65 if (ans[j]&amp;gt;fans) 66 { 67 fans=ans[j]; 68 } 69 cout&amp;lt;&amp;lt;fans&amp;lt;&amp;lt;endl; 70 } 71 72 73 return 0; 74 } 75 76 77</description></item><item><title>codeforces 548 A. Mike and Fax</title><link>https://111qqz.com/2015/05/cf548a/</link><pubDate>Wed, 27 May 2015 14:38:00 +0000</pubDate><guid>https://111qqz.com/2015/05/cf548a/</guid><description>
http://codeforces.com/problemset/problem/548/A
水题。分割成K个，每个串判断是否回文，如果都是就yes，否则no
需要注意的是，可能不能正好分成长度相同的K个，这个时候也要No
1 2 3 4 5 /* *********************************************** 6Author :111qqz 7Created Time :2016年03月03日 星期四 14时09分08秒 8File Name :code/cf/problem/548A.cpp 9************************************************ */ 10 11 #include &amp;lt;algorithm&amp;gt;12 #include &amp;lt;cstdio&amp;gt;13 #include &amp;lt;iostream&amp;gt;14 #include &amp;lt;cstring&amp;gt;15 #include &amp;lt;string&amp;gt;16 #include &amp;lt;cmath&amp;gt;17 #include &amp;lt;map&amp;gt;18 19 using namespace std; 20 const int N=1E3+5; 21 char st[N]; 22 int k,len,ave; 23 bool ok(int l,int r) 24 { 25 for (int i = l ; i&amp;lt;=(l+r)/2;i++) 26 if (st[i]!=st[l+r-i]) 27 return false; 28 return true; 29 } 30 31 int main() 32 { 33 cin&amp;gt;&amp;gt;st; 34 cin&amp;gt;&amp;gt;k; 35 len = strlen(st); 36 ave= len/k; 37 if (k*ave!</description></item><item><title>poj 2492 A Bug's Life (并查集)</title><link>https://111qqz.com/2015/04/poj2492/</link><pubDate>Fri, 17 Apr 2015 21:29:00 +0000</pubDate><guid>https://111qqz.com/2015/04/poj2492/</guid><description>
http://poj.org/problem?id=2492
Hint
Huge input,scanf is recommended.
也是带种类的冰茶几。
由于只分了两类...我们还是可以按照上道题的做法。。
感觉完全是一样的题啊。。
结果一直WA。。。。
最后发现。。。我边读入边判断。。发现同性恋了就直接Break掉了。。。后面改组的数据读到下一组去了233，不WA就日了汪了。。。
还是把数据的读完再进行操作比较好==
1 2 3 4 /* *********************************************** 5Author :111qqz 6Created Time :2016年03月03日 星期四 13时37分36秒 7File Name :code/poj/2492.cpp 8************************************************ */ 9 10 #include &amp;lt;iostream&amp;gt;11 #include &amp;lt;algorithm&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;cstdio&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 16 using namespace std; 17 18 const int N=2E5+7; 19 bool flag; 20 int f[N]; 21 int T,n,m,x,y; 22 char ch; 23 24 int root (int x) 25 { 26 if (f[x]!</description></item><item><title>poj 1703 Find them, Catch them (并查集)</title><link>https://111qqz.com/2015/04/poj1703/</link><pubDate>Fri, 17 Apr 2015 15:52:00 +0000</pubDate><guid>https://111qqz.com/2015/04/poj1703/</guid><description>
http://poj.org/problem?id=1703
种类冰茶几...看到还有一种算是拓展的交加权冰茶几？ 看到有做法是在开一个数组。。。记录是哪一组.... 但是因为只有两组....我们可以分别存... 因为不知道每一个D的两个人分别是哪个组（帮派？） 可以都存一下。 TLE了两次....应该是用了cin的事。。。改成scanf就变WA了。。。 想了下。原来是我对“not sure yet”的判断出现失误。 我开了一个v数组，记录在D下出现的人。 我误以为出现的人的帮派一定是确定的。 实际上并不是。 比如 1,3 5,7 3和7都出现了。但是3和7是一组与否显然还是“not sure yet”
1 2 3 4 /* *********************************************** 5Author :111qqz 6Created Time :2016年03月03日 星期四 13时43分16秒 7File Name :code/poj/1703.cpp 8************************************************ */ 9 10 #include &amp;lt;iostream&amp;gt;11 #include &amp;lt;algorithm&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;cstdio&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 16 using namespace std; 17 18 const int N=2E5+7; 19 bool v[N]; 20 int f[N]; 21 int T,n,m,x,y; 22 char ch; 23 24 int root (int x) 25 { 26 if (f[x]!</description></item><item><title>codeforces 535 C.Tavas and karafs (解方程)</title><link>https://111qqz.com/2015/04/cf535c/</link><pubDate>Thu, 16 Apr 2015 07:16:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf535c/</guid><description>
http://codeforces.com/problemset/problem/535/C
题读了好几遍才读懂。 题意是给出一个等差数列，操作严格要求从最左边不为零的连续m个数减去1，最多执行t次后问离最左边最远的位置在哪里。 有两个限制条件...一个是本身的si不能大于t，否则无法吃完。 还有一个是从sl到sr的和不能超过m*t (比赛的时候考虑的不周到。。实际上只有当r-l+1比m大的时候才是m，也就是说要取min(m,l-r+1)) 这题正解应该是二分....直接Lower_bound。。。看到也有人用前缀和搞的。 我是解方程了（貌似是个傻逼做法）.... 可以列出一个关于r的一元二次方程。。。然后求根公式2333 方程是：
然后再和第一个条件得到的r比较取小的就是结果.....
等周末把这题的二分解法也写一些。
下面是蒟蒻傻逼的数学方恒解法的代码：
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年03月03日 星期四 13时49分13秒 6File Name :code/cf/problem/535C.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 #include &amp;lt;cmath&amp;gt;13 #include &amp;lt;cstdio&amp;gt;14 15 using namespace std; 16 typedef long long LL; 17 const int N=1e5+5; 18 LL A,B,n,l,t,m,p,q,k,ans,a,b,c,dd,q2; 19 long double d,pp; 20 int main() 21 { 22 cin&amp;gt;&amp;gt;A&amp;gt;&amp;gt;B&amp;gt;&amp;gt;n; 23 for ( int i = 1; i &amp;lt;= n ; i++ ) 24 { 25 cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;t&amp;gt;&amp;gt;m; 26 if ( t&amp;lt;A+B*(l-1) ) 27 { 28 cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;endl; 29 continue; 30 } 31 // l = A + (l-1)*B; //wtf。。。这行代码是什么鬼.</description></item><item><title>codeforces 534 C Polycarpus' Dice</title><link>https://111qqz.com/2015/04/cf534c/</link><pubDate>Tue, 14 Apr 2015 20:38:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf534c/</guid><description>
http://codeforces.com/problemset/problem/534/C
题意是说一共有N个骰子，第I个筛子一共有di面...现在知道这些骰子的点数之和，问对于每一个骰子不能取得值有多少个。
乍一看有点不明觉厉...稍微再想下，求取值范围即可。
先把所有di相加，得到所有骰子点数之和的最大值...然后点数之和的最小值当然就是N
对于每个骰子，将最大值和最小值减去这个骰子的对应数值...然后与总和A进行比较。
注意要开long long ！！！
比赛的时候我明明写了typedef。。。结果后面还是忘记了。。。真是悲伤。
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年03月03日 星期四 13时54分19秒 5File Name :code/cf/problem/534C.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstring&amp;gt;11 #include &amp;lt;cmath&amp;gt;12 #include &amp;lt;cstdio&amp;gt;13 typedef long long LL; 14 const int N=2E5+7; 15 LL n,d[N],ans[N]; 16 LL A,MAX,MIN,TMAX,TMIN; 17 18 using namespace std; 19 20 int main() 21 { 22 scanf(&amp;#34;%I64d %I64d&amp;#34;,&amp;amp;n,&amp;amp;A); 23 memset(ans,0,sizeof(ans)); 24 for ( int i = 1; i &amp;lt;= n ;i ++ ) 25 scanf(&amp;#34;%I64d&amp;#34;,&amp;amp;d[i]); 26 MAX = 0; 27 MIN = n; 28 for ( int i = 1; i &amp;lt;= n ; i++ ) 29 MAX = MAX + d[i]; 30 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 31 { 32 TMAX = MAX - d[i]; 33 TMIN = MIN - 1; 34 if (d[i]&amp;gt;=(A-TMIN)) 35 { 36 ans[i] =ans[i]+d[i]-(A-TMIN); 37 } 38 if (A&amp;gt;=TMAX+1) 39 { 40 ans[i] =ans[i]+A-TMAX-1; 41 } 42 43 } 44 for ( int i = 1; i &amp;lt; n ; i++) 45 cout&amp;lt;&amp;lt;ans[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; 46 cout&amp;lt;&amp;lt;ans[n]; 47 48 49 return 0; 50 } 51</description></item><item><title>cf 534B. Covered Path</title><link>https://111qqz.com/2015/04/cf534b/</link><pubDate>Tue, 14 Apr 2015 20:32:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf534b/</guid><description>
http://codeforces.com/problemset/problem/534/B
题意是说一辆车，每秒内的速度恒定...第I秒到第I+1秒的速度变化不超过D。初始速度为V1，末速度为V2，经过时间t，问最远能走多远。
策略就是尽可能加速...加到某个时间，如果在这个时间不开始减速就回不到V2了。
从后往前预处理下每秒钟能达到的最大速度（如果超过这个速度，将不能减回到V2）
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月22日 星期一 23时49分32秒 5File Name :code/cf/problem/534B.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cmath&amp;gt;10 #include &amp;lt;cstring&amp;gt;11 #include &amp;lt;algorithm&amp;gt;12 13 using namespace std; 14 const int N=1E2+5; 15 const int inf=8E9; 16 int a[N],m[N]; 17 int v1,v2,t,d,tmp,p,ans,n; 18 19 20 int main() 21 { 22 cin&amp;gt;&amp;gt;v1&amp;gt;&amp;gt;v2&amp;gt;&amp;gt;t&amp;gt;&amp;gt;d; 23 p = inf; 24 memset(a,0,sizeof(a)); 25 a[1]= v1; 26 tmp = v2; 27 m[t]= v2; 28 for ( int i = t-1 ; i &amp;gt;= 1; i--) 29 { 30 tmp = tmp+d; 31 m[i] = tmp; 32 } 33 for ( int i =2 ;i &amp;lt;= t; i++ ) 34 { 35 if (a[i-1]+d&amp;lt;=m[i]) 36 { 37 a[i] = a[i-1] + d; 38 } 39 else 40 { 41 a[i] = m[i]; 42 p = i; 43 break; 44 } 45 } 46 ans = 0; 47 for ( int i = p ; i &amp;lt;= t; i++ ) 48 a[i] = m[i]; 49 for ( int i = 1; i &amp;lt;= t ; i++ ) 50 { 51 if (i&amp;lt;p) 52 ans = ans + a[i]; 53 else ans = ans + m[i]; 54 } 55 // for ( int i = 1; i &amp;lt;= t ; i++) 56 // cout&amp;lt;&amp;lt;&amp;#34;a[i]:&amp;#34;&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl; 57 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 58 59 return 0; 60 } 61</description></item><item><title>cf 535B Tavas and SaDDas</title><link>https://111qqz.com/2015/04/cf535btavasandsaddas/</link><pubDate>Tue, 14 Apr 2015 20:27:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf535btavasandsaddas/</guid><description>
B. Tavas and SaDDas
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: &amp;quot;If you solve the following problem, I'll return it to you.</description></item><item><title>codeforces 534 A. Exam</title><link>https://111qqz.com/2015/04/cf534a/</link><pubDate>Mon, 13 Apr 2015 02:55:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf534a/</guid><description>
A. Exam
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
An exam for n students will take place in a long and narrow room, so the students will sit in a line in some order. The teacher suspects that students with adjacent numbers (i and i + 1) always studied side by side and became friends and if they take an exam sitting next to each other, they will help each other for sure.</description></item><item><title>codeforces 479D. Long Jumps</title><link>https://111qqz.com/2015/04/cf479d/</link><pubDate>Wed, 08 Apr 2015 11:52:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf479d/</guid><description>
http://codeforces.com/problemset/problem/479/D
题意是说有一把尺子，本身有一些刻度，然后需要测量x和y，问最少需要添加多少个刻度，如果需要，这些刻度分别添加在什么位置。
一开始没有看清题目，以为答案最多为4，但是发现，a[1]=0 a[n]=l这两个是确定的，所以答案最多为2，
而不会出现中间有两个刻度，无论是往前刻还是往后都会越界的情况。
先去看看已知的刻度里有没有直接满足的。
除此之外，如果在已知的刻度下无法测量x也无法测量y，我们还可以找找是否能有公用点使得只刻一个刻度就可以满足题意。公用点分两种情况，一种是在两个刻度之间，另一种是在两个刻度的同侧。
前一种没什么坑，后一种要判断是否越界！！！
如果在已知的刻度下能测量x或者能测量出y但不能同时测量的话，就没有必要找公用点。
还有就是查找的话如果线性找复杂度是O(n2)，会TLE在第27个点。
我们用二分...
话说STL里竟然连二分查找也有。。。。简直orz。。。。真是省时省力。
代码：
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月22日 星期一 23时42分46秒 6File Name :code/cf/problem/479D.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 #include &amp;lt;cstdio&amp;gt;13 #include &amp;lt;cmath&amp;gt;14 15 using namespace std; 16 17 int n,l,x,y; 18 const int N=1E5+7; 19 int a[N]; 20 int ans,p,q; 21 bool flag1,flag2,flag3,flag4; 22 23 int main() 24 { 25 scanf(&amp;#34;%d %d %d %d&amp;#34;,&amp;amp;n,&amp;amp;l,&amp;amp;x,&amp;amp;y); 26 flag1 = false; 27 flag2 = false; 28 flag3 = false; 29 flag4 = false; 30 31 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 32 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); 33 ans = 2; 34 p = -1; 35 q = 0; 36 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 37 { 38 if(binary_search(a,a+n+1,a[i]+x)) 39 { 40 flag1 = true; 41 42 } 43 if (binary_search(a,a+n+1,a[i]+y)) 44 { 45 flag2 = true; 46 } 47 if (binary_search(a,a+n+1,a[i]+x+y)) 48 { 49 flag3 = true; 50 p = a[i]; 51 } 52 if (binary_search(a,a+n+1,a[i]+y-x)&amp;amp;&amp;amp;((a[i]+y&amp;lt;=l)||(a[i]-x&amp;gt;=0))) 53 { 54 flag4 = true; 55 p = a[i]; 56 } 57 } 58 59 if ( flag1) {ans--;q = 1 ;} 60 if ( flag2 ){ ans--;q = 2 ;} 61 if ( ans==2&amp;amp;&amp;amp;(flag3||flag4)) 62 { 63 ans--; 64 } 65 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 66 if ( ans==2 ) 67 { 68 cout&amp;lt;&amp;lt;a[1]+x&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;a[1]+y&amp;lt;&amp;lt;endl; 69 } 70 if ( ans==1 ) 71 { 72 if ( p==-1 ) 73 { 74 if ( q==1 ) 75 cout&amp;lt;&amp;lt;a[1]+y&amp;lt;&amp;lt;endl; 76 else cout&amp;lt;&amp;lt;a[1]+x&amp;lt;&amp;lt;endl; 77 } 78 else 79 { 80 if ( p+y&amp;lt;=l ) 81 cout&amp;lt;&amp;lt;p+y&amp;lt;&amp;lt;endl; 82 else cout&amp;lt;&amp;lt;p-x&amp;lt;&amp;lt;endl; 83 } 84 } 85 return 0; 86 } 87 88</description></item><item><title>codeforces 525 B. Pasha and String</title><link>https://111qqz.com/2015/04/cf525b/</link><pubDate>Wed, 08 Apr 2015 11:40:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf525b/</guid><description>
http://codeforces.com/problemset/problem/525/B
题意是说一个字符串，进行m次颠倒变换（从a[i]位置到a[l-i+1]位置），问得到的字符串。容易发现，对于越在里边（对称，也就是越靠近中间位置）的字符，调换的次数越多。我们可以把a[i]从小到大排序。然后经过分析发现，把两个相邻的a[i]分为一组，做处理，如果m为奇数，最后还剩下a[m]没有被分组，要单独处理a[m]细节上要注意st数组是从st[0]开始的...好吧的确不方便，适牛也说我了。。数组下标以后还是从0开始吧。。。主要是受高中OI用的pascal的影响。。。那个数组下标随便啊。代码： 1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月22日 星期一 23时39分51秒 6File Name :code/cf/problem/525B.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 #include &amp;lt;cmath&amp;gt;13 #include &amp;lt;cstdio&amp;gt;14 15 using namespace std; 16 17 int m,k,len; 18 const int N=2E5+7; 19 int a[N]; 20 char st[N]; 21 22 int main() 23 { 24 cin&amp;gt;&amp;gt;st; 25 scanf(&amp;#34;%d&amp;#34;,&amp;amp;m); 26 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 27 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); 28 sort(a+1,a+m+1); 29 k = 1; 30 len = strlen(st); 31 while (k&amp;lt;=m) 32 { 33 for ( int j = a[k] ; j &amp;lt;= a[k+1]-1 ; j++) 34 swap(st[j-1],st[len-j]); 35 k = k + 2; 36 } 37 if ( m %2==1 ) 38 for ( int i = a[m]; i &amp;lt;= len/2 ; i++ ) 39 swap(st[i-1],st[len-i]); 40 cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; 41 return 0; 42 } 43 44 45</description></item><item><title>codeforces 482 A. Diverse Permutation（构造）</title><link>https://111qqz.com/2015/04/cf482/</link><pubDate>Wed, 08 Apr 2015 11:32:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf482/</guid><description>
C - C
**Time Limit:**1000MS **Memory Limit:**262144KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Permutation_p_ is an ordered set of integers _p_1, p_2, ..., p__n, consisting of n distinct positive integers not larger than n. We'll denote as_n the length of permutation _p_1, _p_2, ..., p__n.
Your task is to find such permutation p of length n, that the group of numbers |_p_1 - _p_2|, |_p_2 - _p_3|, ..., |p__n - 1 - p__n| has exactly k distinct elements.</description></item><item><title>codeforces 47 C. Exams</title><link>https://111qqz.com/2015/04/cf479c/</link><pubDate>Wed, 08 Apr 2015 11:24:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf479c/</guid><description>
http://codeforces.com/problemset/problem/479/C
1/************************************************ 2Author :111qqz 3Created Time :2016年02月22日 星期一 23时31分10秒 4File Name :code/cf/problem/479C.cpp 5************************************************ */ 6 7#include &amp;lt;iostream&amp;gt;8#include &amp;lt;algorithm&amp;gt;9#include &amp;lt;cstring&amp;gt;10#include &amp;lt;cstdio&amp;gt;11 12#include &amp;lt;cmath&amp;gt;13 14using namespace std; 15int n,ans; 16const int N=1E4+5; 17int a[N],b[N]; 18 19struct Q 20{int a,b; 21}q[N]; 22 23bool cmp(Q x, Q y) 24{ 25 if ( x.a&amp;lt;y.a) return true; 26 if ( x.a==y.a &amp;amp;&amp;amp;x.b&amp;lt;y.b ) return true; 27 return false; 28} 29 30int main() 31{ 32 scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); 33 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 34 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;q[i].</description></item><item><title>hdu 1160 FatMouse's Speed (最长上升子序列)</title><link>https://111qqz.com/2015/04/hdu1160/</link><pubDate>Mon, 06 Apr 2015 16:36:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1160/</guid><description>
FatMouse's Speed Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 10172 Accepted Submission(s): 4521
Special Judge
Problem Description
FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing.</description></item><item><title>hdu 1260 tickets</title><link>https://111qqz.com/2015/04/hdu1260/</link><pubDate>Mon, 06 Apr 2015 16:23:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1260/</guid><description>
Tickets **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 1408 Accepted Submission(s): 687
**
Problem Description
Jesus, what a great movie! Thousands of people are rushing to the cinema. However, this is really a tuff time for Joe who sells the film tickets. He is wandering when could he go back home as early as possible.
A good approach, reducing the total time of tickets selling, is let adjacent people buy tickets together.</description></item><item><title>hdu 1176 免费馅饼(二维dp)</title><link>https://111qqz.com/2015/04/hdu1176/</link><pubDate>Sun, 05 Apr 2015 18:05:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1176/</guid><description>
免费馅饼 **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 29065 Accepted Submission(s): 9921
**
Problem Description
都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：
为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）
Input
输入数据有多组。每组数据的第一行为以正整数n(0
Output
每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。
提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。
Sample Input
6
5 1
4 1
6 1
7 2
7 2
8 3
0
Sample Output
4
Author
lwg
二维dp
状态转移方程也很容易想到
dp[i][j]表示在时间i，位置J的时候能得到的馅饼的个数。
dp[i][j]是由dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]得到。
注意边界和初始化。
因为一开始是在位置5
所以 dp[1][4]=a[1][4];
　dp[1][5]=a[1][5];
　dp[1][6]=a[1][6];
但是取出最大的dp[i][j]的时候出了问题导致我一直WA，而且还没有想的很明白。。
AC代码：
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月22日 星期一 23时18分21秒 6File Name :code/hdu/1176.</description></item><item><title>hdu 1114 - Piggy-Bank (完全背包)</title><link>https://111qqz.com/2015/04/hdu1114/</link><pubDate>Sun, 05 Apr 2015 15:14:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1114/</guid><description>
F - Piggy-Bank
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig.</description></item><item><title>hdu 1087 - Super Jumping! Jumping! Jumping! (最长上升子序列)</title><link>https://111qqz.com/2015/04/hdu1087/</link><pubDate>Sun, 05 Apr 2015 14:12:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1087/</guid><description>
E - Super Jumping! Jumping! Jumping!
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Nowadays, a kind of chess game called &amp;quot;Super Jumping! Jumping! Jumping!&amp;quot; is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now.
The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or &amp;quot;start&amp;quot; or &amp;quot;end&amp;quot;.</description></item><item><title>hdu1069 Monkey and Banana (最长下降子序列)</title><link>https://111qqz.com/2015/04/hdu1069/</link><pubDate>Sun, 05 Apr 2015 05:04:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1069/</guid><description>
C - Monkey and Banana
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food.</description></item><item><title>hdu 1171 Big Event in HDU （母函数，01背包）</title><link>https://111qqz.com/2015/04/hdu1171/</link><pubDate>Sat, 04 Apr 2015 14:56:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1171/</guid><description>
**Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 26534 Accepted Submission(s): 9332 **
Problem Description
Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don't know that Computer College had ever been split into Computer College and Software College in 2002. The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too.</description></item><item><title>hdu 1203 I NEED A OFFER! （01背包）</title><link>https://111qqz.com/2015/04/hdu1203/</link><pubDate>Sat, 04 Apr 2015 12:12:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu1203/</guid><description>
I NEED A OFFER! **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 18287 Accepted Submission(s): 7320 **
Problem Description
Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。
Input
输入有若干组数据，每组数据的第一行有两个正整数n,m(0&amp;lt;=n&amp;lt;=10000,0&amp;lt;=m&amp;lt;=10000) 后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。 输入的最后有两个0。
Output
每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。
Sample Input
10 3 4 0.1 4 0.2 5 0.3 0 0
Sample Output
44.0%
Hint
You should use printf(&amp;quot;%%&amp;quot;) to print a '%'.
01背包
最开始WA在初始化，dp数组全都赋值为1，忘赋了dp[0]，导致如果恰好是花光所有钱得到答案的时候答案错误。
然后还一直WA。
后来发现是当N=0的时候，我直接取了所有A[I]=0对应的B[I]中最大的值。。。这显然是错的，少年你是脑抽吗。。。。。
然后修改了下，终于A掉了。。。。。
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月22日 星期一 22时50分40秒 5File Name :code/hdu/1203.</description></item><item><title>hdu 2546 饭卡 （01背包）</title><link>https://111qqz.com/2015/04/hdu2546/</link><pubDate>Sat, 04 Apr 2015 08:53:00 +0000</pubDate><guid>https://111qqz.com/2015/04/hdu2546/</guid><description>
饭卡 **Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 14225 Accepted Submission(s): 4945
**
Problem Description
电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。
某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。
Input
多组数据。对于每组数据：
第一行为正整数n，表示菜的数量。n&amp;lt;=1000。
第二行包括n个正整数，表示每种菜的价格。价格不超过50。
第三行包括一个正整数m，表示卡上的余额。m&amp;lt;=1000。
n=0表示数据结束。
Output
对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。
Sample Input
1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0
Sample Output
-45 32
Source
UESTC 6th Programming Contest Online
在入门dp。
显然是01背包。 cost和value都是价钱。
但是有限制条件。
很容易想到，为了使得余额最少，我们要把最贵的留在最后买。
读入的时候把最贵的菜价拿出来
然后剩下的n-1个菜，做一个容量为m-5的01背包。
注意如果m&amp;lt;5,直接输出即可。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月22日 星期一 22时44分27秒 6File Name :code/hdu/2546.</description></item><item><title>HDOJ 4882 Loves Codefires</title><link>https://111qqz.com/2015/03/hdu4882/</link><pubDate>Tue, 31 Mar 2015 10:40:00 +0000</pubDate><guid>https://111qqz.com/2015/03/hdu4882/</guid><description>
ZCC Loves Codefires
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 988 Accepted Submission(s): 500
Problem Description
Though ZCC has many Fans, ZCC himself is a crazy Fan of a coder, called &amp;quot;Memset137&amp;quot;.
It was on Codefires(CF), an online competitive programming site, that ZCC knew Memset137, and immediately became his fan.
But why?
Because Memset137 can solve all problem in rounds, without unsuccessful submissions; his estimation of time to solve certain problem is so accurate, that he can surely get an Accepted the second he has predicted.</description></item><item><title>poj 1065 Wooden Sticks</title><link>https://111qqz.com/2015/03/poj1065/</link><pubDate>Tue, 31 Mar 2015 07:05:00 +0000</pubDate><guid>https://111qqz.com/2015/03/poj1065/</guid><description>
Wooden Sticks Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 19008 Accepted: 8012 Description
There is a pile of n wooden sticks. The length and weight of each stick are known in advance. The sticks are to be processed by a woodworking machine in one by one fashion. It needs some time, called setup time, for the machine to prepare processing a stick. The setup times are associated with cleaning operations and changing tools and shapes in the machine.</description></item><item><title>codeforces 447 B. DZY Loves Strings</title><link>https://111qqz.com/2015/03/cf447b/</link><pubDate>Mon, 30 Mar 2015 09:45:00 +0000</pubDate><guid>https://111qqz.com/2015/03/cf447b/</guid><description>
简单贪心。 因为填的字母没有次数限制，所以最优策略很容易想到，就是在最后面填最大的。 不用实际去填，算出ans就可以。
1 2 3 4 #include &amp;lt;iostream&amp;gt;5 #include &amp;lt;cmath&amp;gt;6 #include &amp;lt;cstring&amp;gt;7 #include &amp;lt;algorithm&amp;gt;8 9 using namespace std; 10 11 int main() 12 { 13 int k,len; 14 char st[2000]; 15 int a[2000]; 16 memset(a,0,sizeof(a)); 17 int w[50]; 18 cin&amp;gt;&amp;gt;st&amp;gt;&amp;gt;k; 19 int m=-1; 20 for (int i=1;i&amp;lt;=26;i++) 21 { 22 23 cin&amp;gt;&amp;gt;w[i]; 24 if (w[i]&amp;gt;m) 25 m=w[i]; 26 } 27 len=strlen(st); 28 for (int i=0;i&amp;lt;len;i++) 29 a[i]=(int)(st[i]-96); 30 long long ans=0; 31 for (int i=0;i&amp;lt;len;i++) 32 { 33 ans=ans+w[a[i]]*(i+1); 34 // cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 35 } 36 for (int i=len;i&amp;lt;len+k;i++) 37 ans=ans+m*(i+1); 38 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 39 return 0; 40 } 41</description></item><item><title>hdu 1009 FatMouse' Trade</title><link>https://111qqz.com/2015/03/hdu1009/</link><pubDate>Mon, 30 Mar 2015 08:33:00 +0000</pubDate><guid>https://111qqz.com/2015/03/hdu1009/</guid><description>
简单贪心.... 需要注意的是数据是非负，所以有0的情况要考虑周全，基本都要特殊处理。 多WA了三次，不知道为什么交C++可以过，交G++就不行。
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月19日 星期五 16时38分28秒 5File Name :code/hdu/1009.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cstring&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstdio&amp;gt;12 #include &amp;lt;iomanip&amp;gt;13 14 using namespace std; 15 16 int main() 17 { 18 int m,n,f[1500],j[1500]; 19 double scale[1500]; 20 double ans,sum; 21 while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;m,&amp;amp;n)!=EOF&amp;amp;&amp;amp;(m!=-1)) 22 { ans=0; 23 // if (m==0) 24 memset(scale,0,sizeof(scale)); 25 memset(f,0,sizeof(f)); 26 memset(j,0,sizeof(j)); 27 // bool flag=false; 28 for (int i=1;i&amp;lt;=n;i++) 29 { 30 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;j[i],&amp;amp;f[i]); 31 if (f[i]!</description></item><item><title>hdu 1050 Moving Tables</title><link>https://111qqz.com/2015/03/hdu1050/</link><pubDate>Thu, 26 Mar 2015 11:01:00 +0000</pubDate><guid>https://111qqz.com/2015/03/hdu1050/</guid><description>
一开始算法想的有点问题。
坑点在于走廊两侧都有房间
也就是说room1和room2对应的位置是一样的
1 to 3 4to6 是没法同时完成的。
做法就是整个扫一遍，看哪个位置的重复次数最大，*10就是答案。
1 2 #include &amp;lt;iostream&amp;gt;3 #include &amp;lt;algorithm&amp;gt;4 #include &amp;lt;cmath&amp;gt;5 #include&amp;lt;cstdio&amp;gt;6 #include &amp;lt;cstring&amp;gt;7 8 using namespace std; 9 10 int main() 11 { 12 int t,n,a[300],b[300]; 13 int p[300]; 14 int ans; 15 scanf(&amp;#34;%d&amp;#34;,&amp;amp;t); 16 while (t--) 17 { 18 19 scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); 20 memset(p,0,sizeof(p)); 21 memset(a,0,sizeof(a)); 22 memset(b,0,sizeof(b)); 23 for (int i=1;i&amp;lt;=n;i++) 24 { 25 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a[i],&amp;amp;b[i]); 26 if (a[i]&amp;gt;b[i]) 27 swap(a[i],b[i]); 28 for (int j=(a[i]+1)/2;j&amp;lt;=(b[i]+1)/2;j++) 29 p[j]++; 30 } 31 ans=0; 32 for (int i=1;i&amp;lt;=200;i++) 33 if (p[i]&amp;gt;ans) 34 ans=p[i]; 35 printf(&amp;#34;%d\n&amp;#34;,ans*10); 36 } 37 return 0; 38 } 39</description></item><item><title>hdu 5120 - Intersection</title><link>https://111qqz.com/2015/02/hdu5120/</link><pubDate>Thu, 19 Feb 2015 07:22:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu5120/</guid><description>
题意：求两个相等的圆环的相交的面积.... 简单计算几何+容斥原理？ 扇形面积公式记错调了半天2333333333 这题不难...倒是从学长那里收获了几点关于代码规范的问题... 听说了学长在北京区域赛时把PI定义错了一位结果一直WA的教训.... 以后还是写acos(-1)吧 局部变量和全局变量因为【想怎么其变量名想得整个人都不好了】就起成了一样的...被学长给了差评。 哦，对！还有一个就是发现了cmath库里有一个奇葩的函数名叫y1.。。。。。。。 —————————————————————————————————————————————— 竟然CE了 提示 error:pow(int,int) is ambiguous 看来我对语言的掌握程度还是不行呀.....
&amp;quot;就是一个函数声明为pow(double, double)你必须传两个double参数进去。但你传int也可以，int会转型会double，但c++有重载。声明了两个函数pow(double, double)，pow(long long, double),你传两个int进去编译器不知道把int转为double还是转为long long&amp;quot; &amp;quot;解决办法是把int转型成double (xxx) 或者long long (xxx)&amp;quot; 也可以 简单粗暴的xxx.0
(int,int)-&amp;gt;(double,int)?(double,double)
1 2 3 #include &amp;lt;iostream&amp;gt;4 #include &amp;lt;cmath&amp;gt;5 #include &amp;lt;iomanip&amp;gt;6 7 using namespace std; 8 9 int t,tt; 10 int rr,RR,x11,x22,y11,y22; 11 double ans; 12 const double PI=acos(-1); 13 const double C=10e-6; 14 double area(int x1,int y1,int x2,int y2,int R,int r); 15 int main() 16 { 17 cin&amp;gt;&amp;gt;t; 18 tt=t; 19 while (t--) 20 { 21 cin&amp;gt;&amp;gt;rr&amp;gt;&amp;gt;RR; 22 cin&amp;gt;&amp;gt;x11&amp;gt;&amp;gt;y11&amp;gt;&amp;gt;x22&amp;gt;&amp;gt;y22; 23 ans=area(x11,y11,x22,y22,RR,RR)-2*area(x11,y11,x22,y22,RR,rr)+ 24 area(x11,y11,x22,y22,rr,rr); 25 cout&amp;lt;&amp;lt;&amp;#34;Case #&amp;#34;&amp;lt;&amp;lt;tt-t&amp;lt;&amp;lt;&amp;#34;: &amp;#34; 26 &amp;lt;&amp;lt;fixed&amp;lt;&amp;lt;setprecision(6)&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 27 } 28 return 0; 29 } 30 double area(int x1,int y1,int x2,int y2,int R,int r) 31 { 32 double d; 33 double A,a; 34 double st; 35 d=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); 36 if (d&amp;gt;=r+R) 37 return 0; 38 if (R-r&amp;gt;=d) 39 return r*r*PI; 40 A=acos((R*R+d*d-r*r)/(2.</description></item><item><title>hdu 5119 - Happy Matt Friends（dp解法）</title><link>https://111qqz.com/2015/02/hdu5119/</link><pubDate>Tue, 17 Feb 2015 09:04:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu5119/</guid><description>
Description
Matt has N friends. They are playing a game together.
Each of Matt’s friends has a magic number. In the game, Matt selects some (could be zero) of his friends. If the xor (exclusive-or) sum of the selected friends’magic numbers is no less than M , Matt wins.
Matt wants to know the number of ways to win.
Input
The first line contains only one integer T , which indicates the number of test cases.</description></item><item><title>hdu 5113 Black And White</title><link>https://111qqz.com/2015/02/hdu5113/</link><pubDate>Tue, 17 Feb 2015 09:01:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu5113/</guid><description>
题意是说用k重颜色填充n*m的方格，第i种颜色要用ci次，保证ci（i属于1..k）的和为n&amp;quot;m，问是否有可行解，若有，输出任意一种。 第一感觉是dfs.。。而且数据范围还那么小。但是鉴于我上次dfs写成汪的经历....嗯 不过群里有学长说似乎剪枝不太好想？ 我一开始分了四类，o行o列，e行e列，e行o列，o行e列，（o是odd，e是even）然后将c[i]排序，先填大的C[I]，感觉这样应该更容易找到解。交了一发,WA掉了。。发现当k较小的时候，也就是c[i]都相对较大的时候，先填大的C[I]的策略会出现错误。于是我换了下....按c[i]的大小从两边往中间...然后我还发现其实o行o列和e行e列可以归为一类，同理，后两种也可以归为一类。又交，又WA2333333 然后想了好久。。。 发现对于上面说的两类的处理顺序不同会得到不同的结果.......只有一种是对的。于是加了个judge函数判断冲突...如果冲突就换个顺序.....再交，A了。
过程中出现了两个语法上的错误....**一个是=写成了==(从来都是把==写成=。。。) 另一个是无参数的函数依然要写（）。。。。。。
确实不难....的确是我生疏了。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 16时20分07秒 6File Name :code/hdu/5113.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 13 using namespace std; 14 15 int c[100],cc[100]; 16 int ans[10][10]; 17 int colorid[100]; 18 int n,m,k; 19 void look(); 20 bool judge(); 21 22 23 int main() 24 { 25 int tt; 26 int t; 27 int kk; 28 29 cin&amp;gt;&amp;gt;t; 30 tt=t; 31 32 33 int i,j; 34 int head; 35 int flag; 36 while (t--) 37 { head=1; 38 flag=1; 39 memset(ans,0,sizeof(ans)); 40 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;k; 41 kk=k; 42 for (i=1;i&amp;lt;=k;i++) 43 cin&amp;gt;&amp;gt;c[i]; 44 45 for (i=1;i&amp;lt;=k;i++) 46 colorid[i]=i; 47 for (i=1;i&amp;lt;k;i++) 48 for (j=i+1;j&amp;lt;=k;j++) 49 if (c[i]&amp;gt;c[j]) 50 { 51 swap(c[i],c[j]); 52 swap(colorid[i],colorid[j]); 53 } 54 for (i=1;i&amp;lt;=k;i++) 55 cc[i]=c[i]; 56 57 58 59 if (c[k]&amp;gt;(n*m+1)/2) { cout&amp;lt;&amp;lt;&amp;#34;Case #&amp;#34;&amp;lt;&amp;lt;tt-t&amp;lt;&amp;lt;&amp;#34;:&amp;#34;&amp;lt;&amp;lt;endl;cout&amp;lt;&amp;lt;&amp;#34;NO&amp;#34;&amp;lt;&amp;lt;endl;continue;} 60 61 for (i=1;i&amp;lt;=n;i++) 62 for (j=1;j&amp;lt;=m;j++) 63 if ((i%2+j%2)%2==1) 64 { 65 if (flag%2==1) 66 { 67 68 69 ans[i][j]=colorid[k]; 70 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[k]&amp;lt;&amp;lt;endl; 71 72 c[k]--; 73 if (c[k]==0) 74 { 75 k--; 76 flag++; 77 78 } 79 } 80 else 81 { 82 ans[i][j]=colorid[head]; 83 84 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[head]&amp;lt;&amp;lt;endl; 85 c[head]--; 86 if (c[head]==0) 87 { 88 head++; 89 flag++; 90 91 } 92 } 93 // look(); 94 } 95 96 97 for (i=1;i&amp;lt;=n;i++) 98 for (j=1;j&amp;lt;=m;j++) 99 if ((i%2+j%2)%2==0) 100 { 101 102 103 if (flag%2==1) 104 { 105 106 107 ans[i][j]=colorid[k]; 108 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[k]&amp;lt;&amp;lt;endl; 109 c[k]--; 110 if (c[k]==0) 111 { 112 k--; 113 flag++; 114 } 115 } 116 else 117 { 118 ans[i][j]=colorid[head]; 119 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[head]&amp;lt;&amp;lt;endl; 120 c[head]--; 121 if (c[head]==0) 122 { 123 head++; 124 flag++; 125 } 126 } 127 // look(); 128 } 129 cout&amp;lt;&amp;lt;&amp;#34;Case #&amp;#34;&amp;lt;&amp;lt;tt-t&amp;lt;&amp;lt;&amp;#34;:&amp;#34;&amp;lt;&amp;lt;endl; 130 cout&amp;lt;&amp;lt;&amp;#34;YES&amp;#34;&amp;lt;&amp;lt;endl; 131 132 if (!</description></item><item><title>hdu 2138 How many prime numbers</title><link>https://111qqz.com/2015/02/hdu2138/</link><pubDate>Tue, 17 Feb 2015 00:58:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu2138/</guid><description>
ACM STEPS里的...这题前面一道是求LCM....结果接下来就是这么一道。。。 朴素会超....筛法会爆....题目顺序真是按照难度来的？ 于是想到 Miller-Rabin素数测试....... 这个方法是基于费马小定理 我的理解就是... 如果我要判断n是否为素数 只要取k个数 如果满足 a^(n-1)mod n =1 那么n就很可能为素数。 证明什么的...暂时还是算了吧...论文里貌似扯了一大堆 第一次用，竟然真的A了。。。。 感觉更好的办法也许是先打一个比较小的素数表，然后每次random选取若干个进行判断...那样应该更可靠些？ 本来想WA掉之后再改的。。。没想到这么写就A掉了。。。。杭电数据略水？
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月19日 星期五 16时54分19秒 5File Name :code/hdu/2138.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cmath&amp;gt;10 #include &amp;lt;stdio.h&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 13 using namespace std; 14 15 typedef long long LL; 16 LL power(LL m,LL n,LL k) 17 { 18 int b = 1; 19 while (n &amp;gt; 0) 20 { 21 if (n &amp;amp; 1) 22 b = (b*m)%k; 23 n = n &amp;gt;&amp;gt; 1 ; 24 m = (m*m)%k; 25 } 26 return b; 27 } 28 bool judge(LL n) 29 { 30 LL i; 31 if (n&amp;lt;=3) return true; 32 for (i=2;i&amp;lt;=ceil(sqrt(n))+1;i++) 33 if (n %i==0) return false; 34 return true; 35 } 36 37 int main() 38 { 39 LL i,n,x; 40 41 while (scanf(&amp;#34;%I64d&amp;#34;,&amp;amp;n)!</description></item></channel></rss>