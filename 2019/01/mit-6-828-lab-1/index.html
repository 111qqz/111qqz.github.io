<!doctype html><html lang=en data-figures class=page>
<head>
<title>【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping | 111qqz的小窝</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta http-equiv=x-ua-compatible content="IE=edge">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-219255388-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-219255388-1')</script>
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta name=description content="花费了30+小时，终于搞定了orz Part 1: PC Bootstrap The PC's Physical Address Space 8086/8088时代 +------------------+ <- 0x00100000 (1MB) | BIOS ROM | +------------------+ …">
<meta name=twitter:card content="summary">
<meta name=twitter:creator content>
<meta name=twitter:title content="【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping">
<meta property="og:url" content="https://111qqz.com/2019/01/mit-6-828-lab-1/">
<meta property="og:title" content="【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping">
<meta property="og:description" content="花费了30+小时，终于搞定了orz Part 1: PC Bootstrap The PC's Physical Address Space 8086/8088时代 +------------------+ <- 0x00100000 (1MB) | BIOS ROM | +------------------+ …">
<meta property="og:image" content="https://111qqz.com/images/thumbnail.png">
<link rel=apple-touch-icon sizes=180x180 href=https://111qqz.com/icons/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=https://111qqz.com/icons/favicon-32x32.png>
<link rel=manifest href=https://111qqz.com/icons/site.webmanifest>
<link rel=canonical href=https://111qqz.com/2019/01/mit-6-828-lab-1/>
<link rel=preload href=https://111qqz.com/css/styles.f143f2039d975cd60c5524f52c5fbb6dd2236d44d0d53d71b5cb6f6127d4fe8082960bbb71fe0345b5bab4119124e0b09c0b7d7f4238a9288afc02815d258f76.css integrity="sha512-8UPyA52XXNYMVST1LF+7bdIjbUTQ1T1xtctvYSfU/oCClgu7cf4DRbW6tBGRJOCwnAt9f0I4qSiK/AKBXSWPdg==" as=style crossorigin=anonymous>
<link rel=preload href=https://111qqz.com/js/bundle.min.3742850abb67c28705371634ec61c30ef94e46abe2abff0aa69f2d0719bdb4593a80e5d4f8c3e1c6ef6f860b354b7dc6dcc282abc788a7fc2798b214527a5207.js as=script integrity="sha512-N0KFCrtnwocFNxY07GHDDvlORqviq/8Kpp8tBxm9tFk6gOXU+MPhxu9vhgs1S33G3MKCq8eIp/wnmLIUUnpSBw==" crossorigin=anonymous>
<link rel=stylesheet type=text/css href=https://111qqz.com/css/styles.f143f2039d975cd60c5524f52c5fbb6dd2236d44d0d53d71b5cb6f6127d4fe8082960bbb71fe0345b5bab4119124e0b09c0b7d7f4238a9288afc02815d258f76.css integrity="sha512-8UPyA52XXNYMVST1LF+7bdIjbUTQ1T1xtctvYSfU/oCClgu7cf4DRbW6tBGRJOCwnAt9f0I4qSiK/AKBXSWPdg==" crossorigin=anonymous>
</head>
<body data-code=7 data-lines=false id=documentTop>
<header class=nav_header>
<nav class=nav><a href=https://111qqz.com/ class="nav_brand nav_item" title=111qqz的小窝>111qqz的小窝
<div class=nav_close>
<div><svg class="icon"><use xlink:href="#open-menu"/></svg><svg class="icon"><use xlink:href="#closeme"/></svg></div>
</div>
</a>
<div class="nav_body nav_body_left">
<div class=nav_parent>
<a href=https://111qqz.com/ class=nav_item title=Home>Home </a>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/categories/acm/ class=nav_item title=ACM-ICPC>ACM-ICPC </a>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/ class=nav_item title=深度学习>深度学习 <img src=https://111qqz.com/icons/caret-icon.svg alt=icon class=nav_icon></a>
<div class=nav_sub>
<span class=nav_child></span>
<a href=https://111qqz.com/tags/caffe/ class="nav_child nav_item" title=caffe源码阅读笔记>caffe源码阅读笔记</a>
<a href=https://111qqz.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/ class="nav_child nav_item" title=推荐系统>推荐系统</a>
<a href=https://111qqz.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89 class="nav_child nav_item" title=计算机视觉>计算机视觉</a>
</div>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/ class=nav_item title=公开课>公开课 <img src=https://111qqz.com/icons/caret-icon.svg alt=icon class=nav_icon></a>
<div class=nav_sub>
<span class=nav_child></span>
<a href=https://111qqz.com/tags/6.828/ class="nav_child nav_item" title=6.828>6.828</a>
<a href=https://111qqz.com/tags/cs341/ class="nav_child nav_item" title=CS341>CS341</a>
<a href=https://111qqz.com/tags/csapp/ class="nav_child nav_item" title=CSAPP>CSAPP</a>
</div>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/ class=nav_item title=工程>工程 <img src=https://111qqz.com/icons/caret-icon.svg alt=icon class=nav_icon></a>
<div class=nav_sub>
<span class=nav_child></span>
<a href=https://111qqz.com/tags/cpp class="nav_child nav_item" title=cpp>cpp</a>
<a href=https://111qqz.com/tags/cuda class="nav_child nav_item" title=cuda>cuda</a>
<a href=https://111qqz.com/tags/leveldb class="nav_child nav_item" title=levelDB源码笔记>levelDB源码笔记</a>
<a href=https://111qqz.com/tags/linux class="nav_child nav_item" title=linux>linux</a>
<a href=https://111qqz.com/tags/%E5%89%8D%E7%AB%AF class="nav_child nav_item" title=前端>前端</a>
<a href=https://111qqz.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86 class="nav_child nav_item" title=图像处理>图像处理</a>
<a href=https://111qqz.com/tags/docker class="nav_child nav_item" title=容器>容器</a>
</div>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88 class=nav_item title=随笔杂谈>随笔杂谈 </a>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86 class=nav_item title=面试>面试 </a>
</div>
<div class=nav_parent>
<a href=https://111qqz.com/top/about/ class=nav_item title=About>About </a>
</div>
<div class=nav_parent>
<a href=# class=nav_item>🌐</a>
<div class=nav_sub>
<span class=nav_child></span>
<a href=https://111qqz.com/ class="nav_child nav_item">English</a>
<a href=https://111qqz.com/zh/ class="nav_child nav_item">Chinese</a>
</div>
</div>
<div class=follow>
<a href=https://github.com/111qqz><svg class="icon"><use xlink:href="#github"/></svg>
</a>
<div class=color_mode>
<input type=checkbox class=color_choice id=mode>
</div>
</div>
</div>
</nav>
</header>
<main>
<div class="grid-inverse wrap content">
<article class=post_content>
<h1 class=post_title>【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping</h1>
<div class=post_meta>
<span><svg class="icon"><use xlink:href="#calendar"/></svg></span>
<span class=post_date>
Jan 24, 2019</span>
<span class=post_time> · 41 min read</span><span>&nbsp;· <a href=https://111qqz.com/tags/6.828 title=6.828 class="post_tag button button_translucent">6.828
</a>
</span>
<span class=page_only>&nbsp;·
<div class=post_share>
Share on:
<a href="https://twitter.com/intent/tweet?text=%e3%80%90%e6%96%bd%e5%b7%a5%e5%ae%8c%e6%88%90%e3%80%91MIT%206.828%20lab%201%3a%20C%2c%20Assembly%2c%20Tools%20and%20Bootstrapping&url=https%3a%2f%2f111qqz.com%2f2019%2f01%2fmit-6-828-lab-1%2f&tw_p=tweetbutton" class=twitter title="Share on Twitter" target=_blank rel=nofollow><svg class="icon"><use xlink:href="#twitter"/></svg>
</a>
<a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2f111qqz.com%2f2019%2f01%2fmit-6-828-lab-1%2f&t=%e3%80%90%e6%96%bd%e5%b7%a5%e5%ae%8c%e6%88%90%e3%80%91MIT%206.828%20lab%201%3a%20C%2c%20Assembly%2c%20Tools%20and%20Bootstrapping" class=facebook title="Share on Facebook" target=_blank rel=nofollow><svg class="icon"><use xlink:href="#facebook"/></svg>
</a>
<a href=#linkedinshare id=linkedinshare class=linkedin title="Share on LinkedIn" rel=nofollow><svg class="icon"><use xlink:href="#linkedin"/></svg>
</a>
<a href=https://111qqz.com/2019/01/mit-6-828-lab-1/ title="Copy Link" class="link link_yank"><svg class="icon"><use xlink:href="#copy"/></svg>
</a>
</div>
</span>
</div>
<div class=post_body><h2 id=花费了30小时终于搞定了orz>花费了30+小时，终于搞定了orz</h2>
<h2 id=part-1-pc-bootstrap>Part 1: PC Bootstrap</h2>
<h3 id=the-pcs-physical-address-space>The PC's Physical Address Space</h3>
<h4 id=80868088时代>8086/8088时代</h4>
<pre><code>+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</code></pre>
<p>由于8086/8088只有20跟地址线，因此物理内存空间就是2^20=1MB.地址空间从0x00000到0xFFFFF.其中从0x00000开始的640k空间被称为"low memory"，是PC真正能使用的RAM。从 0xA0000 到 0xFFFFF　的384k的non-volatile memory被硬件保留，用作video display buffers和BIOS等。</p>
<h4 id=8028680386时代及以后>80286/80386时代及以后</h4>
<p>为了保持向后兼容，因此0-1MB的空间还是和原来保持一致。因此地址空间似乎存在一个“洞”（为什么我觉得其实是两个“洞”。。。不是空着的才叫“洞”吗），PC能使用的RAM被这个“洞”（也就是0xA0000 到 0xFFFFF)分成了0x00000000到0x000BFFFF的640k和 0x00100000到0xFFFFFFFF两部分。</p>
<table align=center>
<tbody>
<tr>
<td>
<pre><code>+------------------+  &lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  &lt;- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</code></pre>
</td>
</tr>
</tbody>
</table>
此外，在地址空间的最上面一部分，通常被BIOS保留用于 32-bit PCI devices的memory mapped. memory mapped是对于memory和I/O设备使用相同的地址空间的一种I/O寻址方式。具体可以参考[Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)。PCI设备具体可以参考[PCI_Express](https://en.wikipedia.org/wiki/PCI_Express)和[深入PCI与PCIe之一：硬件篇](https://zhuanlan.zhihu.com/p/26172972)
<p>目前处理器已经可以支持超过4GB大小的内存空间。因此为了保持后向兼容性，地址空间又会多一个"洞"。</p>
<h3 id=the-rom-bios>The ROM BIOS</h3>
<p>用qemu模拟启动，观察到进入BIOS执行的第一条命令为</p>
<pre><code>[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b
</code></pre>
<p>说明PC执行的第一条指令的物理地址为0xffff0。</p>
<p>然后使用si命令执行单步指令,得到的前面几条执行的指令如下：</p>
<pre><code>[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8
[f000:e062]    0xfe062: jne    0xfd2e1
[f000:e066]    0xfe066: xor    %dx,%dx
[f000:e068]    0xfe068: mov    %dx,%ss
[f000:e06a]    0xfe06a: mov    $0x7000,%esp
[f000:e070]    0xfe070: mov    $0xf34c2,x
[f000:e076]    0xfe076: jmp    0xfd15c
[f000:d15c]    0xfd15c: mov    x,x
...
</code></pre>
<p>如果看着觉得似懂非懂...不要慌，问题不大，因为这里不需要弄明白BIOS到底在干什么。不过建议先复习一下x86汇编，可以参考<a href=http://learn-assembly.blogspot.com/2009/04/general-registers-ax-bx-cx-and-dx.html>General Registers (AX, BX, CX, and DX)</a>，<a href=https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm>Intel 80386 Reference Programmer's Manual Table of Contents</a> 等内容。然后强烈推荐去稍微看一下<a href=ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html#SEC56>gdb_examining data</a> 部分的教程，尤其是查看memory和register内容的章节，对搞清楚BIOS这里到底在干嘛大有裨益。<strong>(x [memory]来查看某个地址的内容，x/i [memory]将该地址的指令以人类可读的方式写出，p/x $[register] 来查看某个寄存器的值。）</strong></p>
<p>那么BIOS大概做了什么呢？主要是建立<a href=https://en.wikipedia.org/wiki/Interrupt_descriptor_table>Interrupt descriptor table</a>（其实就是x86体系架构中断向量表的实现),初始化一些硬件设备，然后寻找一个"bootable"设备。如果找到了这样一个设备，BIOS就将该设备上的boot loader加载到内存，并将控制权交给boot loader.</p>
<p>先明确几个概念。所谓boot loader,就是在加载OS前运行的一段程序。通常在硬盘的第一个sector里，因此这个sector也叫boot sector.至于我们更经常见到的<a href=https://en.wikipedia.org/wiki/Master_boot_record>master boot record(主引导记录)</a>，其实就是一种对于分区过的媒介的特殊的boot sector.</p>
<p>顺便提一句，确定一个设备是否为"bootable"是通过 0x55和0xAA两个boot signature来决定的。具体来说，如果一个设备中的第0个sector的最后两个byte的值分别为0x55和0xAA,就认为这是一个bootable设备。可以参考<a href=https://wiki.osdev.org/Boot_Sequence>bool sequence</a></p>
<h2 id=part-2-the-boot-loader>Part 2: The Boot Loader</h2>
<p>BIOS在初始化完成后需要将boot loader加载到内存，具体的地址为 0x7c00 到0x7dff。</p>
<p>关于0x7c00这个magic number是怎么来的？　其实不重要，不过感兴趣可以参考<a href=https://www.glamenv-septzen.net/en/view/6>Why BIOS loads MBR into 0x7C00 in x86 ?</a>　知道这个magic number其实不是x86相关的，而是和IBM的BIOS开发团队有关就可以了。</p>
<p>boot loader包含一个汇编文件boot/boot.S和一个c语言文件boot/main.c</p>
<p>先来看下boot/boot.S文件都在干什么吧</p>
<p>不过在这之前，不妨先复习一下real mode和proteced mode</p>
<h3 id=real-mode--protected-mode>real mode / protected mode</h3>
<pre><code>  * [Real_mode](https://en.wikipedia.org/wiki/Real_mode)　地址空间被限制在2^20(因为地址总线为20),没有虚拟内存的概念，内存都是真实的物理内存。在real mode下，segment位于物理内存中的固定位置上。
  * 16-bit Protected Mode　登场于intel 80286处理器。首次引入了虚拟内存的概念。依赖局部性原理，只将程序运行需要的部分放入内存，暂时用不到的部分则存储在硬盘。segment的位置在其从disk回到memory中，可能和之前的位置不同。由于segment的位置不再固定，引入[Global Descriptor Table，GDT](https://en.wikipedia.org/wiki/Global_Descriptor_Table)来描述segment的信息，诸如是否在内存中，如果在，在内存中的什么位置，以及访问权限。由于寄存器仍然是16bit,所以segment [OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/)
  *  32-bit Protected Mode 　登场于intel 80386处理器。比起80286,使用的寄存器是32-bit的，因此segment size 增大到4GB(2^32). 同时，由于segment size不再像64k那么小，以前的一整个segment要么都在memory中，要么都在disk中的策略就变得不太科学了。因此引入[paging](https://en.wikipedia.org/wiki/Paging) 机制，将segment分成尺寸更小的page。允许segment中的一部分在memory中。关于paging可以参考[OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/)的18章。
</code></pre>
<p>这里值得一提的是，对于支持protected mode的cpu,启动时为了保持向后兼容，仍然会以real mode启动，之后再切换到protected mode.</p>
<blockquote>_When a processor that supports x86 protected mode is powered on, it begins executing instructions in [real mode](https://en.wikipedia.org/wiki/Real_mode), in order to maintain [backward compatibility](https://en.wikipedia.org/wiki/Backward_compatibility) with earlier x86 processors.[[4]](https://en.wikipedia.org/wiki/Protected_mode#cite_note-Real_mode_on_powered_on-4) Protected mode may only be entered after the system software sets up one descriptor table and enables the Protection Enable (PE) [bit](https://en.wikipedia.org/wiki/Bit) in the [control register](https://en.wikipedia.org/wiki/Control_register) 0 (CR0)_</blockquote>
<h3 id=bootboots文件在干什么>boot/boot.S文件在干什么</h3>
<p>'''s</p>
<pre><code>#include &lt;inc/mmu.h&gt;

# Start the CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.

.set PROT_MODE_CSEG, 0x8         # kernel code segment selector
.set PROT_MODE_DSEG, 0x10        # kernel data segment selector
.set CR0_PE_ON,      0x1         # protected mode enable flag

.globl start
start:
  .code16                     # Assemble for 16-bit mode
  cli                         # Disable interrupts
  cld                         # String operations increment

  # Set up the important data segment registers (DS, ES, SS).
  xorw    %ax,%ax             # Segment number zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment

  # Enable A20:
  #   For backwards compatibility with the earliest PCs, physical
  #   address line 20 is tied low, so that addresses higher than
  #   1MB wrap around to zero by default.  This code undoes this.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  outb    %al,$0x60

  # Switch from real to protected mode, using a bootstrap GDT
  # and segment translation that makes virtual addresses 
  # identical to their physical addresses, so that the 
  # effective memory map does not change during the switch.
  lgdt    gdtdesc  # lgdt means load global descriptor table
  movl    %cr0, x
  orl     $CR0_PE_ON, x  # cr0 = cr0 | 1
  movl    x, %cr0
  
  # Jump to next instruction, but in 32-bit code segment.
  # Switches processor into 32-bit mode.
  ljmp    $PROT_MODE_CSEG, $protcseg

  .code32                     # Assemble for 32-bit mode
protcseg:
  # Set up the protected-mode data segment registers
  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  
  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call bootmain

  # If bootmain returns (it shouldn't), loop.
spin:
  jmp spin

# Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULL                              # null seg
  SEG(STA_X|STA_R, 0x0, 0xffffffff)     # code seg
  SEG(STA_W, 0x0, 0xffffffff)           # data seg

gdtdesc:
  .word   0x17                            # sizeof(gdt) - 1
  .long   gdt                             # address gdt
</code></pre>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=ln>   1</span><span class=w>
</span><span class=ln>   2</span><span class=w></span><span class=err>第一次看到这段代码的时候感觉</span><span class=n>Enable</span><span class=w> </span><span class=nf>A20这一部分比较喵</span><span class=p>(</span><span class=n>ling</span><span class=p>)</span><span class=err>喵</span><span class=p>(</span><span class=n>ren</span><span class=p>)</span><span class=err>喵</span><span class=p>(</span><span class=n>fei</span><span class=p>)</span><span class=err>喵</span><span class=p>(</span><span class=n>jie</span><span class=p>)</span><span class=w>
</span><span class=ln>   3</span><span class=w>
</span><span class=ln>   4</span><span class=w></span><span class=err>可以参考</span><span class=p>[</span><span class=n>A20</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>pain</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>past</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>www</span><span class=p>.</span><span class=n>win</span><span class=p>.</span><span class=n>tue</span><span class=p>.</span><span class=n>nl</span><span class=o>/~</span><span class=n>aeb</span><span class=o>/</span><span class=n>linux</span><span class=o>/</span><span class=n>kbd</span><span class=o>/</span><span class=n>A20</span><span class=p>.</span><span class=n>html</span><span class=p>)</span><span class=err>。重点是</span><span class=w>
</span><span class=ln>   5</span><span class=w>
</span><span class=ln>   6</span><span class=w>
</span><span class=ln>   7</span><span class=w></span><span class=o>&lt;</span><span class=n>blockquote</span><span class=o>&gt;</span><span class=n>One</span><span class=w> </span><span class=n>sets</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>output</span><span class=w> </span><span class=n>port</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>keyboard</span><span class=w> </span><span class=n>controller</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=n>writing</span><span class=w> </span><span class=mi>0</span><span class=n>xd1</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>port</span><span class=w> </span><span class=mi>0</span><span class=n>x64</span><span class=p>,</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>desired</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>output</span><span class=w> </span><span class=n>port</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>port</span><span class=w> </span><span class=mi>0</span><span class=n>x60</span><span class=p>.</span><span class=w> </span><span class=n>One</span><span class=w> </span><span class=n>usually</span><span class=w> </span><span class=n>sees</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=k>values</span><span class=w> </span><span class=mi>0</span><span class=n>xdd</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=mi>0</span><span class=n>xdf</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>disable</span><span class=o>/</span><span class=n>enable</span><span class=w> </span><span class=n>A20</span><span class=p>.</span><span class=o>&lt;/</span><span class=n>blockquote</span><span class=o>&gt;</span><span class=w>
</span><span class=ln>   8</span><span class=w>
</span><span class=ln>   9</span><span class=w>
</span><span class=ln>  10</span><span class=w></span><span class=err>然后比较让人疑惑的可能是</span><span class=s2>&#34;bootstrap GDT”这部分。参考[cs421 x86 Assembly Guide](http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html)尤其是:
</span><span class=ln>  11</span><span class=s2>
</span><span class=ln>  12</span><span class=s2>    
</span><span class=ln>  13</span><span class=s2>    .data		
</span><span class=ln>  14</span><span class=s2>    var:		
</span><span class=ln>  15</span><span class=s2>    .byte 64	/* Declare a byte, referred to as location var, containing the value 64. */
</span><span class=ln>  16</span><span class=s2>    .byte 10	/* Declare a byte with no label, containing the value 10. Its location is var + 1. */
</span><span class=ln>  17</span><span class=s2>    x:		
</span><span class=ln>  18</span><span class=s2>    .short 42	/* Declare a 2-byte value initialized to 42, referred to as location x. */
</span><span class=ln>  19</span><span class=s2>    y:		
</span><span class=ln>  20</span><span class=s2>    .long 30000    	/* Declare a 4-byte value, referred to as location y, initialized to 30000. */
</span><span class=ln>  21</span><span class=s2>    
</span><span class=ln>  22</span><span class=s2>    
</span><span class=ln>  23</span><span class=s2>    s:		
</span><span class=ln>  24</span><span class=s2>    .long 1, 2, 3	/* Declare three 4-byte values, initialized to 1, 2, and 3. 
</span><span class=ln>  25</span><span class=s2>    The value at location s + 8 will be 3. */
</span><span class=ln>  26</span><span class=s2>    barr:		
</span><span class=ln>  27</span><span class=s2>    .zero 10	/* Declare 10 bytes starting at location barr, initialized to 0. */
</span><span class=ln>  28</span><span class=s2>    str:		
</span><span class=ln>  29</span><span class=s2>    .string &#34;</span><span class=n>hello</span><span class=s2>&#34;   	/* Declare 6 bytes starting at the address str initialized to 
</span><span class=ln>  30</span><span class=s2>    the ASCII character values for hello followed by a nul (0) byte. */
</span><span class=ln>  31</span><span class=s2>
</span><span class=ln>  32</span><span class=s2>
</span><span class=ln>  33</span><span class=s2>知道gdtdesc部分做的事情是，在gdtdesc这个位置定义了一个word类型（２字节）的变量，值为0x17,参考注释也就是gdt定义的那一段的size大小。然后在gdtdsec+2这个位置定义了long类型(4字节)的gdt地址.
</span><span class=ln>  34</span><span class=s2>
</span><span class=ln>  35</span><span class=s2>这里gdt和gdtdesc都是&#34;</span><span class=n>label</span><span class=s2>&#34;，label其实就是标记了一个内存地址，方便使用。
</span><span class=ln>  36</span><span class=s2>
</span><span class=ln>  37</span><span class=s2>具体来说，一个“label”的值，是其之后的第一条instruction的内存地址。
</span><span class=ln>  38</span><span class=s2>
</span><span class=ln>  39</span><span class=s2>
</span><span class=ln>  40</span><span class=s2>&lt;blockquote&gt;We use the notation &lt;label&gt; to refer to labeled locations in the program text. Labels can be inserted anywhere in x86 assembly code text by entering a label name followed by a colon. For example,
</span><span class=ln>  41</span><span class=s2>
</span><span class=ln>  42</span><span class=s2>&gt; 
</span><span class=ln>  43</span><span class=s2>&gt; &lt;blockquote&gt;
</span><span class=ln>  44</span><span class=s2>
</span><span class=ln>  45</span><span class=s2>&gt;&gt;     
</span><span class=ln>  46</span><span class=s2>&gt;&gt;            mov 8(p), %esi
</span><span class=ln>  47</span><span class=s2>&gt;&gt;     begin:
</span><span class=ln>  48</span><span class=s2>&gt;&gt;            xor x, x
</span><span class=ln>  49</span><span class=s2>&gt;&gt;            mov (%esi), x
</span><span class=ln>  50</span><span class=s2>&gt;&gt;     
</span><span class=ln>  51</span><span class=s2>&gt;&gt; 
</span><span class=ln>  52</span><span class=s2>&gt;&gt; 
</span><span class=ln>  53</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln>  54</span><span class=s2>&gt; 
</span><span class=ln>  55</span><span class=s2>&gt; 
</span><span class=ln>  56</span><span class=s2>The second instruction in this code fragment is labeled begin. Elsewhere in the code, we can refer to the memory location that this instruction is located at in memory using the more convenient symbolic name begin. This label is just a convenient way of expressing the location instead of its 32-bit value.&lt;/blockquote&gt;
</span><span class=ln>  57</span><span class=s2>
</span><span class=ln>  58</span><span class=s2>
</span><span class=ln>  59</span><span class=s2>然后是关于gdt部分，SEG看起来是个宏，我们看到inc/mmu.h这个文件中相关的部分，豁然开朗。
</span><span class=ln>  60</span><span class=s2>
</span><span class=ln>  61</span><span class=s2>    
</span><span class=ln>  62</span><span class=s2>    #ifdef __ASSEMBLER__
</span><span class=ln>  63</span><span class=s2>    
</span><span class=ln>  64</span><span class=s2>    /*
</span><span class=ln>  65</span><span class=s2>     * Macros to build GDT entries in assembly.
</span><span class=ln>  66</span><span class=s2>     */
</span><span class=ln>  67</span><span class=s2>    #define SEG_NULL                                                \
</span><span class=ln>  68</span><span class=s2>            .word 0, 0;                                             \
</span><span class=ln>  69</span><span class=s2>            .byte 0, 0, 0, 0
</span><span class=ln>  70</span><span class=s2>    #define SEG(type,base,lim)                                      \
</span><span class=ln>  71</span><span class=s2>            .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \
</span><span class=ln>  72</span><span class=s2>            .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \
</span><span class=ln>  73</span><span class=s2>                    (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)
</span><span class=ln>  74</span><span class=s2>    
</span><span class=ln>  75</span><span class=s2>    #else   // not __ASSEMBLER__
</span><span class=ln>  76</span><span class=s2>
</span><span class=ln>  77</span><span class=s2>
</span><span class=ln>  78</span><span class=s2>接下来不太明确的地方可能是cr0部分。
</span><span class=ln>  79</span><span class=s2>
</span><span class=ln>  80</span><span class=s2>我们看到代码最开始有一个CR0_PE_ON,值为0x1.之后就是在计算cr0 = cr0 | 0x1，按照注释说这样就可以把保护模式打开了。理解到这里其实就ok，不过我还是想多说两句。　Control register是用来控制cpu行为的寄存器。cr0是x86体系架构的[Control register](https://en.wikipedia.org/wiki/Control_register)中的一个。cr0是32bit的寄存器，其中一些bit上有名称以及固定的作用。比如对于位置bit 0,该位置的名称是&#34;</span><span class=n>Protected</span><span class=w> </span><span class=n>Mode</span><span class=w> </span><span class=n>Enable</span><span class=s2>&#34;，简称为PE,当该位置值为1,表示保护模式被打开。
</span><span class=ln>  81</span><span class=s2>
</span><span class=ln>  82</span><span class=s2>最后一个小细节是&#34;</span><span class=p>.</span><span class=n>globl</span><span class=w> </span><span class=n>start</span><span class=s2>&#34;。&#34;</span><span class=p>.</span><span class=n>globl</span><span class=s2>&#34;是什么含义？为什么要把start这个label定义成global的？可以参考[What is global _start in assembly language?](https://stackoverflow.com/questions/17898989/what-is-global-start-in-assembly-language)　用人话说就是定义成.globl的lable会被导出到生成的.o文件中，不然linker找不到这个符号。由于start是这个boot.S文件的entry point，因此需要linker看到。
</span><span class=ln>  83</span><span class=s2>
</span><span class=ln>  84</span><span class=s2>最后，从全局来看，boot.S这个文件做了什么呢？　其实上面一个小节中已经提到了。
</span><span class=ln>  85</span><span class=s2>
</span><span class=ln>  86</span><span class=s2>
</span><span class=ln>  87</span><span class=s2>&lt;blockquote&gt;_When a processor that supports x86 protected mode is powered on, it begins executing instructions in [real mode](https://en.wikipedia.org/wiki/Real_mode), in order to maintain [backward compatibility](https://en.wikipedia.org/wiki/Backward_compatibility) with earlier x86 processors.[[4]](https://en.wikipedia.org/wiki/Protected_mode#cite_note-Real_mode_on_powered_on-4) Protected mode may only be entered after the system software sets up one descriptor table and enables the Protection Enable (PE) [bit](https://en.wikipedia.org/wiki/Bit) in the [control register](https://en.wikipedia.org/wiki/Control_register) 0 (CR0)_&lt;/blockquote&gt;
</span><span class=ln>  88</span><span class=s2>
</span><span class=ln>  89</span><span class=s2>
</span><span class=ln>  90</span><span class=s2>
</span><span class=ln>  91</span><span class=s2>
</span><span class=ln>  92</span><span class=s2>
</span><span class=ln>  93</span><span class=s2>### boot/main.c这个文件在干什么
</span><span class=ln>  94</span><span class=s2>
</span><span class=ln>  95</span><span class=s2>
</span><span class=ln>  96</span><span class=s2>
</span><span class=ln>  97</span><span class=s2>    
</span><span class=ln>  98</span><span class=s2>    #include &lt;inc/x86.h&gt;                                                                                                                                                                          
</span><span class=ln>  99</span><span class=s2>    #include &lt;inc/elf.h&gt;                                                                                                                                                                          
</span><span class=ln> 100</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 101</span><span class=s2>    /**********************************************************************                                                                                                                       
</span><span class=ln> 102</span><span class=s2>     * This a dirt simple boot loader, whose sole job is to boot                                                                                                                                  
</span><span class=ln> 103</span><span class=s2>     * an ELF kernel image from the first IDE hard disk.                                                                                                                                          
</span><span class=ln> 104</span><span class=s2>     *                                                                                                                                                                                            
</span><span class=ln> 105</span><span class=s2>     * DISK LAYOUT                                                                                                                                                                                
</span><span class=ln> 106</span><span class=s2>     *  * This program(boot.S and main.c) is the bootloader.  It should                                                                                                                           
</span><span class=ln> 107</span><span class=s2>     *    be stored in the first sector of the disk.                                                                                                                                              
</span><span class=ln> 108</span><span class=s2>     *                                                                                                                                                                                            
</span><span class=ln> 109</span><span class=s2>     *  * The 2nd sector onward holds the kernel image.                                                                                                                                           
</span><span class=ln> 110</span><span class=s2>     *                                                                                                                                                                                            
</span><span class=ln> 111</span><span class=s2>     *  * The kernel image must be in ELF format.                                                                                                                                                 
</span><span class=ln> 112</span><span class=s2>     *                                                                                                                                                                                            
</span><span class=ln> 113</span><span class=s2>     * BOOT UP STEPS                                                                                                                                                                              
</span><span class=ln> 114</span><span class=s2>     *  * when the CPU boots it loads the BIOS into memory and executes it                                                                                                                        
</span><span class=ln> 115</span><span class=s2>     *                                                                                                                                                                                            
</span><span class=ln> 116</span><span class=s2>     *  * the BIOS intializes devices, sets of the interrupt routines, and
</span><span class=ln> 117</span><span class=s2>     *    reads the first sector of the boot device(e.g., hard-drive)
</span><span class=ln> 118</span><span class=s2>     *    into memory and jumps to it.
</span><span class=ln> 119</span><span class=s2>     *
</span><span class=ln> 120</span><span class=s2>     *  * Assuming this boot loader is stored in the first sector of the
</span><span class=ln> 121</span><span class=s2>     *    hard-drive, this code takes over...
</span><span class=ln> 122</span><span class=s2>     *
</span><span class=ln> 123</span><span class=s2>     *  * control starts in boot.S -- which sets up protected mode,
</span><span class=ln> 124</span><span class=s2>     *    and a stack so C code then run, then calls bootmain()
</span><span class=ln> 125</span><span class=s2>     *
</span><span class=ln> 126</span><span class=s2>     *  * bootmain() in this file takes over, reads in the kernel and jumps to it.
</span><span class=ln> 127</span><span class=s2>     **********************************************************************/
</span><span class=ln> 128</span><span class=s2>    
</span><span class=ln> 129</span><span class=s2>    #define SECTSIZE        512
</span><span class=ln> 130</span><span class=s2>    #define ELFHDR          ((struct Elf *) 0x10000) // scratch space
</span><span class=ln> 131</span><span class=s2>    
</span><span class=ln> 132</span><span class=s2>    void readsect(void*, uint32_t);
</span><span class=ln> 133</span><span class=s2>    void readseg(uint32_t, uint32_t, uint32_t);
</span><span class=ln> 134</span><span class=s2>    
</span><span class=ln> 135</span><span class=s2>    void
</span><span class=ln> 136</span><span class=s2>    bootmain(void)
</span><span class=ln> 137</span><span class=s2>    {
</span><span class=ln> 138</span><span class=s2>            struct Proghdr *ph, *eph;
</span><span class=ln> 139</span><span class=s2>    
</span><span class=ln> 140</span><span class=s2>            // read 1st page off disk
</span><span class=ln> 141</span><span class=s2>            readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
</span><span class=ln> 142</span><span class=s2>    
</span><span class=ln> 143</span><span class=s2>            // is this a valid ELF?
</span><span class=ln> 144</span><span class=s2>            if (ELFHDR-&gt;e_magic != ELF_MAGIC)
</span><span class=ln> 145</span><span class=s2>                    goto bad;
</span><span class=ln> 146</span><span class=s2>    
</span><span class=ln> 147</span><span class=s2>            // load each program segment (ignores ph flags)
</span><span class=ln> 148</span><span class=s2>            ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
</span><span class=ln> 149</span><span class=s2>            eph = ph + ELFHDR-&gt;e_phnum;
</span><span class=ln> 150</span><span class=s2>            for (; ph &lt; eph; ph++)
</span><span class=ln> 151</span><span class=s2>                    // p_pa is the load address of this segment (as well
</span><span class=ln> 152</span><span class=s2>                    // as the physical address)
</span><span class=ln> 153</span><span class=s2>                    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);
</span><span class=ln> 154</span><span class=s2>    
</span><span class=ln> 155</span><span class=s2>            // call the entry point from the ELF header
</span><span class=ln> 156</span><span class=s2>            // note: does not return!
</span><span class=ln> 157</span><span class=s2>            ((void (*)(void)) (ELFHDR-&gt;e_entry))();
</span><span class=ln> 158</span><span class=s2>    
</span><span class=ln> 159</span><span class=s2>    bad:
</span><span class=ln> 160</span><span class=s2>            outw(0x8A00, 0x8A00);
</span><span class=ln> 161</span><span class=s2>            outw(0x8A00, 0x8E00);
</span><span class=ln> 162</span><span class=s2>            while (1)
</span><span class=ln> 163</span><span class=s2>                    /* do nothing */;
</span><span class=ln> 164</span><span class=s2>    }
</span><span class=ln> 165</span><span class=s2>    
</span><span class=ln> 166</span><span class=s2>    // Read &#39;count&#39; bytes at &#39;offset&#39; from kernel into physical address &#39;pa&#39;.
</span><span class=ln> 167</span><span class=s2>    // Might copy more than asked
</span><span class=ln> 168</span><span class=s2>    void
</span><span class=ln> 169</span><span class=s2>    readseg(uint32_t pa, uint32_t count, uint32_t offset)
</span><span class=ln> 170</span><span class=s2>    {
</span><span class=ln> 171</span><span class=s2>            uint32_t end_pa;
</span><span class=ln> 172</span><span class=s2>    
</span><span class=ln> 173</span><span class=s2>            end_pa = pa + count;
</span><span class=ln> 174</span><span class=s2>    
</span><span class=ln> 175</span><span class=s2>            // round down to sector boundary
</span><span class=ln> 176</span><span class=s2>            pa &amp;= ~(SECTSIZE - 1);
</span><span class=ln> 177</span><span class=s2>    
</span><span class=ln> 178</span><span class=s2>            // translate from bytes to sectors, and kernel starts at sector 1
</span><span class=ln> 179</span><span class=s2>            offset = (offset / SECTSIZE) + 1;
</span><span class=ln> 180</span><span class=s2>    
</span><span class=ln> 181</span><span class=s2>            // If this is too slow, we could read lots of sectors at a time.
</span><span class=ln> 182</span><span class=s2>            // We&#39;d write more to memory than asked, but it doesn&#39;t matter --
</span><span class=ln> 183</span><span class=s2>            // we load in increasing order.
</span><span class=ln> 184</span><span class=s2>            while (pa &lt; end_pa) {
</span><span class=ln> 185</span><span class=s2>                    // Since we haven&#39;t enabled paging yet and we&#39;re using
</span><span class=ln> 186</span><span class=s2>                    // an identity segment mapping (see boot.S), we can
</span><span class=ln> 187</span><span class=s2>                    // use physical addresses directly.  This won&#39;t be the
</span><span class=ln> 188</span><span class=s2>                    // case once JOS enables the MMU.
</span><span class=ln> 189</span><span class=s2>                    readsect((uint8_t*) pa, offset);
</span><span class=ln> 190</span><span class=s2>                    pa += SECTSIZE;
</span><span class=ln> 191</span><span class=s2>                    offset++;
</span><span class=ln> 192</span><span class=s2>            }
</span><span class=ln> 193</span><span class=s2>    }
</span><span class=ln> 194</span><span class=s2>    
</span><span class=ln> 195</span><span class=s2>    void
</span><span class=ln> 196</span><span class=s2>    waitdisk(void)
</span><span class=ln> 197</span><span class=s2>    {
</span><span class=ln> 198</span><span class=s2>            // wait for disk reaady
</span><span class=ln> 199</span><span class=s2>            while ((inb(0x1F7) &amp; 0xC0) != 0x40)
</span><span class=ln> 200</span><span class=s2>                    /* do nothing */;
</span><span class=ln> 201</span><span class=s2>    }
</span><span class=ln> 202</span><span class=s2>    
</span><span class=ln> 203</span><span class=s2>    void
</span><span class=ln> 204</span><span class=s2>    readsect(void *dst, uint32_t offset)
</span><span class=ln> 205</span><span class=s2>    {
</span><span class=ln> 206</span><span class=s2>            // wait for disk to be ready
</span><span class=ln> 207</span><span class=s2>            waitdisk();
</span><span class=ln> 208</span><span class=s2>    
</span><span class=ln> 209</span><span class=s2>            outb(0x1F2, 1);         // count = 1
</span><span class=ln> 210</span><span class=s2>            outb(0x1F3, offset);
</span><span class=ln> 211</span><span class=s2>            outb(0x1F4, offset &gt;&gt; 8);
</span><span class=ln> 212</span><span class=s2>            outb(0x1F5, offset &gt;&gt; 16);
</span><span class=ln> 213</span><span class=s2>            outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);
</span><span class=ln> 214</span><span class=s2>            outb(0x1F7, 0x20);      // cmd 0x20 - read sectors
</span><span class=ln> 215</span><span class=s2>    
</span><span class=ln> 216</span><span class=s2>            // wait for disk to be ready
</span><span class=ln> 217</span><span class=s2>            waitdisk();
</span><span class=ln> 218</span><span class=s2>    
</span><span class=ln> 219</span><span class=s2>            // read a sector
</span><span class=ln> 220</span><span class=s2>            insl(0x1F0, dst, SECTSIZE/4);
</span><span class=ln> 221</span><span class=s2>    }
</span><span class=ln> 222</span><span class=s2>
</span><span class=ln> 223</span><span class=s2>
</span><span class=ln> 224</span><span class=s2>先注意到一些看起来像是汇编指令的东西...比如outb之类。查看inc/x86.h文件，找到他们的定义。
</span><span class=ln> 225</span><span class=s2>
</span><span class=ln> 226</span><span class=s2>    
</span><span class=ln> 227</span><span class=s2>    static inline void
</span><span class=ln> 228</span><span class=s2>    outb(int port, uint8_t data)
</span><span class=ln> 229</span><span class=s2>    {
</span><span class=ln> 230</span><span class=s2>            asm volatile(</span><span class=s2>&#34;</span><span class=n>outb</span><span class=w> </span><span class=o>%</span><span class=mi>0</span><span class=p>,</span><span class=o>%</span><span class=n>w1</span><span class=s2>&#34; : : &#34;</span><span class=n>a</span><span class=s2>&#34; (data), &#34;</span><span class=n>d</span><span class=s2>&#34; (port));
</span><span class=ln> 231</span><span class=s2>    }
</span><span class=ln> 232</span><span class=s2>    
</span><span class=ln> 233</span><span class=s2>    
</span><span class=ln> 234</span><span class=s2>    static inline void
</span><span class=ln> 235</span><span class=s2>    insl(int port, void *addr, int cnt)
</span><span class=ln> 236</span><span class=s2>    {
</span><span class=ln> 237</span><span class=s2>            asm volatile(&#34;</span><span class=n>cld</span><span class=err>\</span><span class=n>n</span><span class=err>\</span><span class=n>trepne</span><span class=err>\</span><span class=n>n</span><span class=err>\</span><span class=n>tinsl</span><span class=s2>&#34;
</span><span class=ln> 238</span><span class=s2>                         : &#34;</span><span class=o>=</span><span class=n>D</span><span class=s2>&#34; (addr), &#34;</span><span class=o>=</span><span class=n>c</span><span class=s2>&#34; (cnt)
</span><span class=ln> 239</span><span class=s2>                         : &#34;</span><span class=n>d</span><span class=s2>&#34; (port), &#34;</span><span class=mi>0</span><span class=s2>&#34; (addr), &#34;</span><span class=mi>1</span><span class=s2>&#34; (cnt)
</span><span class=ln> 240</span><span class=s2>                         : &#34;</span><span class=n>memory</span><span class=s2>&#34;, &#34;</span><span class=n>cc</span><span class=s2>&#34;);
</span><span class=ln> 241</span><span class=s2>    }
</span><span class=ln> 242</span><span class=s2>    static inline uint8_t
</span><span class=ln> 243</span><span class=s2>    inb(int port)
</span><span class=ln> 244</span><span class=s2>    {       
</span><span class=ln> 245</span><span class=s2>            uint8_t data;
</span><span class=ln> 246</span><span class=s2>            asm volatile(&#34;</span><span class=n>inb</span><span class=w> </span><span class=o>%</span><span class=n>w1</span><span class=p>,</span><span class=o>%</span><span class=mi>0</span><span class=s2>&#34; : &#34;</span><span class=o>=</span><span class=n>a</span><span class=s2>&#34; (data) : &#34;</span><span class=n>d</span><span class=s2>&#34; (port));
</span><span class=ln> 247</span><span class=s2>            return data;
</span><span class=ln> 248</span><span class=s2>    }
</span><span class=ln> 249</span><span class=s2>
</span><span class=ln> 250</span><span class=s2>
</span><span class=ln> 251</span><span class=s2>发现就是用c将汇编封装了一层。这个东西应该叫“inline assembly”，具体可以参考[Brennan&#39;s Guide to Inline Assembly](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html)　其中volatile关键字表示禁止gcc优化这段代码。
</span><span class=ln> 252</span><span class=s2>
</span><span class=ln> 253</span><span class=s2>
</span><span class=ln> 254</span><span class=s2>&lt;blockquote&gt;If your assembly statement _must_ execute where you put it, (i.e. must not be moved out of a loop as an optimization), put the keyword **volatile** after **asm** and before the ()&#39;s. To be ultra-careful, use
</span><span class=ln> 255</span><span class=s2>
</span><span class=ln> 256</span><span class=s2>__asm__ __volatile__ (...whatever...);
</span><span class=ln> 257</span><span class=s2>
</span><span class=ln> 258</span><span class=s2>However, I would like to point out that if your assembly&#39;s only purpose is to calculate the output registers, with no other side effects, you should leave off the **volatile** keyword so your statement will be processed into GCC&#39;s common subexpression elimination optimization.&lt;/blockquote&gt;
</span><span class=ln> 259</span><span class=s2>
</span><span class=ln> 260</span><span class=s2>
</span><span class=ln> 261</span><span class=s2>注释上写的要&#34;</span><span class=n>boot</span><span class=w>  </span><span class=n>an</span><span class=w> </span><span class=n>ELF</span><span class=w> </span><span class=n>kernel</span><span class=w> </span><span class=n>image</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=n>IDE</span><span class=w> </span><span class=n>hard</span><span class=w> </span><span class=n>disk</span><span class=s2>&#34;,那么，首先要知道什么是ELF.　ELF其实就是一种文件格式，全称为“Executable and Linkable Format”可以参考[Executable_and_Linkable_Format#File_layout](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_layout)，建议通读这一部分，内容不多，不过对之后很有用。
</span><span class=ln> 262</span><span class=s2>
</span><span class=ln> 263</span><span class=s2>参考一下inc/elf.h文件,以及main.c中的注释，就可以整体上知道这段代码是在干什么了：将ELF格式的kernel image从硬盘读到内存中，并将控制权交给kernel image.
</span><span class=ln> 264</span><span class=s2>
</span><span class=ln> 265</span><span class=s2>    
</span><span class=ln> 266</span><span class=s2>    #ifndef JOS_INC_ELF_H
</span><span class=ln> 267</span><span class=s2>    #define JOS_INC_ELF_H
</span><span class=ln> 268</span><span class=s2>    
</span><span class=ln> 269</span><span class=s2>    #define ELF_MAGIC 0x464C457FU	/* &#34;</span><span class=err>\</span><span class=n>x7FELF</span><span class=s2>&#34; in little endian */
</span><span class=ln> 270</span><span class=s2>    
</span><span class=ln> 271</span><span class=s2>    struct Elf {
</span><span class=ln> 272</span><span class=s2>    	uint32_t e_magic;	// must equal ELF_MAGIC
</span><span class=ln> 273</span><span class=s2>    	uint8_t e_elf[12];
</span><span class=ln> 274</span><span class=s2>    	/* e_elf[0] 1 for signed 32 bit , 2 for signed 64-bit
</span><span class=ln> 275</span><span class=s2>    	        [1] 1 for little endianness ,2 for big endianness
</span><span class=ln> 276</span><span class=s2>                    [2] version type
</span><span class=ln> 277</span><span class=s2>                    [3] target OS
</span><span class=ln> 278</span><span class=s2>                    [4] ABI version
</span><span class=ln> 279</span><span class=s2>                    [5..11]  unused
</span><span class=ln> 280</span><span class=s2>    	*/
</span><span class=ln> 281</span><span class=s2>    	uint16_t e_type;     // object file type
</span><span class=ln> 282</span><span class=s2>    	uint16_t e_machine;  // instruction set arch , x86/MIPS/IA-64 and etc.
</span><span class=ln> 283</span><span class=s2>    	uint32_t e_version; 
</span><span class=ln> 284</span><span class=s2>    	uint32_t e_entry;    // the memory address of the entry point where process start executing.
</span><span class=ln> 285</span><span class=s2>    	uint32_t e_phoff;    // points to the start of the program header table.
</span><span class=ln> 286</span><span class=s2>    	uint32_t e_shoff;    // Points to the start of the section header table.
</span><span class=ln> 287</span><span class=s2>    	uint32_t e_flags;  
</span><span class=ln> 288</span><span class=s2>    	uint16_t e_ehsize;   // size of this header. 64byte for 64-bit,52bytes for 32-bit
</span><span class=ln> 289</span><span class=s2>    	uint16_t e_phentsize; // the size of a program header table entry.
</span><span class=ln> 290</span><span class=s2>    	uint16_t e_phnum;    // the number of entries in the program header table.
</span><span class=ln> 291</span><span class=s2>    	uint16_t e_shentsize; // the size of a section  header table entry.
</span><span class=ln> 292</span><span class=s2>    	uint16_t e_shnum;    // the number of entries in the section header table.
</span><span class=ln> 293</span><span class=s2>    	uint16_t e_shstrndx; 
</span><span class=ln> 294</span><span class=s2>    };
</span><span class=ln> 295</span><span class=s2>    
</span><span class=ln> 296</span><span class=s2>    struct Proghdr {
</span><span class=ln> 297</span><span class=s2>    	uint32_t p_type;    // type of the segment
</span><span class=ln> 298</span><span class=s2>    	uint32_t p_offset;  //  offset of the segment in the file image
</span><span class=ln> 299</span><span class=s2>    	uint32_t p_va;      // virtual address of the segment in memory
</span><span class=ln> 300</span><span class=s2>    	uint32_t p_pa;      // physical address for segment(?)
</span><span class=ln> 301</span><span class=s2>    	uint32_t p_filesz;  // Size in bytes of the segment in the file image. May be 0.
</span><span class=ln> 302</span><span class=s2>    	uint32_t p_memsz;   // Size in bytes of the segment in memory. May be 0.
</span><span class=ln> 303</span><span class=s2>    	uint32_t p_flags;
</span><span class=ln> 304</span><span class=s2>    	uint32_t p_align;   // 0 and 1 specify no alignment. Otherwise should be a positive, integral power of 2
</span><span class=ln> 305</span><span class=s2>    };
</span><span class=ln> 306</span><span class=s2>    
</span><span class=ln> 307</span><span class=s2>    struct Secthdr {
</span><span class=ln> 308</span><span class=s2>    	uint32_t sh_name; // An offset to a string in the .shstrtab section that represents the name of this section
</span><span class=ln> 309</span><span class=s2>    	uint32_t sh_type; // the type of this header
</span><span class=ln> 310</span><span class=s2>    	uint32_t sh_flags; // the attributes of the section
</span><span class=ln> 311</span><span class=s2>    	uint32_t sh_addr; // Virtual address of the section in memory
</span><span class=ln> 312</span><span class=s2>    	uint32_t sh_offset;  // Offset of the section in the file image
</span><span class=ln> 313</span><span class=s2>    	uint32_t sh_size;    // Size in bytes of the section in the file image. May be 0.
</span><span class=ln> 314</span><span class=s2>    	uint32_t sh_link;    // 
</span><span class=ln> 315</span><span class=s2>    	uint32_t sh_info;
</span><span class=ln> 316</span><span class=s2>    	uint32_t sh_addralign;
</span><span class=ln> 317</span><span class=s2>    	uint32_t sh_entsize;
</span><span class=ln> 318</span><span class=s2>            /*
</span><span class=ln> 319</span><span class=s2>              Contains the size, in bytes, of each entry, for sections that contain fixed-size entries. 
</span><span class=ln> 320</span><span class=s2>              Otherwise, this field contains zero.
</span><span class=ln> 321</span><span class=s2>             */
</span><span class=ln> 322</span><span class=s2>    };
</span><span class=ln> 323</span><span class=s2>    
</span><span class=ln> 324</span><span class=s2>    // Values for Proghdr::p_type
</span><span class=ln> 325</span><span class=s2>    #define ELF_PROG_LOAD		1
</span><span class=ln> 326</span><span class=s2>    
</span><span class=ln> 327</span><span class=s2>    // Flag bits for Proghdr::p_flags
</span><span class=ln> 328</span><span class=s2>    #define ELF_PROG_FLAG_EXEC	1
</span><span class=ln> 329</span><span class=s2>    #define ELF_PROG_FLAG_WRITE	2
</span><span class=ln> 330</span><span class=s2>    #define ELF_PROG_FLAG_READ	4
</span><span class=ln> 331</span><span class=s2>    
</span><span class=ln> 332</span><span class=s2>    // Values for Secthdr::sh_type
</span><span class=ln> 333</span><span class=s2>    #define ELF_SHT_NULL		0
</span><span class=ln> 334</span><span class=s2>    #define ELF_SHT_PROGBITS	1
</span><span class=ln> 335</span><span class=s2>    #define ELF_SHT_SYMTAB		2
</span><span class=ln> 336</span><span class=s2>    #define ELF_SHT_STRTAB		3
</span><span class=ln> 337</span><span class=s2>    
</span><span class=ln> 338</span><span class=s2>    // Values for Secthdr::sh_name
</span><span class=ln> 339</span><span class=s2>    #define ELF_SHN_UNDEF		0
</span><span class=ln> 340</span><span class=s2>    
</span><span class=ln> 341</span><span class=s2>    #endif /* !JOS_INC_ELF_H */
</span><span class=ln> 342</span><span class=s2>
</span><span class=ln> 343</span><span class=s2>
</span><span class=ln> 344</span><span class=s2>下面说几个细节。我们知道readsect是在读一个扇区，但是我怎么知道扇区是这样读的？可以参考[ATA_PIO_Mode的x86 Directions部分](https://wiki.osdev.org/ATA_PIO_Mode)
</span><span class=ln> 345</span><span class=s2>
</span><span class=ln> 346</span><span class=s2>第二个细节是“((void (*)(void)) (ELFHDR-&gt;e_entry))()”，乍一看有点不明觉厉，其实就是一个函数指针，e_entry是入口函数的地址。通知调用该函数，将控制权交给elf格式的kernel image.
</span><span class=ln> 347</span><span class=s2>
</span><span class=ln> 348</span><span class=s2>接下来我们看一下根据编译boot.s和main.c得到的反汇编文件
</span><span class=ln> 349</span><span class=s2>
</span><span class=ln> 350</span><span class=s2>    
</span><span class=ln> 351</span><span class=s2>    obj/boot/boot.out:     file format elf32-i386                                                                                                                                                 
</span><span class=ln> 352</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 353</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 354</span><span class=s2>    Disassembly of section .text:                                                                                                                                                                 
</span><span class=ln> 355</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 356</span><span class=s2>    00007c00 &lt;start&gt;:                                                                                                                                                                             
</span><span class=ln> 357</span><span class=s2>    .set CR0_PE_ON,      0x1         # protected mode enable flag                                                                                                                                 
</span><span class=ln> 358</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 359</span><span class=s2>    .globl start                                                                                                                                                                                  
</span><span class=ln> 360</span><span class=s2>    start:                                                                                                                                                                                        
</span><span class=ln> 361</span><span class=s2>      .code16                     # Assemble for 16-bit mode                                                                                                                                      
</span><span class=ln> 362</span><span class=s2>      cli                         # Disable interrupts                                                                                                                                            
</span><span class=ln> 363</span><span class=s2>        7c00:       fa                      cli                                                                                                                                                   
</span><span class=ln> 364</span><span class=s2>      cld                         # String operations increment                                                                                                                                   
</span><span class=ln> 365</span><span class=s2>        7c01:       fc                      cld                                                                                                                                                   
</span><span class=ln> 366</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 367</span><span class=s2>      # Set up the important data segment registers (DS, ES, SS).                                                                                                                                 
</span><span class=ln> 368</span><span class=s2>      xorw    %ax,%ax             # Segment number zero                                                                                                                                           
</span><span class=ln> 369</span><span class=s2>        7c02:       31 c0                   xor    x,x                                                                                                                                      
</span><span class=ln> 370</span><span class=s2>      movw    %ax,%ds             # -&gt; Data Segment                                                                                                                                               
</span><span class=ln> 371</span><span class=s2>        7c04:       8e d8                   mov    x,%ds                                                                                                                                       
</span><span class=ln> 372</span><span class=s2>      movw    %ax,%es             # -&gt; Extra Segment                                                                                                                                              
</span><span class=ln> 373</span><span class=s2>        7c06:       8e c0                   mov    x,%es                                                                                                                                       
</span><span class=ln> 374</span><span class=s2>      movw    %ax,%ss             # -&gt; Stack Segment                                                                                                                                              
</span><span class=ln> 375</span><span class=s2>        7c08:       8e d0                   mov    x,%ss                                                                                                                                       
</span><span class=ln> 376</span><span class=s2>                                                                                                                                                                                                  
</span><span class=ln> 377</span><span class=s2>    00007c0a &lt;seta20.1&gt;:
</span><span class=ln> 378</span><span class=s2>      # Enable A20:
</span><span class=ln> 379</span><span class=s2>      #   For backwards compatibility with the earliest PCs, physical
</span><span class=ln> 380</span><span class=s2>      #   address line 20 is tied low, so that addresses higher than
</span><span class=ln> 381</span><span class=s2>      #   1MB wrap around to zero by default.  This code undoes this.
</span><span class=ln> 382</span><span class=s2>    seta20.1:
</span><span class=ln> 383</span><span class=s2>      inb     $0x64,%al               # Wait for not busy
</span><span class=ln> 384</span><span class=s2>        7c0a:       e4 64                   in     $0x64,%al
</span><span class=ln> 385</span><span class=s2>      testb   $0x2,%al
</span><span class=ln> 386</span><span class=s2>        7c0c:       a8 02                   test   $0x2,%al
</span><span class=ln> 387</span><span class=s2>      jnz     seta20.1
</span><span class=ln> 388</span><span class=s2>        7c0e:       75 fa                   jne    7c0a &lt;seta20.1&gt;
</span><span class=ln> 389</span><span class=s2>    
</span><span class=ln> 390</span><span class=s2>      movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
</span><span class=ln> 391</span><span class=s2>        7c10:       b0 d1                   mov    $0xd1,%al
</span><span class=ln> 392</span><span class=s2>      outb    %al,$0x64
</span><span class=ln> 393</span><span class=s2>        7c12:       e6 64                   out    %al,$0x64
</span><span class=ln> 394</span><span class=s2>    
</span><span class=ln> 395</span><span class=s2>    00007c14 &lt;seta20.2&gt;:
</span><span class=ln> 396</span><span class=s2>    
</span><span class=ln> 397</span><span class=s2>    seta20.2:
</span><span class=ln> 398</span><span class=s2>      inb     $0x64,%al               # Wait for not busy
</span><span class=ln> 399</span><span class=s2>        7c14:       e4 64                   in     $0x64,%al
</span><span class=ln> 400</span><span class=s2>      testb   $0x2,%al
</span><span class=ln> 401</span><span class=s2>        7c16:       a8 02                   test   $0x2,%al
</span><span class=ln> 402</span><span class=s2>      jnz     seta20.2
</span><span class=ln> 403</span><span class=s2>        7c18:       75 fa                   jne    7c14 &lt;seta20.2&gt;
</span><span class=ln> 404</span><span class=s2>    
</span><span class=ln> 405</span><span class=s2>      movb    $0xdf,%al               # 0xdf -&gt; port 0x60
</span><span class=ln> 406</span><span class=s2>        7c1a:       b0 df                   mov    $0xdf,%al
</span><span class=ln> 407</span><span class=s2>      outb    %al,$0x60
</span><span class=ln> 408</span><span class=s2>        7c1c:       e6 60                   out    %al,$0x60
</span><span class=ln> 409</span><span class=s2>    
</span><span class=ln> 410</span><span class=s2>      # Switch from real to protected mode, using a bootstrap GDT
</span><span class=ln> 411</span><span class=s2>      # and segment translation that makes virtual addresses 
</span><span class=ln> 412</span><span class=s2>      # identical to their physical addresses, so that the 
</span><span class=ln> 413</span><span class=s2>      # effective memory map does not change during the switch.
</span><span class=ln> 414</span><span class=s2>      lgdt    gdtdesc  # lgdt means load global descriptor table
</span><span class=ln> 415</span><span class=s2>        7c1e:       0f 01 16                lgdtl  (%esi)
</span><span class=ln> 416</span><span class=s2>        7c21:       64 7c 0f                fs jl  7c33 &lt;protcseg+0x1&gt;
</span><span class=ln> 417</span><span class=s2>      movl    %cr0, x
</span><span class=ln> 418</span><span class=s2>        7c24:       20 c0                   and    %al,%al
</span><span class=ln> 419</span><span class=s2>      orl     $CR0_PE_ON, x  # crx = crx | 1
</span><span class=ln> 420</span><span class=s2>        7c26:       66 83 c8 01             or     $0x1,%ax
</span><span class=ln> 421</span><span class=s2>      movl    x, %cr0
</span><span class=ln> 422</span><span class=s2>        7c2a:       0f 22 c0                mov    x,%cr0
</span><span class=ln> 423</span><span class=s2>      
</span><span class=ln> 424</span><span class=s2>      # Jump to next instruction, but in 32-bit code segment.
</span><span class=ln> 425</span><span class=s2>      # Switches processor into 32-bit mode.
</span><span class=ln> 426</span><span class=s2>      ljmp    $PROT_MODE_CSEG, $protcseg
</span><span class=ln> 427</span><span class=s2>        7c2d:       ea                      .byte 0xea
</span><span class=ln> 428</span><span class=s2>        7c2e:       32 7c 08 00             xor    0x0(x,x,1),%bh
</span><span class=ln> 429</span><span class=s2>    
</span><span class=ln> 430</span><span class=s2>    00007c32 &lt;protcseg&gt;:
</span><span class=ln> 431</span><span class=s2>    
</span><span class=ln> 432</span><span class=s2>      .code32                     # Assemble for 32-bit mode
</span><span class=ln> 433</span><span class=s2>    protcseg:
</span><span class=ln> 434</span><span class=s2>      # Set up the protected-mode data segment registers
</span><span class=ln> 435</span><span class=s2>      movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
</span><span class=ln> 436</span><span class=s2>        7c32:       66 b8 10 00             mov    $0x10,%ax
</span><span class=ln> 437</span><span class=s2>      movw    %ax, %ds                # -&gt; DS: Data Segment
</span><span class=ln> 438</span><span class=s2>        7c36:       8e d8                   mov    x,%ds
</span><span class=ln> 439</span><span class=s2>      movw    %ax, %es                # -&gt; ES: Extra Segment
</span><span class=ln> 440</span><span class=s2>        7c38:       8e c0                   mov    x,%es
</span><span class=ln> 441</span><span class=s2>      movw    %ax, %fs                # -&gt; FS
</span><span class=ln> 442</span><span class=s2>        7c3a:       8e e0                   mov    x,%fs
</span><span class=ln> 443</span><span class=s2>      movw    %ax, %gs                # -&gt; GS
</span><span class=ln> 444</span><span class=s2>        7c3c:       8e e8                   mov    x,%gs
</span><span class=ln> 445</span><span class=s2>      movw    %ax, %ss                # -&gt; SS: Stack Segment
</span><span class=ln> 446</span><span class=s2>        7c3e:       8e d0                   mov    x,%ss
</span><span class=ln> 447</span><span class=s2>      
</span><span class=ln> 448</span><span class=s2>      # Set up the stack pointer and call into C.
</span><span class=ln> 449</span><span class=s2>      movl    $start, %esp
</span><span class=ln> 450</span><span class=s2>        7c40:       bc 00 7c 00 00          mov    $0x7c00,%esp
</span><span class=ln> 451</span><span class=s2>      call bootmain
</span><span class=ln> 452</span><span class=s2>        7c45:       e8 c0 00 00 00          call   7d0a &lt;bootmain&gt;
</span><span class=ln> 453</span><span class=s2>    
</span><span class=ln> 454</span><span class=s2>    00007c4a &lt;spin&gt;:
</span><span class=ln> 455</span><span class=s2>    
</span><span class=ln> 456</span><span class=s2>      # If bootmain returns (it shouldn&#39;t), loop.
</span><span class=ln> 457</span><span class=s2>    spin:
</span><span class=ln> 458</span><span class=s2>      jmp spin
</span><span class=ln> 459</span><span class=s2>        7c4a:       eb fe                   jmp    7c4a &lt;spin&gt;
</span><span class=ln> 460</span><span class=s2>    
</span><span class=ln> 461</span><span class=s2>    00007c4c &lt;gdt&gt;:
</span><span class=ln> 462</span><span class=s2>            ...
</span><span class=ln> 463</span><span class=s2>        7c54:       ff                      (bad)  
</span><span class=ln> 464</span><span class=s2>        7c55:       ff 00                   incl   (x)
</span><span class=ln> 465</span><span class=s2>        7c57:       00 00                   add    %al,(x)
</span><span class=ln> 466</span><span class=s2>        7c59:       9a cf 00 ff ff 00 00    lcall  $0x0,$0xffff00cf
</span><span class=ln> 467</span><span class=s2>        7c60:       00                      .byte 0x0
</span><span class=ln> 468</span><span class=s2>        7c61:       92                      xchg   x,x
</span><span class=ln> 469</span><span class=s2>        7c62:       cf                      iret   
</span><span class=ln> 470</span><span class=s2>            ...
</span><span class=ln> 471</span><span class=s2>    
</span><span class=ln> 472</span><span class=s2>    00007c64 &lt;gdtdesc&gt;:
</span><span class=ln> 473</span><span class=s2>        7c64:       17                      pop    %ss
</span><span class=ln> 474</span><span class=s2>        7c65:       00 4c 7c 00             add    %cl,0x0(%esp,i,2)
</span><span class=ln> 475</span><span class=s2>            ...
</span><span class=ln> 476</span><span class=s2>    
</span><span class=ln> 477</span><span class=s2>    00007c6a &lt;waitdisk&gt;:
</span><span class=ln> 478</span><span class=s2>            }
</span><span class=ln> 479</span><span class=s2>    }
</span><span class=ln> 480</span><span class=s2>    
</span><span class=ln> 481</span><span class=s2>    void
</span><span class=ln> 482</span><span class=s2>    waitdisk(void)
</span><span class=ln> 483</span><span class=s2>    {
</span><span class=ln> 484</span><span class=s2>        7c6a:       55                      push   p
</span><span class=ln> 485</span><span class=s2>    
</span><span class=ln> 486</span><span class=s2>    static inline uint8_t
</span><span class=ln> 487</span><span class=s2>    inb(int port)
</span><span class=ln> 488</span><span class=s2>    {
</span><span class=ln> 489</span><span class=s2>            uint8_t data;
</span><span class=ln> 490</span><span class=s2>            asm volatile(</span><span class=s2>&#34;</span><span class=n>inb</span><span class=w> </span><span class=o>%</span><span class=n>w1</span><span class=p>,</span><span class=o>%</span><span class=mi>0</span><span class=s2>&#34; : &#34;</span><span class=o>=</span><span class=n>a</span><span class=s2>&#34; (data) : &#34;</span><span class=n>d</span><span class=s2>&#34; (port));
</span><span class=ln> 491</span><span class=s2>        7c6b:       ba f7 01 00 00          mov    $0x1f7,x
</span><span class=ln> 492</span><span class=s2>        7c70:       89 e5                   mov    %esp,p
</span><span class=ln> 493</span><span class=s2>        7c72:       ec                      in     (%dx),%al
</span><span class=ln> 494</span><span class=s2>            // wait for disk reaady
</span><span class=ln> 495</span><span class=s2>            while ((inb(0x1F7) &amp; 0xC0) != 0x40)
</span><span class=ln> 496</span><span class=s2>        7c73:       83 e0 c0                and    $0xffffffc0,x
</span><span class=ln> 497</span><span class=s2>        7c76:       3c 40                   cmp    $0x40,%al
</span><span class=ln> 498</span><span class=s2>        7c78:       75 f8                   jne    7c72 &lt;waitdisk+0x8&gt;
</span><span class=ln> 499</span><span class=s2>                    /* do nothing */;
</span><span class=ln> 500</span><span class=s2>    }
</span><span class=ln> 501</span><span class=s2>        7c7a:       5d                      pop    p
</span><span class=ln> 502</span><span class=s2>        7c7b:       c3                      ret    
</span><span class=ln> 503</span><span class=s2>    
</span><span class=ln> 504</span><span class=s2>    00007c7c &lt;readsect&gt;:
</span><span class=ln> 505</span><span class=s2>    
</span><span class=ln> 506</span><span class=s2>    void
</span><span class=ln> 507</span><span class=s2>    readsect(void *dst, uint32_t offset)
</span><span class=ln> 508</span><span class=s2>    {
</span><span class=ln> 509</span><span class=s2>        7c7c:       55                      push   p
</span><span class=ln> 510</span><span class=s2>        7c7d:       89 e5                   mov    %esp,p
</span><span class=ln> 511</span><span class=s2>        7c7f:       57                      push   i
</span><span class=ln> 512</span><span class=s2>        7c80:       53                      push   x
</span><span class=ln> 513</span><span class=s2>        7c81:       8b 5d 0c                mov    0xc(p),x
</span><span class=ln> 514</span><span class=s2>            // wait for disk to be ready
</span><span class=ln> 515</span><span class=s2>            waitdisk();
</span><span class=ln> 516</span><span class=s2>        7c84:       e8 e1 ff ff ff          call   7c6a &lt;waitdisk&gt;
</span><span class=ln> 517</span><span class=s2>    }
</span><span class=ln> 518</span><span class=s2>    
</span><span class=ln> 519</span><span class=s2>    static inline void
</span><span class=ln> 520</span><span class=s2>    outb(int port, uint8_t data)
</span><span class=ln> 521</span><span class=s2>    {
</span><span class=ln> 522</span><span class=s2>            asm volatile(&#34;</span><span class=n>outb</span><span class=w> </span><span class=o>%</span><span class=mi>0</span><span class=p>,</span><span class=o>%</span><span class=n>w1</span><span class=s2>&#34; : : &#34;</span><span class=n>a</span><span class=s2>&#34; (data), &#34;</span><span class=n>d</span><span class=s2>&#34; (port));
</span><span class=ln> 523</span><span class=s2>        7c89:       ba f2 01 00 00          mov    $0x1f2,x
</span><span class=ln> 524</span><span class=s2>        7c8e:       b0 01                   mov    $0x1,%al
</span><span class=ln> 525</span><span class=s2>        7c90:       ee                      out    %al,(%dx)
</span><span class=ln> 526</span><span class=s2>        7c91:       0f b6 c3                movzbl %bl,x
</span><span class=ln> 527</span><span class=s2>        7c94:       b2 f3                   mov    $0xf3,%dl
</span><span class=ln> 528</span><span class=s2>        7c96:       ee                      out    %al,(%dx)
</span><span class=ln> 529</span><span class=s2>        7c97:       0f b6 c7                movzbl %bh,x
</span><span class=ln> 530</span><span class=s2>        7c9a:       b2 f4                   mov    $0xf4,%dl
</span><span class=ln> 531</span><span class=s2>        7c9c:       ee                      out    %al,(%dx)
</span><span class=ln> 532</span><span class=s2>    
</span><span class=ln> 533</span><span class=s2>            outb(0x1F2, 1);         // count = 1
</span><span class=ln> 534</span><span class=s2>            outb(0x1F3, offset);
</span><span class=ln> 535</span><span class=s2>            outb(0x1F4, offset &gt;&gt; 8);
</span><span class=ln> 536</span><span class=s2>            outb(0x1F5, offset &gt;&gt; 16);
</span><span class=ln> 537</span><span class=s2>        7c9d:       89 d8                   mov    x,x
</span><span class=ln> 538</span><span class=s2>        7c9f:       b2 f5                   mov    $0xf5,%dl
</span><span class=ln> 539</span><span class=s2>        7ca1:       c1 e8 10                shr    $0x10,x
</span><span class=ln> 540</span><span class=s2>        7ca4:       0f b6 c0                movzbl %al,x
</span><span class=ln> 541</span><span class=s2>        7ca7:       ee                      out    %al,(%dx)
</span><span class=ln> 542</span><span class=s2>            outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);
</span><span class=ln> 543</span><span class=s2>        7ca8:       c1 eb 18                shr    $0x18,x
</span><span class=ln> 544</span><span class=s2>        7cab:       b2 f6                   mov    $0xf6,%dl
</span><span class=ln> 545</span><span class=s2>        7cad:       88 d8                   mov    %bl,%al
</span><span class=ln> 546</span><span class=s2>        7caf:       83 c8 e0                or     $0xffffffe0,x
</span><span class=ln> 547</span><span class=s2>        7cb2:       ee                      out    %al,(%dx)
</span><span class=ln> 548</span><span class=s2>        7cb3:       b0 20                   mov    $0x20,%al
</span><span class=ln> 549</span><span class=s2>        7cb5:       b2 f7                   mov    $0xf7,%dl
</span><span class=ln> 550</span><span class=s2>        7cb7:       ee                      out    %al,(%dx)
</span><span class=ln> 551</span><span class=s2>            outb(0x1F7, 0x20);      // cmd 0x20 - read sectors
</span><span class=ln> 552</span><span class=s2>    
</span><span class=ln> 553</span><span class=s2>            // wait for disk to be ready
</span><span class=ln> 554</span><span class=s2>            waitdisk();
</span><span class=ln> 555</span><span class=s2>        7cb8:       e8 ad ff ff ff          call   7c6a &lt;waitdisk&gt;
</span><span class=ln> 556</span><span class=s2>    }
</span><span class=ln> 557</span><span class=s2>    
</span><span class=ln> 558</span><span class=s2>    static inline void
</span><span class=ln> 559</span><span class=s2>    insl(int port, void *addr, int cnt)
</span><span class=ln> 560</span><span class=s2>    {
</span><span class=ln> 561</span><span class=s2>            asm volatile(&#34;</span><span class=n>cld</span><span class=err>\</span><span class=n>n</span><span class=err>\</span><span class=n>trepne</span><span class=err>\</span><span class=n>n</span><span class=err>\</span><span class=n>tinsl</span><span class=s2>&#34;
</span><span class=ln> 562</span><span class=s2>        7cbd:       8b 7d 08                mov    0x8(p),i
</span><span class=ln> 563</span><span class=s2>        7cc0:       b9 80 00 00 00          mov    $0x80,x
</span><span class=ln> 564</span><span class=s2>        7cc5:       ba f0 01 00 00          mov    $0x1f0,x
</span><span class=ln> 565</span><span class=s2>        7cca:       fc                      cld    
</span><span class=ln> 566</span><span class=s2>        7ccb:       f2 6d                   repnz insl (%dx),%es:(i)
</span><span class=ln> 567</span><span class=s2>    
</span><span class=ln> 568</span><span class=s2>            // read a sector
</span><span class=ln> 569</span><span class=s2>            insl(0x1F0, dst, SECTSIZE/4);
</span><span class=ln> 570</span><span class=s2>    }
</span><span class=ln> 571</span><span class=s2>        7ccd:       5b                      pop    x
</span><span class=ln> 572</span><span class=s2>        7cce:       5f                      pop    i
</span><span class=ln> 573</span><span class=s2>        7ccf:       5d                      pop    p
</span><span class=ln> 574</span><span class=s2>        7cd0:       c3                      ret    
</span><span class=ln> 575</span><span class=s2>    
</span><span class=ln> 576</span><span class=s2>    00007cd1 &lt;readseg&gt;:
</span><span class=ln> 577</span><span class=s2>    
</span><span class=ln> 578</span><span class=s2>    // Read &#39;count&#39; bytes at &#39;offset&#39; from kernel into physical address &#39;pa&#39;.
</span><span class=ln> 579</span><span class=s2>    // Might copy more than asked
</span><span class=ln> 580</span><span class=s2>    void
</span><span class=ln> 581</span><span class=s2>    readseg(uint32_t pa, uint32_t count, uint32_t offset)
</span><span class=ln> 582</span><span class=s2>    {
</span><span class=ln> 583</span><span class=s2>        7cd1:       55                      push   p
</span><span class=ln> 584</span><span class=s2>        7cd2:       89 e5                   mov    %esp,p
</span><span class=ln> 585</span><span class=s2>        7cd4:       57                      push   i
</span><span class=ln> 586</span><span class=s2>            uint32_t end_pa;
</span><span class=ln> 587</span><span class=s2>    
</span><span class=ln> 588</span><span class=s2>            end_pa = pa + count;
</span><span class=ln> 589</span><span class=s2>        7cd5:       8b 7d 0c                mov    0xc(p),i
</span><span class=ln> 590</span><span class=s2>    
</span><span class=ln> 591</span><span class=s2>    // Read &#39;count&#39; bytes at &#39;offset&#39; from kernel into physical address &#39;pa&#39;.
</span><span class=ln> 592</span><span class=s2>    // Might copy more than asked
</span><span class=ln> 593</span><span class=s2>    void
</span><span class=ln> 594</span><span class=s2>    readseg(uint32_t pa, uint32_t count, uint32_t offset)
</span><span class=ln> 595</span><span class=s2>    {
</span><span class=ln> 596</span><span class=s2>        7cd8:       56                      push   %esi
</span><span class=ln> 597</span><span class=s2>        7cd9:       8b 75 10                mov    0x10(p),%esi
</span><span class=ln> 598</span><span class=s2>        7cdc:       53                      push   x
</span><span class=ln> 599</span><span class=s2>        7cdd:       8b 5d 08                mov    0x8(p),x
</span><span class=ln> 600</span><span class=s2>    
</span><span class=ln> 601</span><span class=s2>            // round down to sector boundary
</span><span class=ln> 602</span><span class=s2>            pa &amp;= ~(SECTSIZE - 1);
</span><span class=ln> 603</span><span class=s2>    
</span><span class=ln> 604</span><span class=s2>            // translate from bytes to sectors, and kernel starts at sector 1
</span><span class=ln> 605</span><span class=s2>            offset = (offset / SECTSIZE) + 1;
</span><span class=ln> 606</span><span class=s2>        7ce0:       c1 ee 09                shr    $0x9,%esi
</span><span class=ln> 607</span><span class=s2>    void
</span><span class=ln> 608</span><span class=s2>    readseg(uint32_t pa, uint32_t count, uint32_t offset)
</span><span class=ln> 609</span><span class=s2>    {
</span><span class=ln> 610</span><span class=s2>            uint32_t end_pa;
</span><span class=ln> 611</span><span class=s2>    
</span><span class=ln> 612</span><span class=s2>            end_pa = pa + count;
</span><span class=ln> 613</span><span class=s2>        7ce3:       01 df                   add    x,i
</span><span class=ln> 614</span><span class=s2>    
</span><span class=ln> 615</span><span class=s2>            // round down to sector boundary
</span><span class=ln> 616</span><span class=s2>            pa &amp;= ~(SECTSIZE - 1);
</span><span class=ln> 617</span><span class=s2>    
</span><span class=ln> 618</span><span class=s2>            // translate from bytes to sectors, and kernel starts at sector 1
</span><span class=ln> 619</span><span class=s2>            offset = (offset / SECTSIZE) + 1;
</span><span class=ln> 620</span><span class=s2>        7ce5:       46                      inc    %esi
</span><span class=ln> 621</span><span class=s2>            uint32_t end_pa;
</span><span class=ln> 622</span><span class=s2>    
</span><span class=ln> 623</span><span class=s2>            end_pa = pa + count;
</span><span class=ln> 624</span><span class=s2>    
</span><span class=ln> 625</span><span class=s2>            // round down to sector boundary
</span><span class=ln> 626</span><span class=s2>            pa &amp;= ~(SECTSIZE - 1);
</span><span class=ln> 627</span><span class=s2>        7ce6:       81 e3 00 fe ff ff       and    $0xfffffe00,x
</span><span class=ln> 628</span><span class=s2>            offset = (offset / SECTSIZE) + 1;
</span><span class=ln> 629</span><span class=s2>    
</span><span class=ln> 630</span><span class=s2>            // If this is too slow, we could read lots of sectors at a time.
</span><span class=ln> 631</span><span class=s2>            // We&#39;d write more to memory than asked, but it doesn&#39;t matter --
</span><span class=ln> 632</span><span class=s2>            // we load in increasing order.
</span><span class=ln> 633</span><span class=s2>            while (pa &lt; end_pa) {
</span><span class=ln> 634</span><span class=s2>        7cec:       39 fb                   cmp    i,x
</span><span class=ln> 635</span><span class=s2>        7cee:       73 12                   jae    7d02 &lt;readseg+0x31&gt;
</span><span class=ln> 636</span><span class=s2>                    // Since we haven&#39;t enabled paging yet and we&#39;re using
</span><span class=ln> 637</span><span class=s2>                    // an identity segment mapping (see boot.S), we can
</span><span class=ln> 638</span><span class=s2>                    // use physical addresses directly.  This won&#39;t be the
</span><span class=ln> 639</span><span class=s2>                    // case once JOS enables the MMU.
</span><span class=ln> 640</span><span class=s2>                    readsect((uint8_t*) pa, offset);
</span><span class=ln> 641</span><span class=s2>        7cf0:       56                      push   %esi
</span><span class=ln> 642</span><span class=s2>                    pa += SECTSIZE;
</span><span class=ln> 643</span><span class=s2>                    offset++;
</span><span class=ln> 644</span><span class=s2>        7cf1:       46                      inc    %esi
</span><span class=ln> 645</span><span class=s2>            while (pa &lt; end_pa) {
</span><span class=ln> 646</span><span class=s2>                    // Since we haven&#39;t enabled paging yet and we&#39;re using
</span><span class=ln> 647</span><span class=s2>                    // an identity segment mapping (see boot.S), we can
</span><span class=ln> 648</span><span class=s2>                    // use physical addresses directly.  This won&#39;t be the
</span><span class=ln> 649</span><span class=s2>                    // case once JOS enables the MMU.
</span><span class=ln> 650</span><span class=s2>                    readsect((uint8_t*) pa, offset);
</span><span class=ln> 651</span><span class=s2>        7cf2:       53                      push   x
</span><span class=ln> 652</span><span class=s2>                    pa += SECTSIZE;
</span><span class=ln> 653</span><span class=s2>        7cf3:       81 c3 00 02 00 00       add    $0x200,x
</span><span class=ln> 654</span><span class=s2>            while (pa &lt; end_pa) {
</span><span class=ln> 655</span><span class=s2>                    // Since we haven&#39;t enabled paging yet and we&#39;re using
</span><span class=ln> 656</span><span class=s2>                    // an identity segment mapping (see boot.S), we can
</span><span class=ln> 657</span><span class=s2>                    // use physical addresses directly.  This won&#39;t be the
</span><span class=ln> 658</span><span class=s2>                    // case once JOS enables the MMU.
</span><span class=ln> 659</span><span class=s2>                    readsect((uint8_t*) pa, offset);
</span><span class=ln> 660</span><span class=s2>        7cf9:       e8 7e ff ff ff          call   7c7c &lt;readsect&gt;
</span><span class=ln> 661</span><span class=s2>                    pa += SECTSIZE;
</span><span class=ln> 662</span><span class=s2>                    offset++;
</span><span class=ln> 663</span><span class=s2>        7cfe:       58                      pop    x
</span><span class=ln> 664</span><span class=s2>        7cff:       5a                      pop    x
</span><span class=ln> 665</span><span class=s2>        7d00:       eb ea                   jmp    7cec &lt;readseg+0x1b&gt;
</span><span class=ln> 666</span><span class=s2>            }
</span><span class=ln> 667</span><span class=s2>    }
</span><span class=ln> 668</span><span class=s2>        7d02:       8d 65 f4                lea    -0xc(p),%esp
</span><span class=ln> 669</span><span class=s2>        7d05:       5b                      pop    x
</span><span class=ln> 670</span><span class=s2>        7d06:       5e                      pop    %esi
</span><span class=ln> 671</span><span class=s2>        7d07:       5f                      pop    i
</span><span class=ln> 672</span><span class=s2>        7d08:       5d                      pop    p
</span><span class=ln> 673</span><span class=s2>        7d09:       c3                      ret    
</span><span class=ln> 674</span><span class=s2>    
</span><span class=ln> 675</span><span class=s2>    00007d0a &lt;bootmain&gt;:
</span><span class=ln> 676</span><span class=s2>    void readsect(void*, uint32_t);
</span><span class=ln> 677</span><span class=s2>    void readseg(uint32_t, uint32_t, uint32_t);
</span><span class=ln> 678</span><span class=s2>    
</span><span class=ln> 679</span><span class=s2>    void
</span><span class=ln> 680</span><span class=s2>    bootmain(void)
</span><span class=ln> 681</span><span class=s2>    {
</span><span class=ln> 682</span><span class=s2>        7d0a:       55                      push   p
</span><span class=ln> 683</span><span class=s2>        7d0b:       89 e5                   mov    %esp,p
</span><span class=ln> 684</span><span class=s2>        7d0d:       56                      push   %esi
</span><span class=ln> 685</span><span class=s2>        7d0e:       53                      push   x
</span><span class=ln> 686</span><span class=s2>            struct Proghdr *ph, *eph;
</span><span class=ln> 687</span><span class=s2>    
</span><span class=ln> 688</span><span class=s2>            // read 1st page off disk
</span><span class=ln> 689</span><span class=s2>            readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
</span><span class=ln> 690</span><span class=s2>        7d0f:       6a 00                   push   $0x0
</span><span class=ln> 691</span><span class=s2>        7d11:       68 00 10 00 00          push   $0x1000
</span><span class=ln> 692</span><span class=s2>        7d16:       68 00 00 01 00          push   $0x10000
</span><span class=ln> 693</span><span class=s2>        7d1b:       e8 b1 ff ff ff          call   7cd1 &lt;readseg&gt;
</span><span class=ln> 694</span><span class=s2>    
</span><span class=ln> 695</span><span class=s2>            // is this a valid ELF?
</span><span class=ln> 696</span><span class=s2>            if (ELFHDR-&gt;e_magic != ELF_MAGIC)
</span><span class=ln> 697</span><span class=s2>        7d20:       83 c4 0c                add    $0xc,%esp
</span><span class=ln> 698</span><span class=s2>        7d23:       81 3d 00 00 01 00 7f    cmpl   $0x464c457f,0x10000
</span><span class=ln> 699</span><span class=s2>        7d2a:       45 4c 46 
</span><span class=ln> 700</span><span class=s2>        7d2d:       75 38                   jne    7d67 &lt;bootmain+0x5d&gt;
</span><span class=ln> 701</span><span class=s2>                    goto bad;
</span><span class=ln> 702</span><span class=s2>    
</span><span class=ln> 703</span><span class=s2>            // load each program segment (ignores ph flags)
</span><span class=ln> 704</span><span class=s2>            ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
</span><span class=ln> 705</span><span class=s2>        7d2f:       a1 1c 00 01 00          mov    0x1001c,x
</span><span class=ln> 706</span><span class=s2>        7d34:       8d 98 00 00 01 00       lea    0x10000(x),x
</span><span class=ln> 707</span><span class=s2>            eph = ph + ELFHDR-&gt;e_phnum;
</span><span class=ln> 708</span><span class=s2>        7d3a:       0f b7 05 2c 00 01 00    movzwl 0x1002c,x
</span><span class=ln> 709</span><span class=s2>        7d41:       c1 e0 05                shl    $0x5,x
</span><span class=ln> 710</span><span class=s2>        7d44:       8d 34 03                lea    (x,x,1),%esi
</span><span class=ln> 711</span><span class=s2>            for (; ph &lt; eph; ph++)
</span><span class=ln> 712</span><span class=s2>        7d47:       39 f3                   cmp    %esi,x
</span><span class=ln> 713</span><span class=s2>        7d49:       73 16                   jae    7d61 &lt;bootmain+0x57&gt;
</span><span class=ln> 714</span><span class=s2>                    // p_pa is the load address of this segment (as well
</span><span class=ln> 715</span><span class=s2>                    // as the physical address)
</span><span class=ln> 716</span><span class=s2>                    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);
</span><span class=ln> 717</span><span class=s2>        7d4b:       ff 73 04                pushl  0x4(x)
</span><span class=ln> 718</span><span class=s2>                    goto bad;
</span><span class=ln> 719</span><span class=s2>    
</span><span class=ln> 720</span><span class=s2>            // load each program segment (ignores ph flags)
</span><span class=ln> 721</span><span class=s2>            ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
</span><span class=ln> 722</span><span class=s2>            eph = ph + ELFHDR-&gt;e_phnum;
</span><span class=ln> 723</span><span class=s2>            for (; ph &lt; eph; ph++)
</span><span class=ln> 724</span><span class=s2>        7d4e:       83 c3 20                add    $0x20,x
</span><span class=ln> 725</span><span class=s2>                    // p_pa is the load address of this segment (as well
</span><span class=ln> 726</span><span class=s2>                    // as the physical address)
</span><span class=ln> 727</span><span class=s2>                    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);
</span><span class=ln> 728</span><span class=s2>        7d51:       ff 73 f4                pushl  -0xc(x)
</span><span class=ln> 729</span><span class=s2>        7d54:       ff 73 ec                pushl  -0x14(x)
</span><span class=ln> 730</span><span class=s2>        7d57:       e8 75 ff ff ff          call   7cd1 &lt;readseg&gt;
</span><span class=ln> 731</span><span class=s2>                    goto bad;
</span><span class=ln> 732</span><span class=s2>    
</span><span class=ln> 733</span><span class=s2>            // load each program segment (ignores ph flags)
</span><span class=ln> 734</span><span class=s2>            ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
</span><span class=ln> 735</span><span class=s2>            eph = ph + ELFHDR-&gt;e_phnum;
</span><span class=ln> 736</span><span class=s2>            for (; ph &lt; eph; ph++)
</span><span class=ln> 737</span><span class=s2>        7d5c:       83 c4 0c                add    $0xc,%esp
</span><span class=ln> 738</span><span class=s2>        7d5f:       eb e6                   jmp    7d47 &lt;bootmain+0x3d&gt;
</span><span class=ln> 739</span><span class=s2>                    // as the physical address)
</span><span class=ln> 740</span><span class=s2>                    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);
</span><span class=ln> 741</span><span class=s2>    
</span><span class=ln> 742</span><span class=s2>            // call the entry point from the ELF header
</span><span class=ln> 743</span><span class=s2>            // note: does not return!
</span><span class=ln> 744</span><span class=s2>            ((void (*)(void)) (ELFHDR-&gt;e_entry))();
</span><span class=ln> 745</span><span class=s2>        7d61:       ff 15 18 00 01 00       call   *0x10018
</span><span class=ln> 746</span><span class=s2>    }
</span><span class=ln> 747</span><span class=s2>    
</span><span class=ln> 748</span><span class=s2>    static inline void
</span><span class=ln> 749</span><span class=s2>    outw(int port, uint16_t data)
</span><span class=ln> 750</span><span class=s2>    {
</span><span class=ln> 751</span><span class=s2>            asm volatile(</span><span class=s2>&#34;</span><span class=n>outw</span><span class=w> </span><span class=o>%</span><span class=mi>0</span><span class=p>,</span><span class=o>%</span><span class=n>w1</span><span class=s2>&#34; : : &#34;</span><span class=n>a</span><span class=s2>&#34; (data), &#34;</span><span class=n>d</span><span class=s2>&#34; (port));
</span><span class=ln> 752</span><span class=s2>        7d67:       ba 00 8a 00 00          mov    $0x8a00,x
</span><span class=ln> 753</span><span class=s2>        7d6c:       b8 00 8a ff ff          mov    $0xffff8a00,x
</span><span class=ln> 754</span><span class=s2>        7d71:       66 ef                   out    %ax,(%dx)
</span><span class=ln> 755</span><span class=s2>        7d73:       b8 00 8e ff ff          mov    $0xffff8e00,x
</span><span class=ln> 756</span><span class=s2>        7d78:       66 ef                   out    %ax,(%dx)
</span><span class=ln> 757</span><span class=s2>        7d7a:       eb fe                   jmp    7d7a &lt;bootmain+0x70&gt;
</span><span class=ln> 758</span><span class=s2>    
</span><span class=ln> 759</span><span class=s2>
</span><span class=ln> 760</span><span class=s2>
</span><span class=ln> 761</span><span class=s2>
</span><span class=ln> 762</span><span class=s2>
</span><span class=ln> 763</span><span class=s2>可以看到，上面的代码是从0x7c00开始执行的，而用gdb调试发现BIOS执行的第一条指令的位置其实是在0xf000:0xfff0　　那么问题来了...CS段是什么时候从0xf000到0的呢？　在0x7c00之前，BIOS是在做什么呢？
</span><span class=ln> 764</span><span class=s2>
</span><span class=ln> 765</span><span class=s2>我们用gdb看一下这一部分的代码:
</span><span class=ln> 766</span><span class=s2>
</span><span class=ln> 767</span><span class=s2>    
</span><span class=ln> 768</span><span class=s2>    [f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b
</span><span class=ln> 769</span><span class=s2>    [f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8
</span><span class=ln> 770</span><span class=s2>    [f000:e062]    0xfe062: jne    0xfd2e1
</span><span class=ln> 771</span><span class=s2>    [f000:e066]    0xfe066: xor    %dx,%dx
</span><span class=ln> 772</span><span class=s2>    [f000:e068]    0xfe068: mov    %dx,%ss
</span><span class=ln> 773</span><span class=s2>    [f000:e06a]    0xfe06a: mov    $0x7000,%esp
</span><span class=ln> 774</span><span class=s2>    [f000:e070]    0xfe070: mov    $0xf34c2,x
</span><span class=ln> 775</span><span class=s2>    [f000:e076]    0xfe076: jmp    0xfd15c
</span><span class=ln> 776</span><span class=s2>    [f000:d15c]    0xfd15c: mov    x,x
</span><span class=ln> 777</span><span class=s2>    [f000:d15f]    0xfd15f: cli  
</span><span class=ln> 778</span><span class=s2>    [f000:d160]    0xfd160: cld 
</span><span class=ln> 779</span><span class=s2>    [f000:d161]    0xfd161: mov    $0x8f,x
</span><span class=ln> 780</span><span class=s2>    [f000:d167]    0xfd167: out    %al,$0x70
</span><span class=ln> 781</span><span class=s2>    [f000:d169]    0xfd169: in     $0x71,%al
</span><span class=ln> 782</span><span class=s2>    [f000:d16b]    0xfd16b: in     $0x92,%al
</span><span class=ln> 783</span><span class=s2>    [f000:d16d]    0xfd16d: or     $0x2,%al
</span><span class=ln> 784</span><span class=s2>    [f000:d16f]    0xfd16f: out    %al,$0x92
</span><span class=ln> 785</span><span class=s2>    [f000:d171]    0xfd171: lidtw  %cs:0x6ab8
</span><span class=ln> 786</span><span class=s2>    [f000:d177]    0xfd177: lgdtw  %cs:0x6a74
</span><span class=ln> 787</span><span class=s2>    [f000:d17d]    0xfd17d: mov    %cr0,x
</span><span class=ln> 788</span><span class=s2>    [f000:d180]    0xfd180: or     $0x1,x
</span><span class=ln> 789</span><span class=s2>    [f000:d184]    0xfd184: mov    x,%cr0
</span><span class=ln> 790</span><span class=s2>    [f000:d187]    0xfd187: ljmpl  $0x8,$0xfd18f
</span><span class=ln> 791</span><span class=s2>    
</span><span class=ln> 792</span><span class=s2>    The target architecture is assumed to be i386
</span><span class=ln> 793</span><span class=s2>    0xfd18f:     mov    $0x10,x
</span><span class=ln> 794</span><span class=s2>    0xfd194:     mov    x,%ds
</span><span class=ln> 795</span><span class=s2>    0xfd196:     mov    x,%es
</span><span class=ln> 796</span><span class=s2>    0xfd198:     mov    x,%ss
</span><span class=ln> 797</span><span class=s2>    0xfd19a:     mov    x,%fs
</span><span class=ln> 798</span><span class=s2>    0xfd19c:     mov    x,%gs
</span><span class=ln> 799</span><span class=s2>    0xfd19e:     mov    x,x
</span><span class=ln> 800</span><span class=s2>    0xfd1a0:     jmp    *x
</span><span class=ln> 801</span><span class=s2>    0xf34c2:     push   x
</span><span class=ln> 802</span><span class=s2>    0xf34c3:     sub    $0x2c,%esp
</span><span class=ln> 803</span><span class=s2>    0xf34c6:     movl   $0xf5b5c,0x4(%esp)
</span><span class=ln> 804</span><span class=s2>    0xf34ce:     movl   $0xf447b,(%esp)
</span><span class=ln> 805</span><span class=s2>    0xf34d5:     call   0xf099e
</span><span class=ln> 806</span><span class=s2>    0xf099e:     lea    0x8(%esp),x
</span><span class=ln> 807</span><span class=s2>    0xf09a2:     mov    0x4(%esp),x
</span><span class=ln> 808</span><span class=s2>    0xf09a6:     mov    $0xf5b58,x
</span><span class=ln> 809</span><span class=s2>    0xf09ab:     call   0xf0574
</span><span class=ln> 810</span><span class=s2>    0xf0574:     push   p
</span><span class=ln> 811</span><span class=s2>    0xf0575:     push   i
</span><span class=ln> 812</span><span class=s2>    0xf0576:     push   %esi
</span><span class=ln> 813</span><span class=s2>    0xf0577:     push   x
</span><span class=ln> 814</span><span class=s2>    0xf0578:     sub    $0xc,%esp
</span><span class=ln> 815</span><span class=s2>    0xf057b:     mov    x,0x4(%esp)
</span><span class=ln> 816</span><span class=s2>    0xf057f:     mov    x,p
</span><span class=ln> 817</span><span class=s2>    0xf0581:     mov    x,%esi
</span><span class=ln> 818</span><span class=s2>    0xf0583:     movsbl 0x0(p),x
</span><span class=ln> 819</span><span class=s2>    0xf0587:     test   %dl,%dl
</span><span class=ln> 820</span><span class=s2>    0xf0589:     je     0xf0758
</span><span class=ln> 821</span><span class=s2>    0xf058f:     cmp    $0x25,%dl
</span><span class=ln> 822</span><span class=s2>    0xf0592:     jne    0xf0741
</span><span class=ln> 823</span><span class=s2>    0xf0741:     mov    0x4(%esp),x
</span><span class=ln> 824</span><span class=s2>    
</span><span class=ln> 825</span><span class=s2>    
</span><span class=ln> 826</span><span class=s2>    
</span><span class=ln> 827</span><span class=s2>    
</span><span class=ln> 828</span><span class=s2>    
</span><span class=ln> 829</span><span class=s2>
</span><span class=ln> 830</span><span class=s2>
</span><span class=ln> 831</span><span class=s2>其中的lidtw是加载向量描述表(load interrupt descriptor table), lgdtw是加载全局描述表(global descriptor table,GDT) 可以参考[ LGDT/LIDT -- Load Global/Interrupt Descriptor Table Register](https://www.fermimn.edu.it/linux/quarta/x86/lgdt.htm)
</span><span class=ln> 832</span><span class=s2>
</span><span class=ln> 833</span><span class=s2>第16,17行的0x70,0x71可以参考[CMOS#Accessing_CMOS_Registers](https://wiki.osdev.org/CMOS#Accessing_CMOS_Registers)，虽然我觉得这太细节了，不看也罢。
</span><span class=ln> 834</span><span class=s2>
</span><span class=ln> 835</span><span class=s2>18-20行的内容，是快速enbale A20的方法，可以参考[A20_Line ](https://wiki.osdev.org/A20_Line)
</span><span class=ln> 836</span><span class=s2>
</span><span class=ln> 837</span><span class=s2>然后第21-26行...似曾相识啊..这不就是启动protected mode的步骤吗...
</span><span class=ln> 838</span><span class=s2>
</span><span class=ln> 839</span><span class=s2>可是这还没有加载boot loader啊..怎么就进入protected mode了呢。。参考[bootloader - switching processor to protected mode](https://stackoverflow.com/questions/5211541/bootloader-switching-processor-to-protected-mode)，发现有些BIOS在实现的时候，会在加载boot loader之前，先短暂进入保护模式，目的可能是为了使用在保护模式下的一些特性(比如32-bit的register)，然后在进入bootloader之前，再切换回实模式。 以及据某6.828学习群大佬说...在进入boot loader之前进入保护模式的方法和boot loader中进入保护模式的方法是不一样的...进入保护模式的方法一共有四种... 感觉太过细节，暂且不去关心了。
</span><span class=ln> 840</span><span class=s2>
</span><span class=ln> 841</span><span class=s2>第26行之后的代码...抱歉我也不是很懂...看起来无关紧要，如果之后发现这段是重要的再说。
</span><span class=ln> 842</span><span class=s2>
</span><span class=ln> 843</span><span class=s2>来回答一下几个问题吧。
</span><span class=ln> 844</span><span class=s2>
</span><span class=ln> 845</span><span class=s2>
</span><span class=ln> 846</span><span class=s2>&lt;blockquote&gt;
</span><span class=ln> 847</span><span class=s2>
</span><span class=ln> 848</span><span class=s2>&gt; 
</span><span class=ln> 849</span><span class=s2>&gt; 
</span><span class=ln> 850</span><span class=s2> 	  * At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?
</span><span class=ln> 851</span><span class=s2>
</span><span class=ln> 852</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln> 853</span><span class=s2>
</span><span class=ln> 854</span><span class=s2>
</span><span class=ln> 855</span><span class=s2>开始执行32-bit code是从位置0x7c32,执行的命令为mov    $0x10,%ax
</span><span class=ln> 856</span><span class=s2>从16-bit mode转化到32-bit mode是将control register 0 的 第1位(PE)设置为1导致的。
</span><span class=ln> 857</span><span class=s2>
</span><span class=ln> 858</span><span class=s2>
</span><span class=ln> 859</span><span class=s2>&lt;blockquote&gt;
</span><span class=ln> 860</span><span class=s2>
</span><span class=ln> 861</span><span class=s2>&gt; 
</span><span class=ln> 862</span><span class=s2>&gt; 
</span><span class=ln> 863</span><span class=s2> 	  * What is the _last_ instruction of the boot loader executed, and what is the _first_ instruction of the kernel it just loaded?
</span><span class=ln> 864</span><span class=s2>
</span><span class=ln> 865</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln> 866</span><span class=s2>
</span><span class=ln> 867</span><span class=s2>
</span><span class=ln> 868</span><span class=s2>boot loader执行的最后一条指令是0x7d61:      call   *0x10018  ,对应的c语言代码是 ((void (*)(void)) (ELFHDR-&gt;e_entry))();   kernel加载后执行的第一条指令为 movw   $0x1234,0x472
</span><span class=ln> 869</span><span class=s2>
</span><span class=ln> 870</span><span class=s2>
</span><span class=ln> 871</span><span class=s2>
</span><span class=ln> 872</span><span class=s2>&lt;blockquote&gt;
</span><span class=ln> 873</span><span class=s2>
</span><span class=ln> 874</span><span class=s2>&gt; 
</span><span class=ln> 875</span><span class=s2>&gt; 
</span><span class=ln> 876</span><span class=s2> 	  * _Where_ is the first instruction of the kernel?
</span><span class=ln> 877</span><span class=s2>
</span><span class=ln> 878</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln> 879</span><span class=s2>
</span><span class=ln> 880</span><span class=s2>
</span><span class=ln> 881</span><span class=s2>kernel的第一条指令的地址为0x10000c
</span><span class=ln> 882</span><span class=s2>
</span><span class=ln> 883</span><span class=s2>
</span><span class=ln> 884</span><span class=s2>&lt;blockquote&gt;
</span><span class=ln> 885</span><span class=s2>
</span><span class=ln> 886</span><span class=s2>&gt; 
</span><span class=ln> 887</span><span class=s2>&gt; 
</span><span class=ln> 888</span><span class=s2> 	  * How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?
</span><span class=ln> 889</span><span class=s2>
</span><span class=ln> 890</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln> 891</span><span class=s2>
</span><span class=ln> 892</span><span class=s2>
</span><span class=ln> 893</span><span class=s2>boot loader先读一小部分kernel，具体来说是8个sector，也就是1 page,对应的代码为 readseg((uint32_t) ELFHDR, SECTSIZE*8, 0); 然后读进来的这部分里面包含了整个kernel有多大的信息，这些信息存储在inc/elf.h文件中。
</span><span class=ln> 894</span><span class=s2>
</span><span class=ln> 895</span><span class=s2>
</span><span class=ln> 896</span><span class=s2>### Loading the Kernel
</span><span class=ln> 897</span><span class=s2>
</span><span class=ln> 898</span><span class=s2>
</span><span class=ln> 899</span><span class=s2>练习4提到了要熟悉c语言的指针..去看了下推荐的&#34;</span><span class=n>_The</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=n>Programming</span><span class=w> </span><span class=n>Language_</span><span class=w> </span><span class=s2>&#34;..发现真是一本非常棒的入门书...之前还以为是像《算法导论》一样只可远观的大部头...可惜已经不适初学者了... 练习4中给出了一段使用c语言指针的代码，第5个输出要注意一下大小端...
</span><span class=ln> 900</span><span class=s2>
</span><span class=ln> 901</span><span class=s2>    
</span><span class=ln> 902</span><span class=s2>    #include &lt;stdio.h&gt;
</span><span class=ln> 903</span><span class=s2>    #include &lt;stdlib.h&gt;
</span><span class=ln> 904</span><span class=s2>    
</span><span class=ln> 905</span><span class=s2>    void
</span><span class=ln> 906</span><span class=s2>    f(void)
</span><span class=ln> 907</span><span class=s2>    {
</span><span class=ln> 908</span><span class=s2>        int a[4];
</span><span class=ln> 909</span><span class=s2>        int *b = malloc(16);
</span><span class=ln> 910</span><span class=s2>        int *c;
</span><span class=ln> 911</span><span class=s2>        int i;
</span><span class=ln> 912</span><span class=s2>    
</span><span class=ln> 913</span><span class=s2>        printf(&#34;</span><span class=mi>1</span><span class=p>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>p</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;, a, b, c);
</span><span class=ln> 914</span><span class=s2>    
</span><span class=ln> 915</span><span class=s2>        c = a;
</span><span class=ln> 916</span><span class=s2>        for (i = 0; i &lt; 4; i++)
</span><span class=ln> 917</span><span class=s2>    	a[i] = 100 + i;
</span><span class=ln> 918</span><span class=s2>        c[0] = 200;
</span><span class=ln> 919</span><span class=s2>        printf(&#34;</span><span class=mi>2</span><span class=p>:</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;,
</span><span class=ln> 920</span><span class=s2>    	   a[0], a[1], a[2], a[3]);
</span><span class=ln> 921</span><span class=s2>    
</span><span class=ln> 922</span><span class=s2>        c[1] = 300;
</span><span class=ln> 923</span><span class=s2>        *(c + 2) = 301;
</span><span class=ln> 924</span><span class=s2>        3[c] = 302;
</span><span class=ln> 925</span><span class=s2>        printf(&#34;</span><span class=mi>3</span><span class=p>:</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;,
</span><span class=ln> 926</span><span class=s2>    	   a[0], a[1], a[2], a[3]);
</span><span class=ln> 927</span><span class=s2>    
</span><span class=ln> 928</span><span class=s2>        c = c + 1;
</span><span class=ln> 929</span><span class=s2>        *c = 400;
</span><span class=ln> 930</span><span class=s2>        printf(&#34;</span><span class=mi>4</span><span class=p>:</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;,
</span><span class=ln> 931</span><span class=s2>    	   a[0], a[1], a[2], a[3]);
</span><span class=ln> 932</span><span class=s2>    
</span><span class=ln> 933</span><span class=s2>        c = (int *) ((char *) c + 1);
</span><span class=ln> 934</span><span class=s2>        *c = 500;
</span><span class=ln> 935</span><span class=s2>        printf(&#34;</span><span class=mi>5</span><span class=p>:</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;,
</span><span class=ln> 936</span><span class=s2>    	   a[0], a[1], a[2], a[3]);
</span><span class=ln> 937</span><span class=s2>    
</span><span class=ln> 938</span><span class=s2>        b = (int *) a + 1;
</span><span class=ln> 939</span><span class=s2>        c = (int *) ((char *) a + 1);
</span><span class=ln> 940</span><span class=s2>        printf(&#34;</span><span class=mi>6</span><span class=p>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>%</span><span class=n>p</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;, a, b, c);
</span><span class=ln> 941</span><span class=s2>    }
</span><span class=ln> 942</span><span class=s2>    
</span><span class=ln> 943</span><span class=s2>    int
</span><span class=ln> 944</span><span class=s2>    main(int ac, char **av)
</span><span class=ln> 945</span><span class=s2>    {
</span><span class=ln> 946</span><span class=s2>        f();
</span><span class=ln> 947</span><span class=s2>        return 0;
</span><span class=ln> 948</span><span class=s2>    }
</span><span class=ln> 949</span><span class=s2>    
</span><span class=ln> 950</span><span class=s2>
</span><span class=ln> 951</span><span class=s2>
</span><span class=ln> 952</span><span class=s2>
</span><span class=ln> 953</span><span class=s2>
</span><span class=ln> 954</span><span class=s2>在继续之前，需要仔细看一下elf文件的内容[ELF](https://wiki.osdev.org/ELF)
</span><span class=ln> 955</span><span class=s2>
</span><span class=ln> 956</span><span class=s2>
</span><span class=ln> 957</span><span class=s2>### ELF文件
</span><span class=ln> 958</span><span class=s2>
</span><span class=ln> 959</span><span class=s2>
</span><span class=ln> 960</span><span class=s2>elf文件分成了很多个section,通常.data section存放初始化的global/static variable,.text 存放代码，.rodata section 用来存放字符串常量，.bss section用来存放未初始化的global/static variabel.  .bss section没有对应的变量内容，原因是未初始化的变量按照规定会默认为0，因此没必要再存一次。“Thus there is no need to store contents for .bss in the ELF binary; instead, the linker records just the address and size of the .bss section. The loader or the program itself must arrange to zero the.bss section.”
</span><span class=ln> 961</span><span class=s2>
</span><span class=ln> 962</span><span class=s2>我们比较关心的是.data section, .text section, .rodata section
</span><span class=ln> 963</span><span class=s2>
</span><span class=ln> 964</span><span class=s2>我们可以用 objdump -h 命令查看一个ELF文件的 section header,
</span><span class=ln> 965</span><span class=s2>
</span><span class=ln> 966</span><span class=s2>    
</span><span class=ln> 967</span><span class=s2>    objdump -h obj/kern/kernel
</span><span class=ln> 968</span><span class=s2>    
</span><span class=ln> 969</span><span class=s2>    obj/kern/kernel:     file format elf32-i386
</span><span class=ln> 970</span><span class=s2>    
</span><span class=ln> 971</span><span class=s2>    Sections:
</span><span class=ln> 972</span><span class=s2>    Idx Name          Size      VMA       LMA       File off  Algn
</span><span class=ln> 973</span><span class=s2>      0 .text         00001917  f0100000  00100000  00001000  2**4
</span><span class=ln> 974</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, CODE
</span><span class=ln> 975</span><span class=s2>      1 .rodata       00000714  f0101920  00101920  00002920  2**5
</span><span class=ln> 976</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class=ln> 977</span><span class=s2>      2 .stab         00003889  f0102034  00102034  00003034  2**2
</span><span class=ln> 978</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class=ln> 979</span><span class=s2>      3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0
</span><span class=ln> 980</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class=ln> 981</span><span class=s2>      4 .data         0000a300  f0108000  00108000  00009000  2**12
</span><span class=ln> 982</span><span class=s2>                      CONTENTS, ALLOC, LOAD, DATA
</span><span class=ln> 983</span><span class=s2>      5 .bss          00000648  f0112300  00112300  00013300  2**5
</span><span class=ln> 984</span><span class=s2>                      CONTENTS, ALLOC, LOAD, DATA
</span><span class=ln> 985</span><span class=s2>      6 .comment      00000023  00000000  00000000  00013948  2**0
</span><span class=ln> 986</span><span class=s2>                      CONTENTS, READONLY
</span><span class=ln> 987</span><span class=s2>
</span><span class=ln> 988</span><span class=s2>
</span><span class=ln> 989</span><span class=s2>
</span><span class=ln> 990</span><span class=s2>
</span><span class=ln> 991</span><span class=s2>其中size是这个section的大小，VMA (Virtual Memory Address，6.828中叫link address) 是section开始执行时所在的memory address,LMA (Load Memory Address)是这个section被加载到memory中所处的位置。通常这两个地址是一样的。
</span><span class=ln> 992</span><span class=s2>
</span><span class=ln> 993</span><span class=s2>boot loader使用elf文件中的program header来决定如何记载section, program header指明了ELF文件的哪一部分需要记载到memory中，以及加载到memory的什么位置。我们可以用bjdump -x obj/kern/kernel查看ELF的全部header文件
</span><span class=ln> 994</span><span class=s2>
</span><span class=ln> 995</span><span class=s2>
</span><span class=ln> 996</span><span class=s2>&lt;blockquote&gt;练习5 Trace through the first few instructions of the boot loader again and identify the first instruction that would &#34;</span><span class=n>break</span><span class=s2>&#34; or otherwise do the wrong thing if you were to get the boot loader&#39;s link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don&#39;t forget to change the link address back and make clean again afterward!&lt;/blockquote&gt;
</span><span class=ln> 997</span><span class=s2>
</span><span class=ln> 998</span><span class=s2>
</span><span class=ln> 999</span><span class=s2>把boot loader的link address从0x7c00改成了0x9c00... 然后进入gdb单步调试。
</span><span class=ln>1000</span><span class=s2>
</span><span class=ln>1001</span><span class=s2>发现lgdtw的参数出现了负数 [ 0:7c1e] =&gt; 0x7c1e: lgdtw -0x639c  ，然后继续执行，到[ 0:7c2d] =&gt; 0x7c2d: ljmp $0x8,$0x9c32  ,发生了crash.
</span><span class=ln>1002</span><span class=s2>
</span><span class=ln>1003</span><span class=s2>我们观察到生成的boot.asm文件，地址确实是从0x9c00开始了。
</span><span class=ln>1004</span><span class=s2>
</span><span class=ln>1005</span><span class=s2>    
</span><span class=ln>1006</span><span class=s2>    protcseg:
</span><span class=ln>1007</span><span class=s2>      # Set up the protected-mode data segment registers
</span><span class=ln>1008</span><span class=s2>      movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
</span><span class=ln>1009</span><span class=s2>        9c32:       66 b8 10 00             mov    $0x10,%ax
</span><span class=ln>1010</span><span class=s2>      movw    %ax, %ds                # -&gt; DS: Data Segment
</span><span class=ln>1011</span><span class=s2>        9c36:       8e d8                   mov    x,%ds
</span><span class=ln>1012</span><span class=s2>      movw    %ax, %es                # -&gt; ES: Extra Segment
</span><span class=ln>1013</span><span class=s2>        9c38:       8e c0                   mov    x,%es
</span><span class=ln>1014</span><span class=s2>      movw    %ax, %fs                # -&gt; FS
</span><span class=ln>1015</span><span class=s2>        9c3a:       8e e0                   mov    x,%fs
</span><span class=ln>1016</span><span class=s2>      movw    %ax, %gs                # -&gt; GS
</span><span class=ln>1017</span><span class=s2>        9c3c:       8e e8                   mov    x,%gs
</span><span class=ln>1018</span><span class=s2>      movw    %ax, %ss                # -&gt; SS: Stack Segment
</span><span class=ln>1019</span><span class=s2>        9c3e:       8e d0                   mov    x,%ss
</span><span class=ln>1020</span><span class=s2>    
</span><span class=ln>1021</span><span class=s2>      # Set up the stack pointer and call into C.
</span><span class=ln>1022</span><span class=s2>      movl    $start, %esp
</span><span class=ln>1023</span><span class=s2>        9c40:       bc 00 9c 00 00          mov    $0x9c00,%esp
</span><span class=ln>1024</span><span class=s2>      call bootmain
</span><span class=ln>1025</span><span class=s2>        9c45:       e8 c0 00 00 00          call   9d0a &lt;bootmain&gt;
</span><span class=ln>1026</span><span class=s2>    
</span><span class=ln>1027</span><span class=s2>    00009c4a &lt;spin&gt;:
</span><span class=ln>1028</span><span class=s2>    
</span><span class=ln>1029</span><span class=s2>      # If bootmain returns (it shouldn&#39;t), loop.
</span><span class=ln>1030</span><span class=s2>    spin:
</span><span class=ln>1031</span><span class=s2>      jmp spin
</span><span class=ln>1032</span><span class=s2>        9c4a:       eb fe                   jmp    9c4a &lt;spin&gt;
</span><span class=ln>1033</span><span class=s2>
</span><span class=ln>1034</span><span class=s2>
</span><span class=ln>1035</span><span class=s2>但是实际上。。BIOS仍然把boot loader记载到了0x7c00....这是约定俗成吗？ BIOS无视Boot loader的link address，直接加载到0x7c00?   没有找到相关资料，有待进一步探寻。
</span><span class=ln>1036</span><span class=s2>
</span><span class=ln>1037</span><span class=s2>
</span><span class=ln>1038</span><span class=s2>&lt;blockquote&gt;练习6 Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)&lt;/blockquote&gt;
</span><span class=ln>1039</span><span class=s2>
</span><span class=ln>1040</span><span class=s2>
</span><span class=ln>1041</span><span class=s2>这个问题是问，BIOS进入boot loader时（也就是在0x7c00时）和boot loader进入kernel时(0x10000c)，地址0x00100000开始的8个word单位的值，为什么不同。
</span><span class=ln>1042</span><span class=s2>
</span><span class=ln>1043</span><span class=s2>0x7c00时，0x00100000处的8个word的值都为0...
</span><span class=ln>1044</span><span class=s2>
</span><span class=ln>1045</span><span class=s2>在0x10000c时，0x00100000处的值翻译成指令之后是：
</span><span class=ln>1046</span><span class=s2>
</span><span class=ln>1047</span><span class=s2>    
</span><span class=ln>1048</span><span class=s2>    0x100000:    add    0x1bad(x),%dh                                                                                                                                    │·······································
</span><span class=ln>1049</span><span class=s2>       0x100006:    add    %al,(x)                                                                                                                                          │·······································
</span><span class=ln>1050</span><span class=s2>       0x100008:    decb   0x52(i)                                                                                                                                          │·······································
</span><span class=ln>1051</span><span class=s2>       0x10000b:    in     $0x66,%al                                                                                                                                           │·······································
</span><span class=ln>1052</span><span class=s2>       0x10000d:    movl   $0xb81234,0x472                                                                                                                                     │·······································
</span><span class=ln>1053</span><span class=s2>       0x100017:    add    %dl,(x)                                                                                                                                          │·······································
</span><span class=ln>1054</span><span class=s2>       0x100019:    add    %cl,(i)                                                                                                                                          │·······································
</span><span class=ln>1055</span><span class=s2>       0x10001b:    and    %al,%bl
</span><span class=ln>1056</span><span class=s2>
</span><span class=ln>1057</span><span class=s2>
</span><span class=ln>1058</span><span class=s2>不一样的原因是，在刚刚进入boot loader时，kernel还没有加载进内存，因此是空的.
</span><span class=ln>1059</span><span class=s2>
</span><span class=ln>1060</span><span class=s2>
</span><span class=ln>1061</span><span class=s2>## Part 3: The Kernel
</span><span class=ln>1062</span><span class=s2>
</span><span class=ln>1063</span><span class=s2>
</span><span class=ln>1064</span><span class=s2>
</span><span class=ln>1065</span><span class=s2>
</span><span class=ln>1066</span><span class=s2>### Using virtual memory to work around position dependence
</span><span class=ln>1067</span><span class=s2>
</span><span class=ln>1068</span><span class=s2>
</span><span class=ln>1069</span><span class=s2>OS的kernel通常喜欢运行再较高地址的虚拟内存中，比如0xf0100000，为的是低地址留给用户程序。但是有的机器可能没有那么大的memory，因此不存在0xf0100000这个物理地址。因此这里需要做一个虚拟内存到物理内存的映射。在这个部分实验中，我们不需要至少地址映射是如何work的，只需要知道效果就好。
</span><span class=ln>1070</span><span class=s2>
</span><span class=ln>1071</span><span class=s2>具体来说，当CR0_PG被置为1之前，内存地址为物理内存地址(严格地说，其实是线性地址，不过在boot/boot.S中做了线性地址到物理地址的等价映射），当CRO_PG flag被置为1之后，地址就变成了虚拟内存地址。我们可以用gdb调试看一下发生了什么。
</span><span class=ln>1072</span><span class=s2>
</span><span class=ln>1073</span><span class=s2>
</span><span class=ln>1074</span><span class=s2>&lt;blockquote&gt;Exercise 7.  Use QEMU and GDB to trace into the JOS kernel and stop at the `movl x, %cr0`. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.
</span><span class=ln>1075</span><span class=s2>
</span><span class=ln>1076</span><span class=s2>What is the first instruction _after_ the new mapping is established that would fail to work properly if the mapping weren&#39;t in place? Comment out the `movl x, %cr0` in kern/entry.S, trace into it, and see if you were right.&lt;/blockquote&gt;
</span><span class=ln>1077</span><span class=s2>
</span><span class=ln>1078</span><span class=s2>
</span><span class=ln>1079</span><span class=s2>先用b *0x10000c处设置断点，这个是JOS kernel开始运行的地址。然后单步几步，在movl x , %cr0处停留，也就是cr0_PG flag恰好也被制为1之前。观察一下0x00100000和0xf0100000的内容:
</span><span class=ln>1080</span><span class=s2>
</span><span class=ln>1081</span><span class=s2>    
</span><span class=ln>1082</span><span class=s2>    (gdb) x/8x 0xf0100000                                                                                                 
</span><span class=ln>1083</span><span class=s2>    0xf0100000 &lt;_start+4026531828&gt;: 0x00000000      0x00000000      0x00000000      0x00000000                                                                                 
</span><span class=ln>1084</span><span class=s2>    0xf0100010 &lt;entry+4&gt;:   0x00000000      0x00000000      0x00000000      0x00000000 
</span><span class=ln>1085</span><span class=s2>    
</span><span class=ln>1086</span><span class=s2>    x/8i 0x00100000                                                                                                                                                      │·······································
</span><span class=ln>1087</span><span class=s2>       0x100000:    add    0x1bad(x),%dh                                                                                                                                    │·······································
</span><span class=ln>1088</span><span class=s2>       0x100006:    add    %al,(x)                                                                                                                                          │·······································
</span><span class=ln>1089</span><span class=s2>       0x100008:    decb   0x52(i)                                                                                                                                          │·······································
</span><span class=ln>1090</span><span class=s2>       0x10000b:    in     $0x66,%al                                                                                                                                           │·······································
</span><span class=ln>1091</span><span class=s2>       0x10000d:    movl   $0xb81234,0x472                                                                                                                                     │·······································
</span><span class=ln>1092</span><span class=s2>       0x100017:    add    %dl,(x)                                                                                                                                          │·······································
</span><span class=ln>1093</span><span class=s2>       0x100019:    add    %cl,(i)                                                                                                                                          │·······································
</span><span class=ln>1094</span><span class=s2>       0x10001b:    and    %al,%bl
</span><span class=ln>1095</span><span class=s2>
</span><span class=ln>1096</span><span class=s2>
</span><span class=ln>1097</span><span class=s2>
</span><span class=ln>1098</span><span class=s2>
</span><span class=ln>1099</span><span class=s2>然后接着单步一次，再次用x/8i观察8条0x00100000和0xf0100000处的内容
</span><span class=ln>1100</span><span class=s2>
</span><span class=ln>1101</span><span class=s2>    
</span><span class=ln>1102</span><span class=s2>    (gdb) x/8i 0x00100000                                                                                                                                                      │·······································
</span><span class=ln>1103</span><span class=s2>       0x100000:    add    0x1bad(x),%dh                                                                                                                                    │·······································
</span><span class=ln>1104</span><span class=s2>       0x100006:    add    %al,(x)                                                                                                                                          │·······································
</span><span class=ln>1105</span><span class=s2>       0x100008:    decb   0x52(i)                                                                                                                                          │·······································
</span><span class=ln>1106</span><span class=s2>       0x10000b:    in     $0x66,%al                                                                                                                                           │·······································
</span><span class=ln>1107</span><span class=s2>       0x10000d:    movl   $0xb81234,0x472                                                                                                                                     │·······································
</span><span class=ln>1108</span><span class=s2>       0x100017:    add    %dl,(x)                                                                                                                                          │·······································
</span><span class=ln>1109</span><span class=s2>       0x100019:    add    %cl,(i)                                                                                                                                          │·······································
</span><span class=ln>1110</span><span class=s2>       0x10001b:    and    %al,%bl                                                                                                                                             │·······································
</span><span class=ln>1111</span><span class=s2>    (gdb) x/8i 0xf0100000                                                                                                                                                      │·······································
</span><span class=ln>1112</span><span class=s2>       0xf0100000 &lt;_start+4026531828&gt;:      add    0x1bad(x),%dh                                                                                                            │·······································
</span><span class=ln>1113</span><span class=s2>       0xf0100006 &lt;_start+4026531834&gt;:      add    %al,(x)                                                                                                                  │·······································
</span><span class=ln>1114</span><span class=s2>       0xf0100008 &lt;_start+4026531836&gt;:      decb   0x52(i)                                                                                                                  │·······································
</span><span class=ln>1115</span><span class=s2>       0xf010000b &lt;_start+4026531839&gt;:      in     $0x66,%al                                                                                                                   │·······································
</span><span class=ln>1116</span><span class=s2>       0xf010000d &lt;entry+1&gt;:        movl   $0xb81234,0x472                                                                                                                     │·······································
</span><span class=ln>1117</span><span class=s2>       0xf0100017 &lt;entry+11&gt;:       add    %dl,(x)                                                                                                                          │·······································
</span><span class=ln>1118</span><span class=s2>       0xf0100019 &lt;entry+13&gt;:       add    %cl,(i)                                                                                                                          │·······································
</span><span class=ln>1119</span><span class=s2>       0xf010001b &lt;entry+15&gt;:       and    %al,%bl
</span><span class=ln>1120</span><span class=s2>
</span><span class=ln>1121</span><span class=s2>
</span><span class=ln>1122</span><span class=s2>可以观察到，在cx0_PG flag被置为1之前，地址0xf0100000处是一片虚无。
</span><span class=ln>1123</span><span class=s2>
</span><span class=ln>1124</span><span class=s2>置为1之后，地址0xf0100000处的内容和0x00100000处的内容一致。需要注意，此时这两个地址都是虚拟内存地址了。具体来说
</span><span class=ln>1125</span><span class=s2>
</span><span class=ln>1126</span><span class=s2>
</span><span class=ln>1127</span><span class=s2>&lt;blockquote&gt;Once `CR0_PG` is set, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. `entry_pgdir` translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000&lt;/blockquote&gt;
</span><span class=ln>1128</span><span class=s2>
</span><span class=ln>1129</span><span class=s2>
</span><span class=ln>1130</span><span class=s2>然后我们注释掉`movl x, %cr0` in kern/entry.S
</span><span class=ln>1131</span><span class=s2>
</span><span class=ln>1132</span><span class=s2>再次用gdb调试，发现0x10002a: jmp *x  crash了。 原因显然是由于没有开启保护模式，eax的地址值不合法。
</span><span class=ln>1133</span><span class=s2>
</span><span class=ln>1134</span><span class=s2>
</span><span class=ln>1135</span><span class=s2>### Formatted Printing to the Console
</span><span class=ln>1136</span><span class=s2>
</span><span class=ln>1137</span><span class=s2>
</span><span class=ln>1138</span><span class=s2>printf的格式化输出并不是天生就有的，首先阅读一下相关的几个代码。kern/printf.c, kern/console.c和lib/printfmt.c
</span><span class=ln>1139</span><span class=s2>
</span><span class=ln>1140</span><span class=s2>
</span><span class=ln>1141</span><span class=s2>&lt;blockquote&gt;Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form </span><span class=s2>&#34;</span><span class=o>%</span><span class=n>o</span><span class=s2>&#34;. Find and fill in this code fragment.&lt;/blockquote&gt;
</span><span class=ln>1142</span><span class=s2>
</span><span class=ln>1143</span><span class=s2>
</span><span class=ln>1144</span><span class=s2>很简单，修改之后代码为
</span><span class=ln>1145</span><span class=s2>
</span><span class=ln>1146</span><span class=s2>    
</span><span class=ln>1147</span><span class=s2>    case &#39;o&#39;:
</span><span class=ln>1148</span><span class=s2>    			// Replace this with your code.
</span><span class=ln>1149</span><span class=s2>    			num = getuint(&amp;ap,lflag);
</span><span class=ln>1150</span><span class=s2>    			base = 8;
</span><span class=ln>1151</span><span class=s2>    			goto number;
</span><span class=ln>1152</span><span class=s2>
</span><span class=ln>1153</span><span class=s2>
</span><span class=ln>1154</span><span class=s2>接下来来回答几个问题
</span><span class=ln>1155</span><span class=s2>
</span><span class=ln>1156</span><span class=s2>
</span><span class=ln>1157</span><span class=s2>&lt;blockquote&gt;
</span><span class=ln>1158</span><span class=s2>
</span><span class=ln>1159</span><span class=s2>&gt; 
</span><span class=ln>1160</span><span class=s2>&gt; 
</span><span class=ln>1161</span><span class=s2> 	  1. Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?
</span><span class=ln>1162</span><span class=s2>
</span><span class=ln>1163</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln>1164</span><span class=s2>
</span><span class=ln>1165</span><span class=s2>
</span><span class=ln>1166</span><span class=s2>printf.c与console.c的接口是console.c中的cputchar()，作用是向console中打印一个字符。printf.c在patch()函数中使用了cputchar()
</span><span class=ln>1167</span><span class=s2>
</span><span class=ln>1168</span><span class=s2>
</span><span class=ln>1169</span><span class=s2>&lt;blockquote&gt;2.Explain the following from console.c:
</span><span class=ln>1170</span><span class=s2>
</span><span class=ln>1171</span><span class=s2>&gt;     
</span><span class=ln>1172</span><span class=s2>&gt;     if (crt_pos &gt;= CRT_SIZE) {
</span><span class=ln>1173</span><span class=s2>&gt;              int i;
</span><span class=ln>1174</span><span class=s2>&gt;              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
</span><span class=ln>1175</span><span class=s2>&gt;              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)
</span><span class=ln>1176</span><span class=s2>&gt;              crt_buf[i] = 0x0700 | &#39; &#39;;
</span><span class=ln>1177</span><span class=s2>&gt;              crt_pos -= CRT_COLS;
</span><span class=ln>1178</span><span class=s2>&gt;     }
</span><span class=ln>1179</span><span class=s2>&gt; 
</span><span class=ln>1180</span><span class=s2>&gt; 
</span><span class=ln>1181</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln>1182</span><span class=s2>
</span><span class=ln>1183</span><span class=s2>
</span><span class=ln>1184</span><span class=s2>这段代码很显然，含义是屏幕的字符数超过了屏幕能显示的最大数目的情况下，将第二行到最后一行的字符整体上移一行（这样原先的第一行就被覆盖了），然后将最后一行的内容清空（因为已经上移到倒数第二行了)   应该是类似屏幕滚动的效果
</span><span class=ln>1185</span><span class=s2>
</span><span class=ln>1186</span><span class=s2>
</span><span class=ln>1187</span><span class=s2>&lt;blockquote&gt;3. For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#39;s calling convention on the x86.
</span><span class=ln>1188</span><span class=s2>
</span><span class=ln>1189</span><span class=s2>Trace the execution of the following code step-by-step:
</span><span class=ln>1190</span><span class=s2>
</span><span class=ln>1191</span><span class=s2>&gt;     
</span><span class=ln>1192</span><span class=s2>&gt;     int x = 1, y = 3, z = 4;
</span><span class=ln>1193</span><span class=s2>&gt;     cprintf(&#34;</span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>%</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;, x, y, z);
</span><span class=ln>1194</span><span class=s2>&gt;     
</span><span class=ln>1195</span><span class=s2>&gt; 
</span><span class=ln>1196</span><span class=s2>&gt; 
</span><span class=ln>1197</span><span class=s2>
</span><span class=ln>1198</span><span class=s2>&gt; 
</span><span class=ln>1199</span><span class=s2>&gt; 
</span><span class=ln>1200</span><span class=s2> 	  * In the call to `cprintf()`, to what does `fmt` point? To what does `ap` point?
</span><span class=ln>1201</span><span class=s2> 	  * List (in order of execution) each call to `cons_putc`, `va_arg`, and `vcprintf`. For `cons_putc`, list its argument as well. For `va_arg`, list what `ap` points to before and after the call. For `vcprintf` list the values of its two arguments.
</span><span class=ln>1202</span><span class=s2>
</span><span class=ln>1203</span><span class=s2>这个问题的解答可以先参考一下[c语言变长参数](https://111qqz.com/2019/02/variadic-function-of-c/)和[x86 calling conventions](https://111qqz.com/2019/01/x86-calling-conventions/)
</span><span class=ln>1204</span><span class=s2>
</span><span class=ln>1205</span><span class=s2>我们先看一下print.c的代码:
</span><span class=ln>1206</span><span class=s2>
</span><span class=ln>1207</span><span class=s2>&gt;     
</span><span class=ln>1208</span><span class=s2>&gt;     static void
</span><span class=ln>1209</span><span class=s2>&gt;     putch(int ch, int *cnt)
</span><span class=ln>1210</span><span class=s2>&gt;     {
</span><span class=ln>1211</span><span class=s2>&gt;     	cputchar(ch);
</span><span class=ln>1212</span><span class=s2>&gt;     	*cnt++;
</span><span class=ln>1213</span><span class=s2>&gt;     }
</span><span class=ln>1214</span><span class=s2>&gt;     
</span><span class=ln>1215</span><span class=s2>&gt;     int
</span><span class=ln>1216</span><span class=s2>&gt;     vcprintf(const char *fmt, va_list ap)
</span><span class=ln>1217</span><span class=s2>&gt;     {
</span><span class=ln>1218</span><span class=s2>&gt;     	int cnt = 0;
</span><span class=ln>1219</span><span class=s2>&gt;     
</span><span class=ln>1220</span><span class=s2>&gt;     	vprintfmt((void*)putch, &amp;cnt, fmt, ap);
</span><span class=ln>1221</span><span class=s2>&gt;     	return cnt;
</span><span class=ln>1222</span><span class=s2>&gt;     }
</span><span class=ln>1223</span><span class=s2>&gt;     
</span><span class=ln>1224</span><span class=s2>&gt;     int
</span><span class=ln>1225</span><span class=s2>&gt;     cprintf(const char *fmt, ...)
</span><span class=ln>1226</span><span class=s2>&gt;     {
</span><span class=ln>1227</span><span class=s2>&gt;     	va_list ap;
</span><span class=ln>1228</span><span class=s2>&gt;     	int cnt;
</span><span class=ln>1229</span><span class=s2>&gt;     
</span><span class=ln>1230</span><span class=s2>&gt;     	va_start(ap, fmt);
</span><span class=ln>1231</span><span class=s2>&gt;     	cnt = vcprintf(fmt, ap);
</span><span class=ln>1232</span><span class=s2>&gt;     	va_end(ap);
</span><span class=ln>1233</span><span class=s2>&gt;     
</span><span class=ln>1234</span><span class=s2>&gt;     	return cnt;
</span><span class=ln>1235</span><span class=s2>&gt;     }
</span><span class=ln>1236</span><span class=s2>&gt;     
</span><span class=ln>1237</span><span class=s2>&gt; 
</span><span class=ln>1238</span><span class=s2>&gt; 
</span><span class=ln>1239</span><span class=s2>从int cprintf(const char *fmt, ...)开始看，参数*fmt应该就是 我们熟悉的c语言的printf的格式化部分，也就是第一个参数。
</span><span class=ln>1240</span><span class=s2>
</span><span class=ln>1241</span><span class=s2>然后整体就是c语言变长参数的routine，但是没有使用va_arg, 而是用cnt = cvprintf(fmt,ap)，返回了一个不知道什么的个数。
</span><span class=ln>1242</span><span class=s2>
</span><span class=ln>1243</span><span class=s2>接下来看int vcprintf(const char *fmt, va_list ap)，好像没什么好看的.... 然后是vprintfmt，代码如下:
</span><span class=ln>1244</span><span class=s2>
</span><span class=ln>1245</span><span class=s2>&gt;     
</span><span class=ln>1246</span><span class=s2>&gt;     void
</span><span class=ln>1247</span><span class=s2>&gt;     vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
</span><span class=ln>1248</span><span class=s2>&gt;     {
</span><span class=ln>1249</span><span class=s2>&gt;     	register const char *p;
</span><span class=ln>1250</span><span class=s2>&gt;     	register int ch, err;
</span><span class=ln>1251</span><span class=s2>&gt;     	unsigned long long num;
</span><span class=ln>1252</span><span class=s2>&gt;     	int base, lflag, width, precision, altflag;
</span><span class=ln>1253</span><span class=s2>&gt;     	char padc;
</span><span class=ln>1254</span><span class=s2>&gt;     
</span><span class=ln>1255</span><span class=s2>&gt;     	while (1) {
</span><span class=ln>1256</span><span class=s2>&gt;     		while ((ch = *(unsigned char *) fmt++) != &#39;%&#39;) {
</span><span class=ln>1257</span><span class=s2>&gt;     			if (ch == &#39;\0&#39;)
</span><span class=ln>1258</span><span class=s2>&gt;     				return;
</span><span class=ln>1259</span><span class=s2>&gt;     			putch(ch, putdat);
</span><span class=ln>1260</span><span class=s2>&gt;     		}
</span><span class=ln>1261</span><span class=s2>&gt;     
</span><span class=ln>1262</span><span class=s2>&gt;     		// Process a %-escape sequence
</span><span class=ln>1263</span><span class=s2>&gt;     		padc = &#39; &#39;;
</span><span class=ln>1264</span><span class=s2>&gt;     		width = -1;
</span><span class=ln>1265</span><span class=s2>&gt;     		precision = -1;
</span><span class=ln>1266</span><span class=s2>&gt;     		lflag = 0;
</span><span class=ln>1267</span><span class=s2>&gt;     		altflag = 0;
</span><span class=ln>1268</span><span class=s2>&gt;     	reswitch:
</span><span class=ln>1269</span><span class=s2>&gt;     		switch (ch = *(unsigned char *) fmt++) {
</span><span class=ln>1270</span><span class=s2>&gt;     
</span><span class=ln>1271</span><span class=s2>&gt;     		// flag to pad on the right
</span><span class=ln>1272</span><span class=s2>&gt;     		case &#39;-&#39;:
</span><span class=ln>1273</span><span class=s2>&gt;     			padc = &#39;-&#39;;
</span><span class=ln>1274</span><span class=s2>&gt;     			goto reswitch;
</span><span class=ln>1275</span><span class=s2>&gt;     
</span><span class=ln>1276</span><span class=s2>&gt;     		// flag to pad with 0&#39;s instead of spaces
</span><span class=ln>1277</span><span class=s2>&gt;     		case &#39;0&#39;:
</span><span class=ln>1278</span><span class=s2>&gt;     			padc = &#39;0&#39;;
</span><span class=ln>1279</span><span class=s2>&gt;     			goto reswitch;
</span><span class=ln>1280</span><span class=s2>&gt;     
</span><span class=ln>1281</span><span class=s2>&gt;     		// width field
</span><span class=ln>1282</span><span class=s2>&gt;     		case &#39;1&#39;:
</span><span class=ln>1283</span><span class=s2>&gt;     		case &#39;2&#39;:
</span><span class=ln>1284</span><span class=s2>&gt;     		case &#39;3&#39;:
</span><span class=ln>1285</span><span class=s2>&gt;     		case &#39;4&#39;:
</span><span class=ln>1286</span><span class=s2>&gt;     		case &#39;5&#39;:
</span><span class=ln>1287</span><span class=s2>&gt;     		case &#39;6&#39;:
</span><span class=ln>1288</span><span class=s2>&gt;     		case &#39;7&#39;:
</span><span class=ln>1289</span><span class=s2>&gt;     		case &#39;8&#39;:
</span><span class=ln>1290</span><span class=s2>&gt;     		case &#39;9&#39;:
</span><span class=ln>1291</span><span class=s2>&gt;     			for (precision = 0; ; ++fmt) {
</span><span class=ln>1292</span><span class=s2>&gt;     				precision = precision * 10 + ch - &#39;0&#39;;
</span><span class=ln>1293</span><span class=s2>&gt;     				ch = *fmt;
</span><span class=ln>1294</span><span class=s2>&gt;     				if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;)
</span><span class=ln>1295</span><span class=s2>&gt;     					break;
</span><span class=ln>1296</span><span class=s2>&gt;     			}
</span><span class=ln>1297</span><span class=s2>&gt;     			goto process_precision;
</span><span class=ln>1298</span><span class=s2>&gt;     
</span><span class=ln>1299</span><span class=s2>&gt;     		case &#39;*&#39;:
</span><span class=ln>1300</span><span class=s2>&gt;     			precision = va_arg(ap, int);
</span><span class=ln>1301</span><span class=s2>&gt;     			goto process_precision;
</span><span class=ln>1302</span><span class=s2>&gt;     
</span><span class=ln>1303</span><span class=s2>&gt;     		case &#39;.&#39;:
</span><span class=ln>1304</span><span class=s2>&gt;     			if (width &lt; 0)
</span><span class=ln>1305</span><span class=s2>&gt;     				width = 0;
</span><span class=ln>1306</span><span class=s2>&gt;     			goto reswitch;
</span><span class=ln>1307</span><span class=s2>&gt;     
</span><span class=ln>1308</span><span class=s2>&gt;     		case &#39;#&#39;:
</span><span class=ln>1309</span><span class=s2>&gt;     			altflag = 1;
</span><span class=ln>1310</span><span class=s2>&gt;     			goto reswitch;
</span><span class=ln>1311</span><span class=s2>&gt;     
</span><span class=ln>1312</span><span class=s2>&gt;     		process_precision:
</span><span class=ln>1313</span><span class=s2>&gt;     			if (width &lt; 0)
</span><span class=ln>1314</span><span class=s2>&gt;     				width = precision, precision = -1;
</span><span class=ln>1315</span><span class=s2>&gt;     			goto reswitch;
</span><span class=ln>1316</span><span class=s2>&gt;     
</span><span class=ln>1317</span><span class=s2>&gt;     		// long flag (doubled for long long)
</span><span class=ln>1318</span><span class=s2>&gt;     		case &#39;l&#39;:
</span><span class=ln>1319</span><span class=s2>&gt;     			lflag++;
</span><span class=ln>1320</span><span class=s2>&gt;     			goto reswitch;
</span><span class=ln>1321</span><span class=s2>&gt;     
</span><span class=ln>1322</span><span class=s2>&gt;     		// character
</span><span class=ln>1323</span><span class=s2>&gt;     		case &#39;c&#39;:
</span><span class=ln>1324</span><span class=s2>&gt;     			putch(va_arg(ap, int), putdat);
</span><span class=ln>1325</span><span class=s2>&gt;     			break;
</span><span class=ln>1326</span><span class=s2>&gt;     
</span><span class=ln>1327</span><span class=s2>&gt;     		// error message
</span><span class=ln>1328</span><span class=s2>&gt;     		case &#39;e&#39;:
</span><span class=ln>1329</span><span class=s2>&gt;     			err = va_arg(ap, int);
</span><span class=ln>1330</span><span class=s2>&gt;     			if (err &lt; 0)
</span><span class=ln>1331</span><span class=s2>&gt;     				err = -err;
</span><span class=ln>1332</span><span class=s2>&gt;     			if (err &gt;= MAXERROR || (p = error_string[err]) == NULL)
</span><span class=ln>1333</span><span class=s2>&gt;     				printfmt(putch, putdat, &#34;</span><span class=n>error</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=s2>&#34;, err);
</span><span class=ln>1334</span><span class=s2>&gt;     			else
</span><span class=ln>1335</span><span class=s2>&gt;     				printfmt(putch, putdat, &#34;</span><span class=o>%</span><span class=n>s</span><span class=s2>&#34;, p);
</span><span class=ln>1336</span><span class=s2>&gt;     			break;
</span><span class=ln>1337</span><span class=s2>&gt;     
</span><span class=ln>1338</span><span class=s2>&gt;     		// string
</span><span class=ln>1339</span><span class=s2>&gt;     		case &#39;s&#39;:
</span><span class=ln>1340</span><span class=s2>&gt;     			if ((p = va_arg(ap, char *)) == NULL)
</span><span class=ln>1341</span><span class=s2>&gt;     				p = &#34;</span><span class=p>(</span><span class=no>null</span><span class=p>)</span><span class=s2>&#34;;
</span><span class=ln>1342</span><span class=s2>&gt;     			if (width &gt; 0 &amp;&amp; padc != &#39;-&#39;)
</span><span class=ln>1343</span><span class=s2>&gt;     				for (width -= strnlen(p, precision); width &gt; 0; width--)
</span><span class=ln>1344</span><span class=s2>&gt;     					putch(padc, putdat);
</span><span class=ln>1345</span><span class=s2>&gt;     			for (; (ch = *p++) != &#39;\0&#39; &amp;&amp; (precision &lt; 0 || --precision &gt;= 0); width--)
</span><span class=ln>1346</span><span class=s2>&gt;     				if (altflag &amp;&amp; (ch &lt; &#39; &#39; || ch &gt; &#39;~&#39;))
</span><span class=ln>1347</span><span class=s2>&gt;     					putch(&#39;?&#39;, putdat);
</span><span class=ln>1348</span><span class=s2>&gt;     				else
</span><span class=ln>1349</span><span class=s2>&gt;     					putch(ch, putdat);
</span><span class=ln>1350</span><span class=s2>&gt;     			for (; width &gt; 0; width--)
</span><span class=ln>1351</span><span class=s2>&gt;     				putch(&#39; &#39;, putdat);
</span><span class=ln>1352</span><span class=s2>&gt;     			break;
</span><span class=ln>1353</span><span class=s2>&gt;     
</span><span class=ln>1354</span><span class=s2>&gt;     		// (signed) decimal
</span><span class=ln>1355</span><span class=s2>&gt;     		case &#39;d&#39;:
</span><span class=ln>1356</span><span class=s2>&gt;     			num = getint(&amp;ap, lflag);
</span><span class=ln>1357</span><span class=s2>&gt;     			if ((long long) num &lt; 0) {
</span><span class=ln>1358</span><span class=s2>&gt;     				putch(&#39;-&#39;, putdat);
</span><span class=ln>1359</span><span class=s2>&gt;     				num = -(long long) num;
</span><span class=ln>1360</span><span class=s2>&gt;     			}
</span><span class=ln>1361</span><span class=s2>&gt;     			base = 10;
</span><span class=ln>1362</span><span class=s2>&gt;     			goto number;
</span><span class=ln>1363</span><span class=s2>&gt;     
</span><span class=ln>1364</span><span class=s2>&gt;     		// unsigned decimal
</span><span class=ln>1365</span><span class=s2>&gt;     		case &#39;u&#39;:
</span><span class=ln>1366</span><span class=s2>&gt;     			num = getuint(&amp;ap, lflag);
</span><span class=ln>1367</span><span class=s2>&gt;     			base = 10;
</span><span class=ln>1368</span><span class=s2>&gt;     			goto number;
</span><span class=ln>1369</span><span class=s2>&gt;     
</span><span class=ln>1370</span><span class=s2>&gt;     		// (unsigned) octal
</span><span class=ln>1371</span><span class=s2>&gt;     		case &#39;o&#39;:
</span><span class=ln>1372</span><span class=s2>&gt;     			// Replace this with your code.
</span><span class=ln>1373</span><span class=s2>&gt;     			putch(&#39;X&#39;, putdat);
</span><span class=ln>1374</span><span class=s2>&gt;     			putch(&#39;X&#39;, putdat);
</span><span class=ln>1375</span><span class=s2>&gt;     			putch(&#39;X&#39;, putdat);
</span><span class=ln>1376</span><span class=s2>&gt;     			break;
</span><span class=ln>1377</span><span class=s2>&gt;     
</span><span class=ln>1378</span><span class=s2>&gt;     		// pointer
</span><span class=ln>1379</span><span class=s2>&gt;     		case &#39;p&#39;:
</span><span class=ln>1380</span><span class=s2>&gt;     			putch(&#39;0&#39;, putdat);
</span><span class=ln>1381</span><span class=s2>&gt;     			putch(&#39;x&#39;, putdat);
</span><span class=ln>1382</span><span class=s2>&gt;     			num = (unsigned long long)
</span><span class=ln>1383</span><span class=s2>&gt;     				(uintptr_t) va_arg(ap, void *);
</span><span class=ln>1384</span><span class=s2>&gt;     			base = 16;
</span><span class=ln>1385</span><span class=s2>&gt;     			goto number;
</span><span class=ln>1386</span><span class=s2>&gt;     
</span><span class=ln>1387</span><span class=s2>&gt;     		// (unsigned) hexadecimal
</span><span class=ln>1388</span><span class=s2>&gt;     		case &#39;x&#39;:
</span><span class=ln>1389</span><span class=s2>&gt;     			num = getuint(&amp;ap, lflag);
</span><span class=ln>1390</span><span class=s2>&gt;     			base = 16;
</span><span class=ln>1391</span><span class=s2>&gt;     		number:
</span><span class=ln>1392</span><span class=s2>&gt;     			printnum(putch, putdat, num, base, width, padc);
</span><span class=ln>1393</span><span class=s2>&gt;     			break;
</span><span class=ln>1394</span><span class=s2>&gt;     
</span><span class=ln>1395</span><span class=s2>&gt;     		// escaped &#39;%&#39; character
</span><span class=ln>1396</span><span class=s2>&gt;     		case &#39;%&#39;:
</span><span class=ln>1397</span><span class=s2>&gt;     			putch(ch, putdat);
</span><span class=ln>1398</span><span class=s2>&gt;     			break;
</span><span class=ln>1399</span><span class=s2>&gt;     
</span><span class=ln>1400</span><span class=s2>&gt;     		// unrecognized escape sequence - just print it literally
</span><span class=ln>1401</span><span class=s2>&gt;     		default:
</span><span class=ln>1402</span><span class=s2>&gt;     			putch(&#39;%&#39;, putdat);
</span><span class=ln>1403</span><span class=s2>&gt;     			for (fmt--; fmt[-1] != &#39;%&#39;; fmt--)
</span><span class=ln>1404</span><span class=s2>&gt;     				/* do nothing */;
</span><span class=ln>1405</span><span class=s2>&gt;     			break;
</span><span class=ln>1406</span><span class=s2>&gt;     		}
</span><span class=ln>1407</span><span class=s2>&gt;     	}
</span><span class=ln>1408</span><span class=s2>&gt;     }
</span><span class=ln>1409</span><span class=s2>&gt; 
</span><span class=ln>1410</span><span class=s2>&gt; 
</span><span class=ln>1411</span><span class=s2>大致扫一眼可以发现这段代码是处理输出的格式化参数的，包括输出类型，精度，场宽之类。
</span><span class=ln>1412</span><span class=s2>
</span><span class=ln>1413</span><span class=s2>我们注意到putch函数的作用是向console输出一个字符，并统计当前累计的输出字符个数。
</span><span class=ln>1414</span><span class=s2>
</span><span class=ln>1415</span><span class=s2>接下来我们来回答问题:
</span><span class=ln>1416</span><span class=s2>
</span><span class=ln>1417</span><span class=s2>&gt; 
</span><span class=ln>1418</span><span class=s2>&gt; 
</span><span class=ln>1419</span><span class=s2> 	  * 在cprintf的调用中，fmt指向的是&#34;</span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>%</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;, ap指向的是第一个变长参数，也就是变量x在调用栈中的地址。
</span><span class=ln>1420</span><span class=s2> 	  * cons_putc调用的过程按先后顺序为:
</span><span class=ln>1421</span><span class=s2>
</span><span class=ln>1422</span><span class=s2> 	    * cons_putc(&#39;x&#39;)
</span><span class=ln>1423</span><span class=s2> 	    * cons_putc(&#39; &#39;)
</span><span class=ln>1424</span><span class=s2> 	    * cons_putc(&#39;1&#39;)
</span><span class=ln>1425</span><span class=s2> 	    * cons_putc(&#39;,&#39;)
</span><span class=ln>1426</span><span class=s2> 	    * cons_putc(&#39; &#39;)
</span><span class=ln>1427</span><span class=s2> 	    * cons_putc(&#39;y&#39;)
</span><span class=ln>1428</span><span class=s2> 	    * cons_putc(&#39; &#39;)
</span><span class=ln>1429</span><span class=s2> 	    * cons_putc(&#39;3&#39;)
</span><span class=ln>1430</span><span class=s2> 	    * cons_putc(&#39;,&#39;)
</span><span class=ln>1431</span><span class=s2> 	    * cons_putc(&#39; &#39;)
</span><span class=ln>1432</span><span class=s2> 	    * cons_putc(&#39;z&#39;)
</span><span class=ln>1433</span><span class=s2> 	    * cons_putc(&#39; &#39;)
</span><span class=ln>1434</span><span class=s2> 	    * cons_putc(&#39;4&#39;)
</span><span class=ln>1435</span><span class=s2> 	    * cons_putc(&#39;\n&#39;)
</span><span class=ln>1436</span><span class=s2>
</span><span class=ln>1437</span><span class=s2>
</span><span class=ln>1438</span><span class=s2> 	  * va_arg一共调用了三次
</span><span class=ln>1439</span><span class=s2>
</span><span class=ln>1440</span><span class=s2> 	    * 第一次调用前,ap指向参数x在栈中的地址,调用之后,ap指向参数y在栈中的地址。
</span><span class=ln>1441</span><span class=s2> 	    * 第二次调用前,ap指向参数y在栈中的地址,调用之后,ap指向参数z在栈中的地址。
</span><span class=ln>1442</span><span class=s2> 	    * 第三次调用前,ap指向参数z在栈中的地址,调用之后,ap指向参数z之后4字节的地址。
</span><span class=ln>1443</span><span class=s2>
</span><span class=ln>1444</span><span class=s2>
</span><span class=ln>1445</span><span class=s2> 	  * vcprintf的参数值为&#34;</span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>%</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34; 和 参数x在调用栈中的地址。
</span><span class=ln>1446</span><span class=s2>
</span><span class=ln>1447</span><span class=s2>4.Run the following code.
</span><span class=ln>1448</span><span class=s2>
</span><span class=ln>1449</span><span class=s2>&gt;     
</span><span class=ln>1450</span><span class=s2>&gt;         unsigned int i = 0x00646c72;
</span><span class=ln>1451</span><span class=s2>&gt;         cprintf(&#34;</span><span class=n>H</span><span class=o>%</span><span class=n>x</span><span class=w> </span><span class=n>Wo</span><span class=o>%</span><span class=n>s</span><span class=s2>&#34;, 57616, &amp;i);
</span><span class=ln>1452</span><span class=s2>&gt;     
</span><span class=ln>1453</span><span class=s2>&gt; 
</span><span class=ln>1454</span><span class=s2>&gt; 
</span><span class=ln>1455</span><span class=s2>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. [Here&#39;s an ASCII table](http://web.cs.mun.ca/~michael/c/ascii-table.html) that maps bytes to characters.
</span><span class=ln>1456</span><span class=s2>
</span><span class=ln>1457</span><span class=s2>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set `i` to in order to yield the same output? Would you need to change `57616` to a different value?&lt;/blockquote&gt;
</span><span class=ln>1458</span><span class=s2>
</span><span class=ln>1459</span><span class=s2>
</span><span class=ln>1460</span><span class=s2>输出结果为  &#34;</span><span class=n>He110</span><span class=w> </span><span class=n>World</span><span class=s2>&#34; 前半部分的e110就是57616的十六进制表示。后半部分将unsiged int i 当成unsigned char类型输出，十六进制64,6c,72对应的字符分别为‘d’,‘l’,&#39;r&#39;.
</span><span class=ln>1461</span><span class=s2>
</span><span class=ln>1462</span><span class=s2>然后先复习一下字节序。**整数类型static_cast不会有字节序问题，指针++和--操作不涉及cast和字节序问题。把指针类型reinterpret_cast才会有字节序问题**，例如：
</span><span class=ln>1463</span><span class=s2>
</span><span class=ln>1464</span><span class=s2>    
</span><span class=ln>1465</span><span class=s2>    int a = 0x12345678
</span><span class=ln>1466</span><span class=s2>    char *c = reinterpret_cast&lt;char*&gt;(&amp;a);
</span><span class=ln>1467</span><span class=s2>    printf(&#34;</span><span class=o>%</span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=n>x</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;,c[0],c[1],c[2],c[3]);
</span><span class=ln>1468</span><span class=s2>    //小端输出:78 56 34 12
</span><span class=ln>1469</span><span class=s2>    //大端输出:12 34 56 78
</span><span class=ln>1470</span><span class=s2>
</span><span class=ln>1471</span><span class=s2>
</span><span class=ln>1472</span><span class=s2>由于x86体系架构字节序为little-endian,因此实际输出为&#39;r&#39;,&#39;l&#39;,&#39;d&#39;.
</span><span class=ln>1473</span><span class=s2>
</span><span class=ln>1474</span><span class=s2>如果x86体系架构为large-endian,那么i的值应该改为0x00726c64，以实现相同的输出结果。
</span><span class=ln>1475</span><span class=s2>
</span><span class=ln>1476</span><span class=s2>57616不需要做修改，因为整数类型staic_cast不存在字节序问题。
</span><span class=ln>1477</span><span class=s2>
</span><span class=ln>1478</span><span class=s2>
</span><span class=ln>1479</span><span class=s2>&lt;blockquote&gt;5.In the following code, what is going to be printed after `&#39;y=&#39;`? (note: the answer is not a specific value.) Why does this happen?
</span><span class=ln>1480</span><span class=s2>
</span><span class=ln>1481</span><span class=s2>&gt;     
</span><span class=ln>1482</span><span class=s2>&gt;         cprintf(&#34;</span><span class=n>x</span><span class=o>=%</span><span class=n>d</span><span class=w> </span><span class=n>y</span><span class=o>=%</span><span class=n>d</span><span class=s2>&#34;, 3);
</span><span class=ln>1483</span><span class=s2>&gt; 
</span><span class=ln>1484</span><span class=s2>&gt; 
</span><span class=ln>1485</span><span class=s2>&lt;/blockquote&gt;
</span><span class=ln>1486</span><span class=s2>
</span><span class=ln>1487</span><span class=s2>
</span><span class=ln>1488</span><span class=s2>x的结果就是3，y的输出是没意义的一个整数。原因是，这句话会发生当va_list中没有下一个变量时，仍然使用va_arg去取下一个变量。而根据[va_arg](http://en.cppreference.com/w/cpp/utility/variadic/va_arg)，此时的行为是undefined behaviour.
</span><span class=ln>1489</span><span class=s2>
</span><span class=ln>1490</span><span class=s2>
</span><span class=ln>1491</span><span class=s2>&lt;blockquote&gt;6.Let&#39;s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change `cprintf` or its interface so that it would still be possible to pass it a variable number of arguments?
</span><span class=ln>1492</span><span class=s2>
</span><span class=ln>1493</span><span class=s2>感觉如果知识修改cprintf来达到目的有点难？ 因为压栈顺序和之前相反了，那么va_arg这个宏需要修改一下...或者，添加一个buffer，不是一次处理一个参数，而是先将参数全部读取，然后调换顺序，之后再进行处理。&lt;/blockquote&gt;
</span><span class=ln>1494</span><span class=s2>
</span><span class=ln>1495</span><span class=s2>
</span><span class=ln>1496</span><span class=s2>
</span><span class=ln>1497</span><span class=s2>
</span><span class=ln>1498</span><span class=s2>
</span><span class=ln>1499</span><span class=s2>### The Stack
</span><span class=ln>1500</span><span class=s2>
</span><span class=ln>1501</span><span class=s2>
</span><span class=ln>1502</span><span class=s2>
</span><span class=ln>1503</span><span class=s2>
</span><span class=ln>1504</span><span class=s2>&lt;blockquote&gt;Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which &#34;</span><span class=n>end</span><span class=s2>&#34; of this reserved area is the stack pointer initialized to point to?&lt;/blockquote&gt;
</span><span class=ln>1505</span><span class=s2>
</span><span class=ln>1506</span><span class=s2>
</span><span class=ln>1507</span><span class=s2>参考obj/kernel.asm
</span><span class=ln>1508</span><span class=s2>
</span><span class=ln>1509</span><span class=s2>    
</span><span class=ln>1510</span><span class=s2>    f010002c &lt;relocated&gt;:
</span><span class=ln>1511</span><span class=s2>    relocated:
</span><span class=ln>1512</span><span class=s2>    
</span><span class=ln>1513</span><span class=s2>            # Clear the frame pointer register (EBP)
</span><span class=ln>1514</span><span class=s2>            # so that once we get into debugging C code,
</span><span class=ln>1515</span><span class=s2>            # stack backtraces will be terminated properly.
</span><span class=ln>1516</span><span class=s2>            movl    $0x0,p                       # nuke frame pointer
</span><span class=ln>1517</span><span class=s2>    f010002c:       bd 00 00 00 00          mov    $0x0,p
</span><span class=ln>1518</span><span class=s2>    
</span><span class=ln>1519</span><span class=s2>            # Set the stack pointer
</span><span class=ln>1520</span><span class=s2>            movl    $(bootstacktop),%esp
</span><span class=ln>1521</span><span class=s2>    f0100031:       bc 00 00 11 f0          mov    $0xf0110000,%esp
</span><span class=ln>1522</span><span class=s2>
</span><span class=ln>1523</span><span class=s2>
</span><span class=ln>1524</span><span class=s2>得知kernel初始化stack是在地址0xf010002c和0xf0100031完成的。stack被加载到了地址0xf01100000. 至于kernel如何为stack保留空间这个问题，我的理解是，stack现在有了初始位置，但是它如何知道自己有多大空间呢？ 换句话说，这个问题问的是kernel如何决定stack的大小。这一部分其实定义在inc/memlayout.h中，
</span><span class=ln>1525</span><span class=s2>
</span><span class=ln>1526</span><span class=s2>    
</span><span class=ln>1527</span><span class=s2>    // All physical memory mapped at this address
</span><span class=ln>1528</span><span class=s2>    #define	KERNBASE	0xF0000000
</span><span class=ln>1529</span><span class=s2>    
</span><span class=ln>1530</span><span class=s2>    // At IOPHYSMEM (640K) there is a 384K hole for I/O.  From the kernel,
</span><span class=ln>1531</span><span class=s2>    // IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM.  The hole ends
</span><span class=ln>1532</span><span class=s2>    // at physical address EXTPHYSMEM.
</span><span class=ln>1533</span><span class=s2>    #define IOPHYSMEM	0x0A0000
</span><span class=ln>1534</span><span class=s2>    #define EXTPHYSMEM	0x100000
</span><span class=ln>1535</span><span class=s2>    
</span><span class=ln>1536</span><span class=s2>    // Kernel stack.
</span><span class=ln>1537</span><span class=s2>    #define KSTACKTOP	KERNBASE
</span><span class=ln>1538</span><span class=s2>    #define KSTKSIZE	(8*PGSIZE)   		// size of a kernel stack
</span><span class=ln>1539</span><span class=s2>    #define KSTKGAP		(8*PGSIZE)   		// size of a kernel stack guard
</span><span class=ln>1540</span><span class=s2>    
</span><span class=ln>1541</span><span class=s2>    // Memory-mapped IO.
</span><span class=ln>1542</span><span class=s2>    #define MMIOLIM		(KSTACKTOP - PTSIZE)
</span><span class=ln>1543</span><span class=s2>    #define MMIOBASE	(MMIOLIM - PTSIZE)
</span><span class=ln>1544</span><span class=s2>
</span><span class=ln>1545</span><span class=s2>
</span><span class=ln>1546</span><span class=s2>最后一个问题，由于x86体系架构下栈是向下增长的。因此stack pointer初始指向这段保留区域的大地址端（也就是上面)
</span><span class=ln>1547</span><span class=s2>
</span><span class=ln>1548</span><span class=s2>
</span><span class=ln>1549</span><span class=s2>
</span><span class=ln>1550</span><span class=s2>
</span><span class=ln>1551</span><span class=s2>&lt;blockquote&gt;Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the `test_backtrace` function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of `test_backtrace` push on the stack, and what are those words?
</span><span class=ln>1552</span><span class=s2>
</span><span class=ln>1553</span><span class=s2>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the [tools](https://pdos.csail.mit.edu/6.828/2018/tools.html) page or on Athena. Otherwise, you&#39;ll have to manually translate all breakpoint and memory addresses to linear addresses.&lt;/blockquote&gt;
</span><span class=ln>1554</span><span class=s2>
</span><span class=ln>1555</span><span class=s2>
</span><span class=ln>1556</span><span class=s2>test_backtrace的入口地址在0xf0100040,在这里设置断点，然后最后的输出结果如下:
</span><span class=ln>1557</span><span class=s2>
</span><span class=ln>1558</span><span class=s2>    
</span><span class=ln>1559</span><span class=s2>    entering test_backtrace 5
</span><span class=ln>1560</span><span class=s2>    entering test_backtrace 4
</span><span class=ln>1561</span><span class=s2>    entering test_backtrace 3
</span><span class=ln>1562</span><span class=s2>    entering test_backtrace 2
</span><span class=ln>1563</span><span class=s2>    entering test_backtrace 1
</span><span class=ln>1564</span><span class=s2>    entering test_backtrace 0
</span><span class=ln>1565</span><span class=s2>    leaving test_backtrace 0
</span><span class=ln>1566</span><span class=s2>    leaving test_backtrace 1
</span><span class=ln>1567</span><span class=s2>    leaving test_backtrace 2
</span><span class=ln>1568</span><span class=s2>    leaving test_backtrace 3
</span><span class=ln>1569</span><span class=s2>    leaving test_backtrace 4
</span><span class=ln>1570</span><span class=s2>    leaving test_backtrace 5
</span><span class=ln>1571</span><span class=s2>    Welcome to the JOS kernel monitor!
</span><span class=ln>1572</span><span class=s2>
</span><span class=ln>1573</span><span class=s2>
</span><span class=ln>1574</span><span class=s2>对于每次调用函数test_backtrace,有三个32-bit的变量被压栈，可以参考
</span><span class=ln>1575</span><span class=s2>
</span><span class=ln>1576</span><span class=s2>    
</span><span class=ln>1577</span><span class=s2>    // Test the stack backtrace function (lab 1 only)
</span><span class=ln>1578</span><span class=s2>    void
</span><span class=ln>1579</span><span class=s2>    test_backtrace(int x)
</span><span class=ln>1580</span><span class=s2>    {
</span><span class=ln>1581</span><span class=s2>    f0100040:       55                      push   p
</span><span class=ln>1582</span><span class=s2>    f0100041:       89 e5                   mov    %esp,p
</span><span class=ln>1583</span><span class=s2>    f0100043:       53                      push   x
</span><span class=ln>1584</span><span class=s2>    f0100044:       83 ec 14                sub    $0x14,%esp
</span><span class=ln>1585</span><span class=s2>    f0100047:       8b 5d 08                mov    0x8(p),x
</span><span class=ln>1586</span><span class=s2>            cprintf(&#34;</span><span class=n>entering</span><span class=w> </span><span class=n>test_backtrace</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;, x);
</span><span class=ln>1587</span><span class=s2>    f010004a:       89 5c 24 04             mov    x,0x4(%esp)
</span><span class=ln>1588</span><span class=s2>    f010004e:       c7 04 24 e0 18 10 f0    movl   $0xf01018e0,(%esp)
</span><span class=ln>1589</span><span class=s2>    f0100055:       e8 d7 08 00 00          call   f0100931 &lt;cprintf&gt;
</span><span class=ln>1590</span><span class=s2>            if (x &gt; 0)
</span><span class=ln>1591</span><span class=s2>    f010005a:       85 db                   test   x,x
</span><span class=ln>1592</span><span class=s2>    f010005c:       7e 0d                   jle    f010006b &lt;test_backtrace+0x2b&gt;
</span><span class=ln>1593</span><span class=s2>                    test_backtrace(x-1);
</span><span class=ln>1594</span><span class=s2>    f010005e:       8d 43 ff                lea    -0x1(x),x
</span><span class=ln>1595</span><span class=s2>    f0100061:       89 04 24                mov    x,(%esp)
</span><span class=ln>1596</span><span class=s2>    f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;
</span><span class=ln>1597</span><span class=s2>    f0100069:       eb 1c                   jmp    f0100087 &lt;test_backtrace+0x47&gt;
</span><span class=ln>1598</span><span class=s2>            else
</span><span class=ln>1599</span><span class=s2>                    mon_backtrace(0, 0, 0);
</span><span class=ln>1600</span><span class=s2>    f010006b:       c7 44 24 08 00 00 00    movl   $0x0,0x8(%esp)
</span><span class=ln>1601</span><span class=s2>    f0100072:       00 
</span><span class=ln>1602</span><span class=s2>    f0100073:       c7 44 24 04 00 00 00    movl   $0x0,0x4(%esp)
</span><span class=ln>1603</span><span class=s2>    f010007a:       00 
</span><span class=ln>1604</span><span class=s2>    f010007b:       c7 04 24 00 00 00 00    movl   $0x0,(%esp)
</span><span class=ln>1605</span><span class=s2>    f0100082:       e8 18 07 00 00          call   f010079f &lt;mon_backtrace&gt;
</span><span class=ln>1606</span><span class=s2>            cprintf(&#34;</span><span class=n>leaving</span><span class=w> </span><span class=n>test_backtrace</span><span class=w> </span><span class=o>%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;, x);
</span><span class=ln>1607</span><span class=s2>    f0100087:       89 5c 24 04             mov    x,0x4(%esp)
</span><span class=ln>1608</span><span class=s2>    f010008b:       c7 04 24 fc 18 10 f0    movl   $0xf01018fc,(%esp)
</span><span class=ln>1609</span><span class=s2>    f0100092:       e8 9a 08 00 00          call   f0100931 &lt;cprintf&gt;
</span><span class=ln>1610</span><span class=s2>    }
</span><span class=ln>1611</span><span class=s2>    f0100097:       83 c4 14                add    $0x14,%esp
</span><span class=ln>1612</span><span class=s2>    f010009a:       5b                      pop    x
</span><span class=ln>1613</span><span class=s2>    f010009b:       5d                      pop    p
</span><span class=ln>1614</span><span class=s2>    f010009c:       c3                      ret
</span><span class=ln>1615</span><span class=s2>
</span><span class=ln>1616</span><span class=s2>
</span><span class=ln>1617</span><span class=s2>分别是参数x,ebp和ebx. 参数x和ebp的压栈是常规操作，就不解释了。ebx的压栈可能有些疑问，可以参考[Why are these registers pushed to stack?](https://stackoverflow.com/questions/9797335/why-are-these-registers-pushed-to-stack)
</span><span class=ln>1618</span><span class=s2>
</span><span class=ln>1619</span><span class=s2>下一个练习:
</span><span class=ln>1620</span><span class=s2>
</span><span class=ln>1621</span><span class=s2>
</span><span class=ln>1622</span><span class=s2>&lt;blockquote&gt;Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn&#39;t. _After_ you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.
</span><span class=ln>1623</span><span class=s2>
</span><span class=ln>1624</span><span class=s2>If you use `read_ebp()`, note that GCC may generate &#34;</span><span class=n>optimized</span><span class=s2>&#34; code that calls `read_ebp()` _before_`mon_backtrace()`&#39;s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of `mon_backtrace()` and make sure the call to`read_ebp()` is happening after the function prologue.&lt;/blockquote&gt;
</span><span class=ln>1625</span><span class=s2>
</span><span class=ln>1626</span><span class=s2>
</span><span class=ln>1627</span><span class=s2>这个练习主要参考[x86-calling-conventions](https://111qqz.com/2019/01/x86-calling-conventions/), 主要是需要知道ebp的内容是上一个stack frame中的ebp,以及ebp+4是返回地址,ebp+8是第一个参数，还有ebp的初始值是0.
</span><span class=ln>1628</span><span class=s2>
</span><span class=ln>1629</span><span class=s2>最后的实现为:
</span><span class=ln>1630</span><span class=s2>
</span><span class=ln>1631</span><span class=s2>    
</span><span class=ln>1632</span><span class=s2>    int
</span><span class=ln>1633</span><span class=s2>    mon_backtrace(int argc, char **argv, struct Trapframe *tf)
</span><span class=ln>1634</span><span class=s2>    {
</span><span class=ln>1635</span><span class=s2>            // Your code here.
</span><span class=ln>1636</span><span class=s2>            uint32_t *ebp = (uint32_t*)read_ebp();
</span><span class=ln>1637</span><span class=s2>            int i ;
</span><span class=ln>1638</span><span class=s2>            while (ebp)
</span><span class=ln>1639</span><span class=s2>            {
</span><span class=ln>1640</span><span class=s2>                    cprintf(&#34;</span><span class=n>ebp</span><span class=w> </span><span class=n>x</span><span class=w>  </span><span class=n>eip</span><span class=w> </span><span class=n>x</span><span class=w>  </span><span class=s2>&#34;,ebp,*(ebp+1));
</span><span class=ln>1641</span><span class=s2>                    cprintf(&#34;</span><span class=n>args</span><span class=s2>&#34;);
</span><span class=ln>1642</span><span class=s2>                    for ( i = 2 ; i &lt; 7 ; i++)
</span><span class=ln>1643</span><span class=s2>                    {
</span><span class=ln>1644</span><span class=s2>                            cprintf(&#34;</span><span class=w> </span><span class=n>x</span><span class=s2>&#34;,*(ebp+i));
</span><span class=ln>1645</span><span class=s2>                    }
</span><span class=ln>1646</span><span class=s2>                    cprintf(&#34;</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;);
</span><span class=ln>1647</span><span class=s2>                    ebp = (uint32_t*)*ebp;
</span><span class=ln>1648</span><span class=s2>            }
</span><span class=ln>1649</span><span class=s2>            return 0;
</span><span class=ln>1650</span><span class=s2>    }
</span><span class=ln>1651</span><span class=s2>
</span><span class=ln>1652</span><span class=s2>
</span><span class=ln>1653</span><span class=s2>
</span><span class=ln>1654</span><span class=s2>
</span><span class=ln>1655</span><span class=s2>然后是最后一个练习:
</span><span class=ln>1656</span><span class=s2>
</span><span class=ln>1657</span><span class=s2>
</span><span class=ln>1658</span><span class=s2>&lt;blockquote&gt;Exercise 12. Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.
</span><span class=ln>1659</span><span class=s2>
</span><span class=ln>1660</span><span class=s2>In `debuginfo_eip`, where do __STAB_* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:
</span><span class=ln>1661</span><span class=s2>
</span><span class=ln>1662</span><span class=s2>&gt; 
</span><span class=ln>1663</span><span class=s2>&gt; 
</span><span class=ln>1664</span><span class=s2> 	  * look in the file kern/kernel.ld for __STAB_*
</span><span class=ln>1665</span><span class=s2> 	  * run objdump -h obj/kern/kernel
</span><span class=ln>1666</span><span class=s2> 	  * run objdump -G obj/kern/kernel
</span><span class=ln>1667</span><span class=s2> 	  * run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.
</span><span class=ln>1668</span><span class=s2> 	  * see if the bootloader loads the symbol table in memory as part of loading the kernel binary
</span><span class=ln>1669</span><span class=s2>
</span><span class=ln>1670</span><span class=s2>Complete the implementation of `debuginfo_eip` by inserting the call to `stab_binsearch` to find the line number for an address.
</span><span class=ln>1671</span><span class=s2>
</span><span class=ln>1672</span><span class=s2>Add a backtrace command to the kernel monitor, and extend your implementation of `mon_backtrace` to call `debuginfo_eip` and print a line for each stack frame of the form:
</span><span class=ln>1673</span><span class=s2>
</span><span class=ln>1674</span><span class=s2>&gt;     
</span><span class=ln>1675</span><span class=s2>&gt;     K&gt; backtrace
</span><span class=ln>1676</span><span class=s2>&gt;     Stack backtrace:
</span><span class=ln>1677</span><span class=s2>&gt;       ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
</span><span class=ln>1678</span><span class=s2>&gt;              kern/monitor.c:143: monitor+106
</span><span class=ln>1679</span><span class=s2>&gt;       ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
</span><span class=ln>1680</span><span class=s2>&gt;              kern/init.c:49: i386_init+59
</span><span class=ln>1681</span><span class=s2>&gt;       ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
</span><span class=ln>1682</span><span class=s2>&gt;              kern/entry.S:70: &lt;unknown&gt;+0
</span><span class=ln>1683</span><span class=s2>&gt;     K&gt; 
</span><span class=ln>1684</span><span class=s2>&gt;     
</span><span class=ln>1685</span><span class=s2>&gt; 
</span><span class=ln>1686</span><span class=s2>&gt; 
</span><span class=ln>1687</span><span class=s2>Each line gives the file name and line within that file of the stack frame&#39;s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).
</span><span class=ln>1688</span><span class=s2>
</span><span class=ln>1689</span><span class=s2>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.
</span><span class=ln>1690</span><span class=s2>
</span><span class=ln>1691</span><span class=s2>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. `printf(&#34;</span><span class=o>%</span><span class=p>.</span><span class=o>*</span><span class=n>s</span><span class=s2>&#34;, length, string)` prints at most `length` characters of `string`. Take a look at the printf man page to find out why this works.
</span><span class=ln>1692</span><span class=s2>
</span><span class=ln>1693</span><span class=s2>You may find that some functions are missing from the backtrace. For example, you will probably see a call to `monitor()` but not to `runcmd()`. This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 fromGNUMakefile, the backtraces may make more sense (but your kernel will run more slowly).&lt;/blockquote&gt;
</span><span class=ln>1694</span><span class=s2>
</span><span class=ln>1695</span><span class=s2>
</span><span class=ln>1696</span><span class=s2>需要先了解一下stab,简单来说是一种调试数据格式。具体可以参考[stabs](https://en.wikipedia.org/wiki/Stabs) 和 [调试 DWARF 和 STAB 格式](https://www.ibm.com/developerworks/cn/opensource/os-debugging/) 。
</span><span class=ln>1697</span><span class=s2>
</span><span class=ln>1698</span><span class=s2>objdump -h obj/kern/kernel的输出为
</span><span class=ln>1699</span><span class=s2>
</span><span class=ln>1700</span><span class=s2>    
</span><span class=ln>1701</span><span class=s2>    obj/kern/kernel:     file format elf32-i386
</span><span class=ln>1702</span><span class=s2>    
</span><span class=ln>1703</span><span class=s2>    Sections:
</span><span class=ln>1704</span><span class=s2>    Idx Name          Size      VMA       LMA       File off  Algn
</span><span class=ln>1705</span><span class=s2>      0 .text         00001937  f0100000  00100000  00001000  2**4
</span><span class=ln>1706</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, CODE
</span><span class=ln>1707</span><span class=s2>      1 .rodata       0000079c  f0101940  00101940  00002940  2**5
</span><span class=ln>1708</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class=ln>1709</span><span class=s2>      2 .stab         000038e9  f01020dc  001020dc  000030dc  2**2
</span><span class=ln>1710</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class=ln>1711</span><span class=s2>      3 .stabstr      000018f0  f01059c5  001059c5  000069c5  2**0
</span><span class=ln>1712</span><span class=s2>                      CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class=ln>1713</span><span class=s2>      4 .data         0000a300  f0108000  00108000  00009000  2**12
</span><span class=ln>1714</span><span class=s2>                      CONTENTS, ALLOC, LOAD, DATA
</span><span class=ln>1715</span><span class=s2>      5 .bss          00000648  f0112300  00112300  00013300  2**5
</span><span class=ln>1716</span><span class=s2>                      CONTENTS, ALLOC, LOAD, DATA
</span><span class=ln>1717</span><span class=s2>      6 .comment      00000023  00000000  00000000  00013948  2**0
</span><span class=ln>1718</span><span class=s2>                      CONTENTS, READONLY
</span><span class=ln>1719</span><span class=s2>
</span><span class=ln>1720</span><span class=s2>
</span><span class=ln>1721</span><span class=s2>我们可以看到stabstr段的link address(VMA)为f01059c5.
</span><span class=ln>1722</span><span class=s2>
</span><span class=ln>1723</span><span class=s2>然后用gdb调试，先断点到0x10000c,也就是bootloader记载kernel的位置。然后再单步执行几步，直到开启保护模式。此时查看 地址f01059c5，结果如下，说明boot loader在加载kernel的同时也将符号表加载到了内存中
</span><span class=ln>1724</span><span class=s2>
</span><span class=ln>1725</span><span class=s2>    
</span><span class=ln>1726</span><span class=s2>    (gdb) x/8s 0xf01059c5
</span><span class=ln>1727</span><span class=s2>    0xf01059c5:     &#34;&#34;
</span><span class=ln>1728</span><span class=s2>    0xf01059c6:     &#34;</span><span class=err>{</span><span class=n>standard</span><span class=w> </span><span class=n>input</span><span class=err>}</span><span class=s2>&#34;
</span><span class=ln>1729</span><span class=s2>    0xf01059d7:     &#34;</span><span class=n>kern</span><span class=o>/</span><span class=n>entry</span><span class=p>.</span><span class=n>S</span><span class=s2>&#34;
</span><span class=ln>1730</span><span class=s2>    0xf01059e4:     &#34;</span><span class=n>kern</span><span class=o>/</span><span class=n>entrypgdir</span><span class=p>.</span><span class=n>c</span><span class=s2>&#34;
</span><span class=ln>1731</span><span class=s2>    0xf01059f6:     &#34;</span><span class=n>gcc2_compiled</span><span class=p>.</span><span class=s2>&#34;
</span><span class=ln>1732</span><span class=s2>    0xf0105a05:     &#34;</span><span class=kt>int</span><span class=p>:</span><span class=nf>t</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span><span class=o>=</span><span class=nf>r</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span><span class=o>-</span><span class=mi>2147483648</span><span class=p>;</span><span class=mi>2147483647</span><span class=p>;</span><span class=s2>&#34;
</span><span class=ln>1733</span><span class=s2>    0xf0105a2f:     &#34;</span><span class=kt>char</span><span class=p>:</span><span class=nf>t</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span><span class=o>=</span><span class=nf>r</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span><span class=mi>0</span><span class=p>;</span><span class=mi>127</span><span class=p>;</span><span class=s2>&#34;
</span><span class=ln>1734</span><span class=s2>    0xf0105a49:     &#34;</span><span class=k>long</span><span class=w> </span><span class=kt>int</span><span class=p>:</span><span class=nf>t</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>3</span><span class=p>)</span><span class=o>=</span><span class=nf>r</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>3</span><span class=p>);</span><span class=o>-</span><span class=mi>2147483648</span><span class=p>;</span><span class=mi>2147483647</span><span class=p>;</span><span class=s2>&#34;
</span><span class=ln>1735</span><span class=s2>    
</span><span class=ln>1736</span><span class=s2>
</span><span class=ln>1737</span><span class=s2>
</span><span class=ln>1738</span><span class=s2>
</span><span class=ln>1739</span><span class=s2>
</span><span class=ln>1740</span><span class=s2>接下来先看一下我们要补全的kern/kdebug.c文件
</span><span class=ln>1741</span><span class=s2>
</span><span class=ln>1742</span><span class=s2>    
</span><span class=ln>1743</span><span class=s2>    int
</span><span class=ln>1744</span><span class=s2>    debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
</span><span class=ln>1745</span><span class=s2>    {
</span><span class=ln>1746</span><span class=s2>    	const struct Stab *stabs, *stab_end;
</span><span class=ln>1747</span><span class=s2>    	const char *stabstr, *stabstr_end;
</span><span class=ln>1748</span><span class=s2>    	int lfile, rfile, lfun, rfun, lline, rline;
</span><span class=ln>1749</span><span class=s2>    
</span><span class=ln>1750</span><span class=s2>    	// Initialize *info
</span><span class=ln>1751</span><span class=s2>    	info-&gt;eip_file = &#34;</span><span class=o>&lt;</span><span class=n>unknown</span><span class=o>&gt;</span><span class=s2>&#34;;
</span><span class=ln>1752</span><span class=s2>    	info-&gt;eip_line = 0;
</span><span class=ln>1753</span><span class=s2>    	info-&gt;eip_fn_name = &#34;</span><span class=o>&lt;</span><span class=n>unknown</span><span class=o>&gt;</span><span class=s2>&#34;;
</span><span class=ln>1754</span><span class=s2>    	info-&gt;eip_fn_namelen = 9;
</span><span class=ln>1755</span><span class=s2>    	info-&gt;eip_fn_addr = addr;
</span><span class=ln>1756</span><span class=s2>    	info-&gt;eip_fn_narg = 0;
</span><span class=ln>1757</span><span class=s2>    
</span><span class=ln>1758</span><span class=s2>    	// Find the relevant set of stabs
</span><span class=ln>1759</span><span class=s2>    	if (addr &gt;= ULIM) {
</span><span class=ln>1760</span><span class=s2>    		stabs = __STAB_BEGIN__;
</span><span class=ln>1761</span><span class=s2>    		stab_end = __STAB_END__;
</span><span class=ln>1762</span><span class=s2>    		stabstr = __STABSTR_BEGIN__;
</span><span class=ln>1763</span><span class=s2>    		stabstr_end = __STABSTR_END__;
</span><span class=ln>1764</span><span class=s2>    	} else {
</span><span class=ln>1765</span><span class=s2>    		// Can&#39;t search for user-level addresses yet!
</span><span class=ln>1766</span><span class=s2>      	        panic(&#34;</span><span class=k>User</span><span class=w> </span><span class=n>address</span><span class=s2>&#34;);
</span><span class=ln>1767</span><span class=s2>    	}
</span><span class=ln>1768</span><span class=s2>    
</span><span class=ln>1769</span><span class=s2>    	// String table validity checks
</span><span class=ln>1770</span><span class=s2>    	if (stabstr_end &lt;= stabstr || stabstr_end[-1] != 0)
</span><span class=ln>1771</span><span class=s2>    		return -1;
</span><span class=ln>1772</span><span class=s2>    
</span><span class=ln>1773</span><span class=s2>    	// Now we find the right stabs that define the function containing
</span><span class=ln>1774</span><span class=s2>    	// &#39;eip&#39;.  First, we find the basic source file containing &#39;eip&#39;.
</span><span class=ln>1775</span><span class=s2>    	// Then, we look in that source file for the function.  Then we look
</span><span class=ln>1776</span><span class=s2>    	// for the line number.
</span><span class=ln>1777</span><span class=s2>    
</span><span class=ln>1778</span><span class=s2>    	// Search the entire set of stabs for the source file (type N_SO).
</span><span class=ln>1779</span><span class=s2>    	lfile = 0;
</span><span class=ln>1780</span><span class=s2>    	rfile = (stab_end - stabs) - 1;
</span><span class=ln>1781</span><span class=s2>    	stab_binsearch(stabs, &amp;lfile, &amp;rfile, N_SO, addr);
</span><span class=ln>1782</span><span class=s2>    	if (lfile == 0)
</span><span class=ln>1783</span><span class=s2>    		return -1;
</span><span class=ln>1784</span><span class=s2>    
</span><span class=ln>1785</span><span class=s2>    	// Search within that file&#39;s stabs for the function definition
</span><span class=ln>1786</span><span class=s2>    	// (N_FUN).
</span><span class=ln>1787</span><span class=s2>    	lfun = lfile;
</span><span class=ln>1788</span><span class=s2>    	rfun = rfile;
</span><span class=ln>1789</span><span class=s2>    	stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_FUN, addr);
</span><span class=ln>1790</span><span class=s2>    
</span><span class=ln>1791</span><span class=s2>    	if (lfun &lt;= rfun) {
</span><span class=ln>1792</span><span class=s2>    		// stabs[lfun] points to the function name
</span><span class=ln>1793</span><span class=s2>    		// in the string table, but check bounds just in case.
</span><span class=ln>1794</span><span class=s2>    		if (stabs[lfun].n_strx &lt; stabstr_end - stabstr)
</span><span class=ln>1795</span><span class=s2>    			info-&gt;eip_fn_name = stabstr + stabs[lfun].n_strx;
</span><span class=ln>1796</span><span class=s2>    		info-&gt;eip_fn_addr = stabs[lfun].n_value;
</span><span class=ln>1797</span><span class=s2>    		addr -= info-&gt;eip_fn_addr;
</span><span class=ln>1798</span><span class=s2>    		// Search within the function definition for the line number.
</span><span class=ln>1799</span><span class=s2>    		lline = lfun;
</span><span class=ln>1800</span><span class=s2>    		rline = rfun;
</span><span class=ln>1801</span><span class=s2>    	} else {
</span><span class=ln>1802</span><span class=s2>    		// Couldn&#39;t find function stab!  Maybe we&#39;re in an assembly
</span><span class=ln>1803</span><span class=s2>    		// file.  Search the whole file for the line number.
</span><span class=ln>1804</span><span class=s2>    		info-&gt;eip_fn_addr = addr;
</span><span class=ln>1805</span><span class=s2>    		lline = lfile;
</span><span class=ln>1806</span><span class=s2>    		rline = rfile;
</span><span class=ln>1807</span><span class=s2>    	}
</span><span class=ln>1808</span><span class=s2>    	// Ignore stuff after the colon.
</span><span class=ln>1809</span><span class=s2>    	info-&gt;eip_fn_namelen = strfind(info-&gt;eip_fn_name, &#39;:&#39;) - info-&gt;eip_fn_name;
</span><span class=ln>1810</span><span class=s2>    
</span><span class=ln>1811</span><span class=s2>    
</span><span class=ln>1812</span><span class=s2>    	// Search within [lline, rline] for the line number stab.
</span><span class=ln>1813</span><span class=s2>    	// If found, set info-&gt;eip_line to the right line number.
</span><span class=ln>1814</span><span class=s2>    	// If not found, return -1.
</span><span class=ln>1815</span><span class=s2>    	//
</span><span class=ln>1816</span><span class=s2>    	// Hint:
</span><span class=ln>1817</span><span class=s2>    	//	There&#39;s a particular stabs type used for line numbers.
</span><span class=ln>1818</span><span class=s2>    	//	Look at the STABS documentation and &lt;inc/stab.h&gt; to find
</span><span class=ln>1819</span><span class=s2>    	//	which one.
</span><span class=ln>1820</span><span class=s2>    	//   use N_SLINE
</span><span class=ln>1821</span><span class=s2>    
</span><span class=ln>1822</span><span class=s2>    	// Your code here.
</span><span class=ln>1823</span><span class=s2>    
</span><span class=ln>1824</span><span class=s2>    
</span><span class=ln>1825</span><span class=s2>    
</span><span class=ln>1826</span><span class=s2>    
</span><span class=ln>1827</span><span class=s2>    
</span><span class=ln>1828</span><span class=s2>    	// Search backwards from the line number for the relevant filename
</span><span class=ln>1829</span><span class=s2>    	// stab.
</span><span class=ln>1830</span><span class=s2>    	// We can&#39;t just use the &#34;</span><span class=n>lfile</span><span class=s2>&#34; stab because inlined functions
</span><span class=ln>1831</span><span class=s2>    	// can interpolate code from a different file!
</span><span class=ln>1832</span><span class=s2>    	// Such included source files use the N_SOL stab type.
</span><span class=ln>1833</span><span class=s2>    	while (lline &gt;= lfile
</span><span class=ln>1834</span><span class=s2>    	       &amp;&amp; stabs[lline].n_type != N_SOL
</span><span class=ln>1835</span><span class=s2>    	       &amp;&amp; (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
</span><span class=ln>1836</span><span class=s2>    		lline--;
</span><span class=ln>1837</span><span class=s2>    	if (lline &gt;= lfile &amp;&amp; stabs[lline].n_strx &lt; stabstr_end - stabstr)
</span><span class=ln>1838</span><span class=s2>    		info-&gt;eip_file = stabstr + stabs[lline].n_strx;
</span><span class=ln>1839</span><span class=s2>    
</span><span class=ln>1840</span><span class=s2>    
</span><span class=ln>1841</span><span class=s2>    	// Set eip_fn_narg to the number of arguments taken by the function,
</span><span class=ln>1842</span><span class=s2>    	// or 0 if there was no containing function.
</span><span class=ln>1843</span><span class=s2>    	if (lfun &lt; rfun)
</span><span class=ln>1844</span><span class=s2>    		for (lline = lfun + 1;
</span><span class=ln>1845</span><span class=s2>    		     lline &lt; rfun &amp;&amp; stabs[lline].n_type == N_PSYM;
</span><span class=ln>1846</span><span class=s2>    		     lline++)
</span><span class=ln>1847</span><span class=s2>    			info-&gt;eip_fn_narg++;
</span><span class=ln>1848</span><span class=s2>    
</span><span class=ln>1849</span><span class=s2>    	return 0;
</span><span class=ln>1850</span><span class=s2>    }
</span><span class=ln>1851</span><span class=s2>
</span><span class=ln>1852</span><span class=s2>
</span><span class=ln>1853</span><span class=s2>发现要补全的地方...其实很容易写？ 因为在要补全的二分之前，已经做了两次二分...照着写一下就好了。
</span><span class=ln>1854</span><span class=s2>
</span><span class=ln>1855</span><span class=s2>    
</span><span class=ln>1856</span><span class=s2>            stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);
</span><span class=ln>1857</span><span class=s2>            if (lline == 0) return -1;
</span><span class=ln>1858</span><span class=s2>            info-&gt;eip_line = stabs[rline].n_desc;
</span><span class=ln>1859</span><span class=s2>
</span><span class=ln>1860</span><span class=s2>
</span><span class=ln>1861</span><span class=s2>然后就是在monitor.c中修改monitor.c中，调用debuginfo_eip，这部分也很容易。
</span><span class=ln>1862</span><span class=s2>
</span><span class=ln>1863</span><span class=s2>    
</span><span class=ln>1864</span><span class=s2>    int
</span><span class=ln>1865</span><span class=s2>    mon_backtrace(int argc, char **argv, struct Trapframe *tf)
</span><span class=ln>1866</span><span class=s2>    {
</span><span class=ln>1867</span><span class=s2>            // Your code here.
</span><span class=ln>1868</span><span class=s2>            uint32_t *ebp = (uint32_t*)read_ebp();
</span><span class=ln>1869</span><span class=s2>            cprintf(&#34;</span><span class=n>Stack</span><span class=w> </span><span class=n>backtrace</span><span class=p>:</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;);
</span><span class=ln>1870</span><span class=s2>            int i ;
</span><span class=ln>1871</span><span class=s2>            struct Eipdebuginfo info;
</span><span class=ln>1872</span><span class=s2>            while (ebp)
</span><span class=ln>1873</span><span class=s2>            {
</span><span class=ln>1874</span><span class=s2>                    uint32_t eip = ebp[1];
</span><span class=ln>1875</span><span class=s2>                    cprintf(&#34;</span><span class=n>ebp</span><span class=w> </span><span class=n>x</span><span class=w>  </span><span class=n>eip</span><span class=w> </span><span class=n>x</span><span class=w>  </span><span class=s2>&#34;,ebp,eip);
</span><span class=ln>1876</span><span class=s2>                    cprintf(&#34;</span><span class=n>args</span><span class=s2>&#34;);
</span><span class=ln>1877</span><span class=s2>                    for ( i = 2 ; i &lt; 7 ; i++)
</span><span class=ln>1878</span><span class=s2>                    {
</span><span class=ln>1879</span><span class=s2>                            cprintf(&#34;</span><span class=w> </span><span class=n>x</span><span class=s2>&#34;,*(ebp+i));
</span><span class=ln>1880</span><span class=s2>                    }
</span><span class=ln>1881</span><span class=s2>                    cprintf(&#34;</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;);
</span><span class=ln>1882</span><span class=s2>                    int status = debuginfo_eip(eip,&amp;info);
</span><span class=ln>1883</span><span class=s2>                    if (status == 0)
</span><span class=ln>1884</span><span class=s2>                    {
</span><span class=ln>1885</span><span class=s2>     
</span><span class=ln>1886</span><span class=s2>                      cprintf(&#34;</span><span class=o>%</span><span class=n>s</span><span class=p>:</span><span class=o>%</span><span class=n>d</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;,info.eip_file,info.eip_line);
</span><span class=ln>1887</span><span class=s2>                      cprintf(&#34;</span><span class=o>%</span><span class=p>.</span><span class=o>*</span><span class=n>s</span><span class=o>+%</span><span class=n>d</span><span class=err>\</span><span class=n>n</span><span class=s2>&#34;,info.eip_fn_namelen,info.eip_fn_name,eip-info.eip_fn_addr);
</span><span class=ln>1888</span><span class=s2>                    }
</span><span class=ln>1889</span><span class=s2>                    ebp = (uint32_t*)*ebp;
</span><span class=ln>1890</span><span class=s2>            }
</span><span class=ln>1891</span><span class=s2>    
</span><span class=ln>1892</span><span class=s2>    
</span><span class=ln>1893</span><span class=s2>            return 0;
</span><span class=ln>1894</span><span class=s2>    }
</span><span class=ln>1895</span><span class=s2>
</span><span class=ln>1896</span><span class=s2>
</span><span class=ln>1897</span><span class=s2>
</span><span class=ln>1898</span><span class=s2>
</span><span class=ln>1899</span><span class=s2>最终效果大概如下：
</span><span class=ln>1900</span><span class=s2>
</span><span class=ln>1901</span><span class=s2>    
</span><span class=ln>1902</span><span class=s2>    entering test_backtrace 5
</span><span class=ln>1903</span><span class=s2>    entering test_backtrace 4
</span><span class=ln>1904</span><span class=s2>    entering test_backtrace 3
</span><span class=ln>1905</span><span class=s2>    entering test_backtrace 2
</span><span class=ln>1906</span><span class=s2>    entering test_backtrace 1
</span><span class=ln>1907</span><span class=s2>    entering test_backtrace 0
</span><span class=ln>1908</span><span class=s2>    Stack backtrace:
</span><span class=ln>1909</span><span class=s2>    ebp f0110ec8  eip f0100b09  args f0102499 f0102499 f0100b09 00000000 f0100d9c
</span><span class=ln>1910</span><span class=s2>    kern/monitor.c:66: mon_backtrace+26
</span><span class=ln>1911</span><span class=s2>    ebp f0110f18  eip f010008b  args 00000000 00000000 00000000 00000000 f0102238
</span><span class=ln>1912</span><span class=s2>    kern/init.c:19: test_backtrace+75
</span><span class=ln>1913</span><span class=s2>    ebp f0110f38  eip f010006d  args 00000000 00000001 f0110f64 00000000 f0102238
</span><span class=ln>1914</span><span class=s2>    kern/init.c:16: test_backtrace+45
</span><span class=ln>1915</span><span class=s2>    ebp f0110f58  eip f010006d  args 00000001 00000002 f0110f84 00000000 f0102238
</span><span class=ln>1916</span><span class=s2>    kern/init.c:16: test_backtrace+45
</span><span class=ln>1917</span><span class=s2>    ebp f0110f78  eip f010006d  args 00000002 00000003 f0110fa4 00000000 f0102238
</span><span class=ln>1918</span><span class=s2>    kern/init.c:16: test_backtrace+45
</span><span class=ln>1919</span><span class=s2>    ebp f0110f98  eip f010006d  args 00000003 00000004 f0110fc4 00000000 f010226f
</span><span class=ln>1920</span><span class=s2>    kern/init.c:16: test_backtrace+45
</span><span class=ln>1921</span><span class=s2>    ebp f0110fb8  eip f010006d  args 00000004 00000005 f0110fe4 00000000 00000000
</span><span class=ln>1922</span><span class=s2>    kern/init.c:16: test_backtrace+45
</span><span class=ln>1923</span><span class=s2>    ebp f0110fd8  eip f01000f1  args 00000005 00001aac 00000640 00000000 00000000
</span><span class=ln>1924</span><span class=s2>    kern/init.c:43: i386_init+81
</span><span class=ln>1925</span><span class=s2>    ebp f0110ff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003
</span><span class=ln>1926</span><span class=s2>    kern/entry.S:83: &lt;unknown&gt;+0
</span><span class=ln>1927</span><span class=s2>    leaving test_backtrace 0
</span><span class=ln>1928</span><span class=s2>    leaving test_backtrace 1
</span><span class=ln>1929</span><span class=s2>    leaving test_backtrace 2
</span><span class=ln>1930</span><span class=s2>    leaving test_backtrace 3
</span><span class=ln>1931</span><span class=s2>    leaving test_backtrace 4
</span><span class=ln>1932</span><span class=s2>    leaving test_backtrace 5
</span><span class=ln>1933</span><span class=s2>    Welcome to the JOS kernel monitor!
</span><span class=ln>1934</span><span class=s2>    
</span><span class=ln>1935</span><span class=s2>
</span><span class=ln>1936</span><span class=s2>
</span><span class=ln>1937</span><span class=s2>如果有些函数没有出现在上面，可能是被优化掉了，试着修改makefile中的编译选项，把O2或者O1修改为O0。
</span><span class=ln>1938</span><span class=s2>
</span><span class=ln>1939</span><span class=s2>至此，我们完成了lab1的全部内容。完结撒花～
</span><span class=ln>1940</span><span class=s2>
</span><span class=ln>1941</span><span class=s2>虽然做了三十个小时...不过真的收获蛮多，感觉像是在玩解谜游戏，线索就是每个练习前后的那些问题。
</span><span class=ln>1942</span><span class=s2>
</span><span class=ln>1943</span><span class=s2>
</span><span class=ln>1944</span><span class=s2>
</span><span class=ln>1945</span><span class=s2>
</span><span class=ln>1946</span><span class=s2>
</span><span class=ln>1947</span><span class=s2>
</span><span class=ln>1948</span><span class=s2>
</span><span class=ln>1949</span><span class=s2>
</span><span class=ln>1950</span><span class=s2>
</span><span class=ln>1951</span><span class=s2>
</span><span class=ln>1952</span><span class=s2>
</span><span class=ln>1953</span><span class=s2>
</span><span class=ln>1954</span><span class=s2>
</span><span class=ln>1955</span><span class=s2>
</span><span class=ln>1956</span><span class=s2>
</span><span class=ln>1957</span><span class=s2>
</span><span class=ln>1958</span><span class=s2>
</span><span class=ln>1959</span><span class=s2>
</span><span class=ln>1960</span><span class=s2>
</span><span class=ln>1961</span><span class=s2>
</span><span class=ln>1962</span><span class=s2>
</span><span class=ln>1963</span><span class=s2>
</span><span class=ln>1964</span><span class=s2>
</span><span class=ln>1965</span><span class=s2>
</span><span class=ln>1966</span><span class=s2>
</span><span class=ln>1967</span><span class=s2>
</span><span class=ln>1968</span><span class=s2>
</span><span class=ln>1969</span><span class=s2>
</span><span class=ln>1970</span><span class=s2>
</span><span class=ln>1971</span><span class=s2>
</span><span class=ln>1972</span><span class=s2>
</span><span class=ln>1973</span><span class=s2>
</span><span class=ln>1974</span><span class=s2>
</span><span class=ln>1975</span><span class=s2>
</span><span class=ln>1976</span><span class=s2>
</span><span class=ln>1977</span><span class=s2>
</span><span class=ln>1978</span><span class=s2>
</span><span class=ln>1979</span><span class=s2>
</span><span class=ln>1980</span><span class=s2>
</span><span class=ln>1981</span><span class=s2>
</span><span class=ln>1982</span><span class=s2>
</span><span class=ln>1983</span><span class=s2>
</span><span class=ln>1984</span><span class=s2>
</span><span class=ln>1985</span><span class=s2>
</span><span class=ln>1986</span><span class=s2>
</span><span class=ln>1987</span><span class=s2>
</span><span class=ln>1988</span><span class=s2>
</span><span class=ln>1989</span><span class=s2>
</span><span class=ln>1990</span><span class=s2>
</span><span class=ln>1991</span><span class=s2>
</span><span class=ln>1992</span><span class=s2>
</span><span class=ln>1993</span><span class=s2>
</span><span class=ln>1994</span><span class=s2>
</span><span class=ln>1995</span><span class=s2>
</span><span class=ln>1996</span><span class=s2>
</span><span class=ln>1997</span><span class=s2>
</span><span class=ln>1998</span><span class=s2>
</span><span class=ln>1999</span><span class=s2>
</span><span class=ln>2000</span><span class=s2>
</span><span class=ln>2001</span><span class=s2>
</span><span class=ln>2002</span><span class=s2>
</span><span class=ln>2003</span><span class=s2>
</span><span class=ln>2004</span><span class=s2>
</span><span class=ln>2005</span><span class=s2>
</span><span class=ln>2006</span><span class=s2>
</span><span class=ln>2007</span><span class=s2>
</span><span class=ln>2008</span><span class=s2>
</span><span class=ln>2009</span><span class=s2>
</span><span class=ln>2010</span><span class=s2>
</span><span class=ln>2011</span><span class=s2>
</span><span class=ln>2012</span><span class=s2>
</span><span class=ln>2013</span><span class=s2>
</span><span class=ln>2014</span><span class=s2>
</span><span class=ln>2015</span><span class=s2>
</span><span class=ln>2016</span><span class=s2>
</span><span class=ln>2017</span><span class=s2>
</span><span class=ln>2018</span><span class=s2>
</span><span class=ln>2019</span><span class=s2>[routline](http://dict.youdao.com/search?q=routline&amp;keyfrom=chrome.extension) [详细](http://www.youdao.com/search?q=routline&amp;ue=utf8&amp;keyfrom=chrome.extension)X
</span><span class=ln>2020</span><span class=s2>
</span><span class=ln>2021</span><span class=s2>
</span><span class=ln>2022</span><span class=s2>
</span><span class=ln>2023</span><span class=s2>
</span><span class=ln>2024</span><span class=s2>
</span><span class=ln>2025</span><span class=s2>
</span><span class=ln>2026</span><span class=s2>
</span><span class=ln>2027</span><span class=s2>  没有英汉互译结果
</span><span class=ln>2028</span><span class=s2>[请尝试网页搜索](http://www.youdao.com/search?q=routline&amp;ue=utf8&amp;keyfrom=chrome.extension)
</span><span class=ln>2029</span><span class=s2>
</span><span class=ln>2030</span><span class=s2>
</span><span class=ln>2031</span><span class=s2>
</span><span class=ln>2032</span><span class=s2>
</span><span class=ln>2033</span><span class=s2>
</span><span class=ln>2034</span><span class=s2>
</span><span class=ln>2035</span><span class=s2>
</span><span class=ln>2036</span><span class=s2>
</span><span class=ln>2037</span><span class=s2>
</span><span class=ln>2038</span><span class=s2>
</span><span class=ln>2039</span><span class=s2>
</span><span class=ln>2040</span><span class=s2>
</span><span class=ln>2041</span><span class=s2>
</span><span class=ln>2042</span><span class=s2>
</span><span class=ln>2043</span><span class=s2>
</span><span class=ln>2044</span><span class=s2>
</span><span class=ln>2045</span><span class=s2>
</span><span class=ln>2046</span><span class=s2>
</span><span class=ln>2047</span><span class=s2>
</span><span class=ln>2048</span><span class=s2>
</span><span class=ln>2049</span><span class=s2>
</span><span class=ln>2050</span><span class=s2>
</span><span class=ln>2051</span><span class=s2>
</span><span class=ln>2052</span><span class=s2>
</span><span class=ln>2053</span><span class=s2>
</span><span class=ln>2054</span><span class=s2>
</span><span class=ln>2055</span><span class=s2>
</span></code></pre></div>
</div>
<div class=post_comments>
</div>
</article>
<aside class=sidebar>
<section class=sidebar_inner>
<h2>111qqz</h2>
<div class=author_bio>
深度学习框架工程师@Tencent, ex-ICPCer@HUST
</div>
<a href=https://111qqz.com/top/about/ class="button mt-1" role=button title="Read More">Read More</a>
<h2 class=mt-4>Recent Posts</h2>
<ul class=flex-column>
<li>
<a href=https://111qqz.com/2020/06/caffe-notes/ class=nav-link title="caffe 源码阅读笔记">caffe 源码阅读笔记</a>
</li>
<li>
<a href=https://111qqz.com/2019/10/The-Programming-Language-Course/ class=nav-link title="The Programming Language Course">The Programming Language Course</a>
</li>
<li>
<a href=https://111qqz.com/2022/02/2022-to-do-list/ class=nav-link title="2022  TO DO list">2022 TO DO list</a>
</li>
<li>
<a href=https://111qqz.com/2022/03/leveldb-notes-02/ class=nav-link title="levelDB 代码阅读笔记 02 comparator">levelDB 代码阅读笔记 02 comparator</a>
</li>
<li>
<a href=https://111qqz.com/2022/02/leveldb-notes-01/ class=nav-link title="levelDB 代码阅读笔记 01 db.h">levelDB 代码阅读笔记 01 db.h</a>
</li>
<li>
<a href=https://111qqz.com/2022/02/better-blog/ class=nav-link title=博客除草>博客除草</a>
</li>
<li>
<a href=https://111qqz.com/2022/01/goodbye-2021/ class=nav-link title="Goodbye 2021">Goodbye 2021</a>
</li>
<li>
<a href=https://111qqz.com/2021/08/ska_flat_hash_map_notes/ class=nav-link title="ska::flat_hash_map 源码分析">ska::flat_hash_map 源码分析</a>
</li>
</ul>
<div>
<h2 class="mt-4 taxonomy" id=categories-section>Categories</h2>
<nav class=tags_nav>
<a href=https://111qqz.com/categories/acm/ class="post_tag button button_translucent" title=acm>
ACM
<span class=button_tally>913</span>
</a>
<a href=https://111qqz.com/categories/%E5%85%B6%E4%BB%96/ class="post_tag button button_translucent" title=其他>
其他
<span class=button_tally>93</span>
</a>
<a href=https://111qqz.com/categories/deep-learning/ class="post_tag button button_translucent" title=deep-learning>
DEEP-LEARNING
<span class=button_tally>64</span>
</a>
<a href=https://111qqz.com/categories/%E9%9D%A2%E8%AF%95/ class="post_tag button button_translucent" title=面试>
面试
<span class=button_tally>63</span>
</a>
<a href=https://111qqz.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/ class="post_tag button button_translucent" title=随笔杂谈>
随笔杂谈
<span class=button_tally>60</span>
</a>
<a href=https://111qqz.com/categories/%E5%B7%A5%E7%A8%8B/ class="post_tag button button_translucent" title=工程>
工程
<span class=button_tally>48</span>
</a>
<a href=https://111qqz.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/ class="post_tag button button_translucent" title=计算机视觉>
计算机视觉
<span class=button_tally>21</span>
</a>
<a href=https://111qqz.com/categories/mooc/ class="post_tag button button_translucent" title=mooc>
MOOC
<span class=button_tally>15</span>
</a>
<a href=https://111qqz.com/categories/%E4%BC%98%E5%8C%96/ class="post_tag button button_translucent" title=优化>
优化
<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/categories/c++/ class="post_tag button button_translucent" title=c++>
C++
<span class=button_tally>4</span>
</a>
</nav>
</div>
<div>
<h2 class="mt-4 taxonomy" id=tags-section>Tags</h2>
<nav class=tags_nav>
<a href=https://111qqz.com/tags/dp/ class="post_tag button button_translucent" title=dp>
DP
<span class=button_tally>71</span>
</a>
<a href=https://111qqz.com/tags/math/ class="post_tag button button_translucent" title=math>
MATH
<span class=button_tally>49</span>
</a>
<a href=https://111qqz.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/ class="post_tag button button_translucent" title=线段树>
线段树
<span class=button_tally>43</span>
</a>
<a href=https://111qqz.com/tags/brute-force/ class="post_tag button button_translucent" title=brute-force>
BRUTE-FORCE
<span class=button_tally>39</span>
</a>
<a href=https://111qqz.com/tags/leetcode/ class="post_tag button button_translucent" title=leetcode>
LEETCODE
<span class=button_tally>38</span>
</a>
<a href=https://111qqz.com/tags/greedy/ class="post_tag button button_translucent" title=greedy>
GREEDY
<span class=button_tally>36</span>
</a>
<a href=https://111qqz.com/tags/dfs/ class="post_tag button button_translucent" title=dfs>
DFS
<span class=button_tally>34</span>
</a>
<a href=https://111qqz.com/tags/number-theory/ class="post_tag button button_translucent" title=number-theory>
NUMBER-THEORY
<span class=button_tally>27</span>
</a>
<a href=https://111qqz.com/tags/%E6%A8%A1%E6%8B%9F/ class="post_tag button button_translucent" title=模拟>
模拟
<span class=button_tally>24</span>
</a>
<a href=https://111qqz.com/tags/cpp/ class="post_tag button button_translucent" title=cpp>
CPP
<span class=button_tally>23</span>
</a>
<a href=https://111qqz.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/ class="post_tag button button_translucent" title=博弈论>
博弈论
<span class=button_tally>22</span>
</a>
<a href=https://111qqz.com/tags/%E6%9E%84%E9%80%A0/ class="post_tag button button_translucent" title=构造>
构造
<span class=button_tally>22</span>
</a>
<a href=https://111qqz.com/tags/binary-search/ class="post_tag button button_translucent" title=binary-search>
BINARY-SEARCH
<span class=button_tally>21</span>
</a>
<a href=https://111qqz.com/tags/%E6%AF%8D%E5%87%BD%E6%95%B0/ class="post_tag button button_translucent" title=母函数>
母函数
<span class=button_tally>21</span>
</a>
<br>
<div class="post_tags_toggle button">All Tags</div>
<div class=post_tags>
<div class=tags_list>
<a href=https://111qqz.com/tags/01%E8%83%8C%E5%8C%85/ class="post_tag button button_translucent" data-position=9 title=01背包>01背包<span class=button_tally>9</span>
</a>
<a href=https://111qqz.com/tags/2-sat/ class="post_tag button button_translucent" data-position=1 title=2-sat>2-SAT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/6.828/ class="post_tag button button_translucent" data-position=4 title=6.828>6.828<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/ class="post_tag button button_translucent" data-position=4 title=ac自动机>AC自动机<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/anaconda/ class="post_tag button button_translucent" data-position=1 title=anaconda>ANACONDA<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/anchor-box/ class="post_tag button button_translucent" data-position=1 title=anchor-box>ANCHOR-BOX<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/anti-sg/ class="post_tag button button_translucent" data-position=2 title=anti-sg>ANTI-SG<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/archlinux/ class="post_tag button button_translucent" data-position=3 title=archlinux>ARCHLINUX<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/async/ class="post_tag button button_translucent" data-position=1 title=async>ASYNC<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/atom/ class="post_tag button button_translucent" data-position=1 title=atom>ATOM<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/avx/ class="post_tag button button_translucent" data-position=1 title=avx>AVX<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/awk/ class="post_tag button button_translucent" data-position=1 title=awk>AWK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/bfs/ class="post_tag button button_translucent" data-position=20 title=bfs>BFS<span class=button_tally>20</span>
</a>
<a href=https://111qqz.com/tags/binary-search/ class="post_tag button button_translucent" data-position=21 title=binary-search>BINARY-SEARCH<span class=button_tally>21</span>
</a>
<a href=https://111qqz.com/tags/binary-search-tree/ class="post_tag button button_translucent" data-position=1 title=binary-search-tree>BINARY-SEARCH-TREE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/bitset%E4%BC%98%E5%8C%96/ class="post_tag button button_translucent" data-position=4 title=bitset优化>BITSET优化<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/blog/ class="post_tag button button_translucent" data-position=1 title=blog>BLOG<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/boost/ class="post_tag button button_translucent" data-position=1 title=boost>BOOST<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/boosting/ class="post_tag button button_translucent" data-position=1 title=boosting>BOOSTING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/brute-force/ class="post_tag button button_translucent" data-position=39 title=brute-force>BRUTE-FORCE<span class=button_tally>39</span>
</a>
<a href=https://111qqz.com/tags/bsgs/ class="post_tag button button_translucent" data-position=4 title=bsgs>BSGS<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/c++/ class="post_tag button button_translucent" data-position=7 title=c++>C++<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/c++11/ class="post_tag button button_translucent" data-position=1 title=c++11>C++11<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/cache/ class="post_tag button button_translucent" data-position=1 title=cache>CACHE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/caffe/ class="post_tag button button_translucent" data-position=13 title=caffe>CAFFE<span class=button_tally>13</span>
</a>
<a href=https://111qqz.com/tags/caffe2/ class="post_tag button button_translucent" data-position=1 title=caffe2>CAFFE2<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/call-stack/ class="post_tag button button_translucent" data-position=1 title=call-stack>CALL-STACK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/call_once/ class="post_tag button button_translucent" data-position=1 title=call_once>CALL_ONCE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/cdq%E5%88%86%E6%B2%BB/ class="post_tag button button_translucent" data-position=3 title=cdq分治>CDQ分治<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/checkpoint/ class="post_tag button button_translucent" data-position=1 title=checkpoint>CHECKPOINT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/chromebook/ class="post_tag button button_translucent" data-position=1 title=chromebook>CHROMEBOOK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/cmake/ class="post_tag button button_translucent" data-position=1 title=cmake>CMAKE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/codeforces/ class="post_tag button button_translucent" data-position=1 title=codeforces>CODEFORCES<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/condition_variable/ class="post_tag button button_translucent" data-position=1 title=condition_variable>CONDITION_VARIABLE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/convolutional-neural-network/ class="post_tag button button_translucent" data-position=1 title=convolutional-neural-network>CONVOLUTIONAL-NEURAL-NETWORK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/cpp/ class="post_tag button button_translucent" data-position=23 title=cpp>CPP<span class=button_tally>23</span>
</a>
<a href=https://111qqz.com/tags/cs231n/ class="post_tag button button_translucent" data-position=1 title=cs231n>CS231N<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/cs341/ class="post_tag button button_translucent" data-position=1 title=cs341>CS341<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/csapp/ class="post_tag button button_translucent" data-position=7 title=csapp>CSAPP<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/cse599w/ class="post_tag button button_translucent" data-position=1 title=cse599w>CSE599W<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/cuda/ class="post_tag button button_translucent" data-position=6 title=cuda>CUDA<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/cumulative-match-characteristi/ class="post_tag button button_translucent" data-position=1 title=cumulative-match-characteristi>CUMULATIVE-MATCH-CHARACTERISTI<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/d/ class="post_tag button button_translucent" data-position=1 title=d>D<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/dfs/ class="post_tag button button_translucent" data-position=34 title=dfs>DFS<span class=button_tally>34</span>
</a>
<a href=https://111qqz.com/tags/dfs%E5%BA%8F/ class="post_tag button button_translucent" data-position=1 title=dfs序>DFS序<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/dijkstra/ class="post_tag button button_translucent" data-position=2 title=dijkstra>DIJKSTRA<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/discourse/ class="post_tag button button_translucent" data-position=1 title=discourse>DISCOURSE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/dl-sys/ class="post_tag button button_translucent" data-position=1 title=dl-sys>DL-SYS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/docker/ class="post_tag button button_translucent" data-position=5 title=docker>DOCKER<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/dp/ class="post_tag button button_translucent" data-position=71 title=dp>DP<span class=button_tally>71</span>
</a>
<a href=https://111qqz.com/tags/eigen/ class="post_tag button button_translucent" data-position=1 title=eigen>EIGEN<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/end-to-end/ class="post_tag button button_translucent" data-position=1 title=end-to-end>END-TO-END<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/factorial-number-system/ class="post_tag button button_translucent" data-position=1 title=factorial-number-system>FACTORIAL-NUMBER-SYSTEM<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/faster-rcnn/ class="post_tag button button_translucent" data-position=3 title=faster-rcnn>FASTER-RCNN<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/feature-pyramid-networks/ class="post_tag button button_translucent" data-position=1 title=feature-pyramid-networks>FEATURE-PYRAMID-NETWORKS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/fedora/ class="post_tag button button_translucent" data-position=1 title=fedora>FEDORA<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/fish/ class="post_tag button button_translucent" data-position=1 title=fish>FISH<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/floyd/ class="post_tag button button_translucent" data-position=10 title=floyd>FLOYD<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/floyd-%E5%88%A4%E5%9C%88/ class="post_tag button button_translucent" data-position=2 title=floyd-判圈>FLOYD-判圈<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/fpn/ class="post_tag button button_translucent" data-position=1 title=fpn>FPN<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/future/ class="post_tag button button_translucent" data-position=2 title=future>FUTURE<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/g++/ class="post_tag button button_translucent" data-position=1 title=g++>G++<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/galliumos/ class="post_tag button button_translucent" data-position=1 title=galliumos>GALLIUMOS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/gcc/ class="post_tag button button_translucent" data-position=1 title=gcc>GCC<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/gcd/ class="post_tag button button_translucent" data-position=2 title=gcd>GCD<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/gdb/ class="post_tag button button_translucent" data-position=1 title=gdb>GDB<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/gedit/ class="post_tag button button_translucent" data-position=1 title=gedit>GEDIT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/geekos/ class="post_tag button button_translucent" data-position=4 title=geekos>GEEKOS<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/github/ class="post_tag button button_translucent" data-position=1 title=github>GITHUB<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/golang/ class="post_tag button button_translucent" data-position=1 title=golang>GOLANG<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/greedy/ class="post_tag button button_translucent" data-position=36 title=greedy>GREEDY<span class=button_tally>36</span>
</a>
<a href=https://111qqz.com/tags/grpc/ class="post_tag button button_translucent" data-position=2 title=grpc>GRPC<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/grub/ class="post_tag button button_translucent" data-position=1 title=grub>GRUB<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/grundy/ class="post_tag button button_translucent" data-position=1 title=grundy>GRUNDY<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/halide/ class="post_tag button button_translucent" data-position=2 title=halide>HALIDE<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/haproxy/ class="post_tag button button_translucent" data-position=1 title=haproxy>HAPROXY<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/hash/ class="post_tag button button_translucent" data-position=13 title=hash>HASH<span class=button_tally>13</span>
</a>
<a href=https://111qqz.com/tags/hash-map/ class="post_tag button button_translucent" data-position=1 title=hash-map>HASH-MAP<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/haskell/ class="post_tag button button_translucent" data-position=1 title=haskell>HASKELL<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/high-performance-computing/ class="post_tag button button_translucent" data-position=1 title=high-performance-computing>HIGH-PERFORMANCE-COMPUTING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/hugo/ class="post_tag button button_translucent" data-position=2 title=hugo>HUGO<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/image-denoising/ class="post_tag button button_translucent" data-position=1 title=image-denoising>IMAGE-DENOISING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/inception/ class="post_tag button button_translucent" data-position=1 title=inception>INCEPTION<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/java/ class="post_tag button button_translucent" data-position=5 title=java>JAVA<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/javascript/ class="post_tag button button_translucent" data-position=1 title=javascript>JAVASCRIPT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/jdk/ class="post_tag button button_translucent" data-position=1 title=jdk>JDK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/jetson-nano/ class="post_tag button button_translucent" data-position=2 title=jetson-nano>JETSON-NANO<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/json/ class="post_tag button button_translucent" data-position=1 title=json>JSON<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/k-means/ class="post_tag button button_translucent" data-position=2 title=k-means>K-MEANS<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/k-sum/ class="post_tag button button_translucent" data-position=3 title=k-sum>K-SUM<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/k8s/ class="post_tag button button_translucent" data-position=2 title=k8s>K8S<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/kafka/ class="post_tag button button_translucent" data-position=1 title=kafka>KAFKA<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/kd-tree/ class="post_tag button button_translucent" data-position=6 title=kd-tree>KD-TREE<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/km/ class="post_tag button button_translucent" data-position=14 title=km>KM<span class=button_tally>14</span>
</a>
<a href=https://111qqz.com/tags/kmp/ class="post_tag button button_translucent" data-position=19 title=kmp>KMP<span class=button_tally>19</span>
</a>
<a href=https://111qqz.com/tags/km%E7%AE%97%E6%B3%95/ class="post_tag button button_translucent" data-position=1 title=km算法>KM算法<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/latent-factor-model/ class="post_tag button button_translucent" data-position=1 title=latent-factor-model>LATENT-FACTOR-MODEL<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/latex/ class="post_tag button button_translucent" data-position=1 title=latex>LATEX<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/lazy%E6%A0%87%E8%AE%B0/ class="post_tag button button_translucent" data-position=9 title=lazy标记>LAZY标记<span class=button_tally>9</span>
</a>
<a href=https://111qqz.com/tags/lca/ class="post_tag button button_translucent" data-position=10 title=lca>LCA<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/leetcode/ class="post_tag button button_translucent" data-position=38 title=leetcode>LEETCODE<span class=button_tally>38</span>
</a>
<a href=https://111qqz.com/tags/leveldb/ class="post_tag button button_translucent" data-position=6 title=leveldb>LEVELDB<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/linear-classification/ class="post_tag button button_translucent" data-position=1 title=linear-classification>LINEAR-CLASSIFICATION<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/linux/ class="post_tag button button_translucent" data-position=9 title=linux>LINUX<span class=button_tally>9</span>
</a>
<a href=https://111qqz.com/tags/linux-mint/ class="post_tag button button_translucent" data-position=1 title=linux-mint>LINUX-MINT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/lis/ class="post_tag button button_translucent" data-position=5 title=lis>LIS<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/log/ class="post_tag button button_translucent" data-position=2 title=log>LOG<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/lru/ class="post_tag button button_translucent" data-position=2 title=lru>LRU<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/lstm/ class="post_tag button button_translucent" data-position=1 title=lstm>LSTM<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/lua/ class="post_tag button button_translucent" data-position=1 title=lua>LUA<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/lucas%E5%AE%9A%E7%90%86/ class="post_tag button button_translucent" data-position=3 title=lucas定理>LUCAS定理<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/manacher/ class="post_tag button button_translucent" data-position=4 title=manacher>MANACHER<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/manjaro/ class="post_tag button button_translucent" data-position=1 title=manjaro>MANJARO<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/map/ class="post_tag button button_translucent" data-position=6 title=map>MAP<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/math/ class="post_tag button button_translucent" data-position=49 title=math>MATH<span class=button_tally>49</span>
</a>
<a href=https://111qqz.com/tags/mean-average-precision/ class="post_tag button button_translucent" data-position=1 title=mean-average-precision>MEAN-AVERAGE-PRECISION<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/metric-learning/ class="post_tag button button_translucent" data-position=1 title=metric-learning>METRIC-LEARNING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/miller-rabin%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/ class="post_tag button button_translucent" data-position=1 title=miller-rabin素数测试>MILLER-RABIN素数测试<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/model-convertor/ class="post_tag button button_translucent" data-position=1 title=model-convertor>MODEL-CONVERTOR<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/model-distillation/ class="post_tag button button_translucent" data-position=1 title=model-distillation>MODEL-DISTILLATION<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/modern-cpp/ class="post_tag button button_translucent" data-position=8 title=modern-cpp>MODERN-CPP<span class=button_tally>8</span>
</a>
<a href=https://111qqz.com/tags/move/ class="post_tag button button_translucent" data-position=1 title=move>MOVE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/mpi/ class="post_tag button button_translucent" data-position=1 title=mpi>MPI<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/mst/ class="post_tag button button_translucent" data-position=6 title=mst>MST<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/murmurhash/ class="post_tag button button_translucent" data-position=1 title=murmurhash>MURMURHASH<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/mutual-learning/ class="post_tag button button_translucent" data-position=1 title=mutual-learning>MUTUAL-LEARNING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/mysql/ class="post_tag button button_translucent" data-position=3 title=mysql>MYSQL<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/nerdtree/ class="post_tag button button_translucent" data-position=1 title=nerdtree>NERDTREE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/network/ class="post_tag button button_translucent" data-position=1 title=network>NETWORK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/nim%E6%B8%B8%E6%88%8F/ class="post_tag button button_translucent" data-position=4 title=nim游戏>NIM游戏<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/nlp/ class="post_tag button button_translucent" data-position=1 title=nlp>NLP<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/nms/ class="post_tag button button_translucent" data-position=1 title=nms>NMS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/non-local-means/ class="post_tag button button_translucent" data-position=1 title=non-local-means>NON-LOCAL-MEANS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/non-local-neural-networks/ class="post_tag button button_translucent" data-position=1 title=non-local-neural-networks>NON-LOCAL-NEURAL-NETWORKS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/number-theory/ class="post_tag button button_translucent" data-position=27 title=number-theory>NUMBER-THEORY<span class=button_tally>27</span>
</a>
<a href=https://111qqz.com/tags/numpy/ class="post_tag button button_translucent" data-position=1 title=numpy>NUMPY<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/object-detection/ class="post_tag button button_translucent" data-position=2 title=object-detection>OBJECT-DETECTION<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/once_flag/ class="post_tag button button_translucent" data-position=1 title=once_flag>ONCE_FLAG<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/packaged_task/ class="post_tag button button_translucent" data-position=1 title=packaged_task>PACKAGED_TASK<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/pca/ class="post_tag button button_translucent" data-position=2 title=pca>PCA<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/pipline/ class="post_tag button button_translucent" data-position=1 title=pipline>PIPLINE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/pose-driven/ class="post_tag button button_translucent" data-position=1 title=pose-driven>POSE-DRIVEN<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/prim/ class="post_tag button button_translucent" data-position=1 title=prim>PRIM<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/promise/ class="post_tag button button_translucent" data-position=2 title=promise>PROMISE<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/property_tree/ class="post_tag button button_translucent" data-position=1 title=property_tree>PROPERTY_TREE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/protobuf/ class="post_tag button button_translucent" data-position=1 title=protobuf>PROTOBUF<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/python/ class="post_tag button button_translucent" data-position=10 title=python>PYTHON<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/pytorch/ class="post_tag button button_translucent" data-position=1 title=pytorch>PYTORCH<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/qt/ class="post_tag button button_translucent" data-position=5 title=qt>QT<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/react/ class="post_tag button button_translucent" data-position=3 title=react>REACT<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/redux/ class="post_tag button button_translucent" data-position=1 title=redux>REDUX<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/reid/ class="post_tag button button_translucent" data-position=3 title=reid>REID<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/resnet/ class="post_tag button button_translucent" data-position=2 title=resnet>RESNET<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/retinanet/ class="post_tag button button_translucent" data-position=1 title=retinanet>RETINANET<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/rmq/ class="post_tag button button_translucent" data-position=17 title=rmq>RMQ<span class=button_tally>17</span>
</a>
<a href=https://111qqz.com/tags/rnn/ class="post_tag button button_translucent" data-position=1 title=rnn>RNN<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/set/ class="post_tag button button_translucent" data-position=8 title=set>SET<span class=button_tally>8</span>
</a>
<a href=https://111qqz.com/tags/sg%E5%87%BD%E6%95%B0/ class="post_tag button button_translucent" data-position=12 title=sg函数>SG函数<span class=button_tally>12</span>
</a>
<a href=https://111qqz.com/tags/shadowsocks/ class="post_tag button button_translucent" data-position=2 title=shadowsocks>SHADOWSOCKS<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/simd/ class="post_tag button button_translucent" data-position=1 title=simd>SIMD<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/simhash/ class="post_tag button button_translucent" data-position=1 title=simhash>SIMHASH<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/similarity-learning/ class="post_tag button button_translucent" data-position=1 title=similarity-learning>SIMILARITY-LEARNING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/single-state-detector/ class="post_tag button button_translucent" data-position=1 title=single-state-detector>SINGLE-STATE-DETECTOR<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/sj%E5%AE%9A%E7%90%86/ class="post_tag button button_translucent" data-position=2 title=sj定理>SJ定理<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/sliding-windows/ class="post_tag button button_translucent" data-position=1 title=sliding-windows>SLIDING-WINDOWS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/slim/ class="post_tag button button_translucent" data-position=1 title=slim>SLIM<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/sort/ class="post_tag button button_translucent" data-position=1 title=sort>SORT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/sortings/ class="post_tag button button_translucent" data-position=3 title=sortings>SORTINGS<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/spfa/ class="post_tag button button_translucent" data-position=10 title=spfa>SPFA<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/spring/ class="post_tag button button_translucent" data-position=2 title=spring>SPRING<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/ssd/ class="post_tag button button_translucent" data-position=1 title=ssd>SSD<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/steam/ class="post_tag button button_translucent" data-position=2 title=steam>STEAM<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/stl/ class="post_tag button button_translucent" data-position=16 title=stl>STL<span class=button_tally>16</span>
</a>
<a href=https://111qqz.com/tags/stream/ class="post_tag button button_translucent" data-position=1 title=stream>STREAM<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/supercomputing/ class="post_tag button button_translucent" data-position=1 title=supercomputing>SUPERCOMPUTING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/supervisor/ class="post_tag button button_translucent" data-position=1 title=supervisor>SUPERVISOR<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/tarjan/ class="post_tag button button_translucent" data-position=2 title=tarjan>TARJAN<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/tensorflow/ class="post_tag button button_translucent" data-position=12 title=tensorflow>TENSORFLOW<span class=button_tally>12</span>
</a>
<a href=https://111qqz.com/tags/tensorrt/ class="post_tag button button_translucent" data-position=2 title=tensorrt>TENSORRT<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/threading-building-blocks/ class="post_tag button button_translucent" data-position=1 title=threading-building-blocks>THREADING-BUILDING-BLOCKS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/thrust/ class="post_tag button button_translucent" data-position=1 title=thrust>THRUST<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/tree/ class="post_tag button button_translucent" data-position=7 title=tree>TREE<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/trie/ class="post_tag button button_translucent" data-position=7 title=trie>TRIE<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/triplet-loss/ class="post_tag button button_translucent" data-position=1 title=triplet-loss>TRIPLET-LOSS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/tsp/ class="post_tag button button_translucent" data-position=2 title=tsp>TSP<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/two-pointer/ class="post_tag button button_translucent" data-position=5 title=two-pointer>TWO-POINTER<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/typescript/ class="post_tag button button_translucent" data-position=1 title=typescript>TYPESCRIPT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/unicode/ class="post_tag button button_translucent" data-position=1 title=unicode>UNICODE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/variadic-function/ class="post_tag button button_translucent" data-position=1 title=variadic-function>VARIADIC-FUNCTION<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/variety/ class="post_tag button button_translucent" data-position=1 title=variety>VARIETY<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/vector/ class="post_tag button button_translucent" data-position=2 title=vector>VECTOR<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/vim/ class="post_tag button button_translucent" data-position=6 title=vim>VIM<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/vundle/ class="post_tag button button_translucent" data-position=1 title=vundle>VUNDLE<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/whitening/ class="post_tag button button_translucent" data-position=1 title=whitening>WHITENING<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/wordpress/ class="post_tag button button_translucent" data-position=1 title=wordpress>WORDPRESS<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/youcompleteme/ class="post_tag button button_translucent" data-position=1 title=youcompleteme>YOUCOMPLETEME<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/yuv-image-format/ class="post_tag button button_translucent" data-position=1 title=yuv-image-format>YUV-IMAGE-FORMAT<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/ class="post_tag button button_translucent" data-position=1 title=一致性哈希>一致性哈希<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%B8%89%E5%88%86/ class="post_tag button button_translucent" data-position=2 title=三分>三分<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/ class="post_tag button button_translucent" data-position=4 title=中国剩余定理>中国剩余定理<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/ class="post_tag button button_translucent" data-position=5 title=主席树>主席树<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E4%B9%B1%E6%90%9E/ class="post_tag button button_translucent" data-position=6 title=乱搞>乱搞<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E5%88%86/ class="post_tag button button_translucent" data-position=2 title=二分>二分<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/ class="post_tag button button_translucent" data-position=5 title=二分图>二分图<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/ class="post_tag button button_translucent" data-position=4 title=二分图匹配>二分图匹配<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D/ class="post_tag button button_translucent" data-position=14 title=二分图最佳匹配>二分图最佳匹配<span class=button_tally>14</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/ class="post_tag button button_translucent" data-position=4 title=二次剩余>二次剩余<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%AE%B5%E6%A0%91/ class="post_tag button button_translucent" data-position=1 title=二维线段树>二维线段树<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/ class="post_tag button button_translucent" data-position=1 title=二进制>二进制<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/ class="post_tag button button_translucent" data-position=1 title=二项式定理>二项式定理<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/ class="post_tag button button_translucent" data-position=1 title=交互题>交互题<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%A4%E5%8F%89%E6%9F%93%E8%89%B2%E6%B3%95/ class="post_tag button button_translucent" data-position=6 title=交叉染色法>交叉染色法<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/%E4%BA%AC%E4%B8%9C/ class="post_tag button button_translucent" data-position=1 title=京东>京东<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/ class="post_tag button button_translucent" data-position=4 title=优先队列>优先队列<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/ class="post_tag button button_translucent" data-position=5 title=传递闭包>传递闭包<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/ class="post_tag button button_translucent" data-position=4 title=位运算>位运算<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/ class="post_tag button button_translucent" data-position=1 title=依赖注入>依赖注入<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%81%8F%E5%BA%A6/ class="post_tag button button_translucent" data-position=1 title=偏度>偏度<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%85%89%E6%B5%81%E6%B3%95/ class="post_tag button button_translucent" data-position=1 title=光流法>光流法<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/ class="post_tag button button_translucent" data-position=1 title=内存屏障>内存屏障<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%87%B8%E5%8C%85/ class="post_tag button button_translucent" data-position=1 title=凸包>凸包<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%88%86%E5%9D%97/ class="post_tag button button_translucent" data-position=12 title=分块>分块<span class=button_tally>12</span>
</a>
<a href=https://111qqz.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F/ class="post_tag button button_translucent" data-position=1 title=分布式消息系统>分布式消息系统<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%88%86%E6%B2%BB/ class="post_tag button button_translucent" data-position=2 title=分治>分治<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/ class="post_tag button button_translucent" data-position=1 title=分类讨论>分类讨论<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%89%8D%E7%AB%AF/ class="post_tag button button_translucent" data-position=6 title=前端>前端<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/ class="post_tag button button_translucent" data-position=17 title=前缀和>前缀和<span class=button_tally>17</span>
</a>
<a href=https://111qqz.com/tags/%E5%89%A9%E4%BD%99%E7%B3%BB/ class="post_tag button button_translucent" data-position=3 title=剩余系>剩余系<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E5%89%AA%E6%9E%9D/ class="post_tag button button_translucent" data-position=1 title=剪枝>剪枝<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8A%A8%E6%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91/ class="post_tag button button_translucent" data-position=1 title=动态线段树>动态线段树<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7/ class="post_tag button button_translucent" data-position=1 title=动态连通性>动态连通性<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8B%BE%E8%82%A1%E6%95%B0/ class="post_tag button button_translucent" data-position=1 title=勾股数>勾股数<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/ class="post_tag button button_translucent" data-position=15 title=匈牙利算法>匈牙利算法<span class=button_tally>15</span>
</a>
<a href=https://111qqz.com/tags/%E5%8C%BA%E9%97%B4dp/ class="post_tag button button_translucent" data-position=13 title=区间dp>区间DP<span class=button_tally>13</span>
</a>
<a href=https://111qqz.com/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/ class="post_tag button button_translucent" data-position=1 title=区间合并>区间合并<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7/ class="post_tag button button_translucent" data-position=2 title=区间第k大>区间第K大<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%8C%BA%E9%97%B4%E8%AE%A1%E6%95%B0/ class="post_tag button button_translucent" data-position=1 title=区间计数>区间计数<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/ class="post_tag button button_translucent" data-position=1 title=协同过滤>协同过滤<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96/ class="post_tag button button_translucent" data-position=1 title=单调性优化>单调性优化<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/ class="post_tag button button_translucent" data-position=10 title=单调栈>单调栈<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/ class="post_tag button button_translucent" data-position=3 title=单调队列>单调队列<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/ class="post_tag button button_translucent" data-position=22 title=博弈论>博弈论<span class=button_tally>22</span>
</a>
<a href=https://111qqz.com/tags/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/ class="post_tag button button_translucent" data-position=1 title=反向传播>反向传播<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%8F%8D%E7%B4%A0%E6%95%B0/ class="post_tag button button_translucent" data-position=5 title=反素数>反素数<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ class="post_tag button button_translucent" data-position=5 title=可持久化数据结构>可持久化数据结构<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/ class="post_tag button button_translucent" data-position=1 title=右值引用>右值引用<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%90%8C%E6%9E%84/ class="post_tag button button_translucent" data-position=1 title=同构>同构<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%90%8E%E7%BC%80%E5%92%8C/ class="post_tag button button_translucent" data-position=1 title=后缀和>后缀和<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/ class="post_tag button button_translucent" data-position=10 title=后缀数组>后缀数组<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/ class="post_tag button button_translucent" data-position=13 title=后缀自动机>后缀自动机<span class=button_tally>13</span>
</a>
<a href=https://111qqz.com/tags/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/ class="post_tag button button_translucent" data-position=1 title=哥德巴赫猜想>哥德巴赫猜想<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%9B%9B%E5%8F%89%E6%A0%91/ class="post_tag button button_translucent" data-position=1 title=四叉树>四叉树<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/ class="post_tag button button_translucent" data-position=2 title=回文串>回文串<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/ class="post_tag button button_translucent" data-position=7 title=回文自动机>回文自动机<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ class="post_tag button button_translucent" data-position=2 title=图像处理>图像处理<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%9B%BE%E8%AE%BA/ class="post_tag button button_translucent" data-position=16 title=图论>图论<span class=button_tally>16</span>
</a>
<a href=https://111qqz.com/tags/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/ class="post_tag button button_translucent" data-position=1 title=图论基础>图论基础<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%9F%BA%E7%A1%80%E5%9B%BE%E8%AE%BA/ class="post_tag button button_translucent" data-position=1 title=基础图论>基础图论<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/ class="post_tag button button_translucent" data-position=14 title=字符串>字符串<span class=button_tally>14</span>
</a>
<a href=https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2dp/ class="post_tag button button_translucent" data-position=1 title=字符串dp>字符串DP<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E5%90%8C%E6%9E%84/ class="post_tag button button_translucent" data-position=4 title=字符串循环同构>字符串循环同构<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/ class="post_tag button button_translucent" data-position=2 title=完全背包>完全背包<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/ class="post_tag button button_translucent" data-position=1 title=完美转发>完美转发<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/ class="post_tag button button_translucent" data-position=5 title=容斥原理>容斥原理<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E5%AF%B9%E6%8B%8D/ class="post_tag button button_translucent" data-position=1 title=对拍>对拍<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%B0%84%E7%BA%BF%E6%B3%95/ class="post_tag button button_translucent" data-position=1 title=射线法>射线法<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%B0%BA%E5%8F%96/ class="post_tag button button_translucent" data-position=2 title=尺取>尺取<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/ class="post_tag button button_translucent" data-position=10 title=尺取法>尺取法<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9Fhash/ class="post_tag button button_translucent" data-position=2 title=局部敏感hash>局部敏感HASH<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%B3%B0%E5%BA%A6/ class="post_tag button button_translucent" data-position=1 title=峰度>峰度<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/ class="post_tag button button_translucent" data-position=1 title=差分序列>差分序列<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%A5%95/ class="post_tag button button_translucent" data-position=5 title=巴什博奕>巴什博奕<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/ class="post_tag button button_translucent" data-position=9 title=并查集>并查集<span class=button_tally>9</span>
</a>
<a href=https://111qqz.com/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/ class="post_tag button button_translucent" data-position=2 title=并行计算>并行计算<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/ class="post_tag button button_translucent" data-position=1 title=康托展开>康托展开<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/%E9%80%86%E5%B1%95%E5%BC%80/ class="post_tag button button_translucent" data-position=2 title=康托展开/逆展开>康托展开/逆展开<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80/ class="post_tag button button_translucent" data-position=1 title=循环展开>循环展开<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/ class="post_tag button button_translucent" data-position=8 title=循环节>循环节<span class=button_tally>8</span>
</a>
<a href=https://111qqz.com/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/ class="post_tag button button_translucent" data-position=1 title=快速乘>快速乘<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/ class="post_tag button button_translucent" data-position=20 title=快速幂>快速幂<span class=button_tally>20</span>
</a>
<a href=https://111qqz.com/tags/%E5%BF%AB%E9%80%9F%E7%AD%9B/ class="post_tag button button_translucent" data-position=2 title=快速筛>快速筛<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%80%9D%E7%BB%B4/ class="post_tag button button_translucent" data-position=1 title=思维>思维<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/ class="post_tag button button_translucent" data-position=7 title=思维题>思维题<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E6%89%93%E8%A1%A8/ class="post_tag button button_translucent" data-position=2 title=打表>打表<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%89%A9%E5%B1%95bsgs/ class="post_tag button button_translucent" data-position=2 title=扩展bsgs>扩展BSGS<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/ class="post_tag button button_translucent" data-position=8 title=扩展欧几里得算法>扩展欧几里得算法<span class=button_tally>8</span>
</a>
<a href=https://111qqz.com/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/ class="post_tag button button_translucent" data-position=4 title=扫描线>扫描线<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/ class="post_tag button button_translucent" data-position=6 title=抽屉原理>抽屉原理<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/%E6%8B%86%E7%82%B9/ class="post_tag button button_translucent" data-position=6 title=拆点>拆点<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/ class="post_tag button button_translucent" data-position=7 title=拓扑排序>拓扑排序<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/ class="post_tag button button_translucent" data-position=2 title=括号匹配>括号匹配<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%8C%87%E6%95%B0%E5%BE%AA%E7%8E%AF%E8%8A%82/ class="post_tag button button_translucent" data-position=7 title=指数循环节>指数循环节<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/ class="post_tag button button_translucent" data-position=8 title=排列组合>排列组合<span class=button_tally>8</span>
</a>
<a href=https://111qqz.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/ class="post_tag button button_translucent" data-position=2 title=推荐系统>推荐系统<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%95%B0%E4%BD%8Ddp/ class="post_tag button button_translucent" data-position=17 title=数位dp>数位DP<span class=button_tally>17</span>
</a>
<a href=https://111qqz.com/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/ class="post_tag button button_translucent" data-position=2 title=数值计算方法>数值计算方法<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ class="post_tag button button_translucent" data-position=2 title=数字图像处理>数字图像处理<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/ class="post_tag button button_translucent" data-position=1 title=数据压缩>数据压缩<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ class="post_tag button button_translucent" data-position=2 title=数据结构>数据结构<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%95%B0%E8%AE%BA/ class="post_tag button button_translucent" data-position=2 title=数论>数论<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%96%87%E6%98%8E/ class="post_tag button button_translucent" data-position=1 title=文明>文明<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/ class="post_tag button button_translucent" data-position=7 title=斐波那契>斐波那契<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/ class="post_tag button button_translucent" data-position=3 title=斜率优化>斜率优化<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%8E%AF/ class="post_tag button button_translucent" data-position=3 title=无向图的环>无向图的环<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/ class="post_tag button button_translucent" data-position=4 title=曼哈顿距离>曼哈顿距离<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/ class="post_tag button button_translucent" data-position=1 title=最大独立集>最大独立集<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C/ class="post_tag button button_translucent" data-position=3 title=最大连续区间和>最大连续区间和<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/ class="post_tag button button_translucent" data-position=1 title=最大连续和>最大连续和<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/ class="post_tag button button_translucent" data-position=2 title=最小生成树>最小生成树<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/ class="post_tag button button_translucent" data-position=7 title=最小表示法>最小表示法<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/ class="post_tag button button_translucent" data-position=3 title=最小覆盖子串>最小覆盖子串<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E7%9F%A9%E5%BD%A2/ class="post_tag button button_translucent" data-position=1 title=最小覆盖子矩形>最小覆盖子矩形<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/ class="post_tag button button_translucent" data-position=2 title=最小路径覆盖>最小路径覆盖<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96/ class="post_tag button button_translucent" data-position=2 title=最小顶点覆盖>最小顶点覆盖<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/ class="post_tag button button_translucent" data-position=5 title=最短路>最短路<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/ class="post_tag button button_translucent" data-position=1 title=最长下降子序列>最长下降子序列<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E4%B8%B2/ class="post_tag button button_translucent" data-position=4 title=最长公共字串>最长公共字串<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E8%B7%AF/ class="post_tag button button_translucent" data-position=2 title=最长路>最长路<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%9E%84%E9%80%A0/ class="post_tag button button_translucent" data-position=22 title=构造>构造<span class=button_tally>22</span>
</a>
<a href=https://111qqz.com/tags/%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/ class="post_tag button button_translucent" data-position=4 title=枚举子集>枚举子集<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/ class="post_tag button button_translucent" data-position=1 title=染色问题>染色问题<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%A0%88/ class="post_tag button button_translucent" data-position=1 title=栈>栈<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%A0%91%E5%A5%97%E6%A0%91/ class="post_tag button button_translucent" data-position=1 title=树套树>树套树<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%A0%91%E5%BD%A2dp/ class="post_tag button button_translucent" data-position=6 title=树形dp>树形DP<span class=button_tally>6</span>
</a>
<a href=https://111qqz.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/ class="post_tag button button_translucent" data-position=20 title=树状数组>树状数组<span class=button_tally>20</span>
</a>
<a href=https://111qqz.com/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/ class="post_tag button button_translucent" data-position=9 title=树的直径>树的直径<span class=button_tally>9</span>
</a>
<a href=https://111qqz.com/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/ class="post_tag button button_translucent" data-position=1 title=梯度下降>梯度下降<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%A6%82%E7%8E%87/ class="post_tag button button_translucent" data-position=13 title=概率>概率<span class=button_tally>13</span>
</a>
<a href=https://111qqz.com/tags/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/ class="post_tag button button_translucent" data-position=1 title=模型转换>模型转换<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%A8%A1%E6%8B%9F/ class="post_tag button button_translucent" data-position=24 title=模拟>模拟<span class=button_tally>24</span>
</a>
<a href=https://111qqz.com/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/ class="post_tag button button_translucent" data-position=5 title=模拟退火>模拟退火<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/ class="post_tag button button_translucent" data-position=2 title=次小生成树>次小生成树<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/ class="post_tag button button_translucent" data-position=4 title=欧拉函数>欧拉函数<span class=button_tally>4</span>
</a>
<a href=https://111qqz.com/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/ class="post_tag button button_translucent" data-position=1 title=欧拉路>欧拉路<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/ class="post_tag button button_translucent" data-position=1 title=正则表达式>正则表达式<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%AF%8D%E5%87%BD%E6%95%B0/ class="post_tag button button_translucent" data-position=21 title=母函数>母函数<span class=button_tally>21</span>
</a>
<a href=https://111qqz.com/tags/%E6%B0%B4/ class="post_tag button button_translucent" data-position=5 title=水>水<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E6%B0%B4%E9%A2%98/ class="post_tag button button_translucent" data-position=7 title=水题>水题<span class=button_tally>7</span>
</a>
<a href=https://111qqz.com/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/ class="post_tag button button_translucent" data-position=3 title=泰勒展开>泰勒展开<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E6%B8%B8%E6%88%8F/ class="post_tag button button_translucent" data-position=1 title=游戏>游戏<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/ class="post_tag button button_translucent" data-position=1 title=激活函数>激活函数<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%88%AC%E5%B1%B1%E6%B3%95/ class="post_tag button button_translucent" data-position=1 title=爬山法>爬山法<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%88%AC%E8%99%AB/ class="post_tag button button_translucent" data-position=2 title=爬虫>爬虫<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E7%8A%B6%E5%8E%8Bdp/ class="post_tag button button_translucent" data-position=1 title=状压dp>状压DP<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/ class="post_tag button button_translucent" data-position=1 title=状态压缩>状态压缩<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%99%BE%E5%BA%A6/ class="post_tag button button_translucent" data-position=1 title=百度>百度<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%9F%A9%E5%BD%A2%E5%91%A8%E9%95%BF%E5%B9%B6/ class="post_tag button button_translucent" data-position=1 title=矩形周长并>矩形周长并<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/ class="post_tag button button_translucent" data-position=1 title=矩形面积交>矩形面积交<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%9F%A9%E9%98%B5/ class="post_tag button button_translucent" data-position=20 title=矩阵>矩阵<span class=button_tally>20</span>
</a>
<a href=https://111qqz.com/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/ class="post_tag button button_translucent" data-position=5 title=矩阵快速幂>矩阵快速幂<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/ class="post_tag button button_translucent" data-position=11 title=离散化>离散化<span class=button_tally>11</span>
</a>
<a href=https://111qqz.com/tags/%E7%AC%A6%E5%8F%B7%E5%8F%AF%E8%A7%81%E6%80%A7/ class="post_tag button button_translucent" data-position=1 title=符号可见性>符号可见性<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%AC%A6%E5%8F%B7%E8%A1%A8/ class="post_tag button button_translucent" data-position=1 title=符号表>符号表<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/ class="post_tag button button_translucent" data-position=1 title=第二类斯特林数>第二类斯特林数<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%AD%9B%E6%B3%95/ class="post_tag button button_translucent" data-position=1 title=筛法>筛法<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/ class="post_tag button button_translucent" data-position=1 title=系统调用>系统调用<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/ class="post_tag button button_translucent" data-position=43 title=线段树>线段树<span class=button_tally>43</span>
</a>
<a href=https://111qqz.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/ class="post_tag button button_translucent" data-position=10 title=组合数学>组合数学<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/ class="post_tag button button_translucent" data-position=1 title=组合模式>组合模式<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/ class="post_tag button button_translucent" data-position=1 title=组成原理>组成原理<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BB%86%E8%8A%82%E9%A2%98/ class="post_tag button button_translucent" data-position=1 title=细节题>细节题<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BB%93%E8%AE%BA%E9%A2%98/ class="post_tag button button_translucent" data-position=1 title=结论题>结论题<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/ class="post_tag button button_translucent" data-position=1 title=编译原理>编译原理<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/ class="post_tag button button_translucent" data-position=1 title=编译器>编译器<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/ class="post_tag button button_translucent" data-position=1 title=置换群>置换群<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/ class="post_tag button button_translucent" data-position=10 title=莫队算法>莫队算法<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/ class="post_tag button button_translucent" data-position=1 title=蓄水池抽样>蓄水池抽样<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%99%9A%E7%82%B9/ class="post_tag button button_translucent" data-position=1 title=虚点>虚点<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/ class="post_tag button button_translucent" data-position=5 title=裴蜀定理>裴蜀定理<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/ class="post_tag button button_translucent" data-position=1 title=观察者模式>观察者模式<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/ class="post_tag button button_translucent" data-position=2 title=计数排序>计数排序<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/ class="post_tag button button_translucent" data-position=10 title=计数问题>计数问题<span class=button_tally>10</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/ class="post_tag button button_translucent" data-position=20 title=计算几何>计算几何<span class=button_tally>20</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/ class="post_tag button button_translucent" data-position=2 title=计算机视觉>计算机视觉<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%A1%E7%BB%84/ class="post_tag button button_translucent" data-position=1 title=计组>计组<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/ class="post_tag button button_translucent" data-position=2 title=记忆化搜索>记忆化搜索<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ class="post_tag button button_translucent" data-position=2 title=设计模式>设计模式<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%B4%9D%E5%B0%94%E6%95%B0/ class="post_tag button button_translucent" data-position=2 title=贝尔数>贝尔数<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%B4%AA%E5%BF%83/ class="post_tag button button_translucent" data-position=1 title=贪心>贪心<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/ class="post_tag button button_translucent" data-position=3 title=费马小定理>费马小定理<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E8%B4%B9%E9%A9%AC%E7%82%B9/ class="post_tag button button_translucent" data-position=1 title=费马点>费马点<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%B7%AF%E5%BE%84dp/ class="post_tag button button_translucent" data-position=1 title=路径dp>路径DP<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%B7%AF%E5%BE%84%E8%AE%B0%E5%BD%95/ class="post_tag button button_translucent" data-position=2 title=路径记录>路径记录<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%BD%AC%E7%A7%BB%E8%AF%AD%E4%B9%89/ class="post_tag button button_translucent" data-position=1 title=转移语义>转移语义<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E8%BE%93%E5%85%A5%E6%8C%82/ class="post_tag button button_translucent" data-position=2 title=输入挂>输入挂<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86/ class="post_tag button button_translucent" data-position=2 title=辛普森积分>辛普森积分<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/ class="post_tag button button_translucent" data-position=2 title=连通性>连通性<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E9%80%86%E5%85%83/ class="post_tag button button_translucent" data-position=5 title=逆元>逆元<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/ class="post_tag button button_translucent" data-position=5 title=逆序对>逆序对<span class=button_tally>5</span>
</a>
<a href=https://111qqz.com/tags/%E9%80%92%E6%8E%A8/ class="post_tag button button_translucent" data-position=2 title=递推>递推<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E9%87%8D%E5%BF%83/ class="post_tag button button_translucent" data-position=1 title=重心>重心<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/ class="post_tag button button_translucent" data-position=1 title=链式前向星>链式前向星<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/ class="post_tag button button_translucent" data-position=2 title=错排公式>错排公式<span class=button_tally>2</span>
</a>
<a href=https://111qqz.com/tags/%E9%9D%A2%E8%AF%95/ class="post_tag button button_translucent" data-position=1 title=面试>面试<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/ class="post_tag button button_translucent" data-position=3 title=面试经历>面试经历<span class=button_tally>3</span>
</a>
<a href=https://111qqz.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/ class="post_tag button button_translucent" data-position=1 title=预处理>预处理<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/ class="post_tag button button_translucent" data-position=1 title=高斯消元>高斯消元<span class=button_tally>1</span>
</a>
<a href=https://111qqz.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/ class="post_tag button button_translucent" data-position=2 title=高精度>高精度<span class=button_tally>2</span>
</a>
<div class=tags_sort><span title="sort alphabetically">[A~Z]</span><span title="sort by count">[0~9]</span>
</div>
<span class=tags_hide><svg class="icon"><use xlink:href="#closeme"/></svg></span>
</div>
</div>
</nav>
</div>
</section>
</aside>
</div>
</main><svg width="0" height="0" class="hidden"><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter"><path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68.0 01-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043.0-1.924.366-2.643 1.078A3.56 3.56.0 008.766 5.383c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846.0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47.0.929.273 1.705.82 2.388a3.623 3.623.0 002.115 1.291c-.312.08-.641.118-.979.118-.312.0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652.0 002.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422.0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139.0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77.0 001.172-4.892v-.468a7.788 7.788.0 001.84-1.921 8.142 8.142.0 01-2.11.593z"/></symbol><symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar"><path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916.0 1e2v352c0 33.084 26.916 60 60 60h392c33.084.0 60-26.916 60-60V1e2c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028.0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028.0 20 8.972 20 20v48z"/><path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github"><path d="M255.968 5.329C114.624 5.329.0 120.401.0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384.0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008.0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992.0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584.0 34.368-.32 62.08-.32 70.496.0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab"><path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6.0L12.3 74.8z"/><path d="M12.3 74.7.5 111c-1 3.2.0 6.8 3 8.8l101.6 74-92.5-119z"/><path d="M105 193.7l-38.6-119h-54l92.7 119z"/><path d="M105 193.7l38.7-119H66.4l38.7 119z"/><path d="M105 193.7l38.7-119H198l-93 119z"/><path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/><path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6.0L198 74.8z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss"><circle cx="3.429" cy="20.571" r="3.429"/><path d="M11.429 24h4.57C15.999 15.179 8.821 8.001.0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"/><path d="M24 24C24 10.766 13.234.0.0.0v4.571c10.714.0 19.43 8.714 19.43 19.429z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h362c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="arrow"><path d="M604.501 440.509 325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298.0 36.323s26.223 10.024 36.222.0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221.0 9.999-10.023 9.999-26.298.0-36.323z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly"><path d="M504.971 239.029 448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c19.851.0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002.0 004e2 320v108c0 19.851-16.149 36-36 36h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c46.318.0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568.0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255.0 24-10.745 24-24S205.255.0 192 0h-44c-46.318.0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568.0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255.0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851.0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002.0 00112 192z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy"><path d="M23 2.75A2.75 2.75.0 0020.25.0H8.75A2.75 2.75.0 006 2.75v13.5A2.75 2.75.0 008.75 19h11.5A2.75 2.75.0 0023 16.25zM18.25 14.5h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5z"/><path d="M8.75 20.5A4.255 4.255.0 014.5 16.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752.0 001 5.25v16A2.752 2.752.0 003.75 24h12a2.752 2.752.0 002.75-2.75v-.75z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme"><path d="M284.286 256.002 506.143 34.144c7.811-7.811 7.811-20.475.0-28.285-7.811-7.81-20.475-7.811-28.285.0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285.0-7.81 7.811-7.811 20.475.0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475.0 28.285a19.938 19.938.0 0014.143 5.857 19.94 19.94.0 0014.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475.0-28.285L284.286 256.002z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu"><path d="M492 236H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954.0 96s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram"><path d="M12 2.163c3.204.0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849.0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204.0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849.0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zM12 0C8.741.0 8.333.014 7.053.072c-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948s.014 3.668.072 4.948c.2 4.358 2.618 6.78 6.98 6.98C8.333 23.986 8.741 24 12 24s3.668-.014 4.948-.072c4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948s-.014-3.667-.072-4.947c-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403.0-6.162 2.759-6.162 6.162S8.597 18.163 12 18.163s6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zM12 16c-2.209.0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796.0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795.0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="youtube"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23.0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23.0C23.512 20.55 23.971 18.196 24 12c-.029-6.185-.484-8.549-4.385-8.816zM9 16V8l8 3.993L9 16z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow"><path d="M21 27v-8h3v11H0V19h3v8h18z"/><path d="M17.1.2 15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8 13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing"><path d="M18.188.0c-.517.0-.741.325-.927.66.0.0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211.0.375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016.0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894.0 21.686.0h-3.498zM3.648 4.74c-.211.0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016.0.021L1.86 16.051c-.099.188-.093.381.0.529.085.142.239.234.45.234h3.461c.518.0.766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></symbol></svg>
<footer class=footer>
<div class="footer_inner wrap pale">
<img src=https://111qqz.com/icons/apple-touch-icon.png class="icon icon_2 transparent" alt=111qqz的小窝>
<p>Copyright&nbsp;<span class=year></span>&nbsp;111QQZ的小窝. All Rights Reserved</p><a class=to_top href=#documentTop><svg class="icon"><use xlink:href="#arrow"/></svg>
</a>
</div>
</footer>
<script type=text/javascript src=https://111qqz.com/js/bundle.min.3742850abb67c28705371634ec61c30ef94e46abe2abff0aa69f2d0719bdb4593a80e5d4f8c3e1c6ef6f860b354b7dc6dcc282abc788a7fc2798b214527a5207.js integrity="sha512-N0KFCrtnwocFNxY07GHDDvlORqviq/8Kpp8tBxm9tFk6gOXU+MPhxu9vhgs1S33G3MKCq8eIp/wnmLIUUnpSBw==" crossorigin=anonymous></script>
</body>
</html>