---
author: 111qqz
date: 2015-07-28 15:48:00+00:00
draft: false
title: (BC 一周年) hdu 5312  Sequence
type: post
url: /2015/07/hdu5312/
categories:
- ACM
tags:
- math
---


比赛的时候没做出来.这道题需要用到的一个重要的性质是,任意一个自然数可以表示成至多三个三角形数(1,3,6,10,15.....)的和(orz高斯)然后也有推广到任意自然数可以表示成k个k角形数的和的结论(费马提出了猜想,柯西给了证明)然后官方题解说的比较好:


<blockquote>**这个题看上去是一个贪心, 但是这个贪心显然是错的. 事实上这道题目很简单, 先判断1个是否可以, 然后判断2个是否可以. 之后找到最小的k (k > 2)k(k>2), 使得(m - k) mod 6 = 0(m−k)mod6=0即可.**

**证明如下: 3n(n-1)+1 = 6(n*(n-1)/2)+13n(n−1)+1=6(n∗(n−1)/2)+1, 注意到n*(n-1)/2n∗(n−1)/2是三角形数, 任意一个自然数最多只需要3个三角形数即可表示. 枚举需要kk个, 那么显然m=6(km=6(k个三角形数的和)+k)+k, 由于k ge 3k≥3, 只要m-km−k是6的倍数就一定是有解的.**

**事实上, 打个表应该也能发现规律.**</blockquote>


另外还有一点,特判一个和两个的情况时,一个的好判断,扫一遍就好了

两个的话,由于这个数列是递增的,我们可以从两边往中间,算是一个不错的优化,具体见代码.



```c++
    /*************************************************************************
    	> File Name: code/nv/#ann/1003.cpp
    	> Author: 111qqz
    	> Email: rkz2013@126.com
    	> Created Time: 2015年07月28日 星期二 23时03分09秒
     ************************************************************************/
    
    #include<iostream>
    #include<iomanip>
    #include<cstdio>
    #include<algorithm>
    #include<cmath>
    #include<cstring>
    #include<string>
    #include<map>
    #include<set>
    #include<queue>
    #include<vector>
    #include<stack>
    #define y0 abc111qqz
    #define y1 hust111qqz
    #define yn hez111qqz
    #define j1 cute111qqz
    #define tm crazy111qqz
    #define lr dying111qqz
    using namespace std;
    #define REP(i, n) for (int i=0;i<int(n);++i)
    typedef long long LL;
    typedef unsigned long long ULL;
    const int inf = 0x7fffffff;
    const int N=1E5+7;
    int k,m,f[N];
    void init()
    {
        for ( int i = 1 ; i <N; i++)
        {
    	f[i]=3*i*(i-1)+1;
    	if (f[i]>1000000000)
    	{
    	    k = i-1;
    	    break;
    	}
        }
    }
    int solve (int x)
    {
        for ( int i = 1 ; f[i]<=x ; i++ )
        {
    	if (x==f[i])
    	    return 1;
        }
        int j = k;
        for ( int i = 1 ; i <= k-1&&f[i]<x ; i++)
        {
    	while(f[i]+f[j]>x) j--;
    	if (f[i]+f[j]==x) return 2;
        }
        for ( int i = 3 ; i <= m ; i++ )
        {
    	if ((m-i)%6==0)
    	    return i;
        }
    }
    int main()
    {
        int T;
        init();
        cin>>T;
        int ans;
        while (T--)
        {
    
    	scanf("%d",&m);
    	cout<<solve(m)<<endl;
    
        }
    
    	return 0;
    }
    


```
