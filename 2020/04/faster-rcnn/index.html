<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="111qqz的小窝"><meta property="og:type" content="article"><meta property="og:image" content="https://111qqz.github.io/img/2.png"><meta property="twitter:image" content="https://111qqz.github.io/img/2.png"><meta name=title content="Faster Rcnn 目标检测算法"><meta property="og:title" content="Faster Rcnn 目标检测算法"><meta property="twitter:title" content="Faster Rcnn 目标检测算法"><meta name=description content><meta property="og:description" content><meta property="twitter:description" content><meta property="twitter:card" content="summary"><meta name=keyword content="ACM,111qqz,商汤科技,hust,华中科技大学"><link rel="shortcut icon" href=/img/favicon.ico><title>Faster Rcnn 目标检测算法-111qqz的小窝</title><link rel=canonical href=/2020/04/faster-rcnn><link rel=stylesheet href=/css/iDisqus.min.css><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/zanshang.css><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/docco.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/hux-blog.min-custom.css><script data-ad-client=ca-pub-2010211964550865 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=/>111qqz的小窝</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>Home</a></li><li><a href=/categories/acm/>ACM-ICPC</a></li><li><a href=/categories/deep-learning/>深度学习</a></li><li><a href=/categories/mooc/>公开课</a></li><li><a href=/categories/%e5%85%b6%e4%bb%96/>其他</a></li><li><a href=/top/about/>ABOUT</a></li><li><a href=/search>SEARCH <img src=/img/search.png height=15 style=cursor:pointer alt=Search></a></li></ul></div></div></div></nav><script>var $body=document.body;var $toggle=document.querySelector('.navbar-toggle');var $navbar=document.querySelector('#huxblog_navbar');var $collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic)
function handleMagic(e){if($navbar.className.indexOf('in')>0){$navbar.className=" ";setTimeout(function(){if($navbar.className.indexOf('in')<0){$collapse.style.height="0px"}},400)}else{$collapse.style.height="auto"
$navbar.className+=" in";}}</script><style type=text/css>header.intro-header{background-image:url(/img/2.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/faster-rcnn title=faster-rcnn>faster-rcnn</a></div><h1>Faster Rcnn 目标检测算法</h1><h2 class=subheading></h2><span class=meta>Posted by
111qqz
on
Sunday, April 5, 2020
<span id=/2020/04/faster-rcnn class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span><i class="fa fa-eye"></i><span class=old-visitors-count style=display:none></span><span class=leancloud-visitors-count></span></span><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("UzhnsgbPvx1RFb2kNXUHpPtf-gzGzoHsz","OXOvoYGuwMv70Os5GOgaGEWT");</script><script type=text/javascript>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");console.log("aaa")
$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';var OLD_COUNT_CONTAINER_REF='.old-visitors-count';for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){var oldCountSpan=$(element).find(OLD_COUNT_CONTAINER_REF).text();if(oldCountSpan!=''){countSpan.text(0+parseInt(oldCountSpan));}else{countSpan.text(0);}}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);con
query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);var OLD_COUNT_CONTAINER_REF='.old-visitors-count';var $element=$(document.getElementById(url));var oldCountSpan=$element.find(OLD_COUNT_CONTAINER_REF).text();if(oldCountSpan!=''){newcounter.set("time",parseInt(oldCountSpan)+1);}else{newcounter.set("time",1);}
newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");console.log("miao miao miao")
if($('.leancloud_visitors').length==1){addCount(Counter);}else{showTime(Counter);}});</script></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><header><h2>TOC</h2></header><nav id=TableOfContents><ol><li><a href=#背景>背景</a><ol><li><a href=#rcnn>rcnn</a></li><li><a href=#fast-rcnn>fast rcnn</a></li><li><a href=#faster-rcnn>faster rcnn</a></li></ol></li><li><a href=#region-proposal-networkrpn>Region proposal network(RPN)</a><ol><li><a href=#anchor>anchor</a></li><li><a href=#rpn-网络结构>RPN 网络结构</a></li></ol></li><li><a href=#roi-pooling和roi-align-pooling>ROI Pooling和ROI Align Pooling</a></li><li><a href=#总结>总结</a></li><li><a href=#参考链接>参考链接</a></li></ol></nav><h2 id=背景>背景</h2><p>2019年对了好几次faster rcnn，第一次是赛事之窗项目和北京的同事，对齐sdk和训练的实现。
第二次是被tensorRT4和tensorRT5之间默认参数不一致的问题坑了一下。
第三次是被caffe proto中roi align 的默认参数坑了。</p><p>虽然debug了这么多次，踩了一堆坑，但是一段时间不用，细节就会慢慢不记得了。因此来记录一下。</p><hr><p>faster rcnn，是一种"two stage"的目标检测算法。</p><p>所谓"two stage&rdquo;，是说在实际进行目标检测之前，先会通过某种"region proposals&rdquo; algorithm，来获得一定数量的RoI(Regions of Interest),我们下一阶段要检测的obejct有极大可能被包含在这些RoI. 这种"Region based"的方法是对基于"sliding windows"方法的极大改进，因为不需要遍历每一个可能的位置以及crop大小，只需要对这些RoI进行检测，有效地减小了计算量。</p><p>下面简单说一下这一类"Region based"方法的历史脉络</p><h3 id=rcnn>rcnn</h3><p>RCNN的做法是通过一种传统方法"selective search"来得到若干RoI,然后把每一个RoI，后面接CNN进行后续的检测。 显然，这个方法的问题在于计算量非常大。</p><blockquote><p>selective search的策略是，既然是不知道尺度是怎样的，那我们就尽可能遍历所有的尺度，但是不同于暴力穷举，我们可以先得到小尺度的区域，然后一次次合并得到大的尺寸.</p></blockquote><h3 id=fast-rcnn>fast rcnn</h3><p>明眼人可以看出，rcnn计算量过大的原因之一是做了非常多的重复计算。</p><p>因此fast rcnn做的改进是，与其把每一个通过"selective search"得到的RoI在原图上crop出来送进CNN,不如先让整张图过一段CNN,然后把通过"selective search"在原图上得到的RoI先映射到这段CNN的某个conv feature map. 相当于这部分CNN只做了一次，与RoI数量无关，极大地减小了计算量。</p><h3 id=faster-rcnn>faster rcnn</h3><p>终于轮到主角登场了。 fast rcnn极大提高了检测的速度。 然后发现，速度的瓶颈已经不在后续的检测部分了，而是在于“region proposals” algorithm.</p><p>于是，faster-rcnn提出"Region proposal network"来替代"selective search&rdquo;,进一步提高了检测速度。</p><p>放一张结构图，非常清楚。
<img src=https://i.loli.net/2020/04/05/3PV9M287obyiWhv.png alt=rcnn系列结构图.png></p><h2 id=region-proposal-networkrpn>Region proposal network(RPN)</h2><h3 id=anchor>anchor</h3><p>介绍RPN网络首先就要介绍一下anchor.</p><p>（被坑过一次，某个足球项目上，training和inference用的anchor竟然是不一致的。。）</p><p>其实anchor这个概念很简单，用大白话说就是，根据要检测的物体的形状（高矮胖瘦等），<strong>预先</strong> 设置一些不同尺寸（高矮胖瘦）的粗略的框，然后对这些框做一个二分类，判断前景还是背景，同时做bbox regression 来微调坐标，最终得到proposals.</p><p>设置anchor的思路其实就是修改了proposals的默认位置为生成的anchors的位置。对这些anchors进行微调总要比从零开始生成容易得多。</p><p>要注意的是，anchors是在进入网络前预先生成的。
实际项目中，通常设置长宽比为[1:1,2:1,1:2]三种比例，然后通过 <a href=https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py>generate_anchors.py</a> 来生成anchors.</p><p><strong>值得强调的是，anchor的生成是与图像内容无关的．无论图像内容是什么，生成的anchor都是固定的，而RPN网络的目标就是去学习哪些anchor是好的anchor，以及学习到一组"regression coefficients"来用在好的anchor上，从而变成更好的anchor.</strong></p><h3 id=rpn-网络结构>RPN 网络结构</h3><p><img src=https://i.loli.net/2020/04/06/PjJhbluRQUBWr1T.png alt=rpn结构.png></p><p>最下面的conv feature map是经过一段CNN得到的，这部分和fast rcnn是类似的。</p><p>这一段CNN是RPN和后面的detector共用的。</p><p>然后用一个n*n的滑动窗口(原paper中用的3*3，其实就是做了个3*3的卷积)，得到256维的feature(是因为这个conv feature map的深度是256). 然后对于cls和reg 分别做两个fc,输入分别为2和4. 由于一共有k个anchor，因此一共输入2k个scores和4k个coordinates.</p><p>最初我的一个疑惑是，为什么这里要做softmax二分类呢？ 为什么要关心背景的置信度呢？</p><p>原文中的解释是:</p><blockquote><p>For simplicity we implement the cls layer as a two-class
softmax layer. Alternatively, one may use logistic regression to
produce k scores.</p></blockquote><p>实际上，torchvision中rpn的时间就是使用了logistic来计算k个score. 代码如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RPNHead</span>(nn<span style=color:#f92672>.</span>Module):
    <span style=color:#e6db74></span><span style=color:#e6db74>&#34;&#34;&#34;</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    Adds a simple RPN Head with classification and regression heads</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    Arguments:</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        in_channels (int): number of channels of the input feature</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        num_anchors (int): number of anchors to be predicted</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    </span><span style=color:#e6db74>&#34;&#34;&#34;</span>

    <span style=color:#66d9ef>def</span> __init__(self, in_channels, num_anchors):
        super(RPNHead, self)<span style=color:#f92672>.</span>__init__()
        self<span style=color:#f92672>.</span>conv <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Conv2d(
            in_channels, in_channels, kernel_size<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>, stride<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, padding<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
        )
        self<span style=color:#f92672>.</span>cls_logits <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Conv2d(in_channels, num_anchors, kernel_size<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, stride<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
        self<span style=color:#f92672>.</span>bbox_pred <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Conv2d(
            in_channels, num_anchors <span style=color:#f92672>*</span> <span style=color:#ae81ff>4</span>, kernel_size<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, stride<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
        )

        <span style=color:#66d9ef>for</span> l <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>children():
            torch<span style=color:#f92672>.</span>nn<span style=color:#f92672>.</span>init<span style=color:#f92672>.</span>normal_(l<span style=color:#f92672>.</span>weight, std<span style=color:#f92672>=</span><span style=color:#ae81ff>0.01</span>)
            torch<span style=color:#f92672>.</span>nn<span style=color:#f92672>.</span>init<span style=color:#f92672>.</span>constant_(l<span style=color:#f92672>.</span>bias, <span style=color:#ae81ff>0</span>)

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, x):
        <span style=color:#75715e># type: (List[Tensor])</span>
        logits <span style=color:#f92672>=</span> []
        bbox_reg <span style=color:#f92672>=</span> []
        <span style=color:#66d9ef>for</span> feature <span style=color:#f92672>in</span> x:
            t <span style=color:#f92672>=</span> F<span style=color:#f92672>.</span>relu(self<span style=color:#f92672>.</span>conv(feature))
            logits<span style=color:#f92672>.</span>append(self<span style=color:#f92672>.</span>cls_logits(t))
            bbox_reg<span style=color:#f92672>.</span>append(self<span style=color:#f92672>.</span>bbox_pred(t))
        <span style=color:#66d9ef>return</span> logits, bbox_reg
</code></pre></div><p>可以看到 self.cls_logits的输出是num_anchors 个。</p><p>如果是使用softmax来得到2k个score,这里还有一个坑是softmax的维度</p><blockquote><p>&ldquo;Number of labels must match number of predictions; "
&ldquo;e.g., if softmax axis == 1 and prediction shape is (N, C, H, W), "
&ldquo;label count (number of labels) must be N*H*W, "
&ldquo;with integer values in {0, 1, &mldr;, C-1}.";</p></blockquote><p>所以经常要在softmax前后进行reshape
把[1, 2x9, H, W] 变成 [1, 2, 9xH, W]。“腾空”出来一个维度以便softmax分类，之后再reshape回复原状。</p><p>接下来我们整体看一下RPN的pytorch实现。 由于我们不关心training的过程，为了代码的整洁，这里省略了
assign_targets_to_anchors和compute_loss 两个函数的代码。</p><p>这个代码的核心在于 filter_proposals 这个函数，相当于对proposals做一些后处理。比如去掉出了边界框的，去掉太小的proposals,然后根据NMS来再去掉一些。 这里有几个参数要注意:</p><ul><li>pre_nms_top_n. 在进行nms之前保留的proposals个数</li><li>post_nms_top_n. nms之后保留的proposals个数</li></ul><p>（某足球项目，nms还有decode_box 这里的bug和北京的同事联调了半个月才全部解决Orz.. 醉生梦死的经历。 这部分实现其实细节还挺多的，又没有统一的标准，很容易造成误差&mldr; 下次有机会讲一下。</p><p><strong>然后forward函数就相当于某些框架中的(比如caffe)proposal layer.</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RegionProposalNetwork</span>(torch<span style=color:#f92672>.</span>nn<span style=color:#f92672>.</span>Module):
    <span style=color:#e6db74></span><span style=color:#e6db74>&#34;&#34;&#34;</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    Implements Region Proposal Network (RPN).</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    Arguments:</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        anchor_generator (AnchorGenerator): module that generates the anchors for a set of feature</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            maps.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        head (nn.Module): module that computes the objectness and regression deltas</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        fg_iou_thresh (float): minimum IoU between the anchor and the GT box so that they can be</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            considered as positive during training of the RPN.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        bg_iou_thresh (float): maximum IoU between the anchor and the GT box so that they can be</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            considered as negative during training of the RPN.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        batch_size_per_image (int): number of anchors that are sampled during training of the RPN</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            for computing the loss</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        positive_fraction (float): proportion of positive anchors in a mini-batch during training</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            of the RPN</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        pre_nms_top_n (Dict[int]): number of proposals to keep before applying NMS. It should</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            contain two fields: training and testing, to allow for different values depending</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            on training or evaluation</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        post_nms_top_n (Dict[int]): number of proposals to keep after applying NMS. It should</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            contain two fields: training and testing, to allow for different values depending</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            on training or evaluation</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        nms_thresh (float): NMS threshold used for postprocessing the RPN proposals</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    </span><span style=color:#e6db74>&#34;&#34;&#34;</span>
    __annotations__ <span style=color:#f92672>=</span> {
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>box_coder</span><span style=color:#e6db74>&#39;</span>: det_utils<span style=color:#f92672>.</span>BoxCoder,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>proposal_matcher</span><span style=color:#e6db74>&#39;</span>: det_utils<span style=color:#f92672>.</span>Matcher,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>fg_bg_sampler</span><span style=color:#e6db74>&#39;</span>: det_utils<span style=color:#f92672>.</span>BalancedPositiveNegativeSampler,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>pre_nms_top_n</span><span style=color:#e6db74>&#39;</span>: Dict[str, int],
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>post_nms_top_n</span><span style=color:#e6db74>&#39;</span>: Dict[str, int],
    }

    <span style=color:#66d9ef>def</span> __init__(self,
                 anchor_generator,
                 head,
                 <span style=color:#75715e>#</span>
                 fg_iou_thresh, bg_iou_thresh,
                 batch_size_per_image, positive_fraction,
                 <span style=color:#75715e>#</span>
                 pre_nms_top_n, post_nms_top_n, nms_thresh):
        super(RegionProposalNetwork, self)<span style=color:#f92672>.</span>__init__()
        self<span style=color:#f92672>.</span>anchor_generator <span style=color:#f92672>=</span> anchor_generator
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> head
        self<span style=color:#f92672>.</span>box_coder <span style=color:#f92672>=</span> det_utils<span style=color:#f92672>.</span>BoxCoder(weights<span style=color:#f92672>=</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>))

        <span style=color:#75715e># used during training</span>
        self<span style=color:#f92672>.</span>box_similarity <span style=color:#f92672>=</span> box_ops<span style=color:#f92672>.</span>box_iou

        self<span style=color:#f92672>.</span>proposal_matcher <span style=color:#f92672>=</span> det_utils<span style=color:#f92672>.</span>Matcher(
            fg_iou_thresh,
            bg_iou_thresh,
            allow_low_quality_matches<span style=color:#f92672>=</span>True,
        )

        self<span style=color:#f92672>.</span>fg_bg_sampler <span style=color:#f92672>=</span> det_utils<span style=color:#f92672>.</span>BalancedPositiveNegativeSampler(
            batch_size_per_image, positive_fraction
        )
        <span style=color:#75715e># used during testing</span>
        self<span style=color:#f92672>.</span>_pre_nms_top_n <span style=color:#f92672>=</span> pre_nms_top_n
        self<span style=color:#f92672>.</span>_post_nms_top_n <span style=color:#f92672>=</span> post_nms_top_n
        self<span style=color:#f92672>.</span>nms_thresh <span style=color:#f92672>=</span> nms_thresh
        self<span style=color:#f92672>.</span>min_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e-3</span>

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pre_nms_top_n</span>(self):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>training:
            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_pre_nms_top_n[<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>training</span><span style=color:#e6db74>&#39;</span>]
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_pre_nms_top_n[<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>testing</span><span style=color:#e6db74>&#39;</span>]

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>post_nms_top_n</span>(self):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>training:
            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_post_nms_top_n[<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>training</span><span style=color:#e6db74>&#39;</span>]
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_post_nms_top_n[<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>testing</span><span style=color:#e6db74>&#39;</span>]

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>assign_targets_to_anchors</span>(self, anchors, targets):
        <span style=color:#75715e># type: (List[Tensor], List[Dict[str, Tensor]])</span>
        <span style=color:#66d9ef>pass</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_get_top_n_idx</span>(self, objectness, num_anchors_per_level):
        <span style=color:#75715e># type: (Tensor, List[int])</span>
        r <span style=color:#f92672>=</span> []
        offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
        <span style=color:#66d9ef>for</span> ob <span style=color:#f92672>in</span> objectness<span style=color:#f92672>.</span>split(num_anchors_per_level, <span style=color:#ae81ff>1</span>):
            <span style=color:#66d9ef>if</span> torchvision<span style=color:#f92672>.</span>_is_tracing():
                num_anchors, pre_nms_top_n <span style=color:#f92672>=</span> _onnx_get_num_anchors_and_pre_nms_top_n(ob, self<span style=color:#f92672>.</span>pre_nms_top_n())
            <span style=color:#66d9ef>else</span>:
                num_anchors <span style=color:#f92672>=</span> ob<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>1</span>]
                pre_nms_top_n <span style=color:#f92672>=</span> min(self<span style=color:#f92672>.</span>pre_nms_top_n(), num_anchors)
            _, top_n_idx <span style=color:#f92672>=</span> ob<span style=color:#f92672>.</span>topk(pre_nms_top_n, dim<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
            r<span style=color:#f92672>.</span>append(top_n_idx <span style=color:#f92672>+</span> offset)
            offset <span style=color:#f92672>+</span><span style=color:#f92672>=</span> num_anchors
        <span style=color:#66d9ef>return</span> torch<span style=color:#f92672>.</span>cat(r, dim<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_proposals</span>(self, proposals, objectness, image_shapes, num_anchors_per_level):
        <span style=color:#75715e># type: (Tensor, Tensor, List[Tuple[int, int]], List[int])</span>
        num_images <span style=color:#f92672>=</span> proposals<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>]
        device <span style=color:#f92672>=</span> proposals<span style=color:#f92672>.</span>device
        <span style=color:#75715e># do not backprop throught objectness</span>
        objectness <span style=color:#f92672>=</span> objectness<span style=color:#f92672>.</span>detach()
        objectness <span style=color:#f92672>=</span> objectness<span style=color:#f92672>.</span>reshape(num_images, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)

        levels <span style=color:#f92672>=</span> [
            torch<span style=color:#f92672>.</span>full((n,), idx, dtype<span style=color:#f92672>=</span>torch<span style=color:#f92672>.</span>int64, device<span style=color:#f92672>=</span>device)
            <span style=color:#66d9ef>for</span> idx, n <span style=color:#f92672>in</span> enumerate(num_anchors_per_level)
        ]
        levels <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>cat(levels, <span style=color:#ae81ff>0</span>)
        levels <span style=color:#f92672>=</span> levels<span style=color:#f92672>.</span>reshape(<span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>expand_as(objectness)

        <span style=color:#75715e># select top_n boxes independently per level before applying nms</span>
        top_n_idx <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_get_top_n_idx(objectness, num_anchors_per_level)

        image_range <span style=color:#f92672>=</span> torch<span style=color:#f92672>.</span>arange(num_images, device<span style=color:#f92672>=</span>device)
        batch_idx <span style=color:#f92672>=</span> image_range[:, None]

        objectness <span style=color:#f92672>=</span> objectness[batch_idx, top_n_idx]
        levels <span style=color:#f92672>=</span> levels[batch_idx, top_n_idx]
        proposals <span style=color:#f92672>=</span> proposals[batch_idx, top_n_idx]

        final_boxes <span style=color:#f92672>=</span> []
        final_scores <span style=color:#f92672>=</span> []
        <span style=color:#66d9ef>for</span> boxes, scores, lvl, img_shape <span style=color:#f92672>in</span> zip(proposals, objectness, levels, image_shapes):
            boxes <span style=color:#f92672>=</span> box_ops<span style=color:#f92672>.</span>clip_boxes_to_image(boxes, img_shape)
            keep <span style=color:#f92672>=</span> box_ops<span style=color:#f92672>.</span>remove_small_boxes(boxes, self<span style=color:#f92672>.</span>min_size)
            boxes, scores, lvl <span style=color:#f92672>=</span> boxes[keep], scores[keep], lvl[keep]
            <span style=color:#75715e># non-maximum suppression, independently done per level</span>
            keep <span style=color:#f92672>=</span> box_ops<span style=color:#f92672>.</span>batched_nms(boxes, scores, lvl, self<span style=color:#f92672>.</span>nms_thresh)
            <span style=color:#75715e># keep only topk scoring predictions</span>
            keep <span style=color:#f92672>=</span> keep[:self<span style=color:#f92672>.</span>post_nms_top_n()]
            boxes, scores <span style=color:#f92672>=</span> boxes[keep], scores[keep]
            final_boxes<span style=color:#f92672>.</span>append(boxes)
            final_scores<span style=color:#f92672>.</span>append(scores)
        <span style=color:#66d9ef>return</span> final_boxes, final_scores

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>compute_loss</span>(self, objectness, pred_bbox_deltas, labels, regression_targets):
        <span style=color:#75715e># type: (Tensor, Tensor, List[Tensor], List[Tensor])</span>
        <span style=color:#e6db74></span><span style=color:#e6db74>&#34;&#34;&#34;</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        Arguments:</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            objectness (Tensor)</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            pred_bbox_deltas (Tensor)</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            labels (List[Tensor])</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            regression_targets (List[Tensor])</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        Returns:</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            objectness_loss (Tensor)</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            box_loss (Tensor)</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        </span><span style=color:#e6db74>&#34;&#34;&#34;</span>

       <span style=color:#66d9ef>pass</span> 
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, images, features, targets<span style=color:#f92672>=</span>None):
        <span style=color:#75715e># type: (ImageList, Dict[str, Tensor], Optional[List[Dict[str, Tensor]]])</span>
        <span style=color:#e6db74></span><span style=color:#e6db74>&#34;&#34;&#34;</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        Arguments:</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            images (ImageList): images for which we want to compute the predictions</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            features (List[Tensor]): features computed from the images that are</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>                used for computing the predictions. Each tensor in the list</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>                correspond to different feature levels</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            targets (List[Dict[Tensor]]): ground-truth boxes present in the image (optional).</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>                If provided, each element in the dict should contain a field `boxes`,</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>                with the locations of the ground-truth boxes.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        Returns:</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            boxes (List[Tensor]): the predicted boxes from the RPN, one Tensor per</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>                image.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>            losses (Dict[Tensor]): the losses for the model during training. During</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>                testing, it is an empty dict.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>        </span><span style=color:#e6db74>&#34;&#34;&#34;</span>
        <span style=color:#75715e># RPN uses all feature maps that are available</span>
        features <span style=color:#f92672>=</span> list(features<span style=color:#f92672>.</span>values())
        objectness, pred_bbox_deltas <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head(features)
        anchors <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>anchor_generator(images, features)

        num_images <span style=color:#f92672>=</span> len(anchors)
        num_anchors_per_level_shape_tensors <span style=color:#f92672>=</span> [o[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>shape <span style=color:#66d9ef>for</span> o <span style=color:#f92672>in</span> objectness]
        num_anchors_per_level <span style=color:#f92672>=</span> [s[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> s[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> s[<span style=color:#ae81ff>2</span>] <span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> num_anchors_per_level_shape_tensors]
        objectness, pred_bbox_deltas <span style=color:#f92672>=</span> \
            concat_box_prediction_layers(objectness, pred_bbox_deltas)
        <span style=color:#75715e># apply pred_bbox_deltas to anchors to obtain the decoded proposals</span>
        <span style=color:#75715e># note that we detach the deltas because Faster R-CNN do not backprop through</span>
        <span style=color:#75715e># the proposals</span>
        proposals <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>box_coder<span style=color:#f92672>.</span>decode(pred_bbox_deltas<span style=color:#f92672>.</span>detach(), anchors)
        proposals <span style=color:#f92672>=</span> proposals<span style=color:#f92672>.</span>view(num_images, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>)
        boxes, scores <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>filter_proposals(proposals, objectness, images<span style=color:#f92672>.</span>image_sizes, num_anchors_per_level)

        losses <span style=color:#f92672>=</span> {}
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>training:
            <span style=color:#66d9ef>assert</span> targets <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> None
            labels, matched_gt_boxes <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>assign_targets_to_anchors(anchors, targets)
            regression_targets <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>box_coder<span style=color:#f92672>.</span>encode(matched_gt_boxes, anchors)
            loss_objectness, loss_rpn_box_reg <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>compute_loss(
                objectness, pred_bbox_deltas, labels, regression_targets)
            losses <span style=color:#f92672>=</span> {
                <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>loss_objectness</span><span style=color:#e6db74>&#34;</span>: loss_objectness,
                <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>loss_rpn_box_reg</span><span style=color:#e6db74>&#34;</span>: loss_rpn_box_reg,
            }
        <span style=color:#66d9ef>return</span> boxes, losses

</code></pre></div><h2 id=roi-pooling和roi-align-pooling>ROI Pooling和ROI Align Pooling</h2><p>接下来介绍一下ROI Pooling，以及对它的改进 ROI Align Pooling</p><p>为什么需要ROI Pooling? 原因是在经过RPN网络后，得到的proposals的尺寸是不统一的。而CNN网络需要固定尺寸的输入。</p><p><img src=https://i.loli.net/2020/04/06/BzR6ZM94rIvonlN.png alt=roipooling.png></p><p>举个例子，上面8<em>8的的featrue map和7*5的proposal,希望得到2*2的输出。
但是没办法整除，roi pooling的做法是，直接取整，把7分成3,4两部分，把5分成2和3两部分。
然后在这四个区域做pooling，得到2</em>2的尺寸。</p><p>这部分torchvision的pytorch实现里面混合了mask rcnn还有其他关键点算法，不太直观，可以参考caffe的roi pooling layer.</p><p>可以看到里面ceil和floor 的取整操作。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>
<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Dtype<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> ROIPoolingLayer<span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span><span style=color:#f92672>:</span><span style=color:#f92672>:</span>Forward_cpu(<span style=color:#66d9ef>const</span> vector<span style=color:#f92672>&lt;</span>Blob<span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span><span style=color:#f92672>*</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>&amp;</span> bottom,
      <span style=color:#66d9ef>const</span> vector<span style=color:#f92672>&lt;</span>Blob<span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span><span style=color:#f92672>*</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>&amp;</span> top) {
  <span style=color:#66d9ef>const</span> Dtype<span style=color:#f92672>*</span> bottom_data <span style=color:#f92672>=</span> bottom[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>cpu_data();
  <span style=color:#66d9ef>const</span> Dtype<span style=color:#f92672>*</span> bottom_rois <span style=color:#f92672>=</span> bottom[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>cpu_data();
  <span style=color:#75715e>// Number of ROIs
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> num_rois <span style=color:#f92672>=</span> bottom[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>num();
  <span style=color:#66d9ef>int</span> batch_size <span style=color:#f92672>=</span> bottom[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>num();
  <span style=color:#66d9ef>int</span> top_count <span style=color:#f92672>=</span> top[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>count();
  Dtype<span style=color:#f92672>*</span> top_data <span style=color:#f92672>=</span> top[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>mutable_cpu_data();
  caffe_set(top_count, Dtype(<span style=color:#f92672>-</span>FLT_MAX), top_data);
  <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> argmax_data <span style=color:#f92672>=</span> max_idx_.mutable_cpu_data();
  caffe_set(top_count, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, argmax_data);

  <span style=color:#75715e>// For each ROI R = [batch_index x1 y1 x2 y2]: max pool over R
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; n <span style=color:#f92672>&lt;</span> num_rois; <span style=color:#f92672>+</span><span style=color:#f92672>+</span>n) {
    <span style=color:#66d9ef>int</span> roi_batch_ind <span style=color:#f92672>=</span> bottom_rois[<span style=color:#ae81ff>0</span>];
    <span style=color:#66d9ef>int</span> roi_start_w <span style=color:#f92672>=</span> round(bottom_rois[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> spatial_scale_);
    <span style=color:#66d9ef>int</span> roi_start_h <span style=color:#f92672>=</span> round(bottom_rois[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>*</span> spatial_scale_);
    <span style=color:#66d9ef>int</span> roi_end_w <span style=color:#f92672>=</span> round(bottom_rois[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>*</span> spatial_scale_);
    <span style=color:#66d9ef>int</span> roi_end_h <span style=color:#f92672>=</span> round(bottom_rois[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>*</span> spatial_scale_);
    CHECK_GE(roi_batch_ind, <span style=color:#ae81ff>0</span>);
    CHECK_LT(roi_batch_ind, batch_size);

    <span style=color:#66d9ef>int</span> roi_height <span style=color:#f92672>=</span> max(roi_end_h <span style=color:#f92672>-</span> roi_start_h <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>int</span> roi_width <span style=color:#f92672>=</span> max(roi_end_w <span style=color:#f92672>-</span> roi_start_w <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>const</span> Dtype bin_size_h <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(roi_height)
                             <span style=color:#f92672>/</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(pooled_height_);
    <span style=color:#66d9ef>const</span> Dtype bin_size_w <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(roi_width)
                             <span style=color:#f92672>/</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(pooled_width_);

    <span style=color:#66d9ef>const</span> Dtype<span style=color:#f92672>*</span> batch_data <span style=color:#f92672>=</span> bottom_data <span style=color:#f92672>+</span> bottom[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>offset(roi_batch_ind);

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; c <span style=color:#f92672>&lt;</span> channels_; <span style=color:#f92672>+</span><span style=color:#f92672>+</span>c) {
      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ph <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ph <span style=color:#f92672>&lt;</span> pooled_height_; <span style=color:#f92672>+</span><span style=color:#f92672>+</span>ph) {
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> pw <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; pw <span style=color:#f92672>&lt;</span> pooled_width_; <span style=color:#f92672>+</span><span style=color:#f92672>+</span>pw) {
          <span style=color:#75715e>// Compute pooling region for this output unit:
</span><span style=color:#75715e></span>          <span style=color:#75715e>//  start (included) = floor(ph * roi_height / pooled_height_)
</span><span style=color:#75715e></span>          <span style=color:#75715e>//  end (excluded) = ceil((ph + 1) * roi_height / pooled_height_)
</span><span style=color:#75715e></span>          <span style=color:#66d9ef>int</span> hstart <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(floor(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(ph)
                                              <span style=color:#f92672>*</span> bin_size_h));
          <span style=color:#66d9ef>int</span> wstart <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(floor(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(pw)
                                              <span style=color:#f92672>*</span> bin_size_w));
          <span style=color:#66d9ef>int</span> hend <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(ceil(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(ph <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
                                           <span style=color:#f92672>*</span> bin_size_h));
          <span style=color:#66d9ef>int</span> wend <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(ceil(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dtype<span style=color:#f92672>&gt;</span>(pw <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
                                           <span style=color:#f92672>*</span> bin_size_w));

          hstart <span style=color:#f92672>=</span> min(max(hstart <span style=color:#f92672>+</span> roi_start_h, <span style=color:#ae81ff>0</span>), height_);
          hend <span style=color:#f92672>=</span> min(max(hend <span style=color:#f92672>+</span> roi_start_h, <span style=color:#ae81ff>0</span>), height_);
          wstart <span style=color:#f92672>=</span> min(max(wstart <span style=color:#f92672>+</span> roi_start_w, <span style=color:#ae81ff>0</span>), width_);
          wend <span style=color:#f92672>=</span> min(max(wend <span style=color:#f92672>+</span> roi_start_w, <span style=color:#ae81ff>0</span>), width_);

          <span style=color:#66d9ef>bool</span> is_empty <span style=color:#f92672>=</span> (hend <span style=color:#f92672>&lt;</span><span style=color:#f92672>=</span> hstart) <span style=color:#f92672>|</span><span style=color:#f92672>|</span> (wend <span style=color:#f92672>&lt;</span><span style=color:#f92672>=</span> wstart);

          <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> pool_index <span style=color:#f92672>=</span> ph <span style=color:#f92672>*</span> pooled_width_ <span style=color:#f92672>+</span> pw;
          <span style=color:#66d9ef>if</span> (is_empty) {
            top_data[pool_index] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            argmax_data[pool_index] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
          }

          <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> hstart; h <span style=color:#f92672>&lt;</span> hend; <span style=color:#f92672>+</span><span style=color:#f92672>+</span>h) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> w <span style=color:#f92672>=</span> wstart; w <span style=color:#f92672>&lt;</span> wend; <span style=color:#f92672>+</span><span style=color:#f92672>+</span>w) {
              <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> h <span style=color:#f92672>*</span> width_ <span style=color:#f92672>+</span> w;
              <span style=color:#66d9ef>if</span> (batch_data[index] <span style=color:#f92672>&gt;</span> top_data[pool_index]) {
                top_data[pool_index] <span style=color:#f92672>=</span> batch_data[index];
                argmax_data[pool_index] <span style=color:#f92672>=</span> index;
              }
            }
          }
        }
      }
      <span style=color:#75715e>// Increment all data pointers by one channel
</span><span style=color:#75715e></span>      batch_data <span style=color:#f92672>+</span><span style=color:#f92672>=</span> bottom[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>offset(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
      top_data <span style=color:#f92672>+</span><span style=color:#f92672>=</span> top[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>offset(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
      argmax_data <span style=color:#f92672>+</span><span style=color:#f92672>=</span> max_idx_.offset(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
    }
    <span style=color:#75715e>// Increment ROI data pointer
</span><span style=color:#75715e></span>    bottom_rois <span style=color:#f92672>+</span><span style=color:#f92672>=</span> bottom[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>offset(<span style=color:#ae81ff>1</span>);
  }
}



</code></pre></div><p>这个办法简单粗暴，而且很容易意识到，这样取整对真实的信息产生了偏差。大物体可能还好说，小物体的话这个问题就会比较严重。</p><p>因此在<a href=https://arxiv.org/abs/1703.06870>Mask R-CNN</a> 提出了一种改进办法，称之为"RoI Align Pooling&rdquo;.</p><p>思路是说，如果不能整除，那么不取整，而是通过插值等手段近似出那个不整的点的值。</p><p>代码可以参考caffe的GPU实现:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>
<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
__global__ <span style=color:#66d9ef>void</span> RoIAlignForwardKernel(
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> nthreads,
    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> bottom_data,
    <span style=color:#66d9ef>const</span> T spatial_scale,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> position_sensitive,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> channels,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> height,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> width,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> pooled_height,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> pooled_width,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> sampling_ratio,
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> num_roi_per_image,
    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> bottom_rois,
    T<span style=color:#f92672>*</span> top_data) {
  CUDA_KERNEL_LOOP(index, nthreads) {
    <span style=color:#75715e>// (n, c, ph, pw) is an element in the pooled output
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> pw <span style=color:#f92672>=</span> index <span style=color:#f92672>%</span> pooled_width;
    <span style=color:#66d9ef>int</span> ph <span style=color:#f92672>=</span> (index <span style=color:#f92672>/</span> pooled_width) <span style=color:#f92672>%</span> pooled_height;
    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> (index <span style=color:#f92672>/</span> pooled_width <span style=color:#f92672>/</span> pooled_height) <span style=color:#f92672>%</span> channels;
    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> index <span style=color:#f92672>/</span> pooled_width <span style=color:#f92672>/</span> pooled_height <span style=color:#f92672>/</span> channels;

<span style=color:#75715e>//    const T* offset_bottom_rois = bottom_rois + n * 5;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> offset_bottom_rois <span style=color:#f92672>=</span> bottom_rois <span style=color:#f92672>+</span> n <span style=color:#f92672>*</span> <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>int</span> roi_batch_ind <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> num_roi_per_image;

    <span style=color:#75715e>// Do not using rounding; this implementation detail is critical
</span><span style=color:#75715e></span>    T roi_start_w <span style=color:#f92672>=</span> offset_bottom_rois[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> spatial_scale;
    T roi_start_h <span style=color:#f92672>=</span> offset_bottom_rois[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> spatial_scale;
    T roi_end_w <span style=color:#f92672>=</span> offset_bottom_rois[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>*</span> spatial_scale;
    T roi_end_h <span style=color:#f92672>=</span> offset_bottom_rois[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>*</span> spatial_scale;
    <span style=color:#75715e>// T roi_start_w = round(offset_bottom_rois[1] * spatial_scale);
</span><span style=color:#75715e></span>    <span style=color:#75715e>// T roi_start_h = round(offset_bottom_rois[2] * spatial_scale);
</span><span style=color:#75715e></span>    <span style=color:#75715e>// T roi_end_w = round(offset_bottom_rois[3] * spatial_scale);
</span><span style=color:#75715e></span>    <span style=color:#75715e>// T roi_end_h = round(offset_bottom_rois[4] * spatial_scale);
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// Force malformed ROIs to be 1x1
</span><span style=color:#75715e></span>    T roi_width <span style=color:#f92672>=</span> max(roi_end_w <span style=color:#f92672>-</span> roi_start_w, (T)<span style=color:#ae81ff>1.</span>);
    T roi_height <span style=color:#f92672>=</span> max(roi_end_h <span style=color:#f92672>-</span> roi_start_h, (T)<span style=color:#ae81ff>1.</span>);
    T bin_size_h <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(roi_height) <span style=color:#f92672>/</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(pooled_height);
    T bin_size_w <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(roi_width) <span style=color:#f92672>/</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(pooled_width);

    <span style=color:#66d9ef>int</span> c_unpooled <span style=color:#f92672>=</span> c;
    <span style=color:#66d9ef>int</span> channels_unpooled <span style=color:#f92672>=</span> channels;
    <span style=color:#66d9ef>if</span> (position_sensitive) {
      c_unpooled <span style=color:#f92672>=</span> c <span style=color:#f92672>*</span> pooled_height <span style=color:#f92672>*</span> pooled_width <span style=color:#f92672>+</span> ph <span style=color:#f92672>*</span> pooled_width <span style=color:#f92672>+</span> pw;
      channels_unpooled <span style=color:#f92672>=</span> channels <span style=color:#f92672>*</span> pooled_height <span style=color:#f92672>*</span> pooled_width;
    }
    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> offset_bottom_data <span style=color:#f92672>=</span>
        bottom_data <span style=color:#f92672>+</span> (roi_batch_ind <span style=color:#f92672>*</span> channels_unpooled <span style=color:#f92672>+</span> c_unpooled)
            <span style=color:#f92672>*</span> height <span style=color:#f92672>*</span> width;

    <span style=color:#75715e>// We use roi_bin_grid to sample the grid and mimic integral
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> roi_bin_grid_h <span style=color:#f92672>=</span> (sampling_ratio <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
                         <span style=color:#f92672>?</span> sampling_ratio
                         : ceil(roi_height <span style=color:#f92672>/</span> pooled_height);  <span style=color:#75715e>// e.g., = 2
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> roi_bin_grid_w <span style=color:#f92672>=</span>
        (sampling_ratio <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> sampling_ratio : ceil(roi_width <span style=color:#f92672>/</span> pooled_width);

    <span style=color:#75715e>// We do average (integral) pooling inside a bin
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> T count <span style=color:#f92672>=</span> roi_bin_grid_h <span style=color:#f92672>*</span> roi_bin_grid_w;  <span style=color:#75715e>// e.g. = 4
</span><span style=color:#75715e></span>
    T output_val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> iy <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; iy <span style=color:#f92672>&lt;</span> roi_bin_grid_h; iy<span style=color:#f92672>+</span><span style=color:#f92672>+</span>) {  <span style=color:#75715e>// e.g., iy = 0, 1
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> T y <span style=color:#f92672>=</span> roi_start_h <span style=color:#f92672>+</span> ph <span style=color:#f92672>*</span> bin_size_h <span style=color:#f92672>+</span>
          <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(iy <span style=color:#f92672>+</span> <span style=color:#ae81ff>.5f</span>) <span style=color:#f92672>*</span> bin_size_h <span style=color:#f92672>/</span>
              <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(roi_bin_grid_h);  <span style=color:#75715e>// e.g., 0.5, 1.5
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>&lt;</span> roi_bin_grid_w; ix<span style=color:#f92672>+</span><span style=color:#f92672>+</span>) {
        <span style=color:#66d9ef>const</span> T x <span style=color:#f92672>=</span> roi_start_w <span style=color:#f92672>+</span> pw <span style=color:#f92672>*</span> bin_size_w <span style=color:#f92672>+</span>
            <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>.5f</span>) <span style=color:#f92672>*</span> bin_size_w <span style=color:#f92672>/</span>
                <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(roi_bin_grid_w);

        T val <span style=color:#f92672>=</span> bilinear_interpolate(
            offset_bottom_data, height, width, y, x, index);
        output_val <span style=color:#f92672>+</span><span style=color:#f92672>=</span> val;
      }
    }
    output_val <span style=color:#f92672>/</span><span style=color:#f92672>=</span> count;

    top_data[index] <span style=color:#f92672>=</span> output_val;
  }
}


</code></pre></div><p>这里面有一个坑是，roi align layer有个参数叫num_roi_per_image</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>RoIAlignParameter</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>uint32</span> pooled_h <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> [<span style=color:#66d9ef>default</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>uint32</span> pooled_w <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> [<span style=color:#66d9ef>default</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>float</span> spatial_scale <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> [<span style=color:#66d9ef>default</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>int32</span> sample_ratio <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> [<span style=color:#66d9ef>default</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>bool</span> position_sensitive <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span> [<span style=color:#66d9ef>default</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>uint32</span> num_roi_per_image <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span> [<span style=color:#66d9ef>default</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>然后这东西是有一个默认值300的。 因为在roialign之前的proposal layer的post_nms的值一般是300. 所以一般不会有什么影响。
但是如果nms之后的roi数量小于300,而num_roi_per_image又是默认300的话，就会把后面图片的roi分给第一张图，导致结果错误。</p><p>具体请参考<a href=https://111qqz.github.io/2019/12/debug-faster-rcnn-once-again/>记一次faster-rcnn debug记录</a></p><h2 id=总结>总结</h2><ul><li>R-CNN对图像选取若干提议区域，然后用卷积神经网络对每个提议区域做前向计算抽取特征，再用这些特征预测提议区域的类别和边界框。</li><li>Fast R-CNN对R-CNN的一个主要改进在于只对整个图像做卷积神经网络的前向计算。它引入了兴趣区域池化层，从而令兴趣区域能够抽取出形状相同的特征。</li><li>Faster R-CNN将Fast R-CNN中的选择性搜索替换成区域提议网络，从而减少提议区域的生成数量，并保证目标检测的精度。</li><li>Mask R-CNN在Faster R-CNN基础上引入一个全卷积网络，从而借助目标的像素级位置进一步提升目标检测的精度。</li></ul><h2 id=参考链接>参考链接</h2><ul><li><p><a href=https://arxiv.org/abs/1506.01497>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</a></p></li><li><p><a href=https://zhuanlan.zhihu.com/p/73138740>ROI Pooling和ROI Align</a></p></li><li><p><a href=https://arxiv.org/abs/1703.06870>Mask R-CNN</a></p></li></ul><hr><ul class=pager><li class=previous><a href=/2020/04/resnet-learning-notes data-toggle=tooltip data-placement=top title="resnet 学习笔记">&larr;
Previous Post</a></li><li class=next><a href=/2020/04/caffe-source-code-analysis-part4 data-toggle=tooltip data-placement=top title="caffe 源码学习笔记(4) 激活函数">Next
Post &rarr;</a></li></ul><div class=post-comment><span id=/2020/04/faster-rcnn class=leancloud_visitors data-flag-title="Faster Rcnn 目标检测算法"><span class=post-meta-item-text>访问量 "/2020/04/faster-rcnn"</span>
<span class=leancloud-visitors-count></span><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'UzhnsgbPvx1RFb2kNXUHpPtf-gzGzoHsz',appKey:'OXOvoYGuwMv70Os5GOgaGEWT',notify:true,verify:false,avatar:'retro',placeholder:'说点什么吧...',visitor:true});</script></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/bfs title=bfs>bfs</a>
<a href=/tags/binary-search title=binary-search>binary-search</a>
<a href=/tags/brute-force title=brute-force>brute-force</a>
<a href=/tags/dfs title=dfs>dfs</a>
<a href=/tags/dp title=dp>dp</a>
<a href=/tags/greedy title=greedy>greedy</a>
<a href=/tags/kmp title=kmp>kmp</a>
<a href=/tags/leetcode title=leetcode>leetcode</a>
<a href=/tags/math title=math>math</a>
<a href=/tags/number-theory title=number-theory>number-theory</a>
<a href=/tags/rmq title=rmq>rmq</a>
<a href=/tags/stl title=stl>stl</a>
<a href=/tags/%E5%89%8D%E7%BC%80%E5%92%8C title=前缀和>前缀和</a>
<a href=/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA title=博弈论>博弈论</a>
<a href=/tags/%E5%9B%BE%E8%AE%BA title=图论>图论</a>
<a href=/tags/%E5%BF%AB%E9%80%9F%E5%B9%82 title=快速幂>快速幂</a>
<a href=/tags/%E6%95%B0%E4%BD%8Ddp title=数位dp>数位dp</a>
<a href=/tags/%E6%9E%84%E9%80%A0 title=构造>构造</a>
<a href=/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84 title=树状数组>树状数组</a>
<a href=/tags/%E6%A8%A1%E6%8B%9F title=模拟>模拟</a>
<a href=/tags/%E6%AF%8D%E5%87%BD%E6%95%B0 title=母函数>母函数</a>
<a href=/tags/%E7%9F%A9%E9%98%B5 title=矩阵>矩阵</a>
<a href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91 title=线段树>线段树</a>
<a href=/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95 title=计算几何>计算几何</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://111qqz.com>111qqz的wordpress博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href rel=alternate type=application/rss+xml title=111qqz的小窝><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=mailto:hust.111qqz@gmail.com><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-wechat fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/111qqz/><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 111qqz的小窝 2022<br><a href=https://beian.miit.gov.cn/>粤ICP备18103363号</a><br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function async(u,c){var d=document,t='script',o=d.createElement(t),s=d.getElementsByTagName(t)[0];o.src=u;if(c){o.addEventListener('load',function(e){c(null,e);},false);}
s.parentNode.insertBefore(o,s);}</script><script>if($('#tag_cloud').length!==0){async("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'},};$('#tag_cloud a').tagcloud();})}</script><script>async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var $nav=document.querySelector("nav");if($nav)FastClick.attach($nav);})</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-219255388-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>