<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="111qqz的小窝"><meta property="og:type" content="article"><meta property="og:image" content="https://111qqz.github.io/img/2.png"><meta property="twitter:image" content="https://111qqz.github.io/img/2.png"><meta name=title content="【施工完成】CSAPP bomb lab"><meta property="og:title" content="【施工完成】CSAPP bomb lab"><meta property="twitter:title" content="【施工完成】CSAPP bomb lab"><meta name=description content><meta property="og:description" content><meta property="twitter:description" content><meta property="twitter:card" content="summary"><meta name=keyword content="ACM,111qqz,商汤科技,hust,华中科技大学"><link rel="shortcut icon" href=/img/favicon.ico><title>【施工完成】CSAPP bomb lab-111qqz的小窝</title><link rel=canonical href=/2020/02/csapp-bomblab/><link rel=stylesheet href=/css/iDisqus.min.css><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/zanshang.css><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/docco.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/hux-blog.min-custom.css></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=/>111qqz的小窝</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>Home</a></li><li><a href=/categories/acm/>ACM-ICPC</a></li><li><a href=/categories/deep-learning/>深度学习</a></li><li><a href=/categories/mooc/>公开课</a></li><li><a href=/categories/%e5%85%b6%e4%bb%96/>其他</a></li><li><a href=/top/about/>ABOUT</a></li><li><a href=/search>SEARCH <img src=/img/search.png height=15 style=cursor:pointer alt=Search></a></li></ul></div></div></div></nav><script>var $body=document.body;var $toggle=document.querySelector('.navbar-toggle');var $navbar=document.querySelector('#huxblog_navbar');var $collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic)
function handleMagic(e){if($navbar.className.indexOf('in')>0){$navbar.className=" ";setTimeout(function(){if($navbar.className.indexOf('in')<0){$collapse.style.height="0px"}},400)}else{$collapse.style.height="auto"
$navbar.className+=" in";}}</script><style type=text/css>header.intro-header{background-image:url(/img/2.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/csapp title=csapp>csapp</a></div><h1>【施工完成】CSAPP bomb lab</h1><h2 class=subheading></h2><span class=meta>Posted by
111qqz
on
Saturday, February 1, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><header><h2>TOC</h2></header><nav id=TableOfContents><ol><li><a href=#背景>背景</a></li><li><a href=#拆除phase-1>拆除phase 1</a></li><li><a href=#拆除phase-2>拆除phase 2</a></li><li><a href=#拆除phase-3>拆除phase 3</a></li><li><a href=#拆除phase-4>拆除phase 4</a></li><li><a href=#拆除phase-5>拆除phase 5</a></li><li><a href=#拆除phase-6>拆除phase 6</a></li></ol></nav><h2 id=背景>背景</h2><p>疫情肆虐,在家百无聊赖,于是开始拆炸弹.
炸弹分为6个阶段,每个阶段必须输入一个特定的字符串,否则炸弹就会爆炸.
提供给我们的是一个.c文件和一个linux可执行文件bomb</p><pre><code class=language-c>
/***************************************************************************
 * Dr. Evil's Insidious Bomb, Version 1.1
 * Copyright 2011, Dr. Evil Incorporated. All rights reserved.
 *
 * LICENSE:
 *
 * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the
 * VICTIM) explicit permission to use this bomb (the BOMB).  This is a
 * time limited license, which expires on the death of the VICTIM.
 * The PERPETRATOR takes no responsibility for damage, frustration,
 * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other
 * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,
 * that is.  The VICTIM may not distribute this bomb source code to
 * any enemies of the PERPETRATOR.  No VICTIM may debug,
 * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any
 * other technique to gain knowledge of and defuse the BOMB.  BOMB
 * proof clothing may not be worn when handling this program.  The
 * PERPETRATOR will not apologize for the PERPETRATOR's poor sense of
 * humor.  This license is null and void where the BOMB is prohibited
 * by law.
 ***************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;support.h&quot;
#include &quot;phases.h&quot;

/* 
 * Note to self: Remember to erase this file so my victims will have no
 * idea what is going on, and so they will all blow up in a
 * spectaculary fiendish explosion. -- Dr. Evil 
 */

FILE *infile;

int main(int argc, char *argv[])
{
    char *input;

    /* Note to self: remember to port this bomb to Windows and put a 
     * fantastic GUI on it. */

    /* When run with no arguments, the bomb reads its input lines 
     * from standard input. */
    if (argc == 1) {  
	infile = stdin;
    } 

    /* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; 
     * until EOF, and then switches to standard input. Thus, as you 
     * defuse each phase, you can add its defusing string to &lt;file&gt; and
     * avoid having to retype it. */
    else if (argc == 2) {
	if (!(infile = fopen(argv[1], &quot;r&quot;))) {
	    printf(&quot;%s: Error: Couldn't open %s\n&quot;, argv[0], argv[1]);
	    exit(8);
	}
    }

    /* You can't call the bomb with more than 1 command line argument. */
    else {
	printf(&quot;Usage: %s [&lt;input_file&gt;]\n&quot;, argv[0]);
	exit(8);
    }

    /* Do all sorts of secret stuff that makes the bomb harder to defuse. */
    initialize_bomb();

    printf(&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;);
    printf(&quot;which to blow yourself up. Have a nice day!\n&quot;);

    /* Hmm...  Six phases must be more secure than one phase! */
    input = read_line();             /* Get input                   */
    phase_1(input);                  /* Run the phase               */
    phase_defused();                 /* Drat!  They figured it out!
				      * Let me know how they did it. */
    printf(&quot;Phase 1 defused. How about the next one?\n&quot;);

    /* The second phase is harder.  No one will ever figure out
     * how to defuse this... */
    input = read_line();
    phase_2(input);
    phase_defused();
    printf(&quot;That's number 2.  Keep going!\n&quot;);

    /* I guess this is too easy so far.  Some more complex code will
     * confuse people. */
    input = read_line();
    phase_3(input);
    phase_defused();
    printf(&quot;Halfway there!\n&quot;);

    /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */
    input = read_line();
    phase_4(input);
    phase_defused();
    printf(&quot;So you got that one.  Try this one.\n&quot;);
    
    /* Round and 'round in memory we go, where we stop, the bomb blows! */
    input = read_line();
    phase_5(input);
    phase_defused();
    printf(&quot;Good work!  On to the next...\n&quot;);

    /* This phase will never be used, since no one will get past the
     * earlier ones.  But just in case, make this one extra hard. */
    input = read_line();
    phase_6(input);
    phase_defused();

    /* Wow, they got it!  But isn't something... missing?  Perhaps
     * something they overlooked?  Mua ha ha ha ha! */
    
    return 0;
}

</code></pre><p>好了.开始用gdb拆炸弹.</p><h2 id=拆除phase-1>拆除phase 1</h2><p>首先看一下phase_1函数的反汇编代码:</p><pre><code class=language-GAS>
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp
   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi
   0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;
   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax
   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;
   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp
   0x0000000000400efb &lt;+27&gt;:    retq   
End of assembler dump.

</code></pre><p>可以看到phase_1函数通过调用strings_not_equal函数判断两个字符串是否相等,如果不相等就跳到explode_bomb炸掉,否则返回到main函数的执行流.</p><p>接下来我们看一下strings_not_equal,暂时省略中间无关的部分.</p><pre><code class=language-GAS>
(gdb) disas strings_not_equal
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 &lt;+0&gt;:     push   %r12
   0x000000000040133a &lt;+2&gt;:     push   %rbp
   0x000000000040133b &lt;+3&gt;:     push   %rbx
   0x000000000040133c &lt;+4&gt;:     mov    %rdi,%rbx
   0x000000000040133f &lt;+7&gt;:     mov    %rsi,%rbp
   0x0000000000401342 &lt;+10&gt;:    callq  0x40131b &lt;string_length&gt;
   0x0000000000401347 &lt;+15&gt;:    mov    %eax,%r12d
   0x000000000040134a &lt;+18&gt;:    mov    %rbp,%rdi
   0x000000000040134d &lt;+21&gt;:    callq  0x40131b &lt;string_length&gt;
   0x0000000000401352 &lt;+26&gt;:    mov    $0x1,%edx
   0x0000000000401357 &lt;+31&gt;:    cmp    %eax,%r12d
   0x000000000040135a &lt;+34&gt;:    jne    0x40139b &lt;strings_not_equal+99&gt;
    ...
    ...
    ...
   0x000000000040139b &lt;+99&gt;:    mov    %edx,%eax
   0x000000000040139d &lt;+101&gt;:   pop    %rbx
   0x000000000040139e &lt;+102&gt;:   pop    %rbp
   0x000000000040139f &lt;+103&gt;:   pop    %r12
   0x00000000004013a1 &lt;+105&gt;:   retq 
</code></pre><p>我们可以看到这里似乎是通过string_length函数求了两个字符串的长度,以此来比较两个函数是否相等.
求字符串长度总需要知道字符串是什么吧? 有戏. 我们再看一下string_length 函数</p><pre><code class=language-GAS>
(gdb) disas string_length
Dump of assembler code for function string_length:
   0x000000000040131b &lt;+0&gt;:     cmpb   $0x0,(%rdi)
   0x000000000040131e &lt;+3&gt;:     je     0x401332 &lt;string_length+23&gt;
   0x0000000000401320 &lt;+5&gt;:     mov    %rdi,%rdx
   0x0000000000401323 &lt;+8&gt;:     add    $0x1,%rdx
   0x0000000000401327 &lt;+12&gt;:    mov    %edx,%eax
   0x0000000000401329 &lt;+14&gt;:    sub    %edi,%eax
   0x000000000040132b &lt;+16&gt;:    cmpb   $0x0,(%rdx)
   0x000000000040132e &lt;+19&gt;:    jne    0x401323 &lt;string_length+8&gt;
   0x0000000000401330 &lt;+21&gt;:    repz retq 
   0x0000000000401332 &lt;+23&gt;:    mov    $0x0,%eax
   0x0000000000401337 &lt;+28&gt;:    retq   
End of assembler dump.

</code></pre><p>可以看出,该函数先判断字符串是否为空,然后根据c style 字符串末尾的&rsquo;\0'作为循环的终止条件得到字符串的长度.</p><p>显然,字符串内容存储在 寄存器 rdi的值所在的地址.</p><p>我们在string_length 函数开始的位置设置断点,得到两个字符串.第一个为用户输入的字符串,第二个就是phase_1 过关需要的字符串,问题解决!</p><pre><code class=language-GAS>
(gdb) b string_length
Breakpoint 1 at 0x40131b
(gdb) c
The program is not being run.
(gdb) r
Starting program: /home/coder/workspace/csapp-lab/bomblab/bomb 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
hello from 111qqz 

Breakpoint 1, 0x000000000040131b in string_length ()
(gdb) print (char *) $rdi
$1 = 0x603780 &lt;input_strings&gt; &quot;hello from 111qqz &quot;
(gdb) c
Continuing.

Breakpoint 1, 0x000000000040131b in string_length ()
(gdb) print (char *) $rdi
$2 = 0x402400 &quot;Border relations with Canada have never been better.&quot;
(gdb) 

</code></pre><h2 id=拆除phase-2>拆除phase 2</h2><p>接下来开始解决第二阶段.</p><p>看一下phase_2 的反汇编代码:</p><pre><code class=language-GAS>
disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc &lt;+0&gt;:     push   %rbp
   0x0000000000400efd &lt;+1&gt;:     push   %rbx
   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp
   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi
   0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;
   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax
   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)
   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;
   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx
=&gt; 0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx
   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;
   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;
   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;
   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp
   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx
   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp
   0x0000000000400f42 &lt;+70&gt;:    retq   
End of assembler dump.

</code></pre><p>接下来看一下read_six_numbers函数</p><pre><code class=language-GAS>
disas read_six_numbers 
Dump of assembler code for function read_six_numbers:
   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx
   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx
   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax
   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)
   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax
   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)
   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9
   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8
   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi
   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax
   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax
   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;
   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp
   0x000000000040149d &lt;+65&gt;:    retq   
End of assembler dump.


</code></pre><p>看起来是从stdin读了六个值,如果输入值的个数不足6个,就会炸掉.</p><p>从</p><pre><code class=language-GAS>
 0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi
 (gdb) print (char *) 0x4025c3
$155 = 0x4025c3 &quot;%d %d %d %d %d %d&quot;

</code></pre><p>可以得出,读入的六个值的类型都为int.</p><p>从read_six_numbers的 [+0, +32] 部分的代码可以得出,读取的六个数的存储位置. 依次为:</p><pre><code class=language-GAS>
%rsi     %rdx
%rsi+4   %rcx
%rsi+8   %r8
%rsi+12  %r9
%rsi+16  (%rsp) 或者 %rax
%rsi+20  (%rsp +8)


(gdb) print /x $rdx
$171 = 0x7fffffffdae0
(gdb) print /x $rcx
$172 = 0x7fffffffdae4
(gdb) print /x $r8
$173 = 0x7fffffffdae8
(gdb) print /x $r9
$174 = 0x7fffffffdaec
(gdb) print /x $rax
$175 = 0x7fffffffdaf0
(gdb) print /x *(int *) ($rsp+8)
$176 = 0xffffdaf4

</code></pre><p><strong>需要注意的是这些汇编代码中的常数都是十六进制</strong></p><p>接下来我们可以从phase_2的 [+14,+20]行中看出,</p><pre><code class=language-GAS>
   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi
   0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;
   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;
   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;

</code></pre><p>(%rsp)的值必须为1,否则炸弹就炸了. 而(%rsp)的值,实际上就是read_six_numbers中 %rsi的值.</p><p>因此 也就是读取的第一个数 %rsi 必须为 1.</p><p>第一个数正确后,会跳转到:</p><pre><code class=language-GAS>

   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;

</code></pre><p>可以看到 %rbx的值为读取的第二个数,而%rbp的值为读取的六个数后一个位置,猜想是类似EOF或者EOL之类标示stdin结束的值.</p><p>接下来查看 [+27,+48]行代码</p><pre><code class=language-GAS>
   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax
   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)
   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;
   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx
=&gt; 0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx
   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;


</code></pre><p>可以看出这段代码是一个循环,循环终止条件为 %rbx等于 %rbp, 证实了刚刚 %rbp是某种终止符的猜想.</p><p>看起来是从第二个数,每个数(%rbx)必须等于前一个数 %eax,也就是 (%rbx - 4)的二倍,否则炸断就会炸.</p><p>因此推断,这六个数分别为: 1 2 4 8 16 32</p><p>问题解决!</p><h2 id=拆除phase-3>拆除phase 3</h2><p>接下来开始解决第三阶段.</p><p>看一下phase_3 的反汇编代码:</p><pre><code class=language-GAS>
(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi
   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax
   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax
   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;
   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;
   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax
=&gt; 0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)
   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax
   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax
   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax
   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax
   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax
   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax
   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax
   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400fad &lt;+106&gt;:   callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax
   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;
   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax
   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;
   0x0000000000400fc4 &lt;+129&gt;:   callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp
   0x0000000000400fcd &lt;+138&gt;:   retq   
End of assembler dump.


</code></pre><p>可以看出这是一段switch 语句
从stdin读了两个值,第一个数为case 的label,然后得到的结果与读入的第二个数比较,不相等就会爆炸.</p><p>从</p><pre><code class=language-GAS>
(gdb) print (char *) 0x4025cf
$18 = 0x4025cf &quot;%d %d&quot;

</code></pre><p>读入的两个值都为int类型.</p><p>根据如下代码可以得知,第一个值的范围在[0,7]之间.</p><pre><code class=language-GAS>
   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;

</code></pre><p>[0,7]区间内共有8个整数,于是我们检查从地址 0x402470 开始的8个word,得到:</p><pre><code class=language-GAS>
(gdb) x/16w  0x402470
0x402470:       0x00400f7c      0x00000000      0x00400fb9      0x00000000
0x402480:       0x00400f83      0x00000000      0x00400f8a      0x00000000
0x402490:       0x00400f91      0x00000000      0x00400f98      0x00000000
0x4024a0:       0x00400f9f      0x00000000      0x00400fa6      0x00000000


</code></pre><p>再对照 phase_3 的汇编代码,得到如下 case label与返回值的对应关系,其中括号内为十进制表示.</p><pre><code class=language-GAS>
0: 0xcf(207)
1: 0x137(311)
2: 0x2c3(707)
3: 0x100(256)
4: 0x185(389)
5: 0xce(206)
6: 0x2aa(682)
7: 0x147(327)
</code></pre><p>因此phase 3的答案有上述8对,输入任意一对即可.</p><h2 id=拆除phase-4>拆除phase 4</h2><p>接下来开始解决第四阶段.</p><p>汇编代码为:</p><pre><code class=language-GAS>
disas  phase_4
Dump of assembler code for function phase_4:
   0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp
   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx
   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi
   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax
   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;
   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax
   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;
   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;
   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx
   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi
   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi
   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;
   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax
   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;
   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;
   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp
   0x0000000000401061 &lt;+85&gt;:    retq   
End of assembler dump.


</code></pre><p>根据</p><pre><code class=language-GAS>
(gdb) print (char *) 0x4025cf
$1 = 0x4025cf &quot;%d %d&quot;

</code></pre><p>可以得知,依然是读取了两个int类型的值.
第一个值存储在 (%rsp+0x8),第二个值存储在(%rsp+0xc)</p><p>根据 [+34,+41] 得知, 第一个数的范围是[0,14]</p><p>接下来查看func4的汇编代码:</p><pre><code class=language-GAS>
(gdb) disas func4
Dump of assembler code for function func4:
   0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp
   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax
   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax
   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx
   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx
   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax
   0x0000000000400fdd &lt;+15&gt;:    sar    %eax
   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx
   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;
   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx
   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;
   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax
   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;
   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax
   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx
   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;
   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi
   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;
   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp
   0x000000000040100b &lt;+61&gt;:    retq   
End of assembler dump.


</code></pre><p>这段代码比较复杂,可以使用gdb watchpoints来观察几个寄存器的变化.</p><p>调试的时候要注意,需要先disable这些寄存器上的watchpoints,当进入到func4函数中再开启.</p><p>最终可以艰难得发现, 读入的第一个值应该为0.</p><p>根据phase_4 汇编代码[+69,+76]</p><pre><code class=language-GAS>
   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;
   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;

</code></pre><p>可以得到读入的第二个值应该为0.</p><p>此外,我们注意到第一个值也只有15种可能的取值情况. 第二个值已经确定,因此总的取值情况也只有15种.</p><p>不妨暴力枚举得到答案.</p><p>综上,输入的两个值为 0 0</p><h2 id=拆除phase-5>拆除phase 5</h2><p>接下来开始解决第五阶段.</p><p>看一下反汇编代码:</p><pre><code class=language-GAS>
(gdb) disas phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 &lt;+0&gt;:     push   %rbx
   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp
   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx
   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax
   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)
   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax
   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;
   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax
   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;
   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;
   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)
   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx
   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx
   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax
   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax
   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;
   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi
   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi
=&gt; 0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;
   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax
   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;
   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;
   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;
   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax
   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;
   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax
   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax
   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;
   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;
   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp
   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx
   0x00000000004010f3 &lt;+145&gt;:   retq   
End of assembler dump.


</code></pre><p>从下面的代码可以得知,读入的字符串的长度为6</p><pre><code class=language-GAS>
   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax
   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;
   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax
    0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;
   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;
</code></pre><p>接下来分析这段代码中比较难懂的部分:</p><pre><code class=language-GAS>
   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx 取读入字符串的第一个字符
   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)    %cl与%ecx是相同的,原因是ascii的取值范围可以通过一个字节表示.
   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx
   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx    将该字符的ascii值与0xf取and,也就是截取该ascii值的后四个bit,得到的值的范围在0..15,该值存储在%edx中
   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx  %rdx作为存储在$0x4024b0位置的下标索引
   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)  #将得到的新的字符存放在以(%rsp+0x10)开始的位置
   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax
   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax
   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;

</code></pre><p>大致可以看出这是一个循环,依次处理每个字符.</p><p>在进入这个循环之前, %rbx 存储着 读入字符串的指针,%rax在[+112] 清空了,是0x0</p><p>$0x4024b0 位置开始的长度16的候选字符串为 &ldquo;maduiersnfotvbyl&rdquo;</p><p><strong>因此上面这段循环做的就是从上述候选字符串中选6个字符,依次存储在从(%rsp+0x10)开始的位置</strong></p><p>接下来我们看这段代码:</p><pre><code class=language-GAS>
   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi
   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi
=&gt; 0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;
   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax
   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;
   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;

</code></pre><p>发现是要求经过变换后的字符串与某个给定的字符串相等</p><p>给定的字符串为"flyers&rdquo;,找出这6个字符再候选字符串中的位置</p><p>分别为 9,15,14,5,6,7
写成十六进制就是 0x9,0xf,0xe,0x5,0x6,0x7</p><p>查看ascii表,找到6个最后的十六进制值为上述值的ascii 码,就是答案.</p><p>显然,答案有多种. 其中一种答案为:</p><p>ionefg</p><p>问题解决!</p><h2 id=拆除phase-6>拆除phase 6</h2><p>一口老血&mldr;phase 6真是恶心&mldr;.花的时间比前面五个加起来还要多</p><p>接下来开始解决第六阶段.</p><p>看一下反汇编代码:</p><pre><code class=language-GAS>
(gdb) disas phase_6
Dump of assembler code for function phase_6:
   0x00000000004010f4 &lt;+0&gt;:     push   %r14
   0x00000000004010f6 &lt;+2&gt;:     push   %r13
   0x00000000004010f8 &lt;+4&gt;:     push   %r12
   0x00000000004010fa &lt;+6&gt;:     push   %rbp
   0x00000000004010fb &lt;+7&gt;:     push   %rbx
   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp
   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13
   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi
   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;
   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14
   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d
   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp
   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax
   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax
   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax
   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;
   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d
   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d
   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;
   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx
   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax
   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)
   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;
   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx
   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx
   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;
   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13
   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;
   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi
   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax
   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx
   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx
   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx
   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)
   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax
   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax
   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;
   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi
   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;
   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx
   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax
   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax
   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;
   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;
   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx
   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi
   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi
   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;
   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx
   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;
   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax
   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx
   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;
   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx
   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax
   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi
   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx
   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx
   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)
   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax
   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax
   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;
   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx
   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;
   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)
   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp
   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax
   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax
=&gt; 0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)
   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;
   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;
   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp
   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;
   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp
   0x00000000004011fb &lt;+263&gt;:   pop    %rbx
   0x00000000004011fc &lt;+264&gt;:   pop    %rbp
   0x00000000004011fd &lt;+265&gt;:   pop    %r12
   0x00000000004011ff &lt;+267&gt;:   pop    %r13
   0x0000000000401201 &lt;+269&gt;:   pop    %r14
   0x0000000000401203 &lt;+271&gt;:   retq   
End of assembler dump.

</code></pre><p>前半部分代码还算比较好懂:</p><pre><code class=language-GAS>
   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;
   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14
   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d
   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp
   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax
   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax
   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax
   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;
   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d
   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d
   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;
   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx
   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax
   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)
   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;
   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;
   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx
   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx
   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;
   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13
   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;

</code></pre><p>这段代码是读取6个int 类型的数,然后每个数必须属于[1,6],并且互不相同.
因此输入的6个数为1..6的6个数字的一个排列.</p><p>接下来也比较好懂,就是把每个读入的数x变成了7-x.</p><p><strong>为了方便说明,接下来省略提及这个变换,将7-x当成读作的数</strong></p><pre><code class=language-GAS>
   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi
   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax
   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx
   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx
   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx
   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)
   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax
   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax
   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;

</code></pre><p>接下来这段简直吐血:</p><pre><code class=language-GAS>

   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi
   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;
   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx
   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax
   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax
   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;
   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;
   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx
   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi
   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi
   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;
   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx
   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;
   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax
   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx
   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;

</code></pre><p>在进入上述这段代码之前, %rsp 存储着第一个读入数的内存地址,%ecx是常数7</p><p>要注意两个语句,一个是 mov (%rsp,%rsi,1),%ecx 中(%rsp,%rsi,1)表示的是读入的数存放的位置</p><p>一个是 mov %rdx,0x20(%rsp,%rsi,2) 中 0x20(%rsp,%rsi,2) 表示的是 某个结果存放的位置.</p><p>这段代码先跳到 +163, 拿到读入的数,看是否等于1</p><ul><li>如果相等: 跳到 +143,把 $0x6032d0 放到 0x20(%rsp,%rsi,2) 的位置</li><li>如果不相等: 继续执行,eax为1,edx为$0x6032d0,然后跳到 +130,edx变为下一个位置$0x6032e0.这样一直进行读入的数x-1次. (比如读入的数是4,那么就会进行3次edx变为下一个位置的操作,也就是变为$0x603300)</li></ul><p><strong>可以看出这是个链表的数据结构.</strong></p><p>因此这段代码做的是, 按照读入的数的从小到大的出现的位置,依次把从 $0x6032e0 到$0x603320 放到<br>栈上(%rsp+0x20+8i)的位置.</p><p>举个例子, 假设读入的数为:</p><pre><code>5 4 3 2 1 6
</code></pre><p>那么从 (%rsp+0x20+8i) 开始的数就是:</p><pre><code class=language-GAS>$0x603310  $0x603300  $0x6032f0 $0x6032e0 $0x6032d0  $0x603320

</code></pre><p>接下来我们看最后一段代码:</p><pre><code class=language-GAS>
   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx
   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax
   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi
   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx
   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx
   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)
   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax
   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax
   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;
   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx
   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;
   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)
   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp
   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax
   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax
   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)
   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;
   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;
   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp
   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;

</code></pre><p>从 [+235,+245] 可以看出,这里要求从 0x20(%rsp) 开始的栈上存储的地址对应位置的值,必须前一个必须大于后一个.</p><p>我们可以查看 从 $0x6032d0位置开始的6个地址中的值:</p><pre><code class=language-GAS>(gdb) x/3w 0x6032d0
0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x00000000
(gdb) x/3w 0x6032e0
0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032d0
(gdb) x/3w 0x6032f0
0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x006032e0
(gdb) x/3w 0x603300
0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x006032f0
(gdb) x/3w 0x603310
0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603300
(gdb) x/3w 0x603320
0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00603310


</code></pre><p>按照值的顺序降序node序号,得到 3 4 5 6 1 2</p><p>最后不要忘记用7减去每个位置的值,因此最终答案就是: 4 3 2 1 6 5</p><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://111qqz.github.io><img src=/img/favicon.png>111qqz的小窝</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/2020/01/caffe-source-code-analysis-part3 data-toggle=tooltip data-placement=top title="caffe 源码学习笔记(3) Net">&larr;
Previous Post</a></li><li class=next><a href=/2020/02/csapp-attacklab/ data-toggle=tooltip data-placement=top title="【施工完成】CSAPP attacklab">Next
Post &rarr;</a></li></ul><div id=git-comments></div><link rel=stylesheet href=https://imsun.github.io/gitment/style/default.css><script src=https://ihtcboy.com/script/gitment.browser.js></script><script>var gitment=new Gitment({id:decodeURI(window.location.pathname),owner:'111qqz',repo:'111qqz.github.io',oauth:{client_id:'8839ce5e58d5197e2490',client_secret:'2d475a8a7e27a8b509847a6c60f692b8cbaa274e',}})
gitment.render('git-comments')</script></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/bfs title=bfs>bfs</a>
<a href=/tags/binary-search title=binary-search>binary-search</a>
<a href=/tags/brute-force title=brute-force>brute-force</a>
<a href=/tags/c++ title=c++>c++</a>
<a href=/tags/caffe title=caffe>caffe</a>
<a href=/tags/dfs title=dfs>dfs</a>
<a href=/tags/dp title=dp>dp</a>
<a href=/tags/greedy title=greedy>greedy</a>
<a href=/tags/hash title=hash>hash</a>
<a href=/tags/km title=km>km</a>
<a href=/tags/kmp title=kmp>kmp</a>
<a href=/tags/leetcode title=leetcode>leetcode</a>
<a href=/tags/math title=math>math</a>
<a href=/tags/number-theory title=number-theory>number-theory</a>
<a href=/tags/rmq title=rmq>rmq</a>
<a href=/tags/sg%E5%87%BD%E6%95%B0 title=sg函数>sg函数</a>
<a href=/tags/stl title=stl>stl</a>
<a href=/tags/tensorflow title=tensorflow>tensorflow</a>
<a href=/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D title=二分图最佳匹配>二分图最佳匹配</a>
<a href=/tags/%E5%88%86%E5%9D%97 title=分块>分块</a>
<a href=/tags/%E5%89%8D%E7%BC%80%E5%92%8C title=前缀和>前缀和</a>
<a href=/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95 title=匈牙利算法>匈牙利算法</a>
<a href=/tags/%E5%8C%BA%E9%97%B4dp title=区间dp>区间dp</a>
<a href=/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA title=博弈论>博弈论</a>
<a href=/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA title=后缀自动机>后缀自动机</a>
<a href=/tags/%E5%9B%BE%E8%AE%BA title=图论>图论</a>
<a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2 title=字符串>字符串</a>
<a href=/tags/%E5%BF%AB%E9%80%9F%E5%B9%82 title=快速幂>快速幂</a>
<a href=/tags/%E6%95%B0%E4%BD%8Ddp title=数位dp>数位dp</a>
<a href=/tags/%E6%9E%84%E9%80%A0 title=构造>构造</a>
<a href=/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84 title=树状数组>树状数组</a>
<a href=/tags/%E6%A6%82%E7%8E%87 title=概率>概率</a>
<a href=/tags/%E6%A8%A1%E6%8B%9F title=模拟>模拟</a>
<a href=/tags/%E6%AF%8D%E5%87%BD%E6%95%B0 title=母函数>母函数</a>
<a href=/tags/%E7%9F%A9%E9%98%B5 title=矩阵>矩阵</a>
<a href=/tags/%E7%A6%BB%E6%95%A3%E5%8C%96 title=离散化>离散化</a>
<a href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91 title=线段树>线段树</a>
<a href=/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95 title=计算几何>计算几何</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://111qqz.com>111qqz的wordpress博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href rel=alternate type=application/rss+xml title=111qqz的小窝><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=mailto:hust.111qqz@gmail.com><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-wechat fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/111qqz/><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 111qqz的小窝 2021<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function async(u,c){var d=document,t='script',o=d.createElement(t),s=d.getElementsByTagName(t)[0];o.src=u;if(c){o.addEventListener('load',function(e){c(null,e);},false);}
s.parentNode.insertBefore(o,s);}</script><script>if($('#tag_cloud').length!==0){async("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'},};$('#tag_cloud a').tagcloud();})}</script><script>async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var $nav=document.querySelector("nav");if($nav)FastClick.attach($nav);})</script></body></html>