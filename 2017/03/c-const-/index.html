<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="111qqz的小窝"><meta property="og:type" content="article"><meta property="og:image" content="https://111qqz.github.io/img/2.png"><meta property="twitter:image" content="https://111qqz.github.io/img/2.png"><meta name=title content="C++ const 用法总结（转载）"><meta property="og:title" content="C++ const 用法总结（转载）"><meta property="twitter:title" content="C++ const 用法总结（转载）"><meta name=description content><meta property="og:description" content><meta property="twitter:description" content><meta property="twitter:card" content="summary"><meta name=keyword content="ACM,111qqz,商汤科技,hust,华中科技大学"><link rel="shortcut icon" href=/img/favicon.ico><title>C++ const 用法总结（转载）-111qqz的小窝</title><link rel=canonical href=/2017/03/c-const-/><link rel=stylesheet href=/css/iDisqus.min.css><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/zanshang.css><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/docco.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=stylesheet href=/css/hux-blog.min.css><link rel=stylesheet href=/css/hux-blog.min-custom.css></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=/>111qqz的小窝</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>Home</a></li><li><a href=/categories/acm/>ACM-ICPC</a></li><li><a href=/categories/deep-learning/>深度学习</a></li><li><a href=/categories/mooc/>公开课</a></li><li><a href=/categories/%e5%85%b6%e4%bb%96/>其他</a></li><li><a href=/top/about/>ABOUT</a></li><li><a href=/search>SEARCH <img src=/img/search.png height=15 style=cursor:pointer alt=Search></a></li></ul></div></div></div></nav><script>var $body=document.body;var $toggle=document.querySelector('.navbar-toggle');var $navbar=document.querySelector('#huxblog_navbar');var $collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic)
function handleMagic(e){if($navbar.className.indexOf('in')>0){$navbar.className=" ";setTimeout(function(){if($navbar.className.indexOf('in')<0){$collapse.style.height="0px"}},400)}else{$collapse.style.height="auto"
$navbar.className+=" in";}}</script><style type=text/css>header.intro-header{background-image:url(/img/2.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags></div><h1>C++ const 用法总结（转载）</h1><h2 class=subheading></h2><span class=meta>Posted by
111qqz
on
Saturday, March 18, 2017
<span id=/2017/03/c-const-/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span><i class="fa fa-eye"></i><span class=old-visitors-count style=display:none></span><span class=leancloud-visitors-count></span></span><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("2dzJwxGKq4hbtg5R5NM8NTzJ-gzGzoHsz","RaYu8uGTiuiIjLISQppPVYWw");</script><script type=text/javascript>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';var OLD_COUNT_CONTAINER_REF='.old-visitors-count';for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){var oldCountSpan=$(element).find(OLD_COUNT_CONTAINER_REF).text();if(oldCountSpan!=''){countSpan.text(0+parseInt(oldCountSpan));}else{countSpan.text(0);}}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);var OLD_COUNT_CONTAINER_REF='.old-visitors-count';var $element=$(document.getElementById(url));var oldCountSpan=$element.find(OLD_COUNT_CONTAINER_REF).text();if(oldCountSpan!=''){newcounter.set("time",parseInt(oldCountSpan)+1);}else{newcounter.set("time",1);}
newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");if($('.leancloud_visitors').length==1){addCount(Counter);}else{showTime(Counter);}});</script></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><header><h2>TOC</h2></header><nav id=TableOfContents></nav><p>基本全文照搬了：<a href=http://blog.csdn.net/eric_jo/article/details/4138548>关于C++ const 的全面总结</a></p><p>总结全面还是要一点时间的orz..感谢原作者，暂时没发现有什么错误（?</p><p>其中对我而言比较陌生的是“<strong>const修饰成员函数</strong>”的用法。。已经加粗。</p><blockquote>    C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。<p>Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。</p><p><strong>一、Const作用</strong></p><p>**   **如下表所示：</p><table width=100%><tbody><tr><blockquote><td width=5%>**No.**</td></blockquote><blockquote><td width=16%>**作用**</td></blockquote><blockquote><td width=20%>**说明**</td></blockquote><blockquote><td width=57%>**参考代码**</td></blockquote></tr><tr><blockquote><td width=5%>1</td></blockquote><blockquote><td width=16%>可以定义const常量</td></blockquote><blockquote><td width=57%>const int Max = 100;</td></blockquote></tr><tr><blockquote><td width=5%>2</td></blockquote><blockquote><td width=16%>便于进行类型检查</td></blockquote><blockquote><td width=20%>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误</td></blockquote><blockquote><td width=57%>void f(const int i) { .........}</blockquote><p>//对传入的参数进行类型检查，不匹配进行提示</p><blockquote></td></blockquote></tr><tr><blockquote><td width=5%>3</td></blockquote><blockquote><td width=16%>可以保护被修饰的东西</td></blockquote><blockquote><td width=20%>防止意外的修改，增强程序的健壮性。</td></blockquote><blockquote><td width=57%>void f(const int i) { i=10;//error! }</blockquote><p>//如果在函数体内修改了i，编译器就会报错</p><blockquote></td></blockquote></tr><tr><blockquote><td width=5%>4</td></blockquote><blockquote><td width=16%>可以很方便地进行参数的调整和修改</td></blockquote><blockquote><td width=20%>同宏定义一样，可以做到不变则已，一变都变</td></blockquote></tr><tr><blockquote><td width=5%>5</td></blockquote><blockquote><td width=16%>为函数重载提供了一个参考</td></blockquote><blockquote><td width=57%>class A</blockquote><p>{
&mldr;&mldr;
void f(int i)       {&mldr;&mldr;} //一个函数
void f(int i) const {&mldr;&mldr;} //上一个函数的重载
&mldr;&mldr;
};</p><blockquote></td></blockquote></tr><tr><blockquote><td width=5%>6</td></blockquote><blockquote><td width=16%>可以节省空间，避免不必要的内存分配</td></blockquote><blockquote><td width=20%>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝</td></blockquote><blockquote><td width=57%>#define PI 3.14159         //常量宏</blockquote><p>const doulbe  Pi=3.14159;  //此时并未将Pi放入ROM中
&mldr;&mldr;
double i=Pi;   //此时为Pi分配内存，以后不再分配！
double I=PI;  //编译期间进行宏替换，分配内存
double j=Pi;  //没有内存分配
double J=PI;  //再进行宏替换，又一次分配内存！</p><blockquote></td></blockquote></tr><tr><blockquote><td width=5%>7</td></blockquote><blockquote><td width=16%> 提高了效率</td></blockquote><blockquote><td width=20%>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</td></blockquote></tr></tbody></table><p><strong>二、Const的使用</strong></p><p><strong>1、定义常量</strong>
(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。</p><p>TYPE const ValueName = value;
const TYPE ValueName = value;
(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.</p><p>extend const int ValueName = value;</p><p><strong>2、指针使用CONST</strong>
(1)指针本身是常量不可变
char* const pContent;</p><p>(2)指针所指向的内容是常量不可变
const char *pContent;</p><p>(3)两者都不可变
const char* const pContent;</p><p>(4)还有其中区别方法，沿着<em>号划一条线：
如果const位于</em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。</p><p><strong>3、函数中使用CONST</strong></p><p>(1)const修饰函数参数
a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</p><p>void function(const int Var);</p><p>b.参数指针所指内容为常量不可变</p><p>void function(const char* Var);</p><p>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</p><p>void function(char* const Var);</p><p>d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：</p><p>void function(const Class& Var); //引用参数在函数内不可以改变</p><p>void function(const TYPE& Var); //引用参数在函数内为常量不可变</p><p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.
(2)const 修饰函数返回值
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。
a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。
b. const int * fun2() //调用时 const int <em>pValue = fun2();
//我们可以把fun2()看作成一个变量，即指针内容不可变。
c.int</em> const fun3()   //调用时 int * const pValue = fun2();
//我们可以把fun2()看作成一个变量，即指针本身不可变。</p><p>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A& test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。
<strong>4、类相关CONST</strong></p><p>(1)const修饰成员变量
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。
class A
{
…
const int nValue;         //成员常量不能被修改
…
A(int x): nValue(x) { } ; //只能在初始化列表中赋值
}</p><p><strong>(2)const修饰成员函数</strong>
** const修饰类的成员函数，则该成员函数不能修改类中成员变量，也不能调用类中任何非const成员函数。一般写在函数的最后来修饰。**
** class A**
** {**
** …**
** void function()const; //常成员函数, 它不改变对象的成员变量.**</p><p><strong>//也不能调用类中任何非const成员函数。</strong>
** }**</p><p><strong>对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。</strong></p><blockquote></blockquote><pre><code>  1. **const成员函数不被允许修改它所在对象的任何一个数据成员。**
  2. **const成员函数能够访问对象的const成员，而其他成员函数不可以。**
</code></pre><p>**任何不会修改数据成员(即函数中的变量)的函数都应该声明为const 类型。如果在编写const 成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。以下程序中，类stack 的成员函数GetCount 仅用于计数，从逻辑上讲GetCount 应当为const 函数。编译器将指出GetCount 函数中的错误。**</blockquote></p><blockquote>(3)const修饰类对象/对象指针/对象引用<blockquote></blockquote><pre><code>  * const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。
  * const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。
</code></pre><p>例如：
class AAA
{
void func1();
void func2() const;
}
const AAA aObj;
aObj.func1(); ×
aObj.func2(); 正确const AAA* aObj = new AAA();
aObj-> func1(); ×
aObj-> func2(); 正确</p><p><strong>三、将Const类型转化为非Const类型的方法</strong></p><p>采用const_cast 进行转换。
用法：const_cast &lt;type_id>  (expression)
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。</p><blockquote></blockquote><pre><code>  * 常量指针被转化成非常量指针，并且仍然指向原来的对象；
  * 常量引用被转换成非常量引用，并且仍然指向原来的对象；
  * 常量对象被转换成非常量对象。
</code></pre><p><strong>四、使用const的一些建议</strong></p><blockquote></blockquote><pre><code>  * 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；
  * 要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题；
  * 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；
  * const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；
  * 不要轻易的将函数的返回值类型定为const;
  * 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;
  * 任何不会修改数据成员的函数都应该声明为const 类型。
</code></pre><p><strong>五、补充重要说明</strong></p><blockquote></blockquote><pre><code>  * 类内部的常量限制：使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式
</code></pre><p>初始化的整型或枚举类型，而且必须是static和const形式。</p><pre><code>  * 如何初始化类内部的常量：一种方法就是static 和 const 并用，在外部初始化，例如：
</code></pre><p>class A { public: A() {} private: static const int i; file://注意必须是静态的！ }；</p><p>const int A::i=3;另一个很常见的方法就是初始化列表： class A { public: A(int</p><p>i=0):test(i) {} private: const int i; }； 还有一种方式就是在外部初始化，</p><pre><code>  * 如果在非const成员函数中，this指针只是一个类类型的；如果在const成员函数中，
</code></pre><p>this指针是一个const类类型的；如果在volatile成员函数中,this指针就是一个</p><p>volatile类类型的。</p><pre><code>  * new返回的指针必须是const类型的。
</code></pre></blockquote><hr><ul class=pager><li class=previous><a href=/2017/03// data-toggle=tooltip data-placement=top title=京东实习面试总结>&larr;
Previous Post</a></li><li class=next><a href=/2017/03/awk-/ data-toggle=tooltip data-placement=top title="AWK 初探">Next
Post &rarr;</a></li></ul><div class=post-comment><span id=/2017/03/c-const-/ class=leancloud_visitors data-flag-title="C++ const 用法总结（转载）"><span class=post-meta-item-text>访问量</span>
<span class=leancloud-visitors-count></span><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'2dzJwxGKq4hbtg5R5NM8NTzJ-gzGzoHsz',appKey:'RaYu8uGTiuiIjLISQppPVYWw',notify:true,verify:false,avatar:'retro',placeholder:'说点什么吧...',visitor:true});</script></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/bfs title=bfs>bfs</a>
<a href=/tags/binary-search title=binary-search>binary-search</a>
<a href=/tags/brute-force title=brute-force>brute-force</a>
<a href=/tags/dfs title=dfs>dfs</a>
<a href=/tags/dp title=dp>dp</a>
<a href=/tags/greedy title=greedy>greedy</a>
<a href=/tags/kmp title=kmp>kmp</a>
<a href=/tags/leetcode title=leetcode>leetcode</a>
<a href=/tags/math title=math>math</a>
<a href=/tags/number-theory title=number-theory>number-theory</a>
<a href=/tags/rmq title=rmq>rmq</a>
<a href=/tags/stl title=stl>stl</a>
<a href=/tags/%E5%89%8D%E7%BC%80%E5%92%8C title=前缀和>前缀和</a>
<a href=/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA title=博弈论>博弈论</a>
<a href=/tags/%E5%9B%BE%E8%AE%BA title=图论>图论</a>
<a href=/tags/%E5%BF%AB%E9%80%9F%E5%B9%82 title=快速幂>快速幂</a>
<a href=/tags/%E6%95%B0%E4%BD%8Ddp title=数位dp>数位dp</a>
<a href=/tags/%E6%9E%84%E9%80%A0 title=构造>构造</a>
<a href=/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84 title=树状数组>树状数组</a>
<a href=/tags/%E6%A8%A1%E6%8B%9F title=模拟>模拟</a>
<a href=/tags/%E6%AF%8D%E5%87%BD%E6%95%B0 title=母函数>母函数</a>
<a href=/tags/%E7%9F%A9%E9%98%B5 title=矩阵>矩阵</a>
<a href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91 title=线段树>线段树</a>
<a href=/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95 title=计算几何>计算几何</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://111qqz.com>111qqz的wordpress博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href rel=alternate type=application/rss+xml title=111qqz的小窝><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=mailto:hust.111qqz@gmail.com><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-wechat fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/111qqz/><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 111qqz的小窝 2021<br><a href=https://beian.miit.gov.cn/>粤ICP备18103363号</a><br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function async(u,c){var d=document,t='script',o=d.createElement(t),s=d.getElementsByTagName(t)[0];o.src=u;if(c){o.addEventListener('load',function(e){c(null,e);},false);}
s.parentNode.insertBefore(o,s);}</script><script>if($('#tag_cloud').length!==0){async("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'},};$('#tag_cloud a').tagcloud();})}</script><script>async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var $nav=document.querySelector("nav");if($nav)FastClick.attach($nav);})</script></body></html>