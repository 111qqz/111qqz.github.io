<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>stl on Clarity</title><link>https://111qqz.com/tags/stl/</link><description>Recent content in stl on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sun, 06 May 2018 09:45:50 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/stl/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ STL Algotithms 学习笔记</title><link>https://111qqz.com/2018/05/c-stl-algotithms-notes/</link><pubDate>Sun, 06 May 2018 09:45:50 +0000</pubDate><guid>https://111qqz.com/2018/05/c-stl-algotithms-notes/</guid><description>
迫于拙劣的cpp水平，这次来记录一些关于STL算法部分的内容。
参考内容是CS106L的course reader
Iterator Categories Iterators分为以下五种:
* Output Iterators:可以使用&amp;quot;++&amp;quot;；可以用*myItr = value,不能用value = *myItr * Input Iterators:可以使用&amp;quot;++&amp;quot;;可以用value = *myItr，不能用*myItr = value * Forward Iterators: 可以使用&amp;quot;++&amp;quot;,可以同时用value = *myItr和*myItr = value * Bidirectional Iterators:比起Forward Iterator 对了&amp;quot;--&amp;quot;,但是不能+或者+= * Random-Access Iterators：比起Bidirectional Iterators多了+和+= Algorithm Naming Conventions 一些关于STL Algorithm的命名规则
后缀_if表示只有当满足一定条件的时候该算法才会执行一定任务。
比如:
bool IsEven(int value) { return value % 2 == 0; } cout &amp;lt;&amp;lt; count_if(myVec.begin(), myVec.end(), IsEven) &amp;lt;&amp;lt; endl; _n表示执行一个特定的操作n次。
比如:
fill_n(myDeque.begin(), 10, 0); Reordering Algorithms * sort: 传入的必须是Random-Access Iterators，记得定义&amp;lt;函数 * random_shuffle:传入的必须是Random-Access Iterators,作用是将一个区间内的元素打乱重排。 可以在使用之前先使用srand函数。 * rotate：作用是循环改变容器中元素的顺序。rotate(v.</description></item><item><title>cuda c++ 基础算法库 thrust 学习笔记</title><link>https://111qqz.com/2018/02/cuda-thrust-notes/</link><pubDate>Sat, 10 Feb 2018 08:43:54 +0000</pubDate><guid>https://111qqz.com/2018/02/cuda-thrust-notes/</guid><description>
可以了解成并行版的STL(?
过了一遍nvidia的官方网文档
发现如果熟悉STL的话,thrust没什么太多好说的,看起来很简单...
不过还是开一篇记录一下,一段时间内估计要和cuda c++ 打交道,就当记录使用过程中遇到的问题吧.</description></item><item><title>BZOJ 1653: [Usaco2006 Feb]Backward Digit Sums(暴力)</title><link>https://111qqz.com/2016/04/bzoj1653/</link><pubDate>Thu, 14 Apr 2016 07:12:27 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1653/</guid><description>
1653: [Usaco2006 Feb]Backward Digit Sums Time Limit: 5 Sec Memory Limit: 64 MB Submit: 349 Solved: 258 [Submit][Status][Discuss]
Description FJ and his cows enjoy playing a mental game. They write down the numbers from 1 to N (1 &amp;lt;= N &amp;lt;= 10) in a certain order and then sum adjacent numbers to produce a new list with one fewer number. They repeat this until only a single number is left. For example, one instance of the game (when N=4) might go like this: 3 1 2 4 4 3 6 7 9 16 Behind FJ's back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number N.</description></item><item><title>uva 156 - Ananagrams</title><link>https://111qqz.com/2016/01/uva156/</link><pubDate>Mon, 25 Jan 2016 09:19:56 +0000</pubDate><guid>https://111qqz.com/2016/01/uva156/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=92 题意：给出一段文字，包含若干个单词，以'#'结束。按照字典序输出所有的ananagrams。所谓ananagram，是指经过任意的重排后，不能得到这段文字中的另一个单词（不区分大小写） 思路：首先是字符串的读入...可以整行读入然后用空格分隔单词。由于补区分大小写，所以要都转化成小写...但是输出的时候要输出原始，所以还记得保留一份。而且要能够通过新的找到原始的（我用了一个toori的map&amp;lt;string,string&amp;gt;来实现） 然后最关键的部分是如何判断两个单词经过重排是否能一样...
我的做法是构造一个hash函数...一个单词的hash值等于对应字母的顺序的平方和...效果还不错？
单词和hash值一一对应...最大也就9E5,可以存的下。然后统计每个hash值出现的次数。对于那些只出现一次的，就是我们要的答案。
还要注意的是输出要按照原始单词的字典序，而不是都变成小写以后的字典序。
所以找到之后可以先找到对应的原始单词存到set里，最后再输出。
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 14时26分38秒 File Name :code/uva/156.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=9E5+7; string str; int a[N]; map&amp;lt;string,int&amp;gt;mp; map&amp;lt;string,int&amp;gt;::iterator it; map&amp;lt;string,string&amp;gt;toori; struct node { string ori; string nw; }st[1005]; set&amp;lt;string&amp;gt;ans; set&amp;lt;string&amp;gt;::iterator it2; int main() { mp.</description></item><item><title>codeforces 29 C. Mail Stamps</title><link>https://111qqz.com/2015/12/cf29c/</link><pubDate>Wed, 30 Dec 2015 12:27:15 +0000</pubDate><guid>https://111qqz.com/2015/12/cf29c/</guid><description>
http://codeforces.com/contest/29/problem/C 题意：给出n个边的关系，保证可以构成一条链。正向或者反向输出这个链。 思路：由于下标很大(1E9)，而关系个数只有1E5..需要离散化。。而且离散化的同时不能丢失边的关系。。。实际上。。直接用vector+map就好了。。。 map &amp;gt;e;即可。然后找到一个度为1的点。。做个dfs...
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 19时55分15秒 File Name :code/cf/problem/29C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; map&amp;lt;int,vector&amp;lt;int&amp;gt; &amp;gt;e; map&amp;lt;int,bool&amp;gt;vis; map&amp;lt;int,int&amp;gt;in; map&amp;lt;int,int&amp;gt;::iterator it; int beg; int n ; void dfs( int x) { vis[x] = true; printf(&amp;quot;%d &amp;quot;,x); for ( int i = 0 ; i &amp;lt; e[x].</description></item><item><title>codeforces 12 C. Fruits</title><link>https://111qqz.com/2015/12/cf12c/</link><pubDate>Tue, 29 Dec 2015 08:05:19 +0000</pubDate><guid>https://111qqz.com/2015/12/cf12c/</guid><description>
http://codeforces.com/contest/12/problem/C 题意：有n个价格价格，m个要买的东西（可能有相同的种类，设为k种），把n个标签中拿出k个给个贴上。。。问最大价钱和最少价钱分别是多少。 思路：贪心。不过要按照map的value排序。。然后发现其实不用排序。。因为map的key值其实不影响。
vector降序排列的话。。直接 sort(v.rbegin(),v.rend());就好。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 15时30分54秒 File Name :code/cf/problem/12C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; map&amp;lt;string,int&amp;gt;mp; int a[N]; map&amp;lt;string,int&amp;gt;::iterator it; vector&amp;lt;int &amp;gt;v; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #332 div 2 D. Spongebob and Squares</title><link>https://111qqz.com/2015/12/cf559d/</link><pubDate>Wed, 23 Dec 2015 08:57:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf559d/</guid><description>
http://codeforces.com/contest/599/problem/D 题意：给出总的方格数x，问有多少种不同尺寸的矩形满足题意，输出方案数和长宽（3,5和5,3算两种） 思路：比赛的时候gg了。。其实稍微在纸上推一下。就会得到对于n,m的矩形，一共会有-nnn+3nnm+n+3n*m的方格。数量级是n3。 我们可以实际跑一遍。发现对于x1E18的数量级，n不会超过1442550，1E6,可以搞。
需要注意的是，一个是会爆int,所以记得用long long
另一个是如果两个数相等，记得只输入一组，并且方案数-1
我是用set +pair存的答案。。反向遍历set的时候要用reserve_iterator...
/* *********************************************** Author :111qqz Created Time :2015年12月23日 星期三 15时54分37秒 File Name :code/cf/#332/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; LL ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL x; LL cur; const LL MAXN = 1442550; set&amp;lt;pi&amp;gt;se; LL cal( LL n,LL m) { LL res = -n*n*n+3*n*n*m+3*n*m+n; return res; } int square = -1; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #333 div 2B. Approximating a Constant Range</title><link>https://111qqz.com/2015/12/cf602b/</link><pubDate>Tue, 22 Dec 2015 08:04:29 +0000</pubDate><guid>https://111qqz.com/2015/12/cf602b/</guid><description>
http://codeforces.com/contest/602/problem/B 题意：给定n个数，问最大连续区间长度，满足这段区间内最大值和最小值的差的绝对值小于等于1. 思路：尺取+set。尺取法，由于要时刻得到一段区间的最大值和最小值，而且可能有重复元素，所以用multiset.
需要注意的是，set里最小值是se.begin() ，最大值是se.rbegin()这样比较好。。不要用se.end()之类。。。
另一个需要注意的是，multiset里用erase的时候。如果se.erase(x)会把集合里所有的x都删除掉。如果指向删除一个，那么应该写成se.erase(se.find(x))
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 15时10分01秒 File Name :code/cf/#333/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; int a[N]; void ruler() { int head = 1; int tail = 1; int ans = -1; multiset&amp;lt;int&amp;gt;se; while (tail&amp;lt;=n) { se.</description></item><item><title>poj 3687 Labeling Balls</title><link>https://111qqz.com/2015/12/poj3687/</link><pubDate>Sat, 19 Dec 2015 09:18:52 +0000</pubDate><guid>https://111qqz.com/2015/12/poj3687/</guid><description>
http://poj.org/problem?id=3687 题意：给定几个标签球的重量大小关系，求每个球是第几重的(即每个球在所有球的重量中由小到大排名是多少)。 （输出是每个球第几重，而不是几号球比几号球重！）。一开始理解错了QAQ 思路：反向拓扑+优先队列。因为正向不好用。。。所以我们连边的时候由重的指向轻的。。这样最先出队的就是最重的。。和上道题差不多？
/* *********************************************** Author :111qqz Created Time :2015年12月19日 星期六 16时32分59秒 File Name :code/poj/3687.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=203; int n,m; bool conc[N][N]; bool ok; int in[N]; int ans[N]; void topo() { priority_queue&amp;lt;int &amp;gt;q; for ( int i = 1 ; i &amp;lt;= n ; i++) if (in[i]==0) q.</description></item><item><title>hdoj4391 Paint The Wall</title><link>https://111qqz.com/2015/12/hdoj4391/</link><pubDate>Tue, 15 Dec 2015 08:52:37 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj4391/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4391 题意：有 n 个点，每个点有一种颜色（可能相同），两种操作：1、将区间 [a,b] 染成颜色 c ; 2、询问区间 [a,b] 中颜色为 c 的点有多少个。 思路：因为颜色种类很多。。。没办法通过建很多棵线段树解决。我们用分块的办法。。。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 15时00分34秒 File Name :code/hdoj/4391.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; //sqrt(n),n最大100000 int n,q,c[N]; int len ,cnt; struct HashBlock{ int siz; //块的大小，因为最后一个快的长度可能不足len, int col;//整块的颜色。当快没有被标记成统一的颜色的时候，为-1 map&amp;lt;int,int&amp;gt;mp; }a[400]; void init() { len = (int)sqrt(n*1.</description></item><item><title>codeforces 567 E President and Roads (优先队列＋迪杰斯特拉＋tarjan)</title><link>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</link><pubDate>Sun, 16 Aug 2015 19:26:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</guid><description>
题意是说，给定一个有向图，对于每一条边，问是否是s到t的最短路上一定会经过的边．
如果是就输出yes
如果不是，问能否通过减少这条边的权值（减少的权值就是修理费用），使得这条边成为新的最短路上的边．
对于一条边是否一定是最短路上的边，我们可以从s做一遍最短路，然后反响建边，从t再做一遍最短路．
得到两个d1,d2数组
如果一条边d1[u] + d2[v] + w(u, v) = 最短路，那这条边在最短路上的边．但是未必不能缺少．
我们还要判断这条边是否是不能缺少的．
不能缺少的意思是说，如果没有这条边，就不能构成最短路．
那么这条边一定是桥．
我们可以用tarjan算法求桥．
据说是水题，不过图论还没怎么刷，所以对我来说还是很有难度的．
只是基本懂了
下面的代码是我仿照其他人的代码写出来的....求不鄙视　＞＜
/************************************************************************* &amp;gt; File Name: code/cf/#314/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 03时09分39秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef pair&amp;lt;LL,LL&amp;gt; P; const int maxn = 200005; const LL mod1 = 1e9 + 7; const LL mod2 = 99999991; const LL inf = 1e15; struct Nod{ LL b,val,next,idx; void init(LL b,LL val,LL next,LL idx){ this-&amp;gt;b=b;this-&amp;gt;val=val;this-&amp;gt;next=next;this-&amp;gt;idx=idx; } }buf[2][maxn]; LL len[2],E[2][maxn]; LL n,m,s,t; LL dis[2][maxn],cnt[2][2][maxn],ans1[maxn],ans2[maxn]; priority_queue&amp;lt;P,vector&amp;lt;P&amp;gt;,greater&amp;lt;P&amp;gt; &amp;gt; q; void init() { memset(E,-1,sizeof(E)); memset(cnt,0,sizeof(cnt)); len[0] = len[1] = 0; } void add_edge(LL a,LL b,LL val,LL idx) { buf[0][len[0]].</description></item><item><title>POJ 1028 Web Navigation</title><link>https://111qqz.com/2015/07/poj1028/</link><pubDate>Wed, 08 Jul 2015 02:08:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1028/</guid><description>
http://poj.org/problem?id=1028
1 2 3 4 /* *********************************************** 5Author :111qqz 6Created Time :2016年02月19日 星期五 15时45分01秒 7File Name :1028.cpp 8************************************************ */ 9 10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstdio&amp;gt;12 #include &amp;lt;iostream&amp;gt;13 #include &amp;lt;cstring&amp;gt;14 #include &amp;lt;string&amp;gt;15 #include &amp;lt;cmath&amp;gt;16 #include &amp;lt;map&amp;gt;17 #include &amp;lt;stack&amp;gt;18 #include &amp;lt;queue&amp;gt;19 20 using namespace std; 21 typedef long long LL; 22 const int inf = 8E8; 23 stack&amp;lt;string&amp;gt; backstack; 24 stack&amp;lt;string&amp;gt; forwardstack; 25 string cur; 26 string cmd; 27 int main() 28 { 29 cur =&amp;#34;http://www.</description></item><item><title>poj 2643 election</title><link>https://111qqz.com/2015/07/poj2643/</link><pubDate>Wed, 08 Jul 2015 01:27:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj2643/</guid><description>
题目链接：http://poj.org/problem?id=2643
在考stl的map...
我是定义了一个string 指向string的，表示参选人和党派的关系，和一个string 指向int的，表示某个党派被投票的次数。
需要注意的是！！！
需要注意的是！！！
需要注意的是！！！
字符串读入部分...
在输入n和m之后，会有一个回车符没读进去...(大概是这样？)
如果不处理一下的话，后面的字符串就会少读入一个...(sad)
解决的办法是在读完n和m之后写一个getchar(); 把回车符读掉。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时44分55秒 6File Name :2643.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 #include &amp;lt;stack&amp;gt;17 #include &amp;lt;queue&amp;gt;18 19 using namespace std; 20 typedef long long LL; 21 const int inf = 8E8; 22 int n,m; 23 string ans; 24 map&amp;lt;string,string&amp;gt;m1; 25 map&amp;lt;string,int&amp;gt;m2; 26 string c_name,p_name; 27 char ch; 28 int main() 29 { 30 cin&amp;gt;&amp;gt;n; 31 getchar(); 32 for ( int i = 1 ; i &amp;lt;= n ; ++i ) 33 { 34 getline(cin,c_name); 35 36 getline(cin,p_name); 37 m1[c_name]=p_name; 38 } 39 cin&amp;gt;&amp;gt;m; 40 getchar(); 41 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 42 { 43 getline(cin,c_name); 44 m2[c_name]++; 45 } 46 map&amp;lt;string,int&amp;gt;::iterator it; 47 int mmax=-1; 48 for (it=m2.</description></item><item><title>poj 3481 double queues</title><link>https://111qqz.com/2015/07/poj3481/</link><pubDate>Fri, 03 Jul 2015 04:10:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3481/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1908
看到有两个优先级，然后题目中又有queue。。。就想到了优先队列。。。
但是优先队列的cmp函数没搞懂，因为比较的是结构体，好像要重载&amp;lt; 什么的。
然而并不会。
其实用map就可以做。。。
map在插入的时候可以自动按关键字排序，简直好评如潮！
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时44分06秒 6File Name :3481.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 #include &amp;lt;stack&amp;gt;17 #include &amp;lt;queue&amp;gt;18 19 using namespace std; 20 typedef long long LL; 21 const int inf = 8E8; 22 23 24 25 int cmd; 26 map&amp;lt;int,int&amp;gt;a; 27 int p,k; 28 29 int main() 30 { 31 32 while (scanf(&amp;#34;%d&amp;#34;,&amp;amp;cmd)!</description></item><item><title>poj 1833 排列</title><link>https://111qqz.com/2015/07/poj1833/</link><pubDate>Thu, 02 Jul 2015 19:21:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1833/</guid><description>
http://poj.org/problem?id=1833
还是next_permutation.
这次是Int类型的
需要注意的是next_permutation是先判断时候有后继，返回一个bool值，如果为true，就转化到后继。
而next_permutation函数本书不考虑其值，就具有转化成后继的作用。
而且默认最后一个排列的下一个排列是第一个排列。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时43分58秒 6File Name :1833.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 17 using namespace std; 18 const int N=3E3+5; 19 int n ,m,k; 20 int a[N],b[N]; 21 22 int main() 23 { 24 cin&amp;gt;&amp;gt;m; 25 while (m--) 26 { 27 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k; 28 // k = k % n; 29 30 for ( int i = 0;i &amp;lt; n ; i++ ) 31 { 32 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); 33 } 34 while (k--) 35 { 36 next_permutation(a,a+n); 37 } 38 for ( int i = 0 ; i &amp;lt; n ; i++ ) 39 { 40 printf(&amp;#34;%d &amp;#34;,a[i]); 41 } 42 printf(&amp;#34;\n&amp;#34;); 43 44 45 } 46 47 48 return 0; 49 } 50 51</description></item><item><title>poj 1256 Anagram</title><link>https://111qqz.com/2015/07/poj1256/</link><pubDate>Thu, 02 Jul 2015 18:41:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1256/</guid><description>
http://poj.org/problem?id=1256
题意是说求出一个字符串的全排列，按字典序
需要注意的是字典序和传统意义上的字典序不同
重新定义了,A
需要自己重写cmp函数。
next_permutation好神....直接求出全排列.....
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 15时43分31秒 6File Name :code/poj/1256.cpp 7************************************************ */ 8 9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstdio&amp;gt;11 #include &amp;lt;iostream&amp;gt;12 #include &amp;lt;cstring&amp;gt;13 #include &amp;lt;string&amp;gt;14 #include &amp;lt;cmath&amp;gt;15 #include &amp;lt;map&amp;gt;16 17 using namespace std; 18 bool cmp(char a,char b) 19 { 20 char x = tolower(a); 21 char y = tolower(b); 22 if (x==y) 23 { 24 return a&amp;lt;b; 25 } 26 else return x&amp;lt;y; 27 } 28 int n; 29 string st; 30 31 int main() 32 { 33 cin&amp;gt;&amp;gt;n; 34 while (n--) 35 { 36 37 cin&amp;gt;&amp;gt;st; 38 sort(st.</description></item></channel></rss>