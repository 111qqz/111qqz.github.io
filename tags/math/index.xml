<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>math on Clarity</title><link>https://111qqz.com/tags/math/</link><description>Recent content in math on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sat, 30 Sep 2017 19:40:15 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>uva 10655 - Contemplation! Algebra （构造矩阵，快速幂）</title><link>https://111qqz.com/2017/10/uva-10655/</link><pubDate>Sat, 30 Sep 2017 19:40:15 +0000</pubDate><guid>https://111qqz.com/2017/10/uva-10655/</guid><description>
uva10655题目链接
题意： 给出a+b和ab的值，问a^n+b^n
思路： 构造矩阵,手写一下很显然...
转移矩阵M=[0 , 1]
[-q,p ]
初始矩阵M1=[p ]
[p^2-2*q]
快速幂即可。
有个坑点在于..读入的结束是p=0&amp;amp;q=0,并且只有这两个输入。
如果用p=0&amp;amp;&amp;amp;q=0作为终止条件，那么就会将三个输入，但p==0&amp;amp;&amp;amp;q==0的情况错误得终止...
正确的做法是 while (~scanf(&amp;quot;%lld%lld%lld&amp;quot;,&amp;amp;p,&amp;amp;q,&amp;amp;n)==3)
/* *********************************************** Author :111qqz Created Time :2017年10月01日 星期日 03时01分38秒 File Name :10655.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL p,q,n; struct Mat { LL mat[105][105]; void clear() { ms(mat,0); } }M,M1; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>codeforces #413 A. Carrot Cakes (模拟)</title><link>https://111qqz.com/2017/05/codeforces-div2-413a/</link><pubDate>Fri, 12 May 2017 13:12:30 +0000</pubDate><guid>https://111qqz.com/2017/05/codeforces-div2-413a/</guid><description>
题目链接
题意：初始有一个锅，每t分钟可以做好k个饼，现在需要N个饼。还可以另外建一个锅，花费d时间，建好以后两个锅可以并行烙饼。问是否应该建锅？（以期减少烙饼时间）
思路：求出两种情况下的总时间，比较一下。
只有一个锅的情况很好求。
两个锅的情况比较麻烦，不如模拟时间流逝？
反正最多也就1E6的时间。。。模拟一下。。。稳。。
/* *********************************************** Author :111qqz Created Time :2017年05月11日 星期四 15时29分43秒 File Name :A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>今日头条笔试题-木棒拼图(数学)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-02/</link><pubDate>Wed, 29 Mar 2017 13:27:24 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-02/</guid><description>
有一个由很多木棒构成的集合，每个木棒有对应的长度，请问能否用集合中的这些木棒以某个顺序首尾相连构成一个面积大于 0 的简单多边形且所有木棒都要用上，简单多边形即不会自交的多边形。
初始集合是空的，有两种操作，要么给集合添加一个长度为 L 的木棒，要么删去集合中已经有的某个木棒。每次操作结束后你都需要告知是否能用集合中的这些木棒构成一个简单多边形。
输入描述: 每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n 表示操作的数量(1 ≤ n ≤ 50000) ， 接下来有n行，每行第一个整数为操作类型 i (i ∈ {1,2})，第二个整数为一个长度 L(1 ≤ L ≤ 1,000,000,000)。如果 i=1 代表在集合内插入一个长度为 L 的木棒，如果 i=2 代表删去在集合内的一根长度为 L 的木棒。输入数据保证删除时集合中必定存在长度为 L 的木棒，且任意操作后集合都是非空的。
输出描述: 对于每一次操作结束有一次输出，如果集合内的木棒可以构成简单多边形，输出 &amp;quot;Yes&amp;quot; ，否则输出 &amp;quot;No&amp;quot;。
输入例子: 5 1 1 1 1 1 1 2 1 1 2 输出例子: No No Yes No No 能组成n边形的条件可以由三角形推广而来..(虽然只是猜想... 也就是n-1条较小边的和大于最大边...事实证明这结论是对的orz.. 然后就是multiset就好...
/* *********************************************** Author :111qqz Created Time :2017年03月29日 星期三 21时17分02秒 File Name :code/toutiao2.</description></item><item><title>BZOJ 1800: [Ahoi2009]fly 飞行棋 （尺取+数学）</title><link>https://111qqz.com/2017/01/bzoj-1800-ahoi2009fly-/</link><pubDate>Thu, 26 Jan 2017 15:42:07 +0000</pubDate><guid>https://111qqz.com/2017/01/bzoj-1800-ahoi2009fly-/</guid><description>
1800: [Ahoi2009]fly 飞行棋 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 1530 Solved: 1220 [Submit][Status][Discuss]
Description 给出圆周上的若干个点，已知点与点之间的弧长，其值均为正整数，并依圆周顺序排列。 请找出这些点中有没有可以围成矩形的，并希望在最短时间内找出所有不重复矩形。
Input 第一行为正整数N，表示点的个数，接下来N行分别为这N个点所分割的各个圆弧长度
Output 所构成不重复矩形的个数
Sample Input 8 1 2 2 3 1 1 3 3
Sample Output 3
HINT N&amp;lt;= 20 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://www.lydsy.com/JudgeOnline/images/1800.jpg
Disk path: /static/http://www.lydsy.com/JudgeOnline/images/1800.jpg
Using Page Bundles: false</description></item><item><title>codeforces #382 div2 D. Taxes(哥德巴赫猜想)</title><link>https://111qqz.com/2016/11/cf375d-2/</link><pubDate>Tue, 29 Nov 2016 11:16:28 +0000</pubDate><guid>https://111qqz.com/2016/11/cf375d-2/</guid><description>
题目链接
题意：一个人有n元前，他要交的税是n的最大因子（除n外)，现在这个投机倒把者想把前分成k部分(k为大于等于１的任意值）每部分不能为１，分别交税，问最少交多少税。
思路：要说因子小。。很容易想到素数。。。然后就很容易想到了维基百科_哥德巴赫猜想
内容是：任何一个大于２的偶数可以写成两个素数的和。
（虽然是一个猜想没有被证明。。。但是1E9这种级别正确性还是很显然的２３３３
那么任何大于２的偶数，答案就是２
奇数可以分成一个３和一个偶数，答案为３．
不过这可能还不够优，这也是这道题的两个trick所在：
如果该数本身为素数，那么不用分（k取１），答案为１
如果该数减去２为素数，那么答案为２．
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 11时36分56秒 File Name :code/cf/#382/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; bool prime( LL x) { for ( LL i = 2 ; i*i &amp;lt;= x ; i++) { if (x%i==0) return false; } return true; } LL solve( LL x) { if (prime(x)) return 1; if (x%2==0) return 2; if (x%2==1) { if (prime(x-2)) return 2; else return 3; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #382 div2 C. Tennis Championship(打表找规律）</title><link>https://111qqz.com/2016/11/cf735d/</link><pubDate>Tue, 29 Nov 2016 11:07:25 +0000</pubDate><guid>https://111qqz.com/2016/11/cf735d/</guid><description>
题目链接
题意：n个人进行淘汰赛制的比赛，输的人直接被淘汰，不进行下一轮，现在要求两个人可以比赛当且仅当两个人的胜场数相差小于等于１，现在问赢得最多场的那个人，最多可能赢多少场。
思路：打表找规律。。。麻蛋。。手算错了n=8。。。结果达成了f[1] = 2,fib[2] =4 的奇怪的fib数列。。。卡了一个多小时。。。气哭了。。。
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 10时16分50秒 File Name :code/cf/#382/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned long long n; unsigned long long x,y,z; unsigned long long solve( unsigned long long xx) { if (xx&amp;lt;=2) return 1; if (xx&amp;lt;=4) return 2; x = 1; y = 2; int p; unsigned long long cur = 4; for ( int i = 3 ; ; i++) { z = x + y; x = y; y = z; cur = cur + z; if (cur&amp;gt;=xx) { p = i; break; } } //cout&amp;lt;&amp;lt;p&amp;lt;&amp;lt;endl; return p; } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1257: [CQOI2007]余数之和sum (数学)</title><link>https://111qqz.com/2016/11/bzoj-1257-cqoi2007sum-/</link><pubDate>Mon, 28 Nov 2016 14:03:30 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1257-cqoi2007sum-/</guid><description>
1257: [CQOI2007]余数之和sum Time Limit: 5 Sec Memory Limit: 162 MB Submit: 3724 Solved: 1711 [Submit][Status][Discuss]
Description 给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7
Input 输入仅一行，包含两个整数n, k。
Output 输出仅一行，即j(n, k)。
Sample Input 5 3
Sample Output 7
HINT 50%的数据满足：1&amp;lt;=n, k&amp;lt;=1000 100%的数据满足：1&amp;lt;=n ,k&amp;lt;=10^9</description></item><item><title>poj 1971 Parallelogram Counting</title><link>https://111qqz.com/2016/11/poj-1971/</link><pubDate>Tue, 22 Nov 2016 15:08:14 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-1971/</guid><description>
题目链接
题意：给出n（n&amp;lt;=1E3）个不同的点，问最多组成多少个平行四边形。
思路：这道题的关键是，对于平行四边形的判断条件，要利用平行四边形对角线的交点平分两条对角线的性质。
也就是说，如果两条线段的对角线重合，那么一定可以组成一个平行四边形。
因此统计中点的位置即可，复杂度nnlg(n*n)
/* *********************************************** Author :111qqz Created Time :2016年11月22日 星期二 22时43分26秒 File Name :code/poj/1971.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; struct point { int x,y; bool operator &amp;lt; (point b)const { if (x==b.</description></item><item><title>bzoj 2456: mode (O(1)找到出现次数大于n/2的数)</title><link>https://111qqz.com/2016/11/bzoj-2456-mode-o1n2/</link><pubDate>Sun, 20 Nov 2016 01:22:28 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-2456-mode-o1n2/</guid><description>
2456: mode Time Limit: 1 Sec Memory Limit: 1 MB Submit: 3887 Solved: 1636 [Submit][Status][Discuss]
Description 给你一个n个数的数列，其中某个数出现了超过n div 2次即众数，请你找出那个数。
Input 第1行一个正整数n。 第2行n个正整数用空格隔开。
Output  一行一个正整数表示那个众数。
Sample Input 5 3 2 3 1 3
Sample Output 3
HINT 100%的数据，n&amp;lt;=500000，数列中每个数&amp;lt;=maxlongint。
zju2132 The Most Frequent Number
思路：一开始没注意空间限制...不过为毛是TLE。。。以至于最后什么都不干也TLE，我才意识到问题并没有辣么简单。。。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: https://111qqz.com/wordpress/wp-content/uploads/2016/11/选区_001-1.png
Disk path: /static/https://111qqz.com/wordpress/wp-content/uploads/2016/11/选区_001-1.png</description></item><item><title>bzoj 1968: [Ahoi2005]COMMON 约数研究 (思维题)</title><link>https://111qqz.com/2016/11/bzoj-1968-ahoi2005common-/</link><pubDate>Fri, 18 Nov 2016 13:50:26 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-1968-ahoi2005common-/</guid><description>
1968: [Ahoi2005]COMMON 约数研究 Time Limit: 1 Sec Memory Limit: 64 MB Submit: 1997 Solved: 1508 [Submit][Status][Discuss]
Description Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://www.lydsy.com/JudgeOnline/images/1968.jpg
Disk path: /static/http://www.lydsy.com/JudgeOnline/images/1968.jpg
Using Page Bundles: false
Input 只有一行一个整数 N（0 &amp;lt; N &amp;lt; 1000000）。
Output 只有一行输出，为整数M，即f(1)到f(N)的累加和。
Sample Input 3
Sample Output 5
HINT Source Day2
思路：如果跟着题目的意思走。。。求每个数的约束个数。。。复杂度是不资瓷的。。。
然而因为是求和，我们可以直接考虑，每个因子对答案的贡献。
容易知道，因子x对答案的贡献为n/x</description></item><item><title>【叉姐的魔法训练第一课_初级魔法练习】poj 3244 Difference between Triplets （数学）</title><link>https://111qqz.com/2016/11/poj-3244/</link><pubDate>Thu, 17 Nov 2016 13:22:47 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-3244/</guid><description>
题目链接
题意： For every pair of triplets, Ta = (Ia, Ja, Ka) and T__b = (Ib, Jb, Kb), we define the difference value between Ta and_T__b_ as follows:
D(Ta,_ Tb_) = max {_Ia_ − _Ib_, _Ja_ − _Jb_, _Ka_ − _Kb_} − min {_Ia_ − _Ib_, _Ja_ − _Jb_, _Ka_ − _Kb_}
Now you are given N triplets, could you write a program to calculate the sum of the difference values between every unordered pair of triplets?</description></item><item><title>light oj 1045 Digits of Factorial (k进制数的位数)</title><link>https://111qqz.com/2016/09/digits-of-factorial-k/</link><pubDate>Tue, 13 Sep 2016 09:41:38 +0000</pubDate><guid>https://111qqz.com/2016/09/digits-of-factorial-k/</guid><description>
题目链接 题意：求n！在k进制表示下有多少位。 思路：答案为[ log(1)+log(2)+...+log(N) ]+1 其中log的底数都是K
由于有多组数据，预处理一个log的前缀和。
/* *********************************************** Author :111qqz Created Time :Tue 13 Sep 2016 05:13:15 PM CST File Name :code/loj/1045.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt;-digits-of-factorial-k进制数的位 #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; int base; double sum[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #368 div 2 C. Pythagorean Triples (构造，数学)</title><link>https://111qqz.com/2016/08/cf707c/</link><pubDate>Sun, 21 Aug 2016 10:45:59 +0000</pubDate><guid>https://111qqz.com/2016/08/cf707c/</guid><description>
题目链接
题意：给出一个数，问包含这个数三个数组成的勾股数，输出另外两个数。
思路：
所谓勾股数,就是当组成一个直角三角形的三边长都为正整数时,我们就称这一组数为勾股数. 那么,组成一组勾股数的三个正整数之间,是否具有一定的规律可寻呢?下面我们一起来观察几组勾股数： 规律一：在勾股数（3,4,5）、（5,12,13）、（7,24,25）（9,40,41）中,我们发现 由（3,4,5）有：32=9=4+5 由（5,12,13）有：52=25=12+13 由（7,24,25）有：72=49=24+25 由（9,40,41）有：92=81=40+41. 即在一组勾股数中,当最小边为奇数时,它的平方刚好等于另外两个连续的正整数之和.因此,我们把它推广到一般,从而可得出以下公式： ∵（2n+1)²=4n²+4n+1=（2n²+2n）+（2n²+2n+1） ∴（2n+1)**²**+（2n²+2n)²=（2n²+2n+1)²（n为正整数） 证明（略） **勾股数公式一：（2n+1,2n²+2n,2n²+2n+1）（n为正整数）** 规律二：在勾股数（6,8,10）、（8,15,17）、（10,24,26）中,我们发现 由（6,8,10）有：62=36+2×（8+10） 由（8,15,17）有：82=64=2×（15+17） 由（10,24,26）有：102=100=2×（24+26） 即在一组勾股数中,当最小边为偶数时,它的平方刚好等于两个连续整数之和的二倍,推广到一般,从而可得出另一公式： ∵（2n）2=4n2=2[（n2-1）+（n2+1）] ∴（2n）2+（n2-1）2=（n2+1）2（n≥2且n为正整数） 证明（略） **勾股数公式二：（2n,n²-1,n²+1）（n≥2且n为正整数）** 利用以上两个公式,我们可以快速写出各组勾股数. 结论是： n&amp;lt;=2无解。
n为奇数用公式1构造。
n为偶数用公式2构造。
** **
 /* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时02分26秒 File Name :code/cf/#368/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;code/in.</description></item><item><title>hdu 5833 || ccpc 2016 网络赛 1002 Zhu and 772002 （高斯消元）</title><link>https://111qqz.com/2016/08/hdu-5833/</link><pubDate>Sun, 14 Aug 2016 11:33:25 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5833/</guid><description>
hdu 5833 题目链接
题意：n个数，保证每个数的素因子不超过2000，从中取若干个，问乘积是完全平方数的方案数。
思路： 完全平方数就是要求每个质因子的指数是偶数次。
列方程组，a1,a2,a3……am分别表示bi是否在集合中。对于每一个素因子，建立异或方程组，要求因子个数为偶数，即异或为0
然后得到自由元的个数为num,答案为2^num-1 (减去空集)
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std; typedef long long LL ; #define pi acos(-1.0) const int mod=1e9+7; const int INF=1e9; const double eqs=1e-9; const int N=310; LL mat[N][N], a[N], equ, var, prime[N]; LL c[N]; LL gauss() { LL i, j, k, h, max_r, tmp; for(i=0,j=0;i&amp;lt;equ&amp;amp;&amp;amp;j&amp;lt;var;i++,j++){ max_r=i; for(k=i+1;k&amp;lt;equ;k++){ if(mat[k][j]&amp;gt;mat[max_r][j]) max_r=k; } if(max_r!</description></item><item><title>hdu 2050 折线分割平面 (找规律，递推)</title><link>https://111qqz.com/2016/07/hdu-2050/</link><pubDate>Wed, 27 Jul 2016 12:35:15 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2050/</guid><description>
hdu 2050题目链接
题意：n条折线。。最多能把平面分成几部分。。 思路：联想到m条直线，最多能把平面分成m*(m+1)/2+1部分。。
画图发现。。。 f[2*n-1]==g[n]。。
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 20时28分57秒 File Name :code/hdu/2050.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust2016 warm up A ||codeforces 682 A. Alyona and Numbers (计数问题，水)</title><link>https://111qqz.com/2016/07/cf682a/</link><pubDate>Mon, 18 Jul 2016 11:49:37 +0000</pubDate><guid>https://111qqz.com/2016/07/cf682a/</guid><description>
cf682A题目链接
题意：两个数组，分别为1..n和1..m。。。从两个数组中各取一个，问和能被5整除的方案数。。。
思路：傻逼题。。。统计%5。。。然后乘法原理。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 12时32分22秒 File Name :code/2016whust/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n,m; LL a[N],b[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4607 Park Visit (树的直径，推公式)</title><link>https://111qqz.com/2016/07/hdu-4607/</link><pubDate>Wed, 13 Jul 2016 07:00:27 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-4607/</guid><description>
hdu4607题目链接 题意：给出一棵树。。。边权都为1. m个查询。。每个查询给一个k,表示只访问k个点。。。问每次的最小路径和是多少。。。 思路：我们发现。。会使路径和变大的一个不利因素是折返。。也就是访问某景点后。。必须要回去才能继续前进。。这样的距离是2倍。。那为了使得路径和尽可能小。。我们就尽量不要访问这样的点。。。而不是这样的点一定在直径上。。。以及我们还发现。。。不在直径上的点。。 。。不管深度如何（深度的意思是说，与和该点最近的直径上的点的距离），距离的贡献是一样的。。都是2倍。。所以我们可以推出一个公式。。。如果树的直径是d,那么k&amp;lt;=d+1的时候，答案为k-1,否则答案为d+(k-d-1)*2。。。
因为bfs的时候忘记标记起点WA了一发蠢哭。。。。2A
/* *********************************************** Author :111qqz Created Time :2016年07月13日 星期三 14时33分29秒 File Name :code/poj/4607.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector&amp;lt; int &amp;gt;edge[N]; int n,m; int d[N]; int lst,beg; bool vis[N]; void bfs( int s) { ms(d,0); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>codeforces #346 div 2 D. Bicycle Race (思维，计算几何，公式)</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-d-bicycle-race-/</link><pubDate>Thu, 31 Mar 2016 09:02:23 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-d-bicycle-race-/</guid><description>
题目链接 题意：给出n+1个点，每次由i点到i+1点，每段线段之间保证不同向或者反向，第一个点和最后一个点保证重合。路径围城的封闭图形中间都是水，问有多少个危险点，使得如果在这个点忘记转弯就会掉进水里。
思路：搞了半天没搞出来qaq
From the track description follows that Maria moves the way that the water always located to the right from her, so she could fall into the water only while turning left. To check if the turn is to the left, let's give every Maria's moves directions a number: moving to the north — 0, moving to the west — 1, to the south — 2 and to the east — 3.</description></item><item><title>hdu 5630 Rikka with Chess （暴力 ，计数问题）</title><link>https://111qqz.com/2016/03/hdu5630/</link><pubDate>Thu, 03 Mar 2016 12:53:20 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5630/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5630 题意：nm的棋盘，相邻格子的颜色相反，每次可以翻转一个任意大小矩形的格子，问最少需要翻转多少次使得棋盘的nm个格子颜色相同。（翻转的意思是颜色反色）
思路：手写了下。。发现。。答案就是n/2+m/2. 对应的最优策略是。。翻偶数行和偶数列，都翻一遍，颜色就一样了。
/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 20时47分47秒 File Name :code/hdu/5630.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1205 吃糖果 （鸽笼原理）</title><link>https://111qqz.com/2016/02/hdu1205/</link><pubDate>Mon, 29 Feb 2016 12:51:51 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1205/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1205 题意：有n种糖果，第i种糖果有a[i]个，相邻两次不能吃一样的糖果，问能否有办法吃完所有糖果... 思路：如果第i种糖果有k个的话，那么其他所有种类的糖果之和至少有k-1个，才可能吃完。复杂度O(n) 看到有人说是抽屉原理.....大概。。。？不过不太明显。。直接想就好吧
/* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 20时40分00秒 File Name :code/hdu/1205.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; LL a[N]; LL total; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1796 How many integers can you find (容斥原理)</title><link>https://111qqz.com/2016/02/hdu1796/</link><pubDate>Mon, 29 Feb 2016 12:00:53 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu1796/</guid><description>
hdu1796 题意：给出n（&amp;lt;=2^31）以及m(&amp;lt;=10)个元素组成的无重复元素集合，集合元素0&amp;lt;=a[i]&amp;lt;=20,问有多少个小于n的数能至少被集合中的一个元素整除。
思路：容斥，找到能被一个元素的，被两个元素的...加加减减。 一个元素的最小公倍数定义成自己，然后多个元素的就两个两个算...
一个坑点是，a[i]有0，而一个数除以0没有意义。。。所以读入的时候处理下。。。把0删掉（个人觉得这个坑点毫无技术含量。。。。0不能作为除数这种事情呵呵呵） 并且如果只有一个数且为0，那么删掉后集合就为空了，特判输出0.
另一个坑点是，别看每个数都很小。。但是求多个数的最小公倍数的时候会爆int...
**虽然最后结果没有爆，但是中间量会爆掉，要开long long **
/* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 19时09分31秒 File Name :code/hdu/1796.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int a[15]; int b[15]; LL gcd ( LL a,LL b) { if (b&amp;gt;a) return gcd(b,a); if (a%b==0) return b; return gcd(b,a%b); } LL lcm( LL a,LL b) { LL res; res = a*b; //10个数的最小公倍数会爆掉.</description></item><item><title>hdu 4336 Card Collector (2012多校 #4) （容斥原理模板题）</title><link>https://111qqz.com/2016/02/hdu4336/</link><pubDate>Mon, 29 Feb 2016 11:00:49 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu4336/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4336
题意：有n种卡片，买一包干脆面得到第i种卡片的概率是p[i],每包干脆面最多有一张卡片，问收集齐所有卡片要买的干脆面的包数的数学期望。
思路：容斥模板题。1.0/p[i]就是拿到某张卡片需要买的包数的数学期望
注意体会这种具体应用容斥的模拟方法，把1&amp;lt;&amp;lt;n转化成二进制来模拟有1个元素的集合，有2个元素的集合...有n个元素的集合。 核心代码：
for ( int msk = 1 ; msk &amp;lt;(1&amp;lt;&amp;lt;n) ; msk++) { double res = 0.0; int bits = 0; for ( int i = 0 ; i &amp;lt; n ; i++) { // cout&amp;lt;&amp;lt;&amp;quot;msk:&amp;quot;&amp;lt;&amp;lt;msk&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;i)&amp;lt;&amp;lt;endl; if (msk&amp;amp;(1&amp;lt;&amp;lt;i)) { bits++; res +=p[i]; } } if (bits%2==1) { ans += 1.0/res; } else { ans -= 1.0/res; } } /* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 18时39分23秒 File Name :code/hdu/4336.</description></item><item><title>poj 3734 Blocks (指数型母函数，泰勒级数展开)</title><link>https://111qqz.com/2016/02/poj-3734/</link><pubDate>Sun, 28 Feb 2016 06:37:08 +0000</pubDate><guid>https://111qqz.com/2016/02/poj-3734/</guid><description>
http://poj.org/problem?id=3734
题意+思路同******hdu2065红色病毒解题报告
/* *********************************************** Author :111qqz Created Time :2016年02月27日 星期六 16时39分53秒 File Name :code/poj/3734.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD =1E4+7; LL n; LL res; LL ksm(LL a,LL b) { LL res = 1; while (b) { if (b&amp;amp;1) res=(res*a)%MOD; b = b&amp;gt;&amp;gt;1; a = (a*a)%MOD; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2065 "红色病毒"问题 (指数型母函数，泰勒级数展开)</title><link>https://111qqz.com/2016/02/hdu2065/</link><pubDate>Sun, 28 Feb 2016 06:26:51 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu2065/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=2065 题意：a,b,c,d四种元素，a,c只能出现偶数次（包括0次），b,d没有限制，问n个（2^64）个元素有多少种不同的组合。 思路：指数型母函数。。。n大的没办法用之前的办法做。
先来看下我们要求的式子：A=(1+x/1!+x^2/2!+x^3/3!……)^2*(1+x^2/2!+x^4/4!+x^6/6!……)^2.
其实一共四个式子相乘，但是a和c的情况相同，b和d的式子相同。
我们要求的是x^n的系数。。。n太大了。。直接搞肯定不行。
想到微积分学的泰勒展开。
e^x=1+x/1!+x^2/2!+x^3/3!+... (|x|&amp;lt;oo)
其实这里x的范围没有意义，因为母函数关注的是系数，不会代入x的值，所以可以不用考虑收敛性。
那么第一项(1+x/1!+x^2/2!+x^3/3!……)^2就可以换成(e^x)^2
第二项没有奇数项，很容易想到可以写成(（e^x+e^(-x)）/2)^2
继续化简：4A=(e^x)^2((e^x+e^(-x))/2)^2
4A = (e^(4x)+2e^(2x)+1)
我们要的是x^n的系数，再正向泰勒展开，得到x^n的系数应该是 (4^n+2*2^n)/4,也就是4^(n-1)+2^(n-1)
因为只要后两位的结果，其实就是结果0.快速幂搞之。
以及，2^64 long long 存不下，应该用unsigned long long ，类型说明符是 %llu
/* *********************************************** Author :111qqz Created Time :2016年02月28日 星期日 14时01分58秒 File Name :code/hdu/2065.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef unsigned long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD = 100; LL n; LL ksm(LL a,LL b) { LL res = 1LL; while (b) { if (b&amp;amp;1) res = (res*a)%MOD; b = b&amp;gt;&amp;gt;1; a =(a*a)%MOD; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1607 [Usaco2008 Dec]Patting Heads 轻拍牛头 （筛法）</title><link>https://111qqz.com/2016/02/bzoj1607/</link><pubDate>Sat, 27 Feb 2016 17:30:18 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj1607/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=1607
题意：n个数，求对于每个数来说，其他n-1个数中是它约数的数的个数。
思路：类似筛法，从小到大处理，数i对其所有倍数的数的答案有cnt[i]的贡献 。最后记得把自己是自己的约数的情况减掉。
/* *********************************************** Author :111qqz Created Time :2016年02月28日 星期日 01时06分35秒 File Name :code/bzoj/1607.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int cnt[N*10]; int ans[N*10]; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces #341 div 2 D. Rat Kwesh and Cheese</title><link>https://111qqz.com/2016/02/cf621d/</link><pubDate>Sun, 07 Feb 2016 20:44:27 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621d/</guid><description>
http://codeforces.com/contest/621/problem/D 题意：给出12个式子，问哪个最大。 思路：主要记住两个。一个是比较指数形式的数一个常用办法是取对数，同时要考虑是否能取对数，分情况讨论对于不能取对数的情况经过变换去取对数。第二个是取了两次对数后比较时候的最大值可能是小于0的。所以初始时置于0不够小。官方题解说得很清楚。
The tricky Rat Kwesh has finally made an appearance; it is time to prepare for some tricks. But truly, we didn't expect it to be so hard for competitors though. Especially the part about taking log of a negative number. We need a way to deal with x__y__z and x__yz. We cannot directly compare them, 200200200 is way too big. So what we do? Take log! Image not found a.</description></item><item><title>codeforces #342 div 2 A. Guest From the Past</title><link>https://111qqz.com/2016/02/codeforces-342-div-2-a-guest-from-the-past/</link><pubDate>Sun, 07 Feb 2016 11:24:07 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-342-div-2-a-guest-from-the-past/</guid><description>
http://codeforces.com/contest/625/problem/A 题意：有n块钱，塑料瓶饮料a元一瓶，玻璃瓶饮料b元一瓶，退还玻璃瓶可以得到c元。问最多能买多少瓶饮料。 思路：贪心。如果塑料瓶比玻璃瓶的实际价格便宜，那么一定买塑料瓶的，否则先买玻璃瓶，再用塑料瓶填。注意一些边界的判断。。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 17时02分32秒 File Name :code/cf/#342/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,c,n; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces 107 B. Basketball Team</title><link>https://111qqz.com/2016/02/codeforces-107-b-basketball-team/</link><pubDate>Wed, 03 Feb 2016 10:43:16 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-107-b-basketball-team/</guid><description>
http://codeforces.com/problemset/problem/107/B
题意：有m个部门，每个部分s[i]个人，HW在第h部门，现在要从这m个部门中挑选包括HW在内的n个人去参加比赛，问被挑选的人中有HW的队友（同部门的人）的概率是多少。如果m个部分的人数不够组成n人的球队，输出-1. 思路：考虑一般情况。至少有一个队友的情况较多，应该从反面考虑，即没有一个队友的情况。选完HW以后面临的状态是：事件总数为从total(m个部门的人员之和)-1个人中选n-1个的方案数，包含的事件数目为从a(a=total-s[h])中选n-1个人包含的方案数。 可以看出分母相同，可以约掉。 然后对于边界情况，首先判断total是否比n小。然后，如果a&amp;lt;n-1,表示除去HW所在的h部分之外的人不可能组成n-1个人，也就是一定要选择HW的队友，概率为1.
/* *********************************************** Author :111qqz Created Time :2016年02月03日 星期三 17时56分30秒 File Name :code/cf/problem/107B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int M=1E3+7; int n ,m,h; int s[M]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 312 B. Archer</title><link>https://111qqz.com/2016/02/cf312b/</link><pubDate>Tue, 02 Feb 2016 06:30:03 +0000</pubDate><guid>https://111qqz.com/2016/02/cf312b/</guid><description>
http://codeforces.com/problemset/problem/312/B 题意：两个人比赛射箭，先射的人射中的概率是a/b,后射的人射中的概率是c/d,问先射的人赢的概率。 思路：应该叫条件概率。。。？ 不过我们可以用古典概型的思维想。每射一次看成一个点，射中的点用白色表示，没有射中的用黑色表示。如果两个人第i次都没有射中，那么就要继续第i+1 轮，而第i+1轮和之前的每一轮是独立的。等于重复这个过程。所以古典概型的样本总量应该减去宝石两个人都没有射中的点的个数，为bd-(b-a)(d-c)，整理为bc+ad-a*c，设为n.要想第一个人赢，那么对于某一次，只要不是第一个人没射中，第二个人射中这种情况，就都是第一个人赢。而第一个人没射中的事件数为b-a,第二个人射中的事件数为c,总数为（b-a）*c，所以答案为(n-(b-a)*c)/n
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 15时57分06秒 File Name :code/cf/518D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,t; double p; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 453 A. Little Pony and Expected Maximum</title><link>https://111qqz.com/2016/02/cf543a/</link><pubDate>Mon, 01 Feb 2016 21:50:39 +0000</pubDate><guid>https://111qqz.com/2016/02/cf543a/</guid><description>
http://codeforces.com/problemset/problem/453/A 题意：m面筛子，每面点数出现的概率相同，连续投掷n次，问出现的最大值的数学期望。 思路：手写样例。。。发现答案为 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://codeforces.com/predownloaded/2a/ed/2aede49a2c6f455a4cb3af6fe16b61f4da56aa87.png
Disk path: /static/http://codeforces.com/predownloaded/2a/ed/2aede49a2c6f455a4cb3af6fe16b61f4da56aa87.png
Using Page Bundles: false
。。。记得把（1/m）^n放进去。
观察答案，可以这样理解（我是用样例推出公式后理解。。。数学差的人心好累）：如果i为最大值，那么n次每次必须投掷出1..i的点数，概率为 (i/m)^n,但是要至少有一个投掷成i，也就是要减去所有的数都是1..i-1中的情况（概率 为((i-1)/m)^n），
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 05时17分24秒 File Name :code/cf/problem/453A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; double ans; int n ,m; double p1[N],p2[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 476 B. Dreamoon and WiFi</title><link>https://111qqz.com/2016/02/cf476b/</link><pubDate>Mon, 01 Feb 2016 20:07:58 +0000</pubDate><guid>https://111qqz.com/2016/02/cf476b/</guid><description>
http://codeforces.com/problemset/problem/476/B 题意：给出两个长度相等-且不超过10的字符串，串1只包含‘-’,'+‘。按照‘+’为1，‘-’为-1累加可以得到一个值。串2还包含若干‘？’，代表该处的值不确定，且为'+'和'-'的概率相等，都是0.5.问串2的值和串1相等的概率。 思路：我们可以扫一遍得到‘？’的个数和两个式子的差值。设问号个数为a,差值为b，那么在a个问号中需要有(a-b)/2个为‘+’（容易知道，a,b一定奇偶性相同，所以a-b一定能被2整除），根据超几何分布，概率为 c[a][(a-b)/2]*(1/2)^a; 写的时候可以先打个组合数的表。1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 03时32分39秒 File Name :code/cf/problem/476B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string s1,s2; int len; int c[20][20]; void pre() { ms(c,0); c[1][1] = 1; c[1][2] = 1; c[2][1] = 1; c[2][2] = 2; c[2][3] = 1; for ( int i =3 ; i &amp;lt;=15 ; i++) for ( int j = 0 ; j &amp;lt;= i ; j++) c[i][j+1] = c[i-1][j+1]+c[i-1][j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #341 div2 C. Wet Shark and Flowers</title><link>https://111qqz.com/2016/02/cf341/</link><pubDate>Mon, 01 Feb 2016 11:55:49 +0000</pubDate><guid>https://111qqz.com/2016/02/cf341/</guid><description>
http://codeforces.com/contest/621/problem/C
C. Wet Shark and Flowers
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
There are n sharks who grow flowers for Wet Shark. They are all sitting around the table, such that sharks i and i + 1 are neighbours for all i from 1 to n - 1. Sharks n and 1 are neighbours too.
Each shark will grow some number of flowers s__i.</description></item><item><title>uva 10916 Factstone Benchmark</title><link>https://111qqz.com/2016/01/uva10916/</link><pubDate>Fri, 29 Jan 2016 12:53:01 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10916/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1857 题意：计算最大的n,满足n!/* *********************************************** Author :111qqz Created Time :2016年01月29日 星期五 19时49分25秒 File Name :code/uva/10916.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair
using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=150; int n; int f[N]; void pre() { f[0] = 3; int per = 2; for ( int i = 1 ; i &amp;lt;=25 ; i++) { f[i]=f[i-1]+per; per++; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 107 The Cat in the Hat</title><link>https://111qqz.com/2016/01/uva107/</link><pubDate>Thu, 28 Jan 2016 13:09:11 +0000</pubDate><guid>https://111qqz.com/2016/01/uva107/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=43 题意：其实就是给了两个式子。。。(N+1)^h=a,N^h=b,a,b已知，然后求关于N的两个式子.。。 思路：数学上这个方程貌似不可解。。？ 所以只能枚举一下==。。。注意精度问题把。。。
然后用换底公式求对数的时候要向上取整。
还有b为1的时候是特殊数据。
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 16时46分38秒 File Name :code/uva/107.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-12; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 846 Steps</title><link>https://111qqz.com/2016/01/uva846/</link><pubDate>Thu, 28 Jan 2016 13:03:14 +0000</pubDate><guid>https://111qqz.com/2016/01/uva846/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=787
题意：从x增加到y，第一步和最后一步步长只能是1，其他步一定可以是上一步减一，和上一步相等，或者上一步步长加一，三种情况，且步长恒为正。问从x到y最少需要的步数。
思路：首先可以知道，走的最快的方法是1+2+3+...+k+...+3+2+1.这个式子的结果是一个完全平方数，为k^2，式子的长度为2*k-1.即为答案。 我们可以知道k肯定不超过 ceil(sqrt(y-x)).但是中间的k是不一定要加的。再判断k^2减去k是否已经达到结果，如果是，就将答案减一。 注意对于这种做法x=y是特殊情况。。需要特判。。。。
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 19时57分44秒 File Name :code/uva/846.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int x,y; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10025 The ? 1 ? 2 ? ... ? n = k problem</title><link>https://111qqz.com/2016/01/uva-10025/</link><pubDate>Thu, 28 Jan 2016 13:02:48 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-10025/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=966 题意：?1?2?3?4...?n=k,把每个?替换成+或者-，找到最小的n使得式子成立。 题意：这道题最关键的一点是。如果s1=1+2+3+.,x+..+n&amp;gt;=k (所有数取正数）,那么一定有s2=1+2+3+..-x+..+n=k
非严格证明如下：
s1-s2 = 2x,s1-k=2x
一个数减去偶数，奇偶性不变。x是从1到n中的一个，2*x则包含了s1和s2相差的数所有可能性。
具体做法就是找到一个大于等于k的s1,且s1-k是偶数。
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 13时58分24秒 File Name :code/uva/10025.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int k; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 113 Power of Cryptography</title><link>https://111qqz.com/2016/01/uva113/</link><pubDate>Wed, 27 Jan 2016 19:16:01 +0000</pubDate><guid>https://111qqz.com/2016/01/uva113/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=49 题意：求p开n次方。保证结果为整数。 思路：p最大10的101次方。。。double最大10的308次方。。因为肯定是整数。。不存在精度问题。。所以可以用douible水过QAQ...
/* *********************************************** Author :111qqz Created Time :2016年01月28日 星期四 03时07分01秒 File Name :code/uva/113.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double n,p; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdoj 5605 || bc #68 div 2 1001 geometry</title><link>https://111qqz.com/2016/01/hdoj5605/</link><pubDate>Sat, 02 Jan 2016 13:36:43 +0000</pubDate><guid>https://111qqz.com/2016/01/hdoj5605/</guid><description>
题意：geometry Accepts: 324 Submissions: 622 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) 问题描述 在平面直角坐标系上有一个点PP, 他的坐标是(x, y)(x,y). 有一条直线y = kx + by=kx+b经过了PP, 且分别交x, yx,y正半轴于A, BA,B. 求|PA| * |PB|∣PA∣∗∣PB∣的最小值. 输入描述 第一行一个TT, 表示数据组数. 接下来TT行每行两个正整数x,yx,y, 表示PP的坐标.
T=500, 0 &amp;lt; X, Y \leq 10000T=500,0/* *********************************************** Author :111qqz Created Time :2016年01月02日 星期六 18时56分10秒 File Name :code/bc/#68/1001.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair</description></item><item><title>cf 611 B ||codeforces goodbye 2015 B. New Year and Old Property (数学或者数位dp)</title><link>https://111qqz.com/2016/01/cf611b/</link><pubDate>Fri, 01 Jan 2016 13:03:22 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611b/</guid><description>
http://codeforces.com/contest/611/problem/B 题意：问a到b（1E18），二进制表示中只有一个0的数有多少个。 思路：这么大的数。。。不是有循环节就是math problems.  UD:20160318讲道理还有可能是数位dp好不好。。。 我们发现可以很容易得算出1到x的二进制表示中只有一个0 的数有多少个。
problem solved.
20160318update:学了数位dp后又看到这题。。。这题显然是数位dp啊。。。亏我找规律搞了出来2333.
后面附上数位dp方法AC的代码
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 22时49分02秒 File Name :code/cf/goodbye2015/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const int N=1E4+7; LL a,b; LL p[N]; LL c[N]; LL cal( LL x) { return ((x-1LL)*x)/2LL; } LL solve (LL x) { if (x==0LL) return 0; LL res= 0LL; LL cnt = 0LL; LL xx = x; while (xx) { cnt++; p[cnt] = xx%2LL; xx/=2LL; } ms(c,0); res+=cal(cnt-1LL); LL tmp = (1LL&amp;lt;&amp;lt;cnt)-1LL; for ( LL i = 0 ; i &amp;lt;cnt-1 ; i++) { LL happ = 1LL&amp;lt;&amp;lt;i; c[i]=tmp-happ; } sort(c,c+cnt-1); for ( LL i = 0 ; i&amp;lt; cnt -1 ; i++) { if (x&amp;gt;=c[i]) res++; } return res; } int main() { cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; LL ans = solve(b)-solve(a-1LL); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; } 数位dp的方法：</description></item><item><title>codeforces #332 div 2 D. Spongebob and Squares</title><link>https://111qqz.com/2015/12/cf559d/</link><pubDate>Wed, 23 Dec 2015 08:57:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf559d/</guid><description>
http://codeforces.com/contest/599/problem/D 题意：给出总的方格数x，问有多少种不同尺寸的矩形满足题意，输出方案数和长宽（3,5和5,3算两种） 思路：比赛的时候gg了。。其实稍微在纸上推一下。就会得到对于n,m的矩形，一共会有-nnn+3nnm+n+3n*m的方格。数量级是n3。 我们可以实际跑一遍。发现对于x1E18的数量级，n不会超过1442550，1E6,可以搞。
需要注意的是，一个是会爆int,所以记得用long long
另一个是如果两个数相等，记得只输入一组，并且方案数-1
我是用set +pair存的答案。。反向遍历set的时候要用reserve_iterator...
/* *********************************************** Author :111qqz Created Time :2015年12月23日 星期三 15时54分37秒 File Name :code/cf/#332/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; LL ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL x; LL cur; const LL MAXN = 1442550; set&amp;lt;pi&amp;gt;se; LL cal( LL n,LL m) { LL res = -n*n*n+3*n*n*m+3*n*m+n; return res; } int square = -1; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #333 div 2 D. Lipshitz Sequence</title><link>https://111qqz.com/2015/12/codeforces-333-div-2-d-lipshitz-sequence/</link><pubDate>Wed, 23 Dec 2015 06:12:24 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-333-div-2-d-lipshitz-sequence/</guid><description>
http://codeforces.com/contest/602/problem/D 题意：见题目描述。 思路：我们很容易发现，l[h]函数其实就是在求区间斜率的最大值。哦不对，是斜率的绝对值的最大值。而且一个显而易见的结论是，斜率最大值一定是由相邻的点得到。画图可以很容易看出。
具体的证明见这里： In order to prove it properly, we'll consider three numbers A__i, A__j, A__k (i &amp;lt; j &amp;lt; k) and show that one of the numbers _L_1(i, j),_L_1(j, k) is ≥ _L_1(i, k). W.l.o.g., we may assume A__i ≤ A__k. There are 3 cases depending on the position of A__j relative to A__i, A__k:
* _A__j_ &amp;gt; _A__i_, _A__k_ — we can see that _L_1(_i_, _j_) &amp;gt; _L_1(_i_, _k_), since |_A__j_ - _A__i_| = _A__j_ - _A__i_ &amp;gt; _A__k_ - _A__i_ = |_A__k_ - _A__i_| and _j_ - _i_ &amp;lt; _k_ - _i_; we just need to divide those inequalities * _A__j_ &amp;lt; _A__i_, _A__k_ — this is similar to the previous case, we can prove that _L_1(_j_, _k_) &amp;gt; _L_1(_i_, _k_) in the same way * _A__i_ ≤ _A__j_ ≤ _A__k_ — this case requires more work: * we'll denote _d_1_y_ = _A__j_ - _A__i_, _d_2_y_ = _A__k_ - _A__j_, _d_1_x_ = _j_ - _i_, _d_2_x_ = _k_ - _j_ * then, _L_1(_i_, _j_) = _d_1_y_ / _d_1_x_, _L_1(_j_, _k_) = _d_2_y_ / _d_2_x_, _L_1(_i_, _k_) = (_d_1_y_ + _d_2_y_) / (_d_1_x_ + _d_2_x_) * let's prove it by contradiction: assume that _L_1(_i_, _j_), _L_1(_j_, _k_) &amp;lt; _L_1(_i_, _k_) * _d_1_y_ + _d_2_y_ = _L_1(_i_, _j_)_d_1_x_ + _L_1(_j_, _k_)_d_2_x_ &amp;lt; _L_1(_i_, _k_)_d_1_x_ + _L_1(_i_, _k_)_d_2_x_ = _L_1(_i_, _k_)(_d_1_x_ + _d_2_x_) = _d_1_y_ + _d_2_y_, which is a contradiction We've just proved that to any _L_1 computed for two elements A[i], A[k] with k &amp;gt; i + 1, we can replace one of i, j by a point _j_between them without decreasing _L_1; a sufficient amount of such operations will give us k = i + 1.</description></item><item><title>codeforces 522 A. Vanya and Table</title><link>https://111qqz.com/2015/12/cf552a/</link><pubDate>Mon, 14 Dec 2015 06:44:28 +0000</pubDate><guid>https://111qqz.com/2015/12/cf552a/</guid><description>
http://codeforces.com/problemset/problem/552/A 题意：一个100*100的网格。然后给n个矩形。每个格子中填上包含这个格子的矩形的个数。最后问所有格子的和。 思路：树状数组搞得...然而..直接求所有矩形面积的和就可以啊喂。。o(n)。。。111qqz你个炒鸡大菜鸡。
/* *********************************************** Author :111qqz Created Time :2015年12月14日 星期一 14时01分14秒 File Name :code/cf/problem/552A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n; int c[N][N]; struct Point { int x1,y1,x2,y2; void input() { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x1,&amp;amp;y1); scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x2,&amp;amp;y2); } }p[N]; int lowbit( int x) { return x&amp;amp;(-x); } void update( int x,int y,int delta) { for ( int i = x ; i &amp;lt;= 105 ; i += lowbit(i)) { for ( int j = y ; j &amp;lt;= 105 ; j +=lowbit(j)) { c[i][j] +=delta; } } } int sum ( int x,int y) { int res = 0 ; for ( int i = x; i&amp;gt;= 1 ; i-=lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j-=lowbit(j)) { res += c[i][j]; // cout&amp;lt;&amp;lt;&amp;quot;res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; } } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #327 A. Wizards' Duel</title><link>https://111qqz.com/2015/12/codeforces-327-a-wizards-duel/</link><pubDate>Fri, 04 Dec 2015 13:18:18 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-327-a-wizards-duel/</guid><description>
题意：一个长度为l的走廊。两个人站在两端点。互相向对方发射某种魔法。A的魔法速度为p米/秒，B的魔法速度为q米/s,魔法相遇以后会反射。反射会发射人那里会再次发射。问两种魔法第二次相遇的时候距离A的距离。 思路：由于每种魔法的速度保持肯定不变。。所以不管第几次相遇。相遇点都是同一个。。。ans=p*(p+q)/l;
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 19时12分56秒 File Name :code/cf/#327/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; double p,q,l; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #319 C - Vasya and Petya's Game (数学)</title><link>https://111qqz.com/2015/09/codeforces319c-vasyaandpetyasgame/</link><pubDate>Fri, 18 Sep 2015 12:46:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces319c-vasyaandpetyasgame/</guid><description>
因为每一个正整数可以唯一分解质因数...
要看能猜多少次，只要知道不大于n的质因子数有多少个即可（相同的算多
由于n才是１０００．所以素数表随便搞就好....不用筛也行...
/************************************************************************* &amp;gt; File Name: code/cf/#319/C.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月18日 星期五 20时29分00秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E3+5; int pri[N]; int cnt; int n; int ans[N]; bool prime( int x) { if (x&amp;lt;=3) return true; for ( int i = 2 ; i *i &amp;lt;= x ; i++) { if (x%i==0) return false; } return true; } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;in.</description></item><item><title>(BC 一周年) hdu 5312 Sequence</title><link>https://111qqz.com/2015/07/hdu5312/</link><pubDate>Tue, 28 Jul 2015 15:48:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5312/</guid><description>
比赛的时候没做出来.这道题需要用到的一个重要的性质是,任意一个自然数可以表示成至多三个三角形数(1,3,6,10,15.....)的和(orz高斯)然后也有推广到任意自然数可以表示成k个k角形数的和的结论(费马提出了猜想,柯西给了证明)然后官方题解说的比较好:
**这个题看上去是一个贪心, 但是这个贪心显然是错的. 事实上这道题目很简单, 先判断1个是否可以, 然后判断2个是否可以. 之后找到最小的k (k 2)k(k2), 使得(m - k) mod 6 = 0(m−k)mod6=0即可.** 证明如下: 3n(n-1)+1 = 6(n(n-1)/2)+13n(n−1)+1=6(n∗(n−1)/2)+1, 注意到n(n-1)/2n∗(n−1)/2是三角形数, 任意一个自然数最多只需要3个三角形数即可表示. 枚举需要kk个, 那么显然m=6(km=6(k个三角形数的和)+k)+k, 由于k ge 3k≥3, 只要m-km−k是6的倍数就一定是有解的.**
**事实上, 打个表应该也能发现规律.**
另外还有一点,特判一个和两个的情况时,一个的好判断,扫一遍就好了
两个的话,由于这个数列是递增的,我们可以从两边往中间,算是一个不错的优化,具体见代码.
1 /************************************************************************* 2&amp;gt; File Name: code/nv/#ann/1003.cpp 3&amp;gt; Author: 111qqz 4&amp;gt; Email: rkz2013@126.com 5&amp;gt; Created Time: 2015年07月28日 星期二 23时03分09秒 6************************************************************************/ 7 8 #include&amp;lt;iostream&amp;gt;9 #include&amp;lt;iomanip&amp;gt;10 #include&amp;lt;cstdio&amp;gt;11 #include&amp;lt;algorithm&amp;gt;12 #include&amp;lt;cmath&amp;gt;13 #include&amp;lt;cstring&amp;gt;14 #include&amp;lt;string&amp;gt;15 #include&amp;lt;map&amp;gt;16 #include&amp;lt;set&amp;gt;17 #include&amp;lt;queue&amp;gt;18 #include&amp;lt;vector&amp;gt;19 #include&amp;lt;stack&amp;gt;20 #define y0 abc111qqz21 #define y1 hust111qqz22 #define yn hez111qqz23 #define j1 cute111qqz24 #define tm crazy111qqz25 #define lr dying111qqz26 using namespace std; 27 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i)28 typedef long long LL; 29 typedef unsigned long long ULL; 30 const int inf = 0x7fffffff; 31 const int N=1E5+7; 32 int k,m,f[N]; 33 void init() 34 { 35 for ( int i = 1 ; i &amp;lt;N; i++) 36 { 37 f[i]=3*i*(i-1)+1; 38 if (f[i]&amp;gt;1000000000) 39 { 40 k = i-1; 41 break; 42 } 43 } 44 } 45 int solve (int x) 46 { 47 for ( int i = 1 ; f[i]&amp;lt;=x ; i++ ) 48 { 49 if (x==f[i]) 50 return 1; 51 } 52 int j = k; 53 for ( int i = 1 ; i &amp;lt;= k-1&amp;amp;&amp;amp;f[i]&amp;lt;x ; i++) 54 { 55 while(f[i]+f[j]&amp;gt;x) j--; 56 if (f[i]+f[j]==x) return 2; 57 } 58 for ( int i = 3 ; i &amp;lt;= m ; i++ ) 59 { 60 if ((m-i)%6==0) 61 return i; 62 } 63 } 64 int main() 65 { 66 int T; 67 init(); 68 cin&amp;gt;&amp;gt;T; 69 int ans; 70 while (T--) 71 { 72 73 scanf(&amp;#34;%d&amp;#34;,&amp;amp;m); 74 cout&amp;lt;&amp;lt;solve(m)&amp;lt;&amp;lt;endl; 75 76 } 77 78 return 0; 79 } 80 81 82</description></item><item><title>codeforces 535 C.Tavas and karafs (解方程)</title><link>https://111qqz.com/2015/04/cf535c/</link><pubDate>Thu, 16 Apr 2015 07:16:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf535c/</guid><description>
http://codeforces.com/problemset/problem/535/C
题读了好几遍才读懂。 题意是给出一个等差数列，操作严格要求从最左边不为零的连续m个数减去1，最多执行t次后问离最左边最远的位置在哪里。 有两个限制条件...一个是本身的si不能大于t，否则无法吃完。 还有一个是从sl到sr的和不能超过m*t (比赛的时候考虑的不周到。。实际上只有当r-l+1比m大的时候才是m，也就是说要取min(m,l-r+1)) 这题正解应该是二分....直接Lower_bound。。。看到也有人用前缀和搞的。 我是解方程了（貌似是个傻逼做法）.... 可以列出一个关于r的一元二次方程。。。然后求根公式2333 方程是：
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: https://111qqz.com/wp-content/uploads/2015/11/161513291826463.jpg
Disk path: /static/https://111qqz.com/wp-content/uploads/2015/11/161513291826463.jpg
Using Page Bundles: false
然后再和第一个条件得到的r比较取小的就是结果.....
等周末把这题的二分解法也写一些。
下面是蒟蒻傻逼的数学方恒解法的代码：
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年03月03日 星期四 13时49分13秒 6File Name :code/cf/problem/535C.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 #include &amp;lt;cmath&amp;gt;13 #include &amp;lt;cstdio&amp;gt;14 15 using namespace std; 16 typedef long long LL; 17 const int N=1e5+5; 18 LL A,B,n,l,t,m,p,q,k,ans,a,b,c,dd,q2; 19 long double d,pp; 20 int main() 21 { 22 cin&amp;gt;&amp;gt;A&amp;gt;&amp;gt;B&amp;gt;&amp;gt;n; 23 for ( int i = 1; i &amp;lt;= n ; i++ ) 24 { 25 cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;t&amp;gt;&amp;gt;m; 26 if ( t&amp;lt;A+B*(l-1) ) 27 { 28 cout&amp;lt;&amp;lt;-1&amp;lt;&amp;lt;endl; 29 continue; 30 } 31 // l = A + (l-1)*B; //wtf。。。这行代码是什么鬼.</description></item><item><title>codeforces 534 C Polycarpus' Dice</title><link>https://111qqz.com/2015/04/cf534c/</link><pubDate>Tue, 14 Apr 2015 20:38:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf534c/</guid><description>
http://codeforces.com/problemset/problem/534/C
题意是说一共有N个骰子，第I个筛子一共有di面...现在知道这些骰子的点数之和，问对于每一个骰子不能取得值有多少个。
乍一看有点不明觉厉...稍微再想下，求取值范围即可。
先把所有di相加，得到所有骰子点数之和的最大值...然后点数之和的最小值当然就是N
对于每个骰子，将最大值和最小值减去这个骰子的对应数值...然后与总和A进行比较。
注意要开long long ！！！
比赛的时候我明明写了typedef。。。结果后面还是忘记了。。。真是悲伤。
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年03月03日 星期四 13时54分19秒 5File Name :code/cf/problem/534C.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;algorithm&amp;gt;10 #include &amp;lt;cstring&amp;gt;11 #include &amp;lt;cmath&amp;gt;12 #include &amp;lt;cstdio&amp;gt;13 typedef long long LL; 14 const int N=2E5+7; 15 LL n,d[N],ans[N]; 16 LL A,MAX,MIN,TMAX,TMIN; 17 18 using namespace std; 19 20 int main() 21 { 22 scanf(&amp;#34;%I64d %I64d&amp;#34;,&amp;amp;n,&amp;amp;A); 23 memset(ans,0,sizeof(ans)); 24 for ( int i = 1; i &amp;lt;= n ;i ++ ) 25 scanf(&amp;#34;%I64d&amp;#34;,&amp;amp;d[i]); 26 MAX = 0; 27 MIN = n; 28 for ( int i = 1; i &amp;lt;= n ; i++ ) 29 MAX = MAX + d[i]; 30 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 31 { 32 TMAX = MAX - d[i]; 33 TMIN = MIN - 1; 34 if (d[i]&amp;gt;=(A-TMIN)) 35 { 36 ans[i] =ans[i]+d[i]-(A-TMIN); 37 } 38 if (A&amp;gt;=TMAX+1) 39 { 40 ans[i] =ans[i]+A-TMAX-1; 41 } 42 43 } 44 for ( int i = 1; i &amp;lt; n ; i++) 45 cout&amp;lt;&amp;lt;ans[i]&amp;lt;&amp;lt;&amp;#34;&amp;#34;; 46 cout&amp;lt;&amp;lt;ans[n]; 47 48 49 return 0; 50 } 51</description></item><item><title>cf 534B. Covered Path</title><link>https://111qqz.com/2015/04/cf534b/</link><pubDate>Tue, 14 Apr 2015 20:32:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf534b/</guid><description>
http://codeforces.com/problemset/problem/534/B
题意是说一辆车，每秒内的速度恒定...第I秒到第I+1秒的速度变化不超过D。初始速度为V1，末速度为V2，经过时间t，问最远能走多远。
策略就是尽可能加速...加到某个时间，如果在这个时间不开始减速就回不到V2了。
从后往前预处理下每秒钟能达到的最大速度（如果超过这个速度，将不能减回到V2）
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月22日 星期一 23时49分32秒 5File Name :code/cf/problem/534B.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cmath&amp;gt;10 #include &amp;lt;cstring&amp;gt;11 #include &amp;lt;algorithm&amp;gt;12 13 using namespace std; 14 const int N=1E2+5; 15 const int inf=8E9; 16 int a[N],m[N]; 17 int v1,v2,t,d,tmp,p,ans,n; 18 19 20 int main() 21 { 22 cin&amp;gt;&amp;gt;v1&amp;gt;&amp;gt;v2&amp;gt;&amp;gt;t&amp;gt;&amp;gt;d; 23 p = inf; 24 memset(a,0,sizeof(a)); 25 a[1]= v1; 26 tmp = v2; 27 m[t]= v2; 28 for ( int i = t-1 ; i &amp;gt;= 1; i--) 29 { 30 tmp = tmp+d; 31 m[i] = tmp; 32 } 33 for ( int i =2 ;i &amp;lt;= t; i++ ) 34 { 35 if (a[i-1]+d&amp;lt;=m[i]) 36 { 37 a[i] = a[i-1] + d; 38 } 39 else 40 { 41 a[i] = m[i]; 42 p = i; 43 break; 44 } 45 } 46 ans = 0; 47 for ( int i = p ; i &amp;lt;= t; i++ ) 48 a[i] = m[i]; 49 for ( int i = 1; i &amp;lt;= t ; i++ ) 50 { 51 if (i&amp;lt;p) 52 ans = ans + a[i]; 53 else ans = ans + m[i]; 54 } 55 // for ( int i = 1; i &amp;lt;= t ; i++) 56 // cout&amp;lt;&amp;lt;&amp;#34;a[i]:&amp;#34;&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl; 57 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 58 59 return 0; 60 } 61</description></item><item><title>hdu 2138 How many prime numbers</title><link>https://111qqz.com/2015/02/hdu2138/</link><pubDate>Tue, 17 Feb 2015 00:58:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu2138/</guid><description>
ACM STEPS里的...这题前面一道是求LCM....结果接下来就是这么一道。。。 朴素会超....筛法会爆....题目顺序真是按照难度来的？ 于是想到 Miller-Rabin素数测试....... 这个方法是基于费马小定理 我的理解就是... 如果我要判断n是否为素数 只要取k个数 如果满足 a^(n-1)mod n =1 那么n就很可能为素数。 证明什么的...暂时还是算了吧...论文里貌似扯了一大堆 第一次用，竟然真的A了。。。。 感觉更好的办法也许是先打一个比较小的素数表，然后每次random选取若干个进行判断...那样应该更可靠些？ 本来想WA掉之后再改的。。。没想到这么写就A掉了。。。。杭电数据略水？
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月19日 星期五 16时54分19秒 5File Name :code/hdu/2138.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cmath&amp;gt;10 #include &amp;lt;stdio.h&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 13 using namespace std; 14 15 typedef long long LL; 16 LL power(LL m,LL n,LL k) 17 { 18 int b = 1; 19 while (n &amp;gt; 0) 20 { 21 if (n &amp;amp; 1) 22 b = (b*m)%k; 23 n = n &amp;gt;&amp;gt; 1 ; 24 m = (m*m)%k; 25 } 26 return b; 27 } 28 bool judge(LL n) 29 { 30 LL i; 31 if (n&amp;lt;=3) return true; 32 for (i=2;i&amp;lt;=ceil(sqrt(n))+1;i++) 33 if (n %i==0) return false; 34 return true; 35 } 36 37 int main() 38 { 39 LL i,n,x; 40 41 while (scanf(&amp;#34;%I64d&amp;#34;,&amp;amp;n)!</description></item></channel></rss>