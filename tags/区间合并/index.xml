<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>区间合并 on 111qqz的小窝</title><link>http://example.org/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</link><description>Recent content in 区间合并 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 23 Sep 2016 10:38:51 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces 380 C. Sereja and Brackets (线段树区间合并)</title><link>http://example.org/2016/09/cf380c/</link><pubDate>Fri, 23 Sep 2016 10:38:51 +0000</pubDate><guid>http://example.org/2016/09/cf380c/</guid><description>题目链接 题意：给出一个由‘(’和‘）’组成的字符串。。。然后给出若干查询。。。每个查询一个区间，问区间中能匹配的括号数。。。
思路：考虑某一个区间中的括号匹配。。。其实是一个不断寻找&amp;rsquo;()&amp;lsquo;然后删去的过程。。。
因此对于某个区间的括号匹配数。。。等于左边区间和右边区间和合法匹配数之和，再加上左区间和右区间新的能匹配到一起的括号数。
（说“因此”是因为。。。只要左边有没匹配的左括号。。。右边有没匹配的右括号。。。因为他们中间有的都是匹配好的括号，会被删除。。。所以两边的括号总能匹配在一起）
具体做法是：
线段树的节点中有三个域，分别表示，合法的括号匹配数，没有被匹配的左括号数，和没有被匹配的右括号数。
query的时候要合并左右两个区间。。。不过可能某一区间中为空。。。这里合理得初始化为node(0,0,0)，就不用分情况讨论了。。。
一个和node(0,0,0)合并对原来的答案没有影响。。。。
以及，凡是需要在query的时候合并区间的问题。。。（不是那种简单的sum,min/max合并）
返回一个node会方便很多。。。。。
/* *********************************************** Author :111qqz Created Time :Fri 23 Sep 2016 05:32:22 PM CST File Name :code/cf/problem//380C.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; struct node { int left,right,sum; node (){} node ( int x,int y,int z): left(x),right(y),sum(z){}; }tree[N&amp;lt;&amp;lt;2]; char st[N]; int n; void PushUp( int rt) { int add = min(tree[rt&amp;lt;&amp;lt;1].</description></item></channel></rss>