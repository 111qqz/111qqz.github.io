<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译原理 on 111qqz的小窝</title><link>http://example.org/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link><description>Recent content in 编译原理 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 23 Jan 2019 11:51:46 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>优化学习笔记(1):Loop unrolling</title><link>http://example.org/2019/01/loop-unrolling/</link><pubDate>Wed, 23 Jan 2019 11:51:46 +0000</pubDate><guid>http://example.org/2019/01/loop-unrolling/</guid><description>迫于生计，最近要学习halide
先去学习/复习一下常见的编译优化技巧。
loop unrolling，也就是循环展开，顾名思义，就是把循环展开来写。
normal loop: int x; for (x = 0; x &amp;lt; 100; x++) { delete(x); } after loop unrolling: int x; for (x = 0; x &amp;lt; 100; x += 5 ) { delete(x); delete(x + 1); delete(x + 2); delete(x + 3); delete(x + 4); } 循环展开是一种优化，可以手动实现也可以编译器自动实现。
为什么要将循环展开？ * 循环每次都需要判断终止条件，展开后可以消除这部分开销。 * 减少[分支预测](https://en.wikipedia.org/wiki/Branch_predictor)开销。循环里的分支是指“跳出循环”还是“进行下一次迭代” * [vectorization](https://en.wikipedia.org/wiki/Automatic_vectorization) for (int y = 0; y &amp;lt; 4; y++) { for (int x_outer = 0; x_outer &amp;lt; 2; x_outer++) { // The loop over x_inner has gone away, and has been // replaced by a vectorized version of the // expression.</description></item></channel></rss>