<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>博弈论 on 111qqz's blog</title><link>https://111qqz.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/</link><description>Recent content in 博弈论 on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 18 Nov 2016 13:33:01 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/index.xml" rel="self" type="application/rss+xml"/><item><title>bzoj 2463: [中山市选2009]谁能赢呢？ (博弈论)</title><link>https://111qqz.com/2016/11/bzoj-2463-2009-/</link><pubDate>Fri, 18 Nov 2016 13:33:01 +0000</pubDate><guid>https://111qqz.com/2016/11/bzoj-2463-2009-/</guid><description>
2463: [中山市选2009]谁能赢呢？ Time Limit: 10 Sec Memory Limit: 128 MB Submit: 1826 Solved: 1347 [Submit][Status][Discuss]
Description 小明和小红经常玩一个博弈游戏。给定一个n×n的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？
Input 输入文件有多组数据。
输入第一行包含一个整数n，表示棋盘的规模。
当输入n为0时，表示输入结束。
Output 对于每组数据，如果小明最后能赢，则输出”Alice”, 否则输出”Bob”, 每一组答案独占一行。
Sample Input 2 0
Sample Output Alice
HINT 对于所有的数据，保证1&amp;lt;=n&amp;lt;=10000。
思路：手写了下几组猜是奇偶性..写了下就过了。
证明：
**首先对于n是偶数，一定能被1*2的骨牌覆盖！所以从起点开始，先手一定走的是骨牌的另一端，后手一定走的是骨牌的前一端，因此无论何时，先手总是可以走。因此先手必胜。** 如果n是奇数，那么去掉一格后一定能被1*2的骨牌覆盖，但是先手从左上角走，就进入了这个S态（必胜态），那么和上边的分析一样了，因此先手必败。
/* *********************************************** Author :111qqz Created Time :2016年11月18日 星期五 21时28分43秒 File Name :code/bzoj/2463.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1874: [BeiJing2009 WinterCamp]取石子游戏 (sg函数，要求输出第一步具体方案)</title><link>https://111qqz.com/2016/07/bzoj1874/</link><pubDate>Fri, 29 Jul 2016 16:19:48 +0000</pubDate><guid>https://111qqz.com/2016/07/bzoj1874/</guid><description>
1874: [BeiJing2009 WinterCamp]取石子游戏 Time Limit: 5 Sec Memory Limit: 162 MB Submit: 726 Solved: 296 [Submit][Status][Discuss]
Description 小H和小Z正在玩一个取石子游戏。 取石子游戏的规则是这样的，每个人每次可以从一堆石子中取出若干个石子，每次取石子的个数有限制，谁不能取石子时就会输掉游戏。 小H先进行操作，他想问你他是否有必胜策略，如果有，第一步如何取石子。
Input 输入文件的第一行为石子的堆数N 接下来N行，每行一个数Ai，表示每堆石子的个数 接下来一行为每次取石子个数的种类数M 接下来M行，每行一个数Bi，表示每次可以取的石子个数，输入保证这M个数按照递增顺序排列。
Output 输出文件第一行为“YES”或者“NO”，表示小H是否有必胜策略。 若结果为“YES”,则第二行包含两个数，第一个数表示从哪堆石子取，第二个数表示取多少个石子，若有多种答案，取第一个数最小的答案，若仍有多种答案，取第二个数最小的答案。
Sample Input 4 7 6 9 3 2 1 2
Sample Output YES 1 1Hint 样例中共有四堆石子，石子个数分别为7、6、9、3，每人每次可以从任何一堆石子中取出1个或者2个石子，小H有必胜策略，事实上只要从第一堆石子中取一个石子即可。
数据规模和约定 数据编号 N范围 Ai范围 数据编号 N范围 Ai范围 1 N=2 Ai≤10 6 N≤10 Ai≤10 2 N=2 Ai≤1000 7 N≤10 Ai≤100 3 N=3 Ai≤100 8 N≤10 Ai≤1000 4 N≤10 Ai≤4 9 N≤10 Ai≤1000 5 N≤10 Ai≤7 10 N≤10 Ai≤1000 对于全部数据，M≤10，Bi≤10</description></item><item><title>hdu 3980 Paint Chain (sg函数，环形串取石子)</title><link>https://111qqz.com/2016/07/hdu-3980/</link><pubDate>Sat, 23 Jul 2016 08:50:39 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-3980/</guid><description>
hdu 3980 题目链接 题意：一个有n个石子的环形串，初始没有被涂颜色，两个人轮流，涂连续m个没有被涂色的石子，不能操作的人为负。问先手是否有必赢策略。
思路：和hdu2999很像。。所不同的是。。。那道题是线型的珠子。。。这道题是环型的数字。。。
然而我们机智得发现。。。环形的任意涂一次。。就变成了线型的啊orz。。。
所以先随便取一次，然后剩下的n-m个按照线型串的方法搞，划分区间即可。
由于先随便取了一次，所以和线型的交换输赢的结论。。。
以及。。要特判一次都不能取的情况。。。2A
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 15时53分18秒 File Name :code/hdu/3980.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; bool vis[N]; int sg[N]; void sg_init(int m) { ms(sg,0); for ( int i = 1 ; i &amp;lt; N ; i++) { ms(vis,false); int tmp = m; tmp = i-m; for ( int j = 0 ; tmp-j&amp;gt;=j ; j++) vis[sg[j]^sg[tmp-j]] = true; for ( int k = 0 ; ;k++) if (!</description></item><item><title>hdu 2999 Stone Game, Why are you always there? (sg函数，线性串取石子)</title><link>https://111qqz.com/2016/07/hdu-2999/</link><pubDate>Sat, 23 Jul 2016 07:48:00 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2999/</guid><description>
hdu2999题目链接
题意：有一串石子，给定一个集合S，每次只能拿连续x个石子，石子必须是在集合S中的数，问先手是否有必赢策略。需要注意石子的位置是不能变化的，也就是说如果一串连续的石子因为中间有石子被取走，那么这段石子就变成不连续的了，也就不能一次取走。
思路：一开始没有读懂题。需要特别强调的是。石子的位置是不能合并的。。
举个例子，如果我有5个石子，S={2},那么我取完一次剩下的情况是 {3,4,5}或者{1},{4,5}或者{1,2},{5}或者{1,2,3} 一共四种。
题意搞清楚以后就好做了。。类似于bomb game那道题。。我们仍然可以把取一次的操作拆分两个子过程，也就是两个区间。我们不关心区间具体的情况，只关心区间的长度。以及，取完只有一个区间的情况不需要特殊考虑，认为是长度为0就可以了，因为sg[0]为0，不影响答案。
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 15时02分17秒 File Name :code/hdu/2999.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2005; int sg[N]; bool vis[N]; set&amp;lt;int&amp;gt;ok; set&amp;lt;int&amp;gt;::iterator it ; int n; int q; void sg_init() { ms(sg,0); for ( int i = 1 ; i &amp;lt; N ; i++) { ms(vis,false); for ( it = ok.</description></item><item><title>hdu 2873 Bomb Game（Sg函数）</title><link>https://111qqz.com/2016/07/hdu-2873/</link><pubDate>Sat, 23 Jul 2016 06:57:10 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2873/</guid><description>
hdu 2873题目链接
题意：n*m个格子，有若干炸弹。对于在第一行或者第一列的炸弹，爆炸后会到那一行或者那一列的更前面（总的来说就是更靠近左上角）的位置。对于其他位置的炸弹，爆炸后会生成两个炸弹，分别到那一行的更前面或者那 一列的更前面。问先手是否有必赢策略。
思路： 不会做2333 参考了 参考博客1 参考博客2
大概明白了一点。整个游戏可以分为若干个炸弹的游戏的和，而实际上一个不在边界行或者列的炸弹，依然可以继续分，分成两个炸弹的和。而位于(i.j)的炸弹，分成两个炸弹的和，有(i-1)*(j-1)种方案（这个不重要2333）
处于边界行或者列的点的sg值我们是可以知道的。。因为规则单一。。和移动等价。。
然后根据边界来进一步处理一般的情况。。
有点类似dp的思想。。。？
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 04时52分16秒 File Name :code/hdu/2873.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n,m; int sg[N][N]; bool vis[N*N]; char maze[N][N]; int px[N],py[N]; void sg_init() { ms(sg,0); for ( int i = 0 ; i &amp;lt; N ; i++) //在边界的只能往一个方向生成炸弹，和移动了炸弹等价。 sg[i][0]=sg[0][i]=i; //还是0based好一点。。。这样（1,1）点的sg值自然就是0了。。。 for ( int i1 = 1 ; i1 &amp;lt; N ; i1++) for ( int i2 = 1 ; i2 &amp;lt; N ; i2++) { ms(vis,false); for ( int j1 = 0 ; j1 &amp;lt; i1 ; j1++) for ( int j2 = 0 ; j2 &amp;lt; i2 ; j2++) vis[sg[i1][j2]^sg[j1][i2]] = true; //注意sg函数的变化规则。。其实是把一次爆炸考虑成两个爆炸的叠加，所以异或了。 for ( int k = 0 ; ; k++) if (!</description></item><item><title>hdu 2509 Be the Winner (anti-sg,sg函数，sj定理)</title><link>https://111qqz.com/2016/07/hdu-2509/</link><pubDate>Fri, 22 Jul 2016 20:47:57 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2509/</guid><description>
hdu2509题目链接 题意：？？？
思路：同1907
/* *********************************************** Author :111qqz Created Time :2016年07月23日 星期六 04时41分38秒 File Name :code/hdu/2509.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1022 ||hdu 1907 John (sg函数，sj定理，anti-sg)</title><link>https://111qqz.com/2016/07/hdu-1907/</link><pubDate>Fri, 22 Jul 2016 20:37:37 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1907/</guid><description>
hdu1907题目链接
题意：n堆石子，每次选一堆，最少拿一个，最多拿光那一堆，拿走最有一个的人输。 问是否有必胜策略。
思路：anti-nim问题。。。
要用到sj定理（是啥。。。?)
参考资料：参考博客
SJ定理 **对于任意一个Anti-SG游戏，如果定义所有子游戏的SG值为0时游戏结束，先手必胜的条件： ** **1、游戏的SG值为0且所有子游戏SG值均不超过1。 ** 2、游戏的SG值不为0且至少一个子游戏SG值超过1。
/* *********************************************** Author :111qqz Created Time :2016年07月22日 星期五 23时09分42秒 File Name :code/hdu/1907.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E3+7; int n; int sg[N]; bool vis[N]; void sg_init() { ms(sg,0); for ( int i = 1 ; i &amp;lt; N ; i++) { sg[i] = i; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1730 Northcott Game (二维sg函数)</title><link>https://111qqz.com/2016/07/hdu-1730/</link><pubDate>Fri, 22 Jul 2016 14:02:29 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1730/</guid><description>
hdu 1730
题意：n行格子，每行m个，每行有一黑一白两个棋子，给定初始位置，先手执黑棋，后手执白棋，每次可以在同一行内向左移动，不能超过边界，且不能越过对方的棋子，同一个格子只能有一个棋子。问先手是否必赢。
思路：可以看成n个独立的游戏的 叠加。。。所以最后异或和一下就好。。
我们来求sg函数。。。一开始的是想把点对hash成一个数。。。然后发现其实没必要。。。直接二维就好了。。
由于初始化的时候要考虑最大。。。所以sg函数的值会有一个便宜。。。和设定N有关。。减去偏移就好了。。。（我的代码里这个偏移是11026）
1A蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年07月22日 星期五 21时01分19秒 File Name :code/hdu/1730.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E2+7; bool vis[N*N]; int sg[N][N]; int n,m; void sg_init(int m) { ms(sg,0); for ( int i1 = 1 ; i1 &amp;lt;= m ; i1++) for ( int i2 = 1 ; i2 &amp;lt;= m ; i2++) { if (i1==i2) continue ; // 棋子不能在同一个位置？ ms(vis,false); int x = i1; int y = i2; if ( x&amp;lt;y ) { for ( int j = x+1 ; j &amp;lt;=y-1; j++) vis[sg[x][j]] = true; for ( int j = 1 ; j &amp;lt;= x-1 ; j++) vis[sg[j][y]] = true; } else { for ( int j = y + 1 ; j &amp;lt;= x-1 ; j++) vis[sg[j][y]] = true; for ( int j =1 ; j &amp;lt;= y-1 ; j++) vis[sg[x][j]] = true; } for ( int j1 = 1 ; j1 &amp;lt;= m ; j1++ ) for ( int j2 = 1 ; j2 &amp;lt;= m ; j2++) if (!</description></item><item><title>hdu 1404 Digital Deletions (博弈论，根据定义)</title><link>https://111qqz.com/2016/07/hdu-1404/</link><pubDate>Fri, 22 Jul 2016 12:39:22 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1404/</guid><description>
hdu 1404题目链接
题意：一个数字串，每次可以选择一位减少任意大小到一个非负数，或者清除一个0以及该位右边的所有数字。问是否有必胜策略。。
思路：定义来搞。。所有能一步走到p点的都是n点，那么如果我们现在知道p点，就可以反过来推n点。。
看到一些人强行把变量名起成sg就说自己用了sg函数也是笑死我了呵呵呵呵
/* *********************************************** Author :111qqz Created Time :2016年07月22日 星期五 19时11分16秒 File Name :code/hdu/1404.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; int sg[N]; bool vis[N]; char st[10]; void solve( int x) { int dig[10]; int cnt = 0; ms(dig,0); int xx = x; while (x) { dig[++cnt] = x % 10; x/=10; } x = xx; // cout&amp;lt;&amp;lt;&amp;quot;cnt:&amp;quot;&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl; // for ( int i = 1 ; i &amp;lt;= cnt ; i ++) cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; dig[i]:&amp;quot;&amp;lt;&amp;lt;dig[i]&amp;lt;&amp;lt;endl; int base = 1; for ( int i = 1 ; i &amp;lt;= cnt ; i++) { for ( int j = dig[i] + 1 ; j &amp;lt;= 9 ; j++) if (x+(j-dig[i])*base&amp;lt;N)sg[x+(j-dig[i])*base] = 1; base *=10; } if (cnt&amp;lt;6) { base = 1; for ( int i = cnt ; i &amp;lt; 6 ; i++) { x*=10; for ( int j = 0 ; j &amp;lt; base ;j++) sg[x+j] = 1; base*=10; } } } void sg_init() { ms(sg,0); // sg[0] = 1; for ( int i = 1 ; i &amp;lt; N ; i++) if (!</description></item><item><title>hdu 1536 S-Nim (sg函数)</title><link>https://111qqz.com/2016/07/hdu-1536/</link><pubDate>Wed, 20 Jul 2016 15:45:35 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1536/</guid><description>
hdu 1536题目链接
题意：还是若干堆石子，但是每次取的个数只能是集合S中有的数。。问是否必赢。。。
思路：sg函数。。。1A
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 23时32分48秒 File Name :code/hdu/1536.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int sg[N]; bool vis[N]; int ok[N]; int k,m; void sg_init() { ms(sg,0); for ( int i = 1; i &amp;lt; N ; i++) { ms(vis,false); for ( int j = 1 ; j &amp;lt;= k ; j++) if (i-ok[j]&amp;gt;=0) vis[sg[i-ok[j]]] = true; for ( int j = 0 ; ; j++) if (!</description></item><item><title>hdu 1517 A Multiplication Game (博弈论，将点的局势对应到段)</title><link>https://111qqz.com/2016/07/hdu-1517/</link><pubDate>Wed, 20 Jul 2016 13:27:59 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1517/</guid><description>
hdu 1517 题目链接
题意：初始为1，每次可以乘2..9中的一个数，最先达到或者超过n的人胜利。问谁有必赢策略。。
思路：一开始想用sg函数。。然而n太大（4e10）。。。绝对会超时。。。
所以可以更朴素得，去画n点和p点。。。我们可以发现。。。连续一段的局势是相同的。。。所以不能，也没必要找到每一个点对应的局势。
[n,+oo]是p点，那么[n/9,n-1]是n点，那么[n/9/2,n/9)又是p点。。。以此类推。。
这道题同时也告诉我们。。。没有什么方法是万能的。。。就算sg函数很神。。也有不能用的时候。。。所以掌握最本质的东西还是很重要的。。。
转载一段题解：
**** 这道题如果用sg函数，利用点的局势做一定会超时，因为相同的局势能够形成连续的段，所以我们可以将局势对应到段来达到一定的优化：
首先题目中能够了解到必败态[n,+oo)，那么可以由此推出必胜态
必胜态就是[n/9,n-1]，也就是有一定有策略达到必败态
另一个必败态就是[n/9/2,n/9)，之后就是一直循环这样的局势，找到了循环，我们可以固定一个点，固定区间的左端点比较易操作，也就是我们通过固定左端点找到１在必胜态区间，还是必败态区间．
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 20时27分11秒 File Name :code/hdu/1517.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1848 Fibonacci again and again (sg函数)</title><link>https://111qqz.com/2016/07/hdu-1848/</link><pubDate>Wed, 20 Jul 2016 12:22:06 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1848/</guid><description>
hdu 1848题目链接
题意：三堆石头，每次任选一堆取，取的石子数目必须是斐波那契数列中的数(1,2,3,5,8....)问先手是否有必赢策略。
思路：sg函数即可。。。。这次sg函数的优越性终于体现出来了。。。其他方法估计很难写吧。。
以及，这道题不知道为什么让我联想到了生成函数。。。感觉生成函数和sg函数作为工具还是有不少共同点的。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 20时08分38秒 File Name :code/hdu/1848.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; bool vis[N]; int sg[N]; int f[N]; int a,b,c; void sg_init() { f[1] = 1; f[2] = 2; ms(sg,0); for ( int i = 3 ; i&amp;lt;=18 ; i++) f[i] = f[i-1] + f[i-2]; // cout&amp;lt;&amp;lt;&amp;quot;jhhhh;&amp;quot;&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt; N ; i++) { ms(vis,false); for ( int j = 1 ; f[j] &amp;lt;= i ; j++) vis[sg[i-f[j]]] = true; for ( int j = 0 ; ; j++) if (!</description></item><item><title>hdu 1850 Being a Good Boy in Spring Festival (nim游戏问必胜方案数，sg函数)</title><link>https://111qqz.com/2016/07/hdu-1850/</link><pubDate>Wed, 20 Jul 2016 12:03:45 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1850/</guid><description>
hdu1850题目链接 题意：n堆石子。。每堆可以取任意多个。。。先取完的赢。。问先手能否赢。。能赢的话第一步有几种取法。。 思路：sg函数。。对于方案数，可以用nim游戏的结论。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2016/07/hdu-1850/https://111qqz.com/wordpress/wp-content/uploads/2016/07/未命名.png
Disk path: /content/post/ACM-ICPC/https://111qqz.com/wordpress/wp-content/uploads/2016/07/未命名.png
Using Page Bundles: true
。设异或和为sum..那么统计满足 a[i]^sum&amp;lt;a[i]的个数就是第一步能走的方案数。
以及。。sg函数。。如果走的步数是任意的。。也就是没有限制。。。那么sg[i] = i...此时也就退化成了一般的nim游戏。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 19时47分48秒 File Name :code/hdu/1850.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; const int M=1E6+7; int n; int sg[M]; int a[N]; void sg_init() { //这个可以记成结论23333 for ( int i = 1 ; i &amp;lt; M ; i ++) sg[i] = i ; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1847 Good Luck in CET-4 Everybody! (巴什博奕,找规律｜｜sg函数)</title><link>https://111qqz.com/2016/07/hdu-1847/</link><pubDate>Wed, 20 Jul 2016 10:59:43 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1847/</guid><description>
hdu1847题目链接 题意：n个石子，每次只能取2的幂次个。。。问先手是否有必赢策略。。。 思路：画n点p点。。。发现n为３的倍数的时候先手必输。。。否则先手必赢。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 18时54分46秒 File Name :code/hdu/1847.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>nim游戏以及证明过程</title><link>https://111qqz.com/2016/07/nim/</link><pubDate>Wed, 20 Jul 2016 08:06:50 +0000</pubDate><guid>https://111qqz.com/2016/07/nim/</guid><description>
参考资料　（后面的证明写错了，差评，不要看，看图就好了）
1. 题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。 题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。 嘿嘿，这个游戏我早就见识过了。小时候用珠算玩这个游戏：第一档拨一个，第二档拨两个，依次直到第五档拨五个。然后两个人就轮流再把棋子拨下来，谁要是最后一个拨谁就赢。有一次暑假看见两个小孩子在玩这个游戏，我就在想有没有一个定论呢。下面就来试着证明一下吧 先解决第一个问题吧。 定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则， 为利己态，用S表示。 [定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。 证明：  若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态，  c = A(1) xor A(2) xor … xor A(n) 0;  把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t)(注：我觉得应该是必然存在奇数个),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。  那么我们把x = A(t) xor c,则得到x  A(1) xor A(2) xor … xor x xor … xor A(n)　（**需要注意的是，这里是没有A(t)这一项的，前面之所以要说明x  = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n)  = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n)  = 0 这就是说从A(t)堆中取出 A(t) - x 根火柴后状态就会从S态变为T态。证毕 Image not found a.</description></item><item><title>hdu 2147 kiki's game (巴什博奕)</title><link>https://111qqz.com/2016/07/hdu-2147/</link><pubDate>Wed, 20 Jul 2016 07:35:25 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2147/</guid><description>
hdu 2147 题目链接
题意：一个n*m的方格，有一个棋子初始在右上角（１，m）,每次可以将棋子向下或者向左或者向左下移动**一个格子，**不能移出边界，当无路可走的时候就输了，问谁存在必赢策略。
思路：画n点p点。。。左下肯定是p　然后最后发现　n%2==1&amp;amp;&amp;amp;m%2==1的时候必输，否则必赢。
然后因为把m%2谢成名m&amp;amp;2 WA了好多发呵呵呵呵呵呵。
/* *********************************************** Author :111qqz Created Time :2016年07月19日 星期二 20时09分37秒 File Name :code/hdu/2147.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1846 Brave Game　（巴什博奕）</title><link>https://111qqz.com/2016/07/hdu-1846-brave-game/</link><pubDate>Tue, 19 Jul 2016 11:55:09 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1846-brave-game/</guid><description>
hdu 1846 题目链接
题意：有n个石子，每次最多取m个，最少取１个，如果没有石子可取就输了。给出n,m，两个人都很聪明，问先手和后手谁赢。。
思路：
首先定义几个概念：
p点：即必败点，某玩家位于此点，只要对方无失误，则必败
**　N点 ：即必胜点，某玩家位于此点，只要自己无失误，则必胜。**
** 一、 所有终结点都是必败点P（这道题目中，轮到谁取石子，还剩0个石子的时候，此人无石子可取，就输了）；**
** 二、所有一步能走到必败点P的就是N点；（这里是_存在一种_情况可以走到p点即可）**
** 三、通过一步操作只能到N点的就是P点；　（这里是_所有_的情况都只能走到n点）**
那么当m=3的时候，则有：
 x ：0 1 2 3 4 5 6 7 8 9 10...
pos：P N N N P N N N P N N ...
１，２，３为n点是因为一步可以走到p点0,直观得说就是剩余１，２，３个石子的时候可以一次拿走。
４为p点是因为，不管怎么走，下一步一定是处于１，２，３这三个n点的，因此４是p点。
因此我们可以得出结论：n%(m+1)==0的时候，后手赢，否则先手赢。
（之前遇到的时候只记了结论，不清楚为什么，这下明白了orz
/* *********************************************** Author :111qqz Created Time :2016年07月19日 星期二 19时41分16秒 File Name :code/hdu/1846.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #334 div 2 E. Lieges of Legendre</title><link>https://111qqz.com/2015/12/cf603e/</link><pubDate>Tue, 22 Dec 2015 06:36:56 +0000</pubDate><guid>https://111qqz.com/2015/12/cf603e/</guid><description>
http://codeforces.com/contest/604/problem/E 题意：有两个人做游戏，游戏规则如下： 有n堆石子，每次可以对一堆石子进行操作，如果当前石子是偶数，那么可以选择将这2*x个石子分成k堆石子数为x的石子堆，还有一种没有前提的操作是取走当前堆的一个石子，问先手赢还是后手赢，先手和后手都足够聪明的情况下。 思路：博弈论。。不会做。。第一次接触sg函数。。转载一篇题解： http://m.blog.csdn.net/blog/qq_24451605/50154973
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 14时29分05秒 File Name :code/cf/#334/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,k,res; int pre[5]={0,1,0,1,2}; int grundy( int a) { if (k%2==0) { if (a==1) return 1; if (a==2) return 2; return (a%2)^1; } else { if (a&amp;lt;5) return pre[a]; if (a%2==1) return 0; return (grundy(a/2)==1?</description></item><item><title>hdu 1849Rabbit and Grass(一维nim游戏,sg函数)</title><link>https://111qqz.com/2015/09/hdu1849/</link><pubDate>Tue, 22 Sep 2015 12:47:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu1849/</guid><description>
Rabbit and Grass **Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3058 Accepted Submission(s): 2261 **
Problem Description
大学时光是浪漫的，女生是浪漫的，圣诞更是浪漫的，但是Rabbit和Grass这两个大学女生在今年的圣诞节却表现得一点都不浪漫：不去逛商场，不去逛公园，不去和AC男约会，两个人竟然猫在寝食下棋…… 说是下棋，其实只是一个简单的小游戏而已，游戏的规则是这样的： 1、棋盘包含1*n个方格，方格从左到右分别编号为0，1，2，…，n-1； 2、m个棋子放在棋盘的方格上，方格可以为空，也可以放多于一个的棋子； 3、双方轮流走棋； 4、每一步可以选择任意一个棋子向左移动到任意的位置（可以多个棋子位于同一个方格），当然，任何棋子不能超出棋盘边界； 5、如果所有的棋子都位于最左边（即编号为0的位置），则游戏结束，并且规定最后走棋的一方为胜者。
对于本题，你不需要考虑n的大小（我们可以假设在初始状态，棋子总是位于棋盘的适当位置）。下面的示意图即为一个1*15的棋盘，共有6个棋子，其中，编号8的位置有两个棋子。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2015/09/hdu1849/https://111qqz.com/wp-content/uploads/2015/11/C101-1004-1.jpg
Disk path: /content/post/ACM-ICPC/https://111qqz.com/wp-content/uploads/2015/11/C101-1004-1.jpg
Using Page Bundles: true
大家知道，虽然偶尔不够浪漫，但是Rabbit和Grass都是冰雪聪明的女生，如果每次都是Rabbit先走棋，请输出最后的结果。
Input
输入数据包含多组测试用例，每个测试用例占二行，首先一行包含一个整数m（0&amp;lt;=m&amp;lt;=1000），表示本测试用例的棋子数目，紧跟着的一行包含m个整数Ki(i=1…m; 0&amp;lt;=Ki&amp;lt;=1000)，分别表示m个棋子初始的位置，m=0则结束输入。
Output
如果Rabbit能赢的话，请输出“Rabbit Win!”，否则请输出“Grass Win!”，每个实例的输出占一行。</description></item><item><title>hdu 2149Public Sale(博弈论　巴什博奕)</title><link>https://111qqz.com/2015/09/hdu2149/</link><pubDate>Tue, 22 Sep 2015 12:26:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu2149/</guid><description>
hdu 2149题目链接
题意＆思路：巴什博奕，点m是n点。。。然后往前画即可。。。
/************************************************************************* &amp;gt; File Name: code/hdu/2149.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 20时18分02秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>hdu 2188 悼念512汶川大地震遇难同胞——选拔志愿者 (巴什博奕)</title><link>https://111qqz.com/2015/09/hdu2188/</link><pubDate>Tue, 22 Sep 2015 12:14:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu2188/</guid><description>
题目链接：hdu 2188题目链接
题意＆思路：巴什博奕。。画n点p点。。。
/************************************************************************* &amp;gt; File Name: code/hdu/2188.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 20时08分08秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; void solve() { int n,m; scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m); if (n%(m+1)!</description></item><item><title>bestcoder #56 div 2 C Clarke and puzzle (nim游戏　树状数组)</title><link>https://111qqz.com/2015/09/bestcoder56div2cclarkeandpuzzlenim/</link><pubDate>Tue, 22 Sep 2015 03:32:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bestcoder56div2cclarkeandpuzzlenim/</guid><description>
比赛的时候没过．还以为是树状数组写残了． 但实际上是有自己不知道的东西． 这种博弈叫　nim游戏 所以这是一个二维的nim游戏． **nim游戏的性质是xor 和为0必败，否则必胜． xor和也有前缀和性质，所以可以用树状数组维护．
/************************************************************************* &amp;gt; File Name: code/bc/#56/r1003.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 11时10分06秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E2+5; int c[N][N]; int a[N][N]; int n,m,q; int lowbit ( int x) { return x&amp;amp;(-x); } void update (int x,int y,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) { for ( int j = y ; j &amp;lt;= m ; j = j + lowbit(j)) { c[i][j]^=delta; } } } int sum( int x,int y) { int res = 0; for ( int i = x; i &amp;gt;= 1 ; i = i - lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j = j - lowbit(j)) { res ^= c[i][j]; } } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item></channel></rss>