<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>动态线段树 on 111qqz的小窝</title><link>http://example.org/tags/%E5%8A%A8%E6%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91/</link><description>Recent content in 动态线段树 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 27 Nov 2016 08:59:09 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%8A%A8%E6%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 5367 digger(动态线段树，区间合并)</title><link>http://example.org/2016/11/hdu-5367-digger/</link><pubDate>Sun, 27 Nov 2016 08:59:09 +0000</pubDate><guid>http://example.org/2016/11/hdu-5367-digger/</guid><description>题目链接
题意：
地主小花有n座山，这些山在地主家门前排成一条直线。这些山一开始均有相同的高度。 每一天，小花都会要求ZJiaQ开挖机把几座山挖掉一定高度，或者给一些山堆上一些高度。并且要求报告ZJiaQ报告现在有多少座山属于“高山脉” 当一排山的高度相等，并且比这排山左边和右边的山要高时，这排山被称为高山脉。 当然，最左边和最右边的山不可能是“高山脉”的一部分 思路：线段树，要维护的域蛮多的。
下面高山脉简称&amp;quot;HM&amp;rdquo;
sum:区间中HM的总长度。
lsum,rsum,区间中包含左端点，右端点的高度相同的山的长度。
lh,rh：区间中包含左端点，包含右端点的的高度相同的山的高度。
llh,rrh:从左端点向右，从有段点向左的，第一个高度不相同的山的高度。
由于这道题n有1E9，没办法像以前的办法build 线段树，因此我们采用动态线段树的技巧。
官方题解：
关于动态线段树：
平时我们做的线段树，假设区间为[1,n]，那我们通常都是直接以 1 号点表示区间【1，n】，以 i2 号点表示 i 节点代表区间的左半区间，以 i2+1 号点表示 i 节点多代表区间的右半区间，一半空间长度都定义为4*n。
 在本题中，n比较大，直接将所有线段树中的所有节点定义出来不现实，那我们注意到，这道题实际上是对区间进行的一系列操作，那么就可能存在一个区间【l，r】，在所有处理过程中，该区间都可以被当做一个整体来看待。 如果是这样的话，我们定义出与该区间的子区间相对应的节点就没有意义了。
 动态生成线段树就是：假设对某一节点 p (代表区间【l，r】)进行处理时，并不是对整个区间[l，r]进行处理，而是对其某个子区间进行处理，那这个时候，该区间就不能一直被当做一个整体来看待，所以生成两个初始子节点lp、rp（节点之均为初始值），表示该区间的左半部分与右半部分，然后父节点 p 在对两个新生成的子节点进行更新。
/* *********************************************** Author :111qqz Created Time :2016年11月27日 星期日 14时45分27秒 File Name :code/hdu/5367.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int INF = 0x3f3f3f3f; const int N=5E4+7; int cur,root; int n,q,nnn; struct Tree { int sum;//高山脉的长度和 int child[2];//左右孩子的编号 int rsum,lsum;//从左端点，右端点其高度相同的连续的山有多少个。 int lh,rh;//左边连续，右边连续的山的高度。 int llh,rrh;//从左边往右第一个不连续，从右边往左第一个不连续的山的高度。 int lazy; void init(int l,int r) { sum = child[0] = child[1] = lh = rh = llh = rrh = lazy = 0; lsum = rsum = r-l+1; //初始所有高度相同，所以高度相同的连续的山的个数等于区间长度。 } }; struct SegmentTree{ Tree tree[N*60]; void check(int &amp;amp;rt,int l,int r) { //cout&amp;lt;&amp;lt;&amp;quot;rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; if (rt) return; rt=++cur; tree[rt].</description></item></channel></rss>