<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>传递闭包 on Clarity</title><link>https://111qqz.com/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/</link><description>Recent content in 传递闭包 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sun, 21 Aug 2016 11:18:49 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 5036 Explosion||2014 北京区域赛网络赛 (概率+bitset优化的状态压缩+floyd传递闭包)</title><link>https://111qqz.com/2016/08/hdu-5036/</link><pubDate>Sun, 21 Aug 2016 11:18:49 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5036/</guid><description>
题目链接
题意：有n扇门，n种钥匙，一一对应。每扇门打开后可能得到k把钥匙（k可能为0）。一扇门还可以用一颗炸弹炸开。现在问要开所有门，使用炸弹的期望个数。
思路：状态压缩。用一个二进制串表示每扇门能打开的门的信息，对应的位上为1表示能打开，为0表示不能打开。
状态是可以传递的。。
如果第i扇门能打开门k，那么能打开第i扇门的第j扇门也可以打开门k。
状态压缩以及传递的过程可以很容易用bitset来维护，这才是bitset的正确打开姿势
相当于用floyd做了一个传递闭包。(floyd的有一层循环隐藏在了bitset中，复杂度没有改变，但是常数小)
最后对于期望的计算方法：统计能打开第i扇门的方案数计为cnt,这cnt的方案中，只有一种是用炸弹炸掉，因此用的炸弹数的期望数为1/cnt
由于期望的独立性，因此打开所有门所有的炸弹数的期望就是每个门的期望累加。
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 18时43分56秒 File Name :code/hdu/5036.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; bitset&amp;lt;N&amp;gt;b[N]; //b[i]表示第i扇门可以打开的门 int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2594 Treasure Exploration (DAG图最小路径覆盖变形，匈牙利算法+floyd求传递闭包)</title><link>https://111qqz.com/2016/05/poj-2594/</link><pubDate>Thu, 26 May 2016 12:43:12 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-2594/</guid><description>
poj 2594 题目链接
题意：一个DAG图，每个点有宝藏...可以降落任意个机器人到任意点...然后机器人可以沿着路径走，路过某个点的时候，可以取走该点的宝藏。问要取走所有宝藏，最少需要多少个机器人。
思路：乍一看。。很像DAG图的最小路径覆盖。。但是最小路径覆盖是要求每个点只能经过一次的。。而这道题路过某个点的时候，可以不取走宝藏。。以及题面里明确说了“you should notice that the roads of two different robots may contain some same point. ”
那是否还可以用最小路径覆盖做呢。。答案是可以的。。。
区别就在于一个点如果被一条路径使用过一次，还可不可以使用第二次。。。
如果我们按照传统的DAG图的最小路径覆盖考虑。。。如果一个点会被路径经过两次。。。那么我们不妨增加一个点。。。 进一步考虑。。。我们要的是尽可能覆盖所有点。。。如果这条路径前后的点不会因为这个点而中断，那么这个增设点是否存在，其实是无所谓的，只要改点前后的点连通性不受影响即可。 说到连通性，不禁想到floyd求传递闭包。
然后对于DAG图的最小路径覆盖问题。。。就可以用hungary算法求解。。。
ans = n - 最大匹配数。
这应该算作hungary的一个应用。</description></item><item><title>poj 1932 XYZZY (floyd传递闭包+spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1932/</link><pubDate>Tue, 24 May 2016 13:00:45 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1932/</guid><description>
poj1932题目链接
题意：初始在点1，有100点能量，然后每个点有一个能量值【-100,100】，经过某个点会加上这个点的能量值，问能否找到一条到点n且的路线，且路径任何点的能量值一直为正。一共不超过100个点。
思路：像样例中是直接联通，一路上的能量值都大于0，这是有解的一种情况。另一种是存在一个正环，可能一次路过后面的能量值不够，但是我们可以走多次啊。
因为要求每一步的能量值都大于0，那么我们可以初始化d[]数组为0，然后用spfa求最长路（只需要把那个三角形等式换个方向即可）
如果可以直接联通，也就是d[n]&amp;gt;0，那么有解。
还有可能是存在一个环（判断环的方法是用一个数组在spfa的时候统计每个点入队的次数，如果一个点的入队次数大于n，那么就存在环，且这个点在环中）
但是我们还要保证起点1和终点n是经过这个环的。
所以先跑一发floyd. 其实n才100也算给了提示吧，不用floyd的话没道理这么小的数据。。？
感觉这道题很棒，把spfa和floyd结合在了一起。
学到了判断环的方法，spfa求最长路的方法，复习了传递闭包。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 20时03分37秒 File Name :code/poj/1932.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; vector&amp;lt; int &amp;gt; edge[N]; int a[N]; bool conc[N][N]; int in[N]; //统计入队次数，大于n次表明有环。 bool inq[N]; int n; int d[N]; void floyd() //传递闭包 { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (conc[i][k]&amp;amp;&amp;amp;conc[k][j]) conc[i][j] = true; } bool spfa(int s) //spfa求最长路。 { ms(in,0); ms(d,0);//因为小于等于0就死，所以初始是0，这样更新的时候一定是正值才更新。 ms(inq,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>BZOJ 1612: [Usaco2008 Jan]Cow Contest奶牛的比赛(floyd,传递闭包)</title><link>https://111qqz.com/2016/04/bzoj1612/</link><pubDate>Sat, 02 Apr 2016 07:55:10 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1612/</guid><description>
1612: [Usaco2008 Jan]Cow Contest奶牛的比赛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 900 Solved: 597 [Submit][Status][Discuss]
Description FJ的N(1 &amp;lt;= N &amp;lt;= 100)头奶牛们最近参加了场程序设计竞赛:)。在赛场上，奶牛们按1..N依次编号。每头奶牛的编程能力不尽相同，并且没有哪两头奶牛的水平不相上下，也就是说，奶牛们的编程能力有明确的排名。 整个比赛被分成了若干轮，每一轮是两头指定编号的奶牛的对决。如果编号为A的奶牛的编程能力强于编号为B的奶牛(1 &amp;lt;= A &amp;lt;= N; 1 &amp;lt;= B &amp;lt;= N; A != B) ，那么她们的对决中，编号为A的奶牛总是能胜出。 FJ想知道奶牛们编程能力的具体排名，于是他找来了奶牛们所有 M(1 &amp;lt;= M &amp;lt;= 4,500)轮比赛的结果，希望你能根据这些信息，推断出尽可能多的奶牛的编程能力排名。比赛结果保证不会自相矛盾。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..M+1行: 每行为2个用空格隔开的整数A、B，描述了参加某一轮比赛的奶 牛的编号，以及结果（编号为A，即为每行的第一个数的奶牛为 胜者）
Output 第1行: 输出1个整数，表示排名可以确定的奶牛的数目 Sample Input 5 5 4 3 4 2 3 2 1 2 2 5</description></item><item><title>poj 3660 Cow Contest (floyd,传递闭包)</title><link>https://111qqz.com/2015/12/poj3660/</link><pubDate>Thu, 17 Dec 2015 14:22:58 +0000</pubDate><guid>https://111qqz.com/2015/12/poj3660/</guid><description>
http://poj.org/problem?id=3660 题意：给定n个奶牛，m个奶牛的关系，a,b表示a比b强...问能确定多少个奶牛的排名。 思路：最重要的一点是。。能确定奶牛i的排名的条件是。。知道奶牛i和其他n-1个奶牛的关系。。不管是能打败奶牛i也好。。会被奶牛i打败也好。。只要不是不确定就行。。所以我们跑一遍floyd做传递闭包。得到任何两个点之间的联系。然后对于每一个点。看其他n-1个点是否和他有关系。
/* *********************************************** Author :111qqz Created Time :2015年12月17日 星期四 21时31分05秒 File Name :code/poj/3660.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n ,m; int v[N][N]; void init() { for ( int i = 0 ; i &amp;lt;= 100 ; i++) for ( int j = 0; j &amp;lt;= 100 ; j++) v[i][j]=i==j?</description></item></channel></rss>