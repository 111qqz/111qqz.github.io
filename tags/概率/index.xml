<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>概率 on Clarity</title><link>https://111qqz.com/tags/%E6%A6%82%E7%8E%87/</link><description>Recent content in 概率 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sun, 21 Aug 2016 11:18:49 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%A6%82%E7%8E%87/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 5036 Explosion||2014 北京区域赛网络赛 (概率+bitset优化的状态压缩+floyd传递闭包)</title><link>https://111qqz.com/2016/08/hdu-5036/</link><pubDate>Sun, 21 Aug 2016 11:18:49 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5036/</guid><description>
题目链接
题意：有n扇门，n种钥匙，一一对应。每扇门打开后可能得到k把钥匙（k可能为0）。一扇门还可以用一颗炸弹炸开。现在问要开所有门，使用炸弹的期望个数。
思路：状态压缩。用一个二进制串表示每扇门能打开的门的信息，对应的位上为1表示能打开，为0表示不能打开。
状态是可以传递的。。
如果第i扇门能打开门k，那么能打开第i扇门的第j扇门也可以打开门k。
状态压缩以及传递的过程可以很容易用bitset来维护，这才是bitset的正确打开姿势
相当于用floyd做了一个传递闭包。(floyd的有一层循环隐藏在了bitset中，复杂度没有改变，但是常数小)
最后对于期望的计算方法：统计能打开第i扇门的方案数计为cnt,这cnt的方案中，只有一种是用炸弹炸掉，因此用的炸弹数的期望数为1/cnt
由于期望的独立性，因此打开所有门所有的炸弹数的期望就是每个门的期望累加。
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 18时43分56秒 File Name :code/hdu/5036.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; bitset&amp;lt;N&amp;gt;b[N]; //b[i]表示第i扇门可以打开的门 int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5645 DZY Loves Balls （古典概型）</title><link>https://111qqz.com/2016/03/hdu5645/</link><pubDate>Tue, 22 Mar 2016 11:45:19 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5645/</guid><description>
题目链接 题意：n（n&amp;lt;=300）个球，每个球上标有一个标号(a[i]&amp;lt;=300),从中拿一个，不放回，再拿一个，问第一个球上的数字严格大于第二个球上的数字的概率。 思路：古典概型。总数为n*(n-1)/2...然后标号最大300,不妨用cnt[i]统计标号为i的球的个数。从小往大扫一遍cnt,cnt[i]对分子的贡献就是cnt[i]*cur。。cur 为 sum{cnt[1]..cnt[i-1]}; 最后注意将分子除以2，因为有一半是第一个球比第二个球小的情况。
/* *********************************************** Author :111qqz Created Time :2016年03月22日 星期二 19时27分40秒 File Name :code/hdu/5645.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int n; int a[N]; int cnt[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4336 Card Collector (2012多校 #4) （容斥原理模板题）</title><link>https://111qqz.com/2016/02/hdu4336/</link><pubDate>Mon, 29 Feb 2016 11:00:49 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu4336/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4336
题意：有n种卡片，买一包干脆面得到第i种卡片的概率是p[i],每包干脆面最多有一张卡片，问收集齐所有卡片要买的干脆面的包数的数学期望。
思路：容斥模板题。1.0/p[i]就是拿到某张卡片需要买的包数的数学期望
注意体会这种具体应用容斥的模拟方法，把1&amp;lt;&amp;lt;n转化成二进制来模拟有1个元素的集合，有2个元素的集合...有n个元素的集合。 核心代码：
for ( int msk = 1 ; msk &amp;lt;(1&amp;lt;&amp;lt;n) ; msk++) { double res = 0.0; int bits = 0; for ( int i = 0 ; i &amp;lt; n ; i++) { // cout&amp;lt;&amp;lt;&amp;quot;msk:&amp;quot;&amp;lt;&amp;lt;msk&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;i)&amp;lt;&amp;lt;endl; if (msk&amp;amp;(1&amp;lt;&amp;lt;i)) { bits++; res +=p[i]; } } if (bits%2==1) { ans += 1.0/res; } else { ans -= 1.0/res; } } /* *********************************************** Author :111qqz Created Time :2016年02月29日 星期一 18时39分23秒 File Name :code/hdu/4336.</description></item><item><title>codeforces 148 D. Bag of mice</title><link>https://111qqz.com/2016/02/cf148d/</link><pubDate>Wed, 03 Feb 2016 19:34:38 +0000</pubDate><guid>https://111qqz.com/2016/02/cf148d/</guid><description>
http://codeforces.com/problemset/problem/148/D 题意：盒子里有w只白老鼠，b只黑老鼠，公主和魔王轮流取（公主先），先取到白老鼠的人获胜。魔王每次取完以后，盒子中的老鼠会因为吓尿了跑掉一只，跑掉的老鼠不算任何人取的。问公主获胜的概率。
思路：概率dp.. dp[i][j]表示有i只白老鼠，j只黑老鼠的时候公主获胜的概率。 转移方程 1. 公主抽到白老鼠（之后龙不必再抽） 胜率为i/(i+j)*1 2. 公主抽到黑老鼠，龙抽到黑老鼠，跳出一只黑老鼠，胜率为j/(i+j) * (j-1)/(i+j-1) * (j-2)/(i+j-2) * f[i][j-3] (j&amp;gt;=3) 3. 公主抽到黑老鼠，龙抽到黑老鼠，跳出一只白老鼠，胜率为j/(i+j) * (j-1)/(i+j-1) * (i/(i+j-2) * f[i-1][j-2] (j&amp;gt;=2) 4. 龙抽到白老鼠，胜率为0 /* *********************************************** Author :111qqz Created Time :2016年02月04日 星期四 02时44分23秒 File Name :code/cf/problem/148D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int w,b; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 107 B. Basketball Team</title><link>https://111qqz.com/2016/02/codeforces-107-b-basketball-team/</link><pubDate>Wed, 03 Feb 2016 10:43:16 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-107-b-basketball-team/</guid><description>
http://codeforces.com/problemset/problem/107/B
题意：有m个部门，每个部分s[i]个人，HW在第h部门，现在要从这m个部门中挑选包括HW在内的n个人去参加比赛，问被挑选的人中有HW的队友（同部门的人）的概率是多少。如果m个部分的人数不够组成n人的球队，输出-1. 思路：考虑一般情况。至少有一个队友的情况较多，应该从反面考虑，即没有一个队友的情况。选完HW以后面临的状态是：事件总数为从total(m个部门的人员之和)-1个人中选n-1个的方案数，包含的事件数目为从a(a=total-s[h])中选n-1个人包含的方案数。 可以看出分母相同，可以约掉。 然后对于边界情况，首先判断total是否比n小。然后，如果a&amp;lt;n-1,表示除去HW所在的h部分之外的人不可能组成n-1个人，也就是一定要选择HW的队友，概率为1.
/* *********************************************** Author :111qqz Created Time :2016年02月03日 星期三 17时56分30秒 File Name :code/cf/problem/107B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int M=1E3+7; int n ,m,h; int s[M]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 518 D. Ilya and Escalator</title><link>https://111qqz.com/2016/02/cf518/</link><pubDate>Tue, 02 Feb 2016 08:20:47 +0000</pubDate><guid>https://111qqz.com/2016/02/cf518/</guid><description>
http://codeforces.com/problemset/problem/518/D
题意：有n个人排队上一个电梯。。。在某一秒内，队首的人有p的概率上电梯，1-p的概率不动。每个人只有在队首的位置才可以上电梯（也就是每一秒内，最多只有一个人可以上电梯）。电梯无线长（也就是上了电梯就不会离开了），问在第t秒的时候，电梯上的人的个数的数学期望是多少。 思路：一开始推公式的我还是图样。这题是dp.其实也不难想。dp[i][j]表示第i秒时电梯上有j个人的概率。 当j==n的时候，也就是所以人都上了电梯以后。dp[i+1][j]+=dp[i][j],对于其他时刻 dp[i+1][j+1]+=dp[i][j]p,dp[i+1][j]+=dp[i][j](1-p). 初始化dp[0][0]=1,即0时刻电梯上有0个人的概率为1. /* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 15时57分06秒 File Name :code/cf/518D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,t; double p; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 312 B. Archer</title><link>https://111qqz.com/2016/02/cf312b/</link><pubDate>Tue, 02 Feb 2016 06:30:03 +0000</pubDate><guid>https://111qqz.com/2016/02/cf312b/</guid><description>
http://codeforces.com/problemset/problem/312/B 题意：两个人比赛射箭，先射的人射中的概率是a/b,后射的人射中的概率是c/d,问先射的人赢的概率。 思路：应该叫条件概率。。。？ 不过我们可以用古典概型的思维想。每射一次看成一个点，射中的点用白色表示，没有射中的用黑色表示。如果两个人第i次都没有射中，那么就要继续第i+1 轮，而第i+1轮和之前的每一轮是独立的。等于重复这个过程。所以古典概型的样本总量应该减去宝石两个人都没有射中的点的个数，为bd-(b-a)(d-c)，整理为bc+ad-a*c，设为n.要想第一个人赢，那么对于某一次，只要不是第一个人没射中，第二个人射中这种情况，就都是第一个人赢。而第一个人没射中的事件数为b-a,第二个人射中的事件数为c,总数为（b-a）*c，所以答案为(n-(b-a)*c)/n
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 15时57分06秒 File Name :code/cf/518D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,t; double p; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 453 A. Little Pony and Expected Maximum</title><link>https://111qqz.com/2016/02/cf543a/</link><pubDate>Mon, 01 Feb 2016 21:50:39 +0000</pubDate><guid>https://111qqz.com/2016/02/cf543a/</guid><description>
http://codeforces.com/problemset/problem/453/A 题意：m面筛子，每面点数出现的概率相同，连续投掷n次，问出现的最大值的数学期望。 思路：手写样例。。。发现答案为 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://codeforces.com/predownloaded/2a/ed/2aede49a2c6f455a4cb3af6fe16b61f4da56aa87.png
Disk path: /static/http://codeforces.com/predownloaded/2a/ed/2aede49a2c6f455a4cb3af6fe16b61f4da56aa87.png
Using Page Bundles: false
。。。记得把（1/m）^n放进去。
观察答案，可以这样理解（我是用样例推出公式后理解。。。数学差的人心好累）：如果i为最大值，那么n次每次必须投掷出1..i的点数，概率为 (i/m)^n,但是要至少有一个投掷成i，也就是要减去所有的数都是1..i-1中的情况（概率 为((i-1)/m)^n），
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 05时17分24秒 File Name :code/cf/problem/453A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; double ans; int n ,m; double p1[N],p2[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 476 B. Dreamoon and WiFi</title><link>https://111qqz.com/2016/02/cf476b/</link><pubDate>Mon, 01 Feb 2016 20:07:58 +0000</pubDate><guid>https://111qqz.com/2016/02/cf476b/</guid><description>
http://codeforces.com/problemset/problem/476/B 题意：给出两个长度相等-且不超过10的字符串，串1只包含‘-’,'+‘。按照‘+’为1，‘-’为-1累加可以得到一个值。串2还包含若干‘？’，代表该处的值不确定，且为'+'和'-'的概率相等，都是0.5.问串2的值和串1相等的概率。 思路：我们可以扫一遍得到‘？’的个数和两个式子的差值。设问号个数为a,差值为b，那么在a个问号中需要有(a-b)/2个为‘+’（容易知道，a,b一定奇偶性相同，所以a-b一定能被2整除），根据超几何分布，概率为 c[a][(a-b)/2]*(1/2)^a; 写的时候可以先打个组合数的表。1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 03时32分39秒 File Name :code/cf/problem/476B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string s1,s2; int len; int c[20][20]; void pre() { ms(c,0); c[1][1] = 1; c[1][2] = 1; c[2][1] = 1; c[2][2] = 2; c[2][3] = 1; for ( int i =3 ; i &amp;lt;=15 ; i++) for ( int j = 0 ; j &amp;lt;= i ; j++) c[i][j+1] = c[i-1][j+1]+c[i-1][j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #341 div2 C. Wet Shark and Flowers</title><link>https://111qqz.com/2016/02/cf341/</link><pubDate>Mon, 01 Feb 2016 11:55:49 +0000</pubDate><guid>https://111qqz.com/2016/02/cf341/</guid><description>
http://codeforces.com/contest/621/problem/C
C. Wet Shark and Flowers
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
There are n sharks who grow flowers for Wet Shark. They are all sitting around the table, such that sharks i and i + 1 are neighbours for all i from 1 to n - 1. Sharks n and 1 are neighbours too.
Each shark will grow some number of flowers s__i.</description></item><item><title>codeforces 30 C. Shooting Gallery</title><link>https://111qqz.com/2015/12/codeforces-30-c-shooting-gallery/</link><pubDate>Tue, 29 Dec 2015 10:54:59 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-30-c-shooting-gallery/</guid><description>
http://codeforces.com/contest/30/problem/C 题意：给出n个target在一个二维平面上。给出每个target的坐标，出现的时间，以及击中的概率。target出现之后就会瞬间消失，枪移动的单位速度为1，射击不需要时间。问能击中的target的最大期望是多少。
思路：路径dp。。。按照时间升序排列。 dp[i]表示到第i个target出现的时候的期望。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 18时14分45秒 File Name :code/cf/problem/30C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n; double dp[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>hdu 5481||bestcoder #57 div 2 C Desiderium (概率)</title><link>https://111qqz.com/2015/09/hdu5481bestcoder57div2cdesiderium/</link><pubDate>Wed, 30 Sep 2015 03:37:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu5481bestcoder57div2cdesiderium/</guid><description>
Desiderium **Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 427 Accepted Submission(s): 167 **
Problem Description
There is a set of intervals, the size of this set is n.
If we select a subset of this set with equal probability, how many the expected length of intervals' union of this subset is?
We assume that the length of empty set's union is 0, and we want the answer multiply 2n modulo 109+7.</description></item><item><title>cf 442B Andrey and Problem</title><link>https://111qqz.com/2015/07/cf442b/</link><pubDate>Tue, 28 Jul 2015 18:18:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf442b/</guid><description>
B. Andrey and Problem
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Andrey needs one more problem to conduct a programming contest. He has n friends who are always willing to help. He can ask some of them to come up with a contest problem. Andrey knows one value for each of his fiends -- the probability that this friend will come up with a problem if Andrey asks him.</description></item></channel></rss>