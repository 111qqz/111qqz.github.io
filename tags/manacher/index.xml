<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>manacher on 111qqz的小窝</title><link>https://111qqz.com/tags/manacher/</link><description>Recent content in manacher on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Mon, 18 Apr 2016 13:06:49 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/manacher/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 4513 吉哥系列故事——完美队形II (回文串,manacher)</title><link>https://111qqz.com/2016/04/hdu-4513/</link><pubDate>Mon, 18 Apr 2016 13:06:49 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu-4513/</guid><description>
题目链接：hdu4513
题意：给出一个n的数的序列，求出一个最长的回文字串，并且满足从[l,mid]单调增（非严格单调，可以相等），[mid,r]单调减（同样是可以相等）
思路：manacher...int型的也是可以搞的。。要求单调的话。。。while扩展的时候判一下就好了。。。
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 20时32分45秒 File Name :code/hdu/4513.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int p[N]; int a[N]; int manacher( int *s) { for ( int i = n ; i &amp;gt;= 0 ; i--) { s[i+i+2] = s[i]; s[i+i+1] = 300; } s[0] = 400;s[2*n+3] =405; // for ( int i = 1 ; i &amp;lt; 2*n+1 ; i++) cout&amp;lt;&amp;lt;&amp;quot;s[i]:&amp;quot;&amp;lt;&amp;lt;s[i]&amp;lt;&amp;lt;endl; int id = 0 ; int maxlen = 0 ; for ( int i = 2 ; i &amp;lt; 2*n +1 ; i++) { if (p[id]+id&amp;gt;i) p[i] = min(p[2*id-i],p[id]+id-i); else p[i] = 1; while (s[i-p[i]]==s[i+p[i]]) { if (s[i-p[i]]==300) { p[i]++; } else if (s[i-p[i]]&amp;lt;300) { if (s[i-p[i]]&amp;gt;s[i-p[i]+2]) break; p[i]++; } // cout&amp;lt;&amp;lt;&amp;quot;aaaaaaaaaooooooo&amp;quot;&amp;lt;&amp;lt;endl; } // cout&amp;lt;&amp;lt;&amp;quot;p[i]:&amp;quot;&amp;lt;&amp;lt;p[i]&amp;lt;&amp;lt;endl; if (id+p[id]&amp;lt;i+p[i]) id = i ; if (maxlen&amp;lt;p[i]) maxlen = p[i]; } return maxlen-1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3294 Girls' research (manacher,回文串)</title><link>https://111qqz.com/2016/04/poj3294/</link><pubDate>Mon, 18 Apr 2016 12:27:55 +0000</pubDate><guid>https://111qqz.com/2016/04/poj3294/</guid><description>
poj 3294 题意：先做个简单替换，然后求替换后的字符串的最长回文串，以及这个最长回文串的开始和结束位置。 思路：manacher..需要注意的是，返回下标的时候如果字符串长度为偶数，那么中间是没有字符的。。。需要特判一下。。（我的做法是left+(ans%2==0);
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 19时40分06秒 File Name :code/hdu/3294.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E5+7; char st[N],st2[N]; int p[N]; char ch; void manacher(char *s) { int len = strlen(s); for ( int i = len ; i&amp;gt;= 0 ; i--) { s[i*2+2] = s[i]; s[i*2+1] = '#'; } int id = 0 ; int maxlen = 0 ; int center = 0 ; s[0]='%'; for ( int i = 2 ; i &amp;lt; 2*len+1 ; i++) { if (id+p[id]&amp;gt;i) p[i] = min(p[2*id-i],p[id]+id-i); else p[i] = 1; while (s[p[i]+i]==s[i-p[i]]) p[i]++; if (id+p[id]&amp;lt;i+p[i]) id = i; if (p[i]&amp;gt;maxlen) { maxlen = p[i]; center = i; } } int ans = (maxlen-1); // cout&amp;lt;&amp;lt;&amp;quot;ans:&amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&amp;quot; center:&amp;quot;&amp;lt;&amp;lt;center&amp;lt;&amp;lt;endl; if (ans&amp;lt;2) { puts(&amp;quot;No solution!</description></item><item><title>poj 3974 Palindrome (最长回文字串，manacher裸题)</title><link>https://111qqz.com/2016/04/poj-3974-palindrome-manacher/</link><pubDate>Mon, 18 Apr 2016 08:46:54 +0000</pubDate><guid>https://111qqz.com/2016/04/poj-3974-palindrome-manacher/</guid><description>
poj3974 题意：求最大长度的回文字串。 思路：manacher裸题，用来练习算法。
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 16时32分25秒 File Name :code/poj/3974.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E6+7; char st[2*N]; int p[2*N]; int manacher(char *s) { int len = strlen(s); for ( int i = len ; i &amp;gt;= 0 ; i-- ) { s[i+i+2]=s[i]; s[i+i+1]='#'; } s[0]='$'; int id = 0 ; int maxlen = 0 ; for ( int i = 2 ; i &amp;lt; 2*len+1 ; i++) { if (id+p[id]&amp;gt;i) p[i] = min(p[2*id-i],id+p[id]-i); else p[i] = 1; while (s[i+p[i]]==s[i-p[i]]) p[i]++; if (id+p[id]&amp;lt;i+p[i]) id = i; if (p[i]&amp;gt;maxlen) maxlen = p[i]; } return maxlen-1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3068 最长回文（O(n)求回文串，manacher算法模板题）</title><link>https://111qqz.com/2016/04/hdu-3068/</link><pubDate>Mon, 18 Apr 2016 07:53:47 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu-3068/</guid><description>
题目链接 题意：求一个字符串中的最长回文串。 思路：昨天武大校赛遇到了一个manacher算法的题。。。我竟然听都没听过。。。
于是去学习了一发。
感觉这篇博客讲得最详细manachar算法学习
于是切了个模板题练手。
先简单说下我对这个算法的理解，等做一些题目以后再来总结一发。 我觉得manachar算法最关键的一点是，如果你枚举回文串的中心位置，当你枚举到i的时候，那么i之前的位置回文串长度的最大值是已经确定的了。 换句话说，后面的中心位置不会影响前面的中心位置的答案。 于是可以利用前面已经做过的匹配来获得一些信息，避免了重复。 不过讲真。。。O(n)的复杂度。。这算法还是相当让人感到震撼的。。。 更具体的部分见代码注释。。。
/* *********************************************** Author :111qqz Created Time :2016年04月18日 星期一 14时06分59秒 File Name :code/hdu/3068.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E6+999; char st[N]; int p[2*N]; //p[i]为以第i个位置的字符为中心的回文串的半径长，默认为1.</description></item></channel></rss>