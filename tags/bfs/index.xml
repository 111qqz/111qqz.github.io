<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bfs on 111qqz的小窝</title><link>http://example.org/tags/bfs/</link><description>Recent content in bfs on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 15 Apr 2016 07:23:53 +0000</lastBuildDate><atom:link href="http://example.org/tags/bfs/index.xml" rel="self" type="application/rss+xml"/><item><title>BZOJ 1656: [Usaco2006 Jan] The Grove 树木(神奇的bfs之射线法)</title><link>http://example.org/2016/04/bzoj-1656/</link><pubDate>Fri, 15 Apr 2016 07:23:53 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1656/</guid><description>1656: [Usaco2006 Jan] The Grove 树木 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 143 Solved: 88 [Submit][Status][Discuss]
Description The pasture contains a small, contiguous grove of trees that has no &amp;lsquo;holes&amp;rsquo; in the middle of the it. Bessie wonders: how far is it to walk around that grove and get back to my starting position? She&amp;rsquo;s just sure there is a way to do it by going from her start location to successive locations by walking horizontally, vertically, or diagonally and counting each move as a single step.</description></item><item><title>BZOJ 1646: [Usaco2007 Open]Catch That Cow 抓住那只牛 (BFS)</title><link>http://example.org/2016/04/bzoj-1646-usaco2007-opencatch-that-cow--bfs/</link><pubDate>Sun, 10 Apr 2016 13:07:12 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1646-usaco2007-opencatch-that-cow--bfs/</guid><description>1646: [Usaco2007 Open]Catch That Cow 抓住那只牛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 915 Solved: 441 [Submit][Status][Discuss]
Description Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 &amp;lt;= N &amp;lt;= 100,000) on a number line and the cow is at a point K (0 &amp;lt;= K &amp;lt;= 100,000) on the same number line.</description></item><item><title>BZOJ 1644: [Usaco2007 Oct]Obstacle Course 障碍训练课 (BFS,DP)</title><link>http://example.org/2016/04/bzoj-1644-usaco2007-octobstacle-course--bfsdp/</link><pubDate>Sun, 10 Apr 2016 12:41:46 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1644-usaco2007-octobstacle-course--bfsdp/</guid><description>1644: [Usaco2007 Oct]Obstacle Course 障碍训练课 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 451 Solved: 226 [Submit][Status][Discuss]
Description 考虑一个 N x N (1 &amp;lt;= N &amp;lt;= 100)的有1个个方格组成的正方形牧场。有些方格是奶牛们不能踏上的，它们被标记为了&amp;rsquo;x'。例如下图：
. . B x . . x x A . . . . x . . x . . . . . x . .
贝茜发现自己恰好在点A处，她想去B处的盐块舔盐。缓慢而且笨拙的动物，比如奶牛，十分讨厌转弯。尽管如此，当然在必要的时候她们还是会转弯的。对于一个给定的牧场，请你计算从A到B最少的转弯次数。开始的时候，贝茜可以使面对任意一个方向。贝茜知道她一定可以到达。
Input 第 1行: 一个整数 N 行
2..N + 1: 行 i+1 有 N 个字符 ('.', &amp;lsquo;x&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;)，表示每个点的状态。</description></item><item><title>BZOJ 1632: [Usaco2007 Feb]Lilypad Pond (BFS,dp)</title><link>http://example.org/2016/04/bzoj-1632/</link><pubDate>Wed, 06 Apr 2016 15:37:13 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1632/</guid><description>1632: [Usaco2007 Feb]Lilypad Pond Time Limit: 5 Sec Memory Limit: 64 MB Submit: 496 Solved: 153 [Submit][Status][Discuss]
Description Farmer John 建造了一个美丽的池塘，用于让他的牛们审美和锻炼。这个长方形的池子被分割成了 M 行和 N 列( 1 ≤ M ≤ 30 ; 1 ≤ N ≤ 30 ) 正方形格子的 。某些格子上有惊人的坚固的莲花，还有一些岩石，其余的只是美丽，纯净，湛蓝的水。 贝茜正在练习芭蕾舞，她从一个莲花跳跃到另一个莲花，当前位于一个莲花。她希望在莲花上一个一个的跳，目标是另一个给定莲花。她能跳既不入水，也不到一个岩石上。 令门外汉惊讶的是，贝茜的每次的跳跃像中国象棋的马一样：横向移动1，纵向移动2，或纵向移动1，横向移动2。贝茜有时可能会有多达8个选择的跳跃。 Farmer John 在观察贝茜的芭蕾舞联系，他意识到有时候贝茜有可能跳不到她想去的目的地，因为路上有些地方没有莲花。于是他想要添加几个莲花使贝茜能够完成任务。一贯节俭的Farmer John想添加最少数量的莲花。当然，莲花不能放在石头上。 请帮助Farmer John确定必须要添加的莲花的最少数量。在添加的莲花最少基础上，算出贝茜从起始点跳到目标点需要的最少的步数。最后，还要算出满足添加的莲花的最少数量时，跳跃最少步数的跳跃路径的条数。
Input 第 1 行: 两个整数 M , N
第 2..M + 1 行:第 i + 1 行，第 i + 1 行 有 N 个整数，表示该位置的状态: 0 为水; 1 为莲花; 2 为岩石; 3 为贝茜开始的位置; 4 为贝茜要去的目标位置.</description></item><item><title>BZOJ 1627: [Usaco2007 Dec]穿越泥地 (BFS)</title><link>http://example.org/2016/04/bzoj1627/</link><pubDate>Mon, 04 Apr 2016 07:00:06 +0000</pubDate><guid>http://example.org/2016/04/bzoj1627/</guid><description>1627: [Usaco2007 Dec]穿越泥地 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 624 Solved: 411 [Submit][Status][Discuss]
Description 清早6：00，Farmer John就离开了他的屋子，开始了他的例行工作：为贝茜挤奶。前一天晚上，整个农场刚经受过一场瓢泼大雨的洗礼，于是不难想见，FJ 现在面对的是一大片泥泞的土地。FJ的屋子在平面坐标(0, 0)的位置，贝茜所在的牛棚则位于坐标(X,Y) (-500 &amp;lt;= X &amp;lt;= 500; -500 &amp;lt;= Y &amp;lt;= 500)处。当然咯， FJ也看到了地上的所有N(1 &amp;lt;= N &amp;lt;= 10,000)个泥塘，第i个泥塘的坐标为 (A_i, B_i) (-500 &amp;lt;= A_i &amp;lt;= 500；-500 &amp;lt;= B_i &amp;lt;= 500)。每个泥塘都只占据了它所在的那个格子。 Farmer John自然不愿意弄脏他新买的靴子，但他同时想尽快到达贝茜所在的位置。为了数那些讨厌的泥塘，他已经耽搁了一些时间了。如果Farmer John 只能平行于坐标轴移动，并且只在x、y均为整数的坐标处转弯，那么他从屋子门口出发，最少要走多少路才能到贝茜所在的牛棚呢？你可以认为从FJ的屋子到牛棚总是存在至少一条不经过任何泥塘的路径。
Input 第1行: 3个用空格隔开的整数：X，Y 和 N
第2..N+1行: 第i+1行为2个用空格隔开的整数：A_i 和 B_i
Output 第1行: 输出1个整数，即FJ在不踏进泥塘的情况下，到达贝茜所在牛棚所需要 走过的最小距离 Sample Input 1 2 7 0 2 -1 3 3 1 1 1 4 2 -1 1 2 2</description></item><item><title>BZOJ1619: [Usaco2008 Nov]Guarding the Farm 保卫牧场 （BFS）</title><link>http://example.org/2016/04/bzoj1619-usaco2008-novguarding-the-farm--bfs/</link><pubDate>Sun, 03 Apr 2016 17:23:04 +0000</pubDate><guid>http://example.org/2016/04/bzoj1619-usaco2008-novguarding-the-farm--bfs/</guid><description>1619: [Usaco2008 Nov]Guarding the Farm 保卫牧场 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 661 Solved: 292 [Submit][Status][Discuss]
Description The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows. He wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 &amp;lt; N &amp;lt;= 700) rows and M (1 &amp;lt; M &amp;lt;= 700) columns.</description></item><item><title>BZOJ 1611: [Usaco2008 Feb]Meteor Shower流星雨 (BFS)</title><link>http://example.org/2016/04/bzoj-1611/</link><pubDate>Sat, 02 Apr 2016 07:06:38 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1611/</guid><description>1611: [Usaco2008 Feb]Meteor Shower流星雨 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1239 Solved: 537 [Submit][Status][Discuss]
Description 去年偶们湖南遭受N年不遇到冰冻灾害，现在芙蓉哥哥则听说另一个骇人听闻的消息： 一场流星雨即将袭击整个霸中，由于流星体积过大，它们无法在撞击到地面前燃烧殆尽， 届时将会对它撞到的一切东西造成毁灭性的打击。很自然地，芙蓉哥哥开始担心自己的 安全问题。以霸中至In型男名誉起誓，他一定要在被流星砸到前，到达一个安全的地方 （也就是说，一块不会被任何流星砸到的土地）。如果将霸中放入一个直角坐标系中， 芙蓉哥哥现在的位置是原点，并且，芙蓉哥哥不能踏上一块被流星砸过的土地。根据预 报，一共有M颗流星(1 &amp;lt;= M &amp;lt;= 50,000)会坠落在霸中上，其中第i颗流星会在时刻 T_i (0 &amp;lt;= T_i &amp;lt;= 1,000)砸在坐标为(X_i, Y_i) (0 &amp;lt;= X_i &amp;lt;= 300；0 &amp;lt;= Y_i &amp;lt;= 300) 的格子里。流星的力量会将它所在的格子，以及周围4个相邻的格子都化为焦土，当然 芙蓉哥哥也无法再在这些格子上行走。芙蓉哥哥在时刻0开始行动，它只能在第一象限中， 平行于坐标轴行动，每1个时刻中，她能移动到相邻的（一般是4个）格子中的任意一个， 当然目标格子要没有被烧焦才行。如果一个格子在时刻t被流星撞击或烧焦，那么芙蓉哥哥 只能在t之前的时刻在这个格子里出现。请你计算一下，芙蓉哥哥最少需要多少时间才能到 达一个安全的格子。
Input 第1行: 1个正整数：M * 第2..M+1行: 第i+1行为3个用空格隔开的整数：X_i，Y_i，以及T_i Output 输出1个整数，即芙蓉哥哥逃生所花的最少时间。如果芙蓉哥哥无论如何都无法在流星雨中存活下来，输出-1
Sample Input 4 0 0 2 2 1 2 1 1 2 0 3 5 输入说明: 一共有4颗流星将坠落在霸中，它们落地点的坐标分别是(0, 0)，(2, 1)，(1, 1) 以及(0, 3)，时刻分别为2，2，2，5。</description></item><item><title>bzoj 1602: [Usaco2008 Oct]牧场行走 (bfs,优先队列)</title><link>http://example.org/2016/03/bzoj1602/</link><pubDate>Thu, 31 Mar 2016 12:57:27 +0000</pubDate><guid>http://example.org/2016/03/bzoj1602/</guid><description>Description
N头牛（2&amp;lt;=n&amp;lt;=1000）别人被标记为1到n，在同样被标记1到n的n块土地上吃草，第i头牛在第i块牧场吃草。 这n块土地被n-1条边连接。 奶牛可以在边上行走，第i条边连接第Ai，Bi块牧场，第i条边的长度是Li（1&amp;lt;=Li&amp;lt;=10000）。 这些边被安排成任意两头奶牛都可以通过这些边到达的情况，所以说这是一棵树。 这些奶牛是非常喜欢交际的，经常会去互相访问,他们想让你去帮助他们计算Q(1&amp;lt;=q&amp;lt;=1000)对奶牛之间的距离。
Input
*第一行：两个被空格隔开的整数：N和Q
*第二行到第n行：第i+1行有两个被空格隔开的整数：AI，BI，LI
*第n+1行到n+Q行：每一行有两个空格隔开的整数：P1，P2，表示两头奶牛的编号。
Output
*第1行到第Q行：每行输出一个数，表示那两头奶牛之间的距离。
Sample Input
4 2
2 1 2
4 3 2
1 4 3
1 2
3 2
Sample Output
2
7
思路：直接bfs&amp;hellip;.貌似因为每个点最多只和两个边相连。。。不用优先队列也行？ 1A,好爽23333.
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 20时27分01秒 File Name :code/bzoj/1602.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+5; int n,q; vector&amp;lt; pi &amp;gt;edge[N]; bool vis[N]; int d[N]; struct node { int x; int d; bool operator &amp;lt; (node b)const { return d&amp;gt;b.</description></item><item><title>bc #77 ||hdu 5652 India and China Origins (图的动态连通性问题，并查集or 二分+bfs验证连通性)</title><link>http://example.org/2016/03/hdu5652/</link><pubDate>Mon, 28 Mar 2016 12:37:40 +0000</pubDate><guid>http://example.org/2016/03/hdu5652/</guid><description>题目链接 题意：没图不好描述，有中文题面中文题面，直接看吧。 思路：据说这道题有三种做法。 当时比赛一种都不会。
先说一种：做法是把格子看成点，可以到达的相邻格子之间看成有边相连，然后倒过来用并查集判断无向图的连通性。具体做法是：先统计初始所有空的位置，然后把所有要增加的山都加上（先统计空的位置是因为山之后要去掉，而去掉以后要得到该点的标号），然后将把所有空的点以及china(设标号为n*m+1)点,和india(**设标号为n*m+2) **点通过并查集来合并..可以从上往下从左往右，每次只需要判断上面的点和左边的点是否有空，如果有就用并查集合并。 china点和india点特殊搞就好。
然后判断india和china是否联通，如果是则输出-1.否则从最后添加的山开始移除，每次移除一座山，添加四个方向能添加的边（注意这里不要忘记如果改点在第0行或者第n-1行还要添加和china或者india的边）
然后移除后询问india和china是否联通 （root(china)==root(india)?）
如果时间i联通了，而i+1没有联通，说明时间i是两国最早的失去联系的时间。
第一次做这种题目，这种题目的一般做法都是倒过来做。貌似还有一个二分删除的山+bfs判断连通性的。。。？ 窝再搞搞看。 update :二分+bfs判断连通性。其实这个思路更常规。。做法就是字面意思。注意无解的判断即可。
并查集解法：
/* *********************************************** Author :111qqz Created Time :2016年03月27日 星期日 20时11分02秒 File Name :code/bc/#77/1003.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; char maze[N][N]; int f[N*N]; int n,m; int q; int p[N][N]; int china; int india; struct node { int x,y; int id; }shan[N*N],kong[N*N]; int root ( int x) { if (x!</description></item><item><title>codeforces 520 B. Two Buttons (bfs)</title><link>http://example.org/2015/08/codeforces520b-twobuttonsbfs/</link><pubDate>Sun, 16 Aug 2015 20:34:00 +0000</pubDate><guid>http://example.org/2015/08/codeforces520b-twobuttonsbfs/</guid><description>做过一道类似的题
因为是问最短，很容易想到是bfs
对于点x，可以到达点x-1,和点2*x
需要注意的是上界限。
并不是max(m,n)
因为可能先达到比m大，之后再减回来的情况是更优的。
max(2m,2n)肯定是足够的
/************************************************************************* &amp;gt; File Name: code/cf/#295/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 04时16分51秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E4+7; int n,m; int d[N]; int mx; void bfs() { memset(d,-1,sizeof(d)); d[n] = 0 ; queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 2688 Cleaning Robot (tsp问题)</title><link>http://example.org/2015/08/poj2688/</link><pubDate>Sat, 15 Aug 2015 20:16:00 +0000</pubDate><guid>http://example.org/2015/08/poj2688/</guid><description>＿＿＿＿＿＿
好蠢，竟然没看出来这道题的不同之处，以为就是个搜
然后样例什么的都过了．．．
结果显然wa&amp;hellip;
然后才发现，这道题应该是tsp问题．
解法是先跑一遍bfs,
对于所有的脏点和起点，得到没两个点之间的距离．
然后跑一遍dfs，枚举出所有的组合，同时更新答案．
晚安．
/************************************************************************* &amp;gt; File Name: code/poj/rr2688.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 03时39分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=25; int w,h; char maze[N][N]; int dist[N][N]; int cnt;//机器人与脏地的个数 int tag[N][N];//标记 bool vist[N][N]; struct node { int x,y; int step; bool ok () { if (x&amp;lt;1||x&amp;gt;h||y&amp;lt;1||y&amp;gt;w||vist[x][y]||maze[x][y]=='x') return false; return true; } }pos[N*N]; node robot; int dir[4][2]={0,-1,0,1,-1,0,1,0}; void bfs(node p,int po) { vist[p.</description></item><item><title>I - Fire Game (两个点开始的bfs)</title><link>http://example.org/2015/07/i-firegamebfs/</link><pubDate>Mon, 27 Jul 2015 11:01:00 +0000</pubDate><guid>http://example.org/2015/07/i-firegamebfs/</guid><description>http://acm.hust.edu.cn/vjudge/contest/view.action?cid=83084#problem/I
I - Fire Game
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire.</description></item><item><title>poj 3414 pots (bfs+路径记录)</title><link>http://example.org/2015/07/poj3414/</link><pubDate>Mon, 27 Jul 2015 08:44:00 +0000</pubDate><guid>http://example.org/2015/07/poj3414/</guid><description>好爽,一遍ac
/************************************************************************* &amp;gt; File Name: code/2015summer/searching/H.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年07月27日 星期一 09时11分28秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int N=1E2+5; int A,B,C; int d[N][N]; bool flag; struct node { int d,opt,par,prea,preb; }q[N][N]; void print(int x,int y) { // cout&amp;lt;&amp;lt;&amp;#34;x:&amp;#34;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;#34;y:&amp;#34;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; if (q[x][y].</description></item><item><title>hdoj 1495 非常可乐(bfs)</title><link>http://example.org/2015/07/hdoj1495/</link><pubDate>Sun, 26 Jul 2015 14:59:00 +0000</pubDate><guid>http://example.org/2015/07/hdoj1495/</guid><description>非常可乐 **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 7194 Accepted Submission(s): 2865
**
Problem Description
大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&amp;lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出&amp;quot;NO&amp;quot;。
Input
三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以&amp;quot;0 0 0&amp;quot;结束。
Output
如果能平分的话请输出最少要倒的次数，否则输出&amp;quot;NO&amp;quot;。
Sample Input
7 4 3 4 1 3 0 0 0
Sample Output
NO 3
平分可乐,不能剩.
奇数的话直接no
偶数的话bfs
妈蛋写了140+行,简直令人感动.
然后一直WA
郁闷了好久,结果今天一看,竟然已经A了&amp;hellip;
是测评傲娇了嘛2333
/************************************************************************* &amp;gt; File Name: code/2015summer/searching/M.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.</description></item><item><title>hdoj 2612 find a way (两次bfs)</title><link>http://example.org/2015/07/hdoj2612/</link><pubDate>Sat, 25 Jul 2015 07:01:00 +0000</pubDate><guid>http://example.org/2015/07/hdoj2612/</guid><description>Find a way ****Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 6221 Accepted Submission(s): 2070
**
**
Problem Description
Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.
Yifenfei&amp;rsquo;s home is at the countryside, but Merceki&amp;rsquo;s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC.</description></item><item><title>poj 3984 迷宫问题</title><link>http://example.org/2015/07/poj3984/</link><pubDate>Sat, 25 Jul 2015 05:53:00 +0000</pubDate><guid>http://example.org/2015/07/poj3984/</guid><description>迷宫问题
/************************************************************************* &amp;gt; File Name: code/2015summer/searching/KK.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年07月25日 星期六 13时33分00秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; int a[10][10]; int head = 0; int tail = 1; int dirx[2]={1,0}; int diry[2]={0,1}; struct node { int x,y,pre; }q[10]; void print(int x) { if (q[x].</description></item><item><title>poj 3087 Shuffle'm Up (bfs)</title><link>http://example.org/2015/07/poj3087/</link><pubDate>Fri, 24 Jul 2015 16:12:00 +0000</pubDate><guid>http://example.org/2015/07/poj3087/</guid><description>http://poj.org/problem?id=3087
用bfs写的，但是其实就是个模拟啊喂！
只有一种操作，何谈最短？　一直往下写就行了．
有一点疑惑，就是map的初始值
比如我定义的　map&amp;lt;string,int&amp;gt;d;它的初始的value是什么？随机值？０？还是什么，百度了下，没找到，求指教．
#include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; map&amp;lt;string,int&amp;gt;d; string st1,st2,tar; int n; bool flag; string add(string a,string b) { string res=&amp;#34;&amp;#34;; int len = a.</description></item><item><title>poj 3126 Prime Path (bfs)</title><link>http://example.org/2015/07/poj3126/</link><pubDate>Fri, 24 Jul 2015 12:53:00 +0000</pubDate><guid>http://example.org/2015/07/poj3126/</guid><description>http://poj.org/problem?id=3126
题意是说,给定两个四位素数a b 问从a变换到b,最少需要变换几次. 变换的要求是,每次只能改变一个数字,而且中间过程得到的四位数也必须为素数. 因为提到最少变换几次,容易想到bfs,bfs第一次搜到的一定是最短步数.
先打个素数表 然后写个函数判断两个四位数有几位数字不同,如果只有一位,返回true,否则返回false 然后竟然wa了两次! 下表写错! pri[k++]=i;是先给pri[k]赋值,再k++; pri[++k]=i;才是先增加,再赋值.这个搞错了.所以wa了&amp;hellip;.sad
/************************************************************************* &amp;gt; File Name: code/poj/3126.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: Fri 24 Jul 2015 01:16:23 AM CST ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int N =1E4+5; int pri[N],which[N]; int a,b,k; bool flag; int d[N]; bool prime(int x) { for ( int i = 2 ; i*i&amp;lt;=x ;i++ ) { if (x %i==0) return false; } return true; } bool ok (int x,int y) { if (d[y]!</description></item><item><title>poj 2251 Dungeon Master (三维bfs)</title><link>http://example.org/2015/07/poj2251/</link><pubDate>Tue, 21 Jul 2015 05:02:00 +0000</pubDate><guid>http://example.org/2015/07/poj2251/</guid><description>http://poj.org/problem?id=2251
简单bfs，只不过是三维的。。。
唯一的坑点在输出上&amp;hellip;
Escaped in %d minute(s) 这意思是答案为1输出minute,不为1输出minutes还是说是不是1都输出minute(s)? 试了下，答案是后者。
另：终于找到了好的读地图的方法。。。而不用担心回车符。
就是先读成字符串。
具体见代码
/************************************************************************* &amp;gt; File Name: code/2015summer/searching/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年07月17日 星期五 16时47分46秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int N=40; char st[N][N][N]; int d[N][N][N]; int l,r,c; int sx,sy,sz,tx,ty,tz; int dirx[6]={1,-1,0,0,0,0}; int diry[6]={0,0,-1,1,0,0}; int dirz[6]={0,0,0,0,1,-1}; bool ok(int x,int y,int z) { if (z&amp;gt;=0&amp;amp;&amp;amp;z&amp;lt;l&amp;amp;&amp;amp;x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;r&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;c&amp;amp;&amp;amp;d[z][x][y]==-1&amp;amp;&amp;amp;st[z][x][y]!</description></item><item><title>poj 3278 catch that cow</title><link>http://example.org/2015/07/poj3278/</link><pubDate>Wed, 08 Jul 2015 02:25:00 +0000</pubDate><guid>http://example.org/2015/07/poj3278/</guid><description>http://poj.org/problem?id=3278
bfs,用到了stl的queue
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 15时45分05秒 File Name :3278.cpp ************************************************ */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; typedef long long LL; const int inf = 8E8; const int N=2E5+7; int d[N]; int n,k; void bfs() { queue&amp;lt;int&amp;gt; q; memset(d,-1,sizeof(d)); q.push(n); d[n]=0; while (!q.empty()) { int x = q.front(); q.pop(); if ( x==k ) { break; } int next[10]; next[1]=x-1; next[2]=x+1; next[3]=2*x; for ( int i = 1; i &amp;lt;= 3 ; i++ ) { if (next[i]&amp;gt;=0&amp;amp;&amp;amp;next[i]&amp;lt;=100000&amp;amp;&amp;amp;d[next[i]]==-1) { d[next[i]]=d[x]+1; q.</description></item></channel></rss>