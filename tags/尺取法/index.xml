<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>尺取法 on Clarity</title><link>https://111qqz.com/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/</link><description>Recent content in 尺取法 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Thu, 13 Apr 2017 13:50:02 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>leetcode 209. Minimum Size Subarray Sum (尺取法)</title><link>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum/</link><pubDate>Thu, 13 Apr 2017 13:50:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum/</guid><description>
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.
For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint
思路：尺取即可。。好久没写，竟然调了半天。。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 20时48分00秒 File Name :209.cpp ************************************************ */ class Solution { public: int ruler(vector&amp;lt;int&amp;gt;nums,int tar,int n) { int head = 0; int tail = 0; int sum = 0 ; int res = 0x3f3f3f3f; while (tail&amp;lt;n&amp;amp;&amp;amp;head&amp;lt;=tail) { sum = sum + nums[tail]; if (sum&amp;gt;=tar) { res = min(res,tail-head+1); while (sum&amp;gt;=tar&amp;amp;&amp;amp;head&amp;lt;tail) { sum-=nums[head]; head++; } if (sum&amp;gt;=tar) { res = min(res,tail-head+1); } else { head--; sum+=nums[head]; res = min(res,tail-head+1); } } tail++; } return res==0x3f3f3f3f?</description></item><item><title>BZOJ 1800: [Ahoi2009]fly 飞行棋 （尺取+数学）</title><link>https://111qqz.com/2017/01/bzoj-1800-ahoi2009fly-/</link><pubDate>Thu, 26 Jan 2017 15:42:07 +0000</pubDate><guid>https://111qqz.com/2017/01/bzoj-1800-ahoi2009fly-/</guid><description>
1800: [Ahoi2009]fly 飞行棋 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 1530 Solved: 1220 [Submit][Status][Discuss]
Description 给出圆周上的若干个点，已知点与点之间的弧长，其值均为正整数，并依圆周顺序排列。 请找出这些点中有没有可以围成矩形的，并希望在最短时间内找出所有不重复矩形。
Input 第一行为正整数N，表示点的个数，接下来N行分别为这N个点所分割的各个圆弧长度
Output 所构成不重复矩形的个数
Sample Input 8 1 2 2 3 1 1 3 3
Sample Output 3
HINT N&amp;lt;= 20 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://www.lydsy.com/JudgeOnline/images/1800.jpg
Disk path: /static/http://www.lydsy.com/JudgeOnline/images/1800.jpg
Using Page Bundles: false</description></item><item><title>codeforces 220 E. Little Elephant and Inversions (树状数组+尺取)</title><link>https://111qqz.com/2016/09/cf220e/</link><pubDate>Thu, 15 Sep 2016 08:13:56 +0000</pubDate><guid>https://111qqz.com/2016/09/cf220e/</guid><description>
题目链接
题意：
how many pairs of integers l and r are there, such that 1 ≤ l &amp;lt; r ≤ n and sequence b = _a_1_a_2... a__l__a__r__a__r + 1... a__n has no more than k inversions.
我花了两个小时才看懂题。。。。一直没懂b数列中a[l]和a[r]怎么就挨着了。。。
其实意思是。。。只保留a数列中1..l和r..n的。。。构成b数列。。。然后b数列的逆序对数小于等于k.问这样的l,r的对数。
思路：尺取+树状数组。
枚举l,每次找到最小的满足题意的r，对答案的贡献是n-r+1,然后用两个树状数组，分别维护增加或者减少一个树的时候，前半段和后半段对逆序数的影响。
/* *********************************************** Author :111qqz Created Time :Wed 14 Sep 2016 04:23:06 PM CST File Name :code/cf/problem/220E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int tree[2][N]; int a[N],p[N]; int n; LL k; int lowbit( int x) { return x&amp;amp;(-x); } void update (int o, int x,int delta) { if (!</description></item><item><title>hdu 4123 Bob’s Race (树的直径+尺取+rmq)(珍爱生命，远离log)</title><link>https://111qqz.com/2016/07/hdu-4123/</link><pubDate>Sun, 17 Jul 2016 16:21:03 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-4123/</guid><description>
hdu 4123 题目链接
题意：一棵树，定义d[i]为点i到树上某点的最大距离。。。给出若干查询，每个查询一个x,问最多能有多少点满足这些点中，最大的d与最小的d的差小于等于x.要求这些点的编号必须是连续的。
思路：可以三遍bfs处理出所有点的d...
由于不能排序。。。所以就是尺取+rmq....
然而神Tm TLE.....
这复杂度还TLe...
结果最后发现是。。。log运算的常数太大被卡。。。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: https://111qqz.com/wordpress/wp-content/uploads/2016/07/2016-07-17-23-19-46-的屏幕截图.png
Disk path: /static/https://111qqz.com/wordpress/wp-content/uploads/2016/07/2016-07-17-23-19-46-的屏幕截图.png
Using Page Bundles: false
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: https://111qqz.com/wordpress/wp-content/uploads/2016/07/2016-07-17-23-26-58-的屏幕截图.png
Disk path: /static/https://111qqz.com/wordpress/wp-content/uploads/2016/07/2016-07-17-23-26-58-的屏幕截图.png
Using Page Bundles: false</description></item><item><title>codeforces 660 C. Hard Process (ruler)</title><link>https://111qqz.com/2016/06/codeforces-660-c-hard-process-ruler/</link><pubDate>Wed, 08 Jun 2016 16:17:00 +0000</pubDate><guid>https://111qqz.com/2016/06/codeforces-660-c-hard-process-ruler/</guid><description>
cf660C
solution:ruler.1A
/* *********************************************** Author :111qqz Created Time :2016年06月08日 星期三 23时43分18秒 File Name :code/cf/problem/660C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int n,k; int sum[N],a[N]; void ruler() { int head = 1; int tail = 1; int l,r; int res = -1; int cnt = 0 ; while (tail&amp;lt;=n) { while (a[tail]==1) tail++; // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;endl; if (a[tail]==0&amp;amp;&amp;amp;tail&amp;lt;=n) cnt++; while (sum[tail]-sum[head-1]&amp;lt;=k&amp;amp;&amp;amp;tail&amp;lt;=n) tail++; // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot;tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;endl; if (tail-head&amp;gt;res) { res = tail-head; // cout&amp;lt;&amp;lt;&amp;quot;res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; l = head; r = tail-1; } while (head&amp;lt;=tail&amp;amp;&amp;amp;sum[tail]-sum[head-1]&amp;gt;k) head++; // cout&amp;lt;&amp;lt;&amp;quot;head::&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;endl; if (tail&amp;lt;=n&amp;amp;&amp;amp;tail-head+1&amp;gt;res) { res = tail-head+1; l = head; r = tail; } } for ( int i = l ; i &amp;lt;= r ; i++) a[i] = 1; cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt;= n ; i++) cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3530 Subsequence (尺取+rmq)</title><link>https://111qqz.com/2016/05/hdu3530/</link><pubDate>Thu, 19 May 2016 09:44:36 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3530/</guid><description>
hdu 3530题目链接
题意：给出n个数，m,k，问最大的j-i+1,使得【i,j】间的最大值与最小值的差属于[m,k] 思路：rmq+尺取。 2A.
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 16时52分03秒 File Name :code/hdu/3530.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int dp[N][20],dp2[N][20]; int m,k; void rmq_init() { for ( int i = 1 ; i &amp;lt;= n ; i ++) dp[i][0] = dp2[i][0] = a[i]; for ( int j = 1 ; (1&amp;lt;&amp;lt;j) &amp;lt;= n ; j++) for ( int i = 1 ; i + (1&amp;lt;&amp;lt;j) -1 &amp;lt;= n ; i++) { dp[i][j] = max(dp[i][j-1],dp[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); dp2[i][j]=min(dp2[i][j-1],dp2[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } } int rmq( int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; int mx = max(dp[l][k],dp[r-(1&amp;lt;&amp;lt;k)+1][k]); int mn = min(dp2[l][k],dp2[r-(1&amp;lt;&amp;lt;k)+1][k]); return mx-mn; } int ruler() { int head = 1; int tail = 1; int res = -1 ; while (tail&amp;lt;=n) { int cur = rmq(head,tail); while (head&amp;lt;tail&amp;amp;&amp;amp;rmq(head,tail)&amp;gt;k) head++; while (tail&amp;lt;n&amp;amp;&amp;amp;rmq(head,tail)&amp;lt;m) tail++; //if (tail&amp;gt;n) break; cur = rmq(head,tail); if (cur&amp;gt;=m&amp;amp;&amp;amp;cur&amp;lt;=k) { res = max(res,tail-head); } // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; tail++; } return res+1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 279 B books</title><link>https://111qqz.com/2015/12/cf279b/</link><pubDate>Tue, 15 Dec 2015 12:23:32 +0000</pubDate><guid>https://111qqz.com/2015/12/cf279b/</guid><description>
http://codeforces.com/problemset/problem/279/B 题意：给定一个序列，问一段连续的序列的和小于等于t的最长的序列的长度。 思路：尺取法。三个月前学习的了。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 20时08分16秒 File Name :code/cf/problem/279B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int t; int a[N]; void solve() { int head = 1; int tail = 1; int sum = 0 ; int ans = 0 ; while (tail&amp;lt;=n) { // cout&amp;lt;&amp;lt;&amp;quot;aaaaa?</description></item><item><title>codeforces #321 div 2 B. Kefa and Company(尺取法)</title><link>https://111qqz.com/2015/09/codeforces321div2b-kefaandcompany/</link><pubDate>Fri, 25 Sep 2015 14:46:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces321div2b-kefaandcompany/</guid><description>
B. Kefa and Company
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company.
Kefa has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa.</description></item><item><title>poj 2566 Bound Found (前缀和，尺取法（two pointer）)</title><link>https://111qqz.com/2015/09/poj2566/</link><pubDate>Thu, 24 Sep 2015 16:26:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2566/</guid><description>
题意　：给定一个长度为n的区间．然后给k次询问，每次一个数t,求一个区间[l,r]使得这个区间和的绝对值最接近t
没办法直接尺取.
先预处理出来前缀和
如果要找一对区间的和的绝对值最最近t
等价于找到两个数i和j,使得sum[i]-sum[j]的绝对值最接近t,且i&amp;lt;&amp;gt;j
那么对前缀和排序...然后尺取
因为答案要输出下标
所以之前先存一下下标．
然后对于i，j
所对应的区间为[min(pre[i].id,pre[j].id)+1,max(pre[i],id,pre[j].id)];
/************************************************************************* &amp;gt; File Name: code/poj/2566.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月24日 星期四 22时10分08秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int N=1E5+7; const int inf = 0x3f3f3f3f; int a[N]; int n ,k; struct Q { int id; int sum; }pre[N]; bool cmp(Q a,Q b) { if (a.</description></item><item><title>poj 3320 Jessica's Reading Problem (尺取法)</title><link>https://111qqz.com/2015/09/poj3320jessicasreadingproblem/</link><pubDate>Thu, 24 Sep 2015 13:37:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj3320jessicasreadingproblem/</guid><description>
Jessica's Reading Problem
**Time Limit:** 1000MS **Memory Limit:** 65536K **Total Submissions:** 8787 **Accepted:** 2824 Description
Jessica's a very lovely girl wooed by lots of boys. Recently she has a problem. The final exam is coming, yet she has spent little time on it. If she wants to pass it, she has to master all ideas included in a very thick text book.</description></item></channel></rss>