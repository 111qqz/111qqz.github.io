<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>反素数 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%8F%8D%E7%B4%A0%E6%95%B0/</link><description>Recent content in 反素数 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 21 Sep 2016 17:03:08 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%8F%8D%E7%B4%A0%E6%95%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 2886 Who Gets the Most Candies? （线段树模拟加强版约瑟夫问题+反素数)</title><link>https://111qqz.com/2016/09/poj-2886/</link><pubDate>Wed, 21 Sep 2016 17:03:08 +0000</pubDate><guid>https://111qqz.com/2016/09/poj-2886/</guid><description>
poj 2886 题目链接
题意：n个人围成一圈，每个人身上由一个数，可正可负。从第k个人开始出圈，如果第k个人身上的数是X,X&amp;gt;0，就左边第x个没有出圈的人出圈，否则右边第-X个人出圈。 第k个人出圈得到的糖果数目为f(k)，f(x)表示x的因子个数。现在问谁能拿到最多的糖果，并且拿到了多少糖果。
思路：看起来好像很麻烦。。其实可以分解成两个问题。
第一个子问题就是约瑟夫问题的加强版。。。每次间隔不是定数，而取决与上一次出队的人。。。
终点是数据有5E5.。。模拟的话会炸掉。。。所以用线段树来模拟这个过程。。。
类似于那道插队的问题。。。线段树的域存的是某区间中空位置的数量。。初始为1.。。
然后每次update的时候优先查看左子树。。。
第二个子问题就是。。。到底第几个出去的人那道的糖果最多。。。。
其实也就是求1..n中。。。因子数最大的那个。。。
利用反素数表。。。每次upper_bound一下即可。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 09:19:11 PM CST File Name :code/poj/2886.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int tree[N&amp;lt;&amp;lt;2]; int n,k; char nam[N][11]; int val[N]; int s[40] = {1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,500001}; int b[40] = {1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200}; void PushUp( int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void build( int l,int r,int rt) { if (l==r) { tree[rt] = 1; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } int update( int p,int l,int r,int rt) { if (l==r) { tree[rt]--; return l; } int m = (l+r)&amp;gt;&amp;gt;1; int ret; if (p&amp;lt;=tree[rt&amp;lt;&amp;lt;1]) ret = update(p,lson); else ret = update(p-tree[rt&amp;lt;&amp;lt;1],rson); PushUp(rt); return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bzoj 1053: [HAOI2007]反素数ant</title><link>https://111qqz.com/2016/09/bzoj-1053/</link><pubDate>Wed, 21 Sep 2016 12:31:01 +0000</pubDate><guid>https://111qqz.com/2016/09/bzoj-1053/</guid><description>
1053: [HAOI2007]反素数ant Time Limit: 10 Sec Memory Limit: 162 MB Submit: 2750 Solved: 1559 [Submit][Status][Discuss]
Description 　对于任何正整数x，其约数的个数记作g(x)。例如g(1)=1、g(6)=4。如果某个正整数x满足：g(x)&amp;gt;g(i) 0&amp;lt;i&amp;lt;x
，则称x为反质数。例如，整数1，2，4，6等都是反质数。现在给定一个数N，你能求出不超过N的最大的反质数么
？
Input 　一个数N（1&amp;lt;=N&amp;lt;=2,000,000,000）。
Output 　不超过N的最大的反质数。
Sample Input 1000
Sample Output 840
HINT Source 思路：dfs然后剪一下。。。和ural 1748同样的做法。。。。
还可以。。。打表。。。。
有表不打和咸鱼有什么区别呢
（oi赛制不可以带纸质材料，所以打表大概算是恶习...不过acm不一样啊orz。。。反素数表1..1E18也才167个。。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 08:15:41 PM CST File Name :code/bzoj/1053.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL anti_prime[]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2095133040,2205403200,2327925600,2793510720,3491888400,4655851200,5587021440,6983776800,10475665200,13967553600,20951330400,27935107200,41902660800,48886437600,64250746560,73329656400,80313433200,97772875200,128501493120,146659312800,160626866400,240940299600,293318625600,321253732800,481880599200,642507465600,963761198400,1124388064800,1606268664000,1686582097200,1927522396800,2248776129600,3212537328000,3373164194400,4497552259200,6746328388800,8995104518400,9316358251200,13492656777600,18632716502400,26985313555200,27949074753600,32607253879200,46581791256000,48910880818800,55898149507200,65214507758400,93163582512000,97821761637600,130429015516800,195643523275200,260858031033600,288807105787200,391287046550400,577614211574400,782574093100800,866421317361600,1010824870255200,1444035528936000,1516237305382800,1732842634723200,2021649740510400,2888071057872000,3032474610765600,4043299481020800,6064949221531200,8086598962041600,10108248702552000,12129898443062400,18194847664593600,20216497405104000,24259796886124800,30324746107656000,36389695329187200,48519593772249600,60649492215312000,72779390658374400,74801040398884800,106858629141264000,112201560598327200,149602080797769600,224403121196654400,299204161595539200,374005201994424000,448806242393308800,673209363589963200,748010403988848000,897612484786617600,1122015605983272000,1346418727179926400,1795224969573235200,2244031211966544000,2692837454359852800,3066842656354276800,4381203794791824000,4488062423933088000,6133685312708553600,8976124847866176000,9200527969062830400}; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 27 E. Number With The Given Amount Of Divisors (dfs，反素数（假）)</title><link>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</link><pubDate>Wed, 21 Sep 2016 09:02:26 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</guid><description>
题目链接
题意：求约数个数恰好为n个的最小的x
思路：这道题是作为反素数的例题出现在acdreamer的博客里的。
但是实际上，这道题应该和反素数没有关系。
如果题目问的是最小的约数个数大于等于n的x，那么答案一定是反素数...打表就行了。。。
但是问的是**恰好，**比如如果n为5，那么最小的x是16，但是x不是反素数。
所以其实就是个dfs啦。
理论依据是：
一个数 A 可以分解成 p1k1 * p2k2 * …… * pnkn 其中p为素数。这样分解之后，A的因子个数
S = （k1+1） *（ k2+1） * …… *（ kn+1）
以及要找的是一个最小的x，满足约数个数等于n。
那么关于反素数的两个性质依然是满足的：
（1）一个反素数的所有质因子必然是从2开始的连续若干个质数，因为反素数是保证约数个数为![](http://img.blog.csdn.net/20140505150741093) 的这个数![](http://img.blog.csdn.net/20140505145329656) 尽量小 （2）同样的道理，如果 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } 网站链接: /2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/http://img.blog.csdn.net/20140505151209203
链接到文件: /content/post/ACM-ICPC/http://img.blog.csdn.net/20140505151209203
使用 Page Bundles: true
，那么必有 Image not found a.warning-link { color: inherit !</description></item><item><title>hdu 2521 反素数</title><link>https://111qqz.com/2016/09/hdu-2521/</link><pubDate>Wed, 21 Sep 2016 08:27:48 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-2521/</guid><description>
题目链接
题意：求区间[a,b]中约数最多的那个数，如果有多个，输出最小的。
思路：看起来好像和反素数没什么关系...只是打个约数个数的表...
但是实际上，所有的答案恰好都是反素数。。。
我们回顾反素数的定义：设f(x)为x的约数个数，那么如果f(n)&amp;gt;f(i) (0&amp;lt;i&amp;lt;n),n就被称为反素数.
换句话说，对于所有f(x)==k的x组成的集合，最小的那个x就是反素数。
需要注意的是，因数个数并不单调。。因此上面那句话并不准确。。。
举个例子，16虽然有5个因子，是第一个有5个因子的数，但是16不是反素数，因为比16小的12有6个因子。
那么这个东西有什么用呢。。。。
我们发现。。。反素数的分布很稀疏。。。因此。。。可以直接打表。。。
一张反素数的表(一共167个)：
{1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2095133040,2205403200,2327925600,2793510720,3491888400,4655851200,5587021440,6983776800,10475665200,13967553600,20951330400,27935107200,41902660800,48886437600,64250746560,73329656400,80313433200,97772875200,128501493120,146659312800,160626866400,240940299600,293318625600,321253732800,481880599200,642507465600,963761198400,1124388064800,1606268664000,1686582097200,1927522396800,2248776129600,3212537328000,3373164194400,4497552259200,6746328388800,8995104518400,9316358251200,13492656777600,18632716502400,26985313555200,27949074753600,32607253879200,46581791256000,48910880818800,55898149507200,65214507758400,93163582512000,97821761637600,130429015516800,195643523275200,260858031033600,288807105787200,391287046550400,577614211574400,782574093100800,866421317361600,1010824870255200,1444035528936000,1516237305382800,1732842634723200,2021649740510400,2888071057872000,3032474610765600,4043299481020800,6064949221531200,8086598962041600,10108248702552000,12129898443062400,18194847664593600,20216497405104000,24259796886124800,30324746107656000,36389695329187200,48519593772249600,60649492215312000,72779390658374400,74801040398884800,106858629141264000,112201560598327200,149602080797769600,224403121196654400,299204161595539200,374005201994424000,448806242393308800,673209363589963200,748010403988848000,897612484786617600,1122015605983272000,1346418727179926400,1795224969573235200,2244031211966544000,2692837454359852800,3066842656354276800,4381203794791824000,4488062423933088000,6133685312708553600,8976124847866176000,9200527969062830400}​ 当然这道题数据小可以直接打因数个数的表...
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 04:00:39 PM CST File Name :code/hdu/2521.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5005; int num[N]; int factor( int n) { if (n==1) return 1; int res = 2 ; int mx = n; for ( int i = 2 ; i &amp;lt; mx ; i++) if (n%i==0) res = n/i==i?</description></item><item><title>反素数学习笔记</title><link>https://111qqz.com/2016/09/</link><pubDate>Wed, 21 Sep 2016 07:24:41 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
acdreamer的博客
wiki上的反素数是什么鬼orz...完全不是一个东西吧。。。。
反素数直观得理解。。。就是一个约数特别多的数。。。因为素数的约数最少。。。所以约数多的数就叫反素数（？随便口胡的...
由于1E18之前的反素数大概只有167个。。。所以打表可以很方便。。。
反素数是第一个约数“增长”到某个数的数，必须是“增长”，而不是第一个约数个数为某个数的数。
因为16是第一个约数个数为5的个数，但是16不是反素数，因为比16小的12有6的约数。。。
反素数的两个性质非常好用。。。
一个是反素数分解的质因子一定是连续的。。。
另一个是反素数分解的质因子的指数一定不增。。。
这两个性质都很显然。。。。证明没啥必要。。。
这两个性质可以用来dfs的时候剪枝。。。</description></item></channel></rss>