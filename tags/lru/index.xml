<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LRU on 111qqz的小窝</title><link>https://111qqz.com/tags/lru/</link><description>Recent content in LRU on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 18 Aug 2017 19:18:25 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/lru/index.xml" rel="self" type="application/rss+xml"/><item><title>leetcode 146. LRU Cache(list+unordered_map)</title><link>https://111qqz.com/2017/08/leetcode-146-lru-cache/</link><pubDate>Fri, 18 Aug 2017 19:18:25 +0000</pubDate><guid>https://111qqz.com/2017/08/leetcode-146-lru-cache/</guid><description>
&lt;p&gt;请实现最近最少使用缓存(Least Recently Used (LRU) cache)类,需要支持 get,
set,操作。
get 操作,给出 key,获取到相应的 value (value 为非负数),如果不存在返回-1,
如果存在此 key 算作被访问过。
set 操作,设置 key,如果 key 存在则覆盖之前的 value (此时相当于访问过一次)。
如果 key 不存在,需要进行插入操作,如果此时已经 key 的数量已经到达 capacity,
这样需要淘汰掉最近最少使用(也就是上次被使用的时间距离现在最久的)的那
一项。&lt;/p&gt;</description></item><item><title>缓存淘汰算法之LRU（转载）</title><link>https://111qqz.com/2017/03/lru/</link><pubDate>Wed, 15 Mar 2017 00:34:50 +0000</pubDate><guid>https://111qqz.com/2017/03/lru/</guid><description>
&lt;p&gt;&lt;a href="http://www.cnblogs.com/-OYK/archive/2012/12/05/2803317.html"&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计组块忘光了呜呜呜。。。来复习一波。。&lt;/p&gt;
&lt;h4 id="1lru"&gt;1. LRU&lt;/h4&gt;
&lt;p&gt;1.1. 原理&lt;/p&gt;
&lt;p&gt;LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。&lt;/p&gt;</description></item></channel></rss>