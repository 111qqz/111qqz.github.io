<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最短路 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/</link><description>Recent content in 最短路 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Mon, 18 Jul 2016 12:20:08 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>whust 2016 warm up E ||codeforces 689 B. Mike and Shortcuts (spfa)</title><link>https://111qqz.com/2016/07/cf689b/</link><pubDate>Mon, 18 Jul 2016 12:20:08 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689b/</guid><description>
cf689B题目链接
题意：n点。。点i到点j的代价是|i-j|..给出n条近路。。。a[i]表示点i到a[i]的代价为1（注意近路不一定就近）
思路：一开始建边卡了一下。。。实际上只要连相邻的就好了。。。然后边表只开了2N蠢哭。。。实际上应该3M...因为连相邻的边是双向的。。。再加上近路的单向。。。然后spfa就好了。。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 13时33分18秒 File Name :code/2016whust/F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int a[N]; bool inq[N]; int d[N]; int head[N]; int cnt; struct Edge { int v; int w; int nxt; }edge[8*N]; void addedge( int u,int v,int w) { edge[cnt].</description></item><item><title>hdu 3873 Invade the Mars (有限制条件的最短路。。)</title><link>https://111qqz.com/2016/07/hdu-3873/</link><pubDate>Thu, 14 Jul 2016 17:25:24 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-3873/</guid><description>
hdu3873题目链接
题意：n个点的图。。。每个点可能被若干其他点保护。。。被保护的意思是。。。如果想访问某个点。。那么必须先访问保护该点的所有点。。。问从点1到点n的最小代价。。
思路：。。一开始写了spfa。。。然后一脸懵逼。。。因为我第一次访问某个点的时候无法保证距离是最短的。。。所以还是上dij吧。。。
然后dij写得比较少。。。不是很熟练。。参考了这篇题解参考题解
思路倒是不难想，我在写spfa的时候也是这样想法，然后试图记录路径递归来搞。。。。。然而并不可以2333
也是第一次遇到带限制条件的最短路。。。还是多积累吧。。。
哦对了。。。权值比较大。。。要记得开long long
/* *********************************************** Author :111qqz Created Time :2016年07月15日 星期五 00时32分14秒 File Name :code/hdu/3873.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; long long ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E3+7; const int M=7E4+7; int n,m; int cnt; int head[N]; int in[N]; //in[i]表示点i被几个点保护。。。 vector &amp;lt;int&amp;gt;prec[N]; LL d[N]; bool vis[N]; LL maxt[N]; struct Edge { int v; LL w; int nxt; }edge[M]; void init() { ms(head,-1); ms(in,0); cnt = 0 ; for ( int i = 1 ; i &amp;lt;= n ; i++) prec[i].</description></item><item><title>BZOJ 1681: [Usaco2005 Mar]Checking an Alibi 不在场的证明 (spfa)</title><link>https://111qqz.com/2016/07/bzoj-1681-usaco2005-marchecking-an-alibi--spfa/</link><pubDate>Wed, 06 Jul 2016 13:18:30 +0000</pubDate><guid>https://111qqz.com/2016/07/bzoj-1681-usaco2005-marchecking-an-alibi--spfa/</guid><description>
1681: [Usaco2005 Mar]Checking an Alibi 不在场的证明 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 250 Solved: 178 [Submit][Status][Discuss]
Description A crime has been comitted: a load of grain has been taken from the barn by one of FJ's cows. FJ is trying to determine which of his C (1 &amp;lt;= C &amp;lt;= 100) cows is the culprit. Fortunately, a passing satellite took an image of his farm M (1 &amp;lt;= M &amp;lt;= 70000) seconds before the crime took place, giving the location of all of the cows.</description></item><item><title>BZOJ 1631: [Usaco2007 Feb]Cow Party (SPFA)</title><link>https://111qqz.com/2016/05/bzoj-1631/</link><pubDate>Sat, 21 May 2016 13:09:57 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj-1631/</guid><description>
1631: [Usaco2007 Feb]Cow Party Time Limit: 5 Sec Memory Limit: 64 MB Submit: 670 Solved: 493 [Submit][Status][Discuss]
Description  农场有N(1≤N≤1000)个牛棚，每个牛棚都有1只奶牛要参加在X牛棚举行的奶牛派对．共有M(1≤M≤100000)条单向路连接着牛棚，第i条踣需要Ti的时间来通过．牛们都很懒，所以不管是前去X牛棚参加派对还是返回住所，她们都采用了用时最少的路线．那么，用时最多的奶牛需要多少时间来回呢？
Input 第1行:三个用空格隔开的整数.
第2行到第M+1行,每行三个用空格隔开的整数:Ai, Bi,以及Ti.表示一条道路的起点,终点和需要花费的时间.
Output 唯一一行:一个整数: 所有参加聚会的奶牛中,需要花费总时间的最大值.
Sample Input 4 8 2 1 2 4 1 3 2 1 4 7 2 1 1 2 3 5 3 1 2 3 4 4 4 2 3
Sample Output 10
HINT 样例说明: 共有4只奶牛参加聚会,有8条路,聚会位于第2个农场. 第4只奶牛可以直接到聚会所在地(花费3时间),然后返程路线经过第1和第3个农场(花费7时间),总共10时间.
思路：想了一下。。因为要知道每个点到x的最短距离。。。以及反过来。。
单向很容易知道。。。以x点为起点做一遍spfa,那么x到每个点的最短距离就知道了。。
那么反过来怎么办呢？
我的做法是反向建边再跑一遍spfa...
1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年04月04日 星期一 19时36分38秒 File Name :code/bzoj/1631.</description></item><item><title>codeforces #333 div 2 C. The Two Routes</title><link>https://111qqz.com/2015/12/cf602c/</link><pubDate>Tue, 22 Dec 2015 09:01:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf602c/</guid><description>
http://codeforces.com/problemset/problem/602/C 题意：给出n个城镇，m条双向铁路，对于任意不同的x,y，如果x,y之间没有铁路，那么一定有双向公路。train只能走铁路，bus只能走公路。现在一辆火车和一辆bus同时从1出发，要到达n，处于安全考虑，bus和火车不能同时处在除了n以外的点。bus和train不要求同时到达。任意一段道路的时间花费都是1小时。问最少需要多久使得bus和train都到达n。如果存在某个不能到达，那么输出-1. 思路：n才400.一开始打算先按照rail和road建两个图。这两个图互为补。然后在floyd的时候加以判断。但是马上就发现。。不能同时到达同伙一个点这个条件其实不会影响。。因为按照题意，一定存在一条1到n的路，不是公路就是铁路。那么就让有路的花费1的代价到n，然后剩下的求一个一到n的最短路即可。由于n才400.。最短路怎么搞都行。。我偷懒就用floyd了。
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 16时28分59秒 File Name :code/cf/#333/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E2+7; int n ,m; int road[N][N]; int rail[N][N]; int floyd() { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (rail[i][j]&amp;gt;rail[i][k]+rail[k][j]) rail[i][j] = rail[i][k] + rail[k][j]; if (rail[1][n]==inf) return -1; else return rail[1][n]; } int floyd2() { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i =1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ;j++) road[i][j] = min(road[i][j],road[i][k]+road[k][j]); if (road[1][n]==inf) return -1; else return road[1][n]; } void init() { // for ( int i = 0 ; i &amp;lt;= 400 ; i++) // for ( int j = 0 ; j &amp;lt;= 400 ; j ++) // { // rail[i][j] = 99999; // road[i][j]= 99999; // } ms(rail,0x3f); ms(road,0x3f); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item></channel></rss>