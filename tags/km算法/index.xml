<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KM算法 on 111qqz的小窝</title><link>https://111qqz.com/tags/km%E7%AE%97%E6%B3%95/</link><description>Recent content in KM算法 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 03 Jun 2016 09:26:47 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/km%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3315 My Brute （二分图最佳匹配,KM算法）</title><link>https://111qqz.com/2016/06/hdu-3315/</link><pubDate>Fri, 03 Jun 2016 09:26:47 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-3315/</guid><description>
hdu3315 题目链接
题意：两个人分别各有n个怪物。进行n场pk.每只怪物必须恰好进行一场pk.如果先手的第i只怪物赢，会获得v[i]的val,输会减少v[i]的val.给出两个人n只怪物的血量和攻击力。先手的初始战斗顺序为1,2,3..n（后手的战斗顺序一直都是1,2,3..n) 现在问能否通过调整顺序使得先手获得的val最大，如果这个val大于0，表示先手可以赢。如果可以赢，那么还要求调整后的顺序和原始顺序的相似度，并且使得相似度尽可能大（If there are multiple orders, you should choose the one whose order changes the least from the original one）
思路：先根据血量和攻击力，n*n的时间处理出每场战斗的输赢信息，然后结合v[i]，得到每两个怪物战斗的先手得到的val的值。
然后和hdu 1853类似，依然希望尽可能多的安排不改变。
我们的做法仍然是把w*N,然后钦定的w再+1
然后改变个数，由于存在负数。。。和hdu 1853的处理有区别。。。
想了一下。。。其实用link数组对照初始钦定顺序就好了啊。。。
1A.爽上天。。。
最近各种1A...？好开心。
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 15时46分12秒 File Name :code/hdu/3315.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int val[N]; int h[N],p[N],a[N],b[N]; int win[N][N]; int w[N][N]; int lx[N],ly[N]; bool visx[N],visy[N]; int link[N]; int slk[N]; int num; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= n ; v++) { if (visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0xc0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while(1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= n ; j++) if (!</description></item></channel></rss>