<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字符串 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><description>Recent content in 字符串 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 07 Feb 2016 11:27:57 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces #342 div 2 B. War of the Corporations</title><link>https://111qqz.com/2016/02/cf625b/</link><pubDate>Sun, 07 Feb 2016 11:27:57 +0000</pubDate><guid>https://111qqz.com/2016/02/cf625b/</guid><description>
http://codeforces.com/contest/625/problem/B 题意：给出两个字符串，问要替换掉多少个字符才能使得前者中不包含后者。 思路：直接搞...找到一个把收尾替换成‘#’,然后下次从该位置继续开始找，直到找不到。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 17时31分33秒 File Name :code/cf/#342/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string ori,tar; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10785 The Mad Numerologist</title><link>https://111qqz.com/2016/01/uva10785/</link><pubDate>Wed, 27 Jan 2016 14:13:44 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10785/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1726 题意：给出26个大写字母的权值，要求构造一个长度为n（n不超过210）的字符串。并且满足奇数位置只能放元音字母，偶数位置只能放辅音字母，且每个元音字母最多放21次，每个辅音字母最多放5次，要求构造的字符串的权值之和最小，在权值最小的前提下字典序最小。
思路：贪心。一开始错误得以为不是完整得不能交换（也就是不完整的字母只能放在最后，这是错误的）。但实际上只要每个字母的数量不变，那么就不影响权值。所以做法是，奇数位置偶数位置分别搞，先把构成字符串的字母按次存入，然后排序一下，输出即可。
/* *********************************************** Author :111qqz Created Time :2016年01月26日 星期二 15时10分28秒 File Name :code/uva/10785.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char a[30],b[30]; char oddans[210],evenans[210]; int n; void pre() { a[1]='A'; a[2]='U'; a[3]='E'; a[4]='O'; a[5]='I'; b[1]='J'; b[2]='S'; b[3]='B'; b[4]='K'; b[5]='T'; b[6]='C'; b[7]='L'; b[8]='D'; b[9]='M'; b[10]='V'; b[11]='N'; b[12]='W'; b[13]='F'; b[14]='X'; b[15]='G'; b[16]='P'; b[17]='Y'; b[18]='H'; b[19]='Q'; b[20]='Z'; b[21]='R'; } void solve () { int odd = (n+1)/2; int even = n/2; int vowa = odd/21; int vowr = odd; int cona = even/5; int conr = even%5; int cnt = 0 ; for ( int i = 1 ; i &amp;lt;= vowa ; i++) { for ( int j =1 ; j &amp;lt;=21 ; j++) { cnt++; oddans[cnt] = a[i]; } } for ( int i = 1 ; i &amp;lt;=vowr ; i++) { cnt++; oddans[cnt]=a[vowa+1]; } cnt = 0 ; for ( int i = 1 ; i &amp;lt;= cona ; i++) { for ( int j = 1 ; j &amp;lt;= 5 ; j++) { cnt++; evenans[cnt]=b[i]; } } for ( int i = 1 ; i &amp;lt;=conr ; i++) { cnt++; evenans[cnt]=b[cona+1]; } sort(oddans+1,oddans+odd+1); sort(evenans+1,evenans+even+1); for ( int i = 1 ;i &amp;lt;= n ; i++) { if (i%2==1) { printf(&amp;quot;%c&amp;quot;,oddans[i/2+1]); } else { printf(&amp;quot;%c&amp;quot;,evenans[i/2]); } } puts(&amp;quot;&amp;quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10194 Football (aka Soccer)</title><link>https://111qqz.com/2016/01/uva10194/</link><pubDate>Wed, 27 Jan 2016 11:57:42 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10194/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1135 题意：给出球队的名字和比赛的信息，得出stanging 思路：字符串处理。需要注意的是多组数据记得初始化多次，以及比较字典序的时候team name是大小写补敏感的。
/* *********************************************** Author :111qqz Created Time :2016年01月26日 星期二 15时47分36秒 File Name :code/uva/10194.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+5; string game[N]; map&amp;lt;string,int&amp;gt;TeamToId; struct Team { string nam; string lowname; int a,b,c,d,e,f,g,h,i; bool operator&amp;lt;(Team p)const { if (b&amp;gt;p.</description></item><item><title>uva 156 - Ananagrams</title><link>https://111qqz.com/2016/01/uva156/</link><pubDate>Mon, 25 Jan 2016 09:19:56 +0000</pubDate><guid>https://111qqz.com/2016/01/uva156/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=92 题意：给出一段文字，包含若干个单词，以'#'结束。按照字典序输出所有的ananagrams。所谓ananagram，是指经过任意的重排后，不能得到这段文字中的另一个单词（不区分大小写） 思路：首先是字符串的读入...可以整行读入然后用空格分隔单词。由于补区分大小写，所以要都转化成小写...但是输出的时候要输出原始，所以还记得保留一份。而且要能够通过新的找到原始的（我用了一个toori的map&amp;lt;string,string&amp;gt;来实现） 然后最关键的部分是如何判断两个单词经过重排是否能一样...
我的做法是构造一个hash函数...一个单词的hash值等于对应字母的顺序的平方和...效果还不错？
单词和hash值一一对应...最大也就9E5,可以存的下。然后统计每个hash值出现的次数。对于那些只出现一次的，就是我们要的答案。
还要注意的是输出要按照原始单词的字典序，而不是都变成小写以后的字典序。
所以找到之后可以先找到对应的原始单词存到set里，最后再输出。
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 14时26分38秒 File Name :code/uva/156.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=9E5+7; string str; int a[N]; map&amp;lt;string,int&amp;gt;mp; map&amp;lt;string,int&amp;gt;::iterator it; map&amp;lt;string,string&amp;gt;toori; struct node { string ori; string nw; }st[1005]; set&amp;lt;string&amp;gt;ans; set&amp;lt;string&amp;gt;::iterator it2; int main() { mp.</description></item><item><title>uva 409 - Excuses, Excuses!</title><link>https://111qqz.com/2016/01/uva409/</link><pubDate>Sun, 24 Jan 2016 12:14:35 +0000</pubDate><guid>https://111qqz.com/2016/01/uva409/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=350 题意：给出k个key word,e个借口...找出包含key word最多的借口，即为最坏的借口。匹配补区分大小写&amp;amp;&amp;amp;同一个key word算多次。 思路：需要注意的是因为不区分大小写，需要都转化成大写或者小写。。但是输出的时候要输出原始的。。所以要另外存一份。
/* *********************************************** Author :111qqz Created Time :2016年01月22日 星期五 17时58分02秒 File Name :code/uva/409.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string str[50]; int k,e; int num[50]; set&amp;lt;string&amp;gt;se; struct node { string exc; string ori; int num; bool operator&amp;lt;(node b)const { return num&amp;gt;b.</description></item><item><title>hdu 5611 || BC #69 div2 1002 Baby Ming and phone number</title><link>https://111qqz.com/2016/01/hdu5611/</link><pubDate>Sat, 23 Jan 2016 14:43:26 +0000</pubDate><guid>https://111qqz.com/2016/01/hdu5611/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5611 题意：给出n个电话号码（长度为11的字符串），满足特殊条件的价格为a，否则为b.特殊条件为最后5位数字一样，最后5位严格递增或者严格递减，最后8位是一个1980年1月一日到2016年12月31日的合法日期。问最后的价值。
思路：直接搞....结果死在cin了。。。原来3E6的cin就会TLE。。。。。q神说1E5有的也会tle.....
所以方案是，能不用cin就不要用cin...
如果要读string的话。。。一个解决办法是把数据流同步关掉（是叫这个名字吗。。）
std::ios::sync_with_stdio(false); 会快很多。。。
还有一个办法是先用scanf读 char[] 然后再转化？ 没试过== 哦哦还要注意要判闰年。 还有要开long long
/* *********************************************** Author :111qqz Created Time :2016年01月23日 星期六 18时58分10秒 File Name :code/bc/#69/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; string str; LL a,b; bool good1(string x) { int len = x.</description></item><item><title>uva 537 Artificial Intelligence?</title><link>https://111qqz.com/2016/01/uva537/</link><pubDate>Fri, 22 Jan 2016 07:14:34 +0000</pubDate><guid>https://111qqz.com/2016/01/uva537/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=478 题意：给出一段文字。。其中包含了 P,U,I（功率，电压，电流）中的两个。。求第三个。 思路：字符串处理。。第一次用vim复制整段代码。。命令模式下按v,然后光标扫过的区域都会选中，按y就就复制到剪贴板了。。 所以虽然代码写了300行但只有100行是需要写的。。200行复制改下就好== WA了两次。。一次是因为I写成了小写。。另一次是因为多组数据记得初始化多次。
/* *********************************************** Author :111qqz Created Time :2016年01月22日 星期五 03时25分16秒 File Name :code/uva/537.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string str; char cstr[20]; double i,p,u; int pu,pp; int pi; int pv,pw,pa; int beishu; string tmp; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10010 - Where's Waldorf?</title><link>https://111qqz.com/2016/01/uva-10010-wheres-waldorf/</link><pubDate>Thu, 21 Jan 2016 17:24:34 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-10010-wheres-waldorf/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=951 题意：给出一个由大小写字母组成的二维maze...给出k个询问。每个询问一个单词。问能否在maze中找到这个单词。不区分大小写。输出开头字母的坐标（从1开始）。如果有多组输出最上面的。如果还有多组，输出最左边的。数据保证至少有一组。 思路：直接找就好了。。。坑的地方是。。。格式。。数据组数之后会有一个空行。然后每两组读入数据之间会有一个空行。。输出的时候每两组数据之间也有一个空行。
我因为一直多输出了一个空行一直wa QAQ
=
/* *********************************************** Author :111qqz Created Time :2016年01月21日 星期四 14时52分51秒 File Name :code/uva/10010.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=80; int n,m; char maze[N][N]; string spa; int k; char target[100]; char nouse[55]; bool hang( int x,int y,char tar[]) { int len = strlen(tar); // cout&amp;lt;&amp;lt;&amp;quot;tar:&amp;quot;&amp;lt;&amp;lt;tar&amp;lt;&amp;lt;endl; if (y+len-1&amp;gt;=m) return false; int cnt = 0 ; for ( int j = y ; j &amp;lt; y+len; j++) { if (maze[x][j]!</description></item><item><title>uva 401 Palindromes</title><link>https://111qqz.com/2016/01/uva-401-palindromes/</link><pubDate>Wed, 20 Jan 2016 15:53:21 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-401-palindromes/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=96&amp;amp;page=show_problem&amp;amp;problem=342 题意：问一个字符串是不是回文串，是不是镜像串。镜像串的意思是。。从镜子里看还一样。。给定了一些存在镜像的字母和数字。。 思路：回文串的判断用c++的string要更容易一些。。直接reverse一下。。判断是否相等就行。。。然后需要注意的是。。如果某个字符补存在镜像那么一定不是镜像串
如果某个字符不存在镜像那么一定不是镜像串！
如果某个字符不存在镜像那么一定不是镜像串！
蠢哭惹好么。。。。
* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 16时00分57秒 File Name :code/uva/401.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string a,b; char tmp[1000005]; map&amp;lt;char,char&amp;gt;mp; void init() { mp.</description></item><item><title>uva 10420 - List of Conquests</title><link>https://111qqz.com/2016/01/uva10420/</link><pubDate>Wed, 20 Jan 2016 11:47:32 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10420/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1361 题意：给n个带空格的字符串，第一个单词是国家，统计每个国家的字符串的个数。 思路：getline函数。。。find函数。。。substr函数。。。map.....
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 19时26分09秒 File Name :code/uva/10420.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string str; int len; map&amp;lt;string,int&amp;gt;mp; map&amp;lt;string,int&amp;gt;::iterator it; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 612 A. The Text Splitting</title><link>https://111qqz.com/2015/12/cf612a/</link><pubDate>Sun, 27 Dec 2015 09:46:17 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612a/</guid><description>
http://codeforces.com/contest/612/problem/A 水题...直接枚举就好。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 22时58分26秒 File Name :code/cf/edu4/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,p,q; char st[N]; bool v[10005]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #327 B Rebranding</title><link>https://111qqz.com/2015/12/codeforces-327-b-rebranding/</link><pubDate>Fri, 04 Dec 2015 13:25:05 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-327-b-rebranding/</guid><description>
http://codeforces.com/contest/591/problem/B
题意：给定一个字符串。给出m组替换。对于某一组替换，给出x,y。将字符串中所有的字符x换成y，所有的字符y换成x. 字符串仅包含英文小写字母。
思路： 可以用一个char 到 char 的map 初始映射本身。。 然后进行m次修改。。需要注意的是，每一次修改要修改全部。。因为当进行完i次修改而要进行i+1次修改的时候。。value值为x的可能不止一个。。所以要从a到z都扫一遍。。
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 19时13分12秒 File Name :code/cf/#327/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char st[N]; int n,m; char x,y; map&amp;lt;char,char&amp;gt;mp; int main() { freopen(&amp;quot;code/in.</description></item><item><title>codeforces edu1 B Queries on a String</title><link>https://111qqz.com/2015/12/codeforces-edu1-b-queries-on-a-string/</link><pubDate>Fri, 04 Dec 2015 06:54:38 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-edu1-b-queries-on-a-string/</guid><description>
题意：给一个字符串（1E4），然后给m次操作（m&amp;lt;=300），每次操作是给定一个区间l,r，然后进行k次（k&amp;lt;=1E6）cyclic shift (rotation) 变换。
One operation of a cyclic shift (rotation) is equivalent to moving the last character to the position of the first character and shifting all other characters one position to the right. For example, if the string s is abacaba and the query is _l_1 = 3, _r_1 = 6, _k_1 = 1 then the answer is abbacaa. If after that we would process the query _l_2 = 1, _r_2 = 4, _k_2 = 2 then we would get the string baabcaa.</description></item><item><title>(BC 一周年)hdu 5311 Hidden String</title><link>https://111qqz.com/2015/07/hdu5311/</link><pubDate>Tue, 28 Jul 2015 14:22:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5311/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5311 题意：问能否从一个给定的字符串中拿出三个不相交的字串（原串可以有剩余），组成字符串“anniversary” 思路：暴力。
比赛的时候没做出来,sad 我发现我有一个问题,就是不敢跑暴力 有不少题其实正解就是暴力 或者有的题,暴力不是标解,但是绝对可A,可我就不敢写... 就觉得不会是这样.. 说到底还是不自信吧...
思路是枚举两个间隔点,将 string tar=&amp;quot;anniversary&amp;quot;分成三个不为空的部分 然后在给的字符串中按顺序查找这三部分 如果都能找到,直接YES 如果任何一种间隔的分段都无法YES 就NO...
妈蛋,if语句后面多写了个分号,调了半个多小时才发现(为啥总是这种傻逼错误....) 还有一点,因为是多组数据,而对于每组数据,将tar拆分的方法都是一样的,可以先预处理一下存到数组里.
1 2 #define yn hez111qqz 3 #define j1 cute111qqz 4 #define tm crazy111qqz 5 #define lr dying111qqz 6 using namespace std; 7 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 8 typedef long long LL; 9 typedef unsigned long long ULL; 10 const int N=1E2+5; 11 int d[N]; 12 int len; 13 string st,tar,s1,s2,s3; 14 bool flag; 15 16 void solve (string x,string y,string z) 17 { 18 int lx = x.</description></item></channel></rss>