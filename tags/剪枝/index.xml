<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>剪枝 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%89%AA%E6%9E%9D/</link><description>Recent content in 剪枝 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 27 May 2016 12:38:07 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%89%AA%E6%9E%9D/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3225 Flowers Placement （dfs+匈牙利算法剪枝，太神了）</title><link>https://111qqz.com/2016/05/hdu-3225/</link><pubDate>Fri, 27 May 2016 12:38:07 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-3225/</guid><description>
hdu 3225题目链接
题意：给出一个n*m的矩阵。每个格子有一个数。每行1..n必须每个出现一次。每列1..n每个数最多出现一次。现在要添加一行，并且补违反上述规则。问添加的方案中字典序第k小的方案。如果一共不足k种方案，那么输出-1.
思路：有点像八皇后。。。就是纯搜。。。不过n好大。。。这么搜会TLE...
想了半天也没思路。。。看了题解。。发现是用二分图匹配来剪枝。。
比较重要的一点是。。。
n个数的某种排列，可以看做是一个位置集合{1..n}和数字集合{1..n}的二分图最大匹配。
我们可以根据这个来剪枝。
具体做法：
**我们先求出一个完备匹配，然后搜索每个位置能够种的花，假设当前位k置种了花i,那么判断k+1--n位置能不能形成一个完备匹配（即能否种出满足条件的花），若能那么当前位置可以种该花，继续搜索，若不能这返回** 然后把一个false写了true.调了一个小时。。。。。。。。。。。。。。无语凝噎。
/* *********************************************** Author :111qqz Created Time :2016年05月27日 星期五 00时42分16秒 File Name :code/hdu/3225.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; bool lie[N][N]; bool hang[N]; int n,m,k; int cnt; //vector &amp;lt;int&amp;gt;ans[N]; //不用每个都存，只存第k个就好。。。前面的随便覆盖。。。 int cur[N]; int link[N],tmp[N]; bool vis[N]; bool g[N][N]; bool findgirl( int x,int limit) { if (x&amp;lt;=limit) return false;//找到的匹配位置一定要在当前的后面。 for ( int i = 1 ; i &amp;lt;= n ; i++) { if (g[x][i]&amp;amp;&amp;amp;!</description></item></channel></rss>