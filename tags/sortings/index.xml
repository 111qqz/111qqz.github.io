<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sortings on 111qqz's blog</title><link>https://111qqz.com/tags/sortings/</link><description>Recent content in sortings on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 31 Mar 2016 08:27:19 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/sortings/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces #346 div 2 B. Qualifying Contest (排序)</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-b-qualifying-contest-/</link><pubDate>Thu, 31 Mar 2016 08:27:19 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-b-qualifying-contest-/</guid><description>
题目链接 题意：给出选手个数n，下面n行每个选手的信息“名字 区域编号 分数”.保证每个区域至少两个选手。问每个区域能否唯一确定一支二人的队伍（尽可能选分数高的，当要选的人里有分数相同的则不能确定。 思路：排序啊。。。然后搞啊。。结果发现思路没缕清。。。在某一个区域中，决定是否能唯一确定队伍的是第二个人和第三个人的成绩，和第一个人无关。 特殊处理一个区域只有两个人参加的，这种情况肯定能唯一确定队伍。 妈蛋，这种傻逼题卡了一个小时。。。。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 16时00分23秒 File Name :code/cf/#346/BB.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int m; int cnt[N]; struct node { string nam; int s; bool operator &amp;lt;(node b)const { return s&amp;gt;b.</description></item><item><title>codeforces 137 C. History (sorting,贪心)</title><link>https://111qqz.com/2016/03/cf137c/</link><pubDate>Thu, 31 Mar 2016 05:33:39 +0000</pubDate><guid>https://111qqz.com/2016/03/cf137c/</guid><description>
题目链接 题意：给出n个时间的开始和截止时间，保证没有两个时间的开始或者截止时间相同，问有多少个时间被包含在其他事件中。即aj &amp;lt; ai and bi &amp;lt; bj.
思路：没有两个事件的时间相同很关键。 那么我们可以直接按照开始时间为关键字排序，然后结束时间取之前发生了的（可能还没发生完）时间的结束时间的最大值即可。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 13时23分21秒 File Name :code/cf/problem/137C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 612 D. The Union of k-Segments</title><link>https://111qqz.com/2015/12/cf612d/</link><pubDate>Sun, 27 Dec 2015 09:37:24 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612d/</guid><description>
http://codeforces.com/contest/612/problem/D
题意：给出n个线段信息，每个线段以l,r的形式给出。给定k。要求从作到右给出至少有k个线段覆盖的区间的信息。并使得区间数目尽可能少。
思路：很经典的一类问题...又想起了当年在tyvj上海洋兄给我的那个把线段比喻成公路，把两个端点比喻成收费站的比喻了。做法是把所有点的信息按照从小到大排序，并且记录点的类型信息，如果点相同，那么我们规定入口处的优先级高。用pair来搞的话。。可以把入口的type规定成-1，出口规定成1.然后从最左边的点开始扫，遇到-1的点厚度+1，遇到1的点厚度-1.当厚度为k的时候记录区间信息。
/* *********************************************** Author :111qqz Created Time :2015年12月26日 星期六 00时14分09秒 File Name :code/cf/edu4/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n ,k; vector&amp;lt; pi&amp;gt; v,ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item></channel></rss>