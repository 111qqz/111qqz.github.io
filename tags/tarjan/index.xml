<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tarjan on 111qqz的小窝</title><link>https://111qqz.com/tags/tarjan/</link><description>Recent content in Tarjan on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 12 Apr 2016 12:28:42 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/tarjan/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 2586 How far away ？ (tarjan算法求LCA模板题)</title><link>https://111qqz.com/2016/04/hdu2586/</link><pubDate>Tue, 12 Apr 2016 12:28:42 +0000</pubDate><guid>https://111qqz.com/2016/04/hdu2586/</guid><description>
题目链接 题意：一棵树，给出n-1个边权，然后q组查询，每组查询询问两个点之间的距离。 思路：
dfs跑出根到每个点的距离，设为dis[i] 那么u,v两点的距离就是ans = dis[u]+dis[v]-2*dis[lca(u,v)];
其中lca(u,v)为u,v的最近公共祖先。 这个式子是利用容斥，其实也很直观。。不理解的话画个图就好。
所以终点就是求两个点的LCA.
据说有好多种做法。今天学习了大概是最简单的一种？ 学习链接
//parent为并查集，FIND为并查集的查找操作 //QUERY为询问结点对集合 //TREE为基图有根树 Tarjan(u) visit[u] = true for each (u, v) in TREE if !visit[v] Tarjan(v) parent[v] = u for each (u, v) in QUERY if visit[v] ans(u, v) = FIND(v) 我的理解：其实本质就是利用并查集。。在访问一个点的子树的时候，这个点其所有子树的祖先。。。由于祖先的节点比较小，所以merge的时候要f[大]=小...
要注意Tarjan 算法是离线算法。
哦对了。。这题要扩展语句才能过，不然会RE...
&amp;lt;span style=&amp;quot;color: blue;&amp;quot;&amp;gt;#pragma comment(linker, &amp;quot;/STACK:1024000000,1024000000&amp;quot;) &amp;lt;/span&amp;gt; /* *********************************************** Author :111qqz Created Time :2016年04月12日 星期二 19时39分38秒 File Name :code/hdu/2586.cpp ************************************************ */ #pragma comment(linker, &amp;quot;/STACK:1024000000,1024000000&amp;quot;) #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 4E4+7; int n,q; vector &amp;lt; pi &amp;gt; edge[N]; vector &amp;lt; pi &amp;gt;query[N]; bool vis[N]; int f[N]; int ans[N]; int dis[N]; void init() { for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>codeforces 567 E President and Roads (优先队列＋迪杰斯特拉＋tarjan)</title><link>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</link><pubDate>Sun, 16 Aug 2015 19:26:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</guid><description>
题意是说，给定一个有向图，对于每一条边，问是否是s到t的最短路上一定会经过的边．
如果是就输出yes
如果不是，问能否通过减少这条边的权值（减少的权值就是修理费用），使得这条边成为新的最短路上的边．
对于一条边是否一定是最短路上的边，我们可以从s做一遍最短路，然后反响建边，从t再做一遍最短路．
得到两个d1,d2数组
如果一条边d1[u] + d2[v] + w(u, v) = 最短路，那这条边在最短路上的边．但是未必不能缺少．
我们还要判断这条边是否是不能缺少的．
不能缺少的意思是说，如果没有这条边，就不能构成最短路．
那么这条边一定是桥．
我们可以用tarjan算法求桥．
据说是水题，不过图论还没怎么刷，所以对我来说还是很有难度的．
只是基本懂了
下面的代码是我仿照其他人的代码写出来的....求不鄙视　＞＜
/************************************************************************* &amp;gt; File Name: code/cf/#314/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 03时09分39秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef pair&amp;lt;LL,LL&amp;gt; P; const int maxn = 200005; const LL mod1 = 1e9 + 7; const LL mod2 = 99999991; const LL inf = 1e15; struct Nod{ LL b,val,next,idx; void init(LL b,LL val,LL next,LL idx){ this-&amp;gt;b=b;this-&amp;gt;val=val;this-&amp;gt;next=next;this-&amp;gt;idx=idx; } }buf[2][maxn]; LL len[2],E[2][maxn]; LL n,m,s,t; LL dis[2][maxn],cnt[2][2][maxn],ans1[maxn],ans2[maxn]; priority_queue&amp;lt;P,vector&amp;lt;P&amp;gt;,greater&amp;lt;P&amp;gt; &amp;gt; q; void init() { memset(E,-1,sizeof(E)); memset(cnt,0,sizeof(cnt)); len[0] = len[1] = 0; } void add_edge(LL a,LL b,LL val,LL idx) { buf[0][len[0]].</description></item></channel></rss>