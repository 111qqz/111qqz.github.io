<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>连通性 on Clarity</title><link>https://111qqz.com/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/</link><description>Recent content in 连通性 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 13 Jul 2016 06:21:41 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 3310 Caterpillar (树的直径+并查集判环+dfs判断连通性)</title><link>https://111qqz.com/2016/07/poj-3310/</link><pubDate>Wed, 13 Jul 2016 06:21:41 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-3310/</guid><description>
poj3310 题目链接
题意：给出一个无向图。。。问是否满足。。联通，并且无环，并且能找到一条路径，图中所有的顶点要么在这条路径上，要么与这条路径上的顶点相邻。
思路：一个一个来。。。联通的话任意起点开始跑一遍dfs? 开一个bool数组标记走过的点。。最后扫一遍。。看是否有点没走过
环的话并查集就好。。
关键是第三个条件。。。根据题中题中的例子。。感觉如果存在这样的路径。。。那么这样的路径应该尽可能长？
于是想到求直径。。。然后在bfs的时候顺便记录路径。。。这样我就知道直径是哪些点。。。然后对于所有点。。判断是否在这条直径上或者与之相邻就好。。。
具体做法是。。。开了一个bool数组ok标记直径上的点。。。在存边的时候用一个to[]数组表示相连。。。to[u]=v,to[v]=u...
然后只要ok[i]或者ok[to[i]]满足其一就好。。。
又是1A，蛤蛤蛤蛤蛤，我好神啊（误
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 20时27分28秒 File Name :code/poj/3310.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int n,m; vector &amp;lt; int &amp;gt;edge[N]; int f[N]; bool vis[N]; bool die; int d[N]; int to[N]; int pre[N];//记录最长的路径。。。 int lst,beg; bool ok[N]; struct Edge { int u,v; }e[N]; void init() { ms(to,-1); ms(pre,-1); ms(vis,false); //for dfs ms(ok,false); for ( int i = 1 ; i &amp;lt;= n ; i++) f[i] = i; for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>bc #73 B || hdu 5631 Rikka with Graph （并查集判断无向图的连通性）</title><link>https://111qqz.com/2016/03/hdu5631/</link><pubDate>Fri, 04 Mar 2016 11:53:45 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5631/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5631 题意;给出一张n个点n+1（n&amp;lt;=100）条边的无向图，现在删除若干条边（至少一条边），问删完之后图依然联通的方案数。 思路：分析可知，由于只删边，不删点，n个点，最少需要n-1条边才能联通，所以最多删两条边。我们可以暴力枚举删除的两条边（或者一条边） O(n^2)的复杂度完全可以接受。剩下的问题就变成了每次删边之后判断图的连通性。 题解给出的是bfs。。。大概是bfs一遍，然后入队的点数是n就联通？ 或者dfs一遍也可以？ 也是标记过的点数是n就说明联通？ 但是看到排名考前的人都是用到了并查集来判断...比较巧妙。
具体做法是：先把所有的点孤立出来，然后开始添加边，每次union成功（就是添加了一条边）的时候计数器+1，n个点如果能合并n-1次，也就是添加了n-1条有效边（最多也只可能是n-1条，那么说明这n个点之间是联通的。
第一次这样用并查集...憋说话，用心感悟。
/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 21时11分19秒 File Name :code/hdu/5631.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int f[N]; bool ban[N]; pi edge[N]; void init() { ms(f,0); for ( int i = 0 ; i &amp;lt; N ; i++) f[i] = i; } int root ( int x) { if (f[x]!</description></item></channel></rss>