<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>树的直径 on 111qqz的小窝</title><link>http://example.org/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link><description>Recent content in 树的直径 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 28 Aug 2016 12:04:15 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 1383 Labyrinth (树的直径裸题)</title><link>http://example.org/2016/08/poj-1383/</link><pubDate>Sun, 28 Aug 2016 12:04:15 +0000</pubDate><guid>http://example.org/2016/08/poj-1383/</guid><description>poj 1383题目链接
题意：一个迷宫图，求最远两点的距离是多少，保证每两个点都是联通的。
思路：树的直径。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; char maze[N][N]; bool vis[N][N]; int ans; int n,m; struct Point { int x,y; int d; bool ok () { if (x&amp;lt;0||y&amp;lt;0||x&amp;gt;=n||y&amp;gt;=m) return false; if (maze[x][y]=='#') return false; if (vis[x][y]) return false; return true; } void out() { cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; } }S,lst; void bfs(Point S) { queue&amp;lt;Point&amp;gt;q; S.</description></item><item><title>hdu 4123 Bob’s Race (树的直径+尺取+rmq)(珍爱生命，远离log)</title><link>http://example.org/2016/07/hdu-4123/</link><pubDate>Sun, 17 Jul 2016 16:21:03 +0000</pubDate><guid>http://example.org/2016/07/hdu-4123/</guid><description>hdu 4123 题目链接
题意：一棵树，定义d[i]为点i到树上某点的最大距离。。。给出若干查询，每个查询一个x,问最多能有多少点满足这些点中，最大的d与最小的d的差小于等于x.要求这些点的编号必须是连续的。
思路：可以三遍bfs处理出所有点的d&amp;hellip;
由于不能排序。。。所以就是尺取+rmq&amp;hellip;.
然而神Tm TLE&amp;hellip;..
这复杂度还TLe&amp;hellip;
结果最后发现是。。。log运算的常数太大被卡。。。
所以做法是先预处理一下。。。嗯。。。。
珍爱生命，远离log! 珍爱生命，远离log! 珍爱生命，远离log! /* *********************************************** Author :111qqz Created Time :2016年07月17日 星期日 19时37分55秒 File Name :code/hdu/4123.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair #define log2 0.</description></item><item><title>POJ 1849 Two (树的直径)</title><link>http://example.org/2016/07/poj1849/</link><pubDate>Sun, 17 Jul 2016 11:33:09 +0000</pubDate><guid>http://example.org/2016/07/poj1849/</guid><description>题目链接
题意:一棵树。。然后初始两个推雪机在点s,问如何选择路径使得处理完所有边上的积雪所耗费的汽油最少（走过一条有雪的边和一条没雪的边耗费的汽油一样）
思路：很容易想到，我们应该尽可能不走已经被清理过雪了的边，因为这样很浪费。。。这样不难想到应该是和树的直径有关。但是初始的位置是给定的。。。怎么办？突然发现由于是给了两个推雪机。。所以其实相当于。。。只有一个推雪机&amp;amp;我们可以从任意位置开始推雪。。。第二个问题是。。。对于不在直径上的边。。我们怎么算cost?解决办法是读边的时候进行记录。。。然后求直径的时候记录路径。。。对于一条边。。。只要有一个点不在直径上。。。那么这条边的代价就是2倍。。。
1A蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年07月17日 星期日 19时04分49秒 File Name :code/poj/1849.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector &amp;lt; pi &amp;gt; edge[N]; int n,s; int lst; int beg; int d[N]; bool vis[N]; bool onpath[N]; int path[N]; int ans; struct Edge { int u,v,w; }e[N]; void init( int n) { for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>hdu 4607 Park Visit (树的直径，推公式)</title><link>http://example.org/2016/07/hdu-4607/</link><pubDate>Wed, 13 Jul 2016 07:00:27 +0000</pubDate><guid>http://example.org/2016/07/hdu-4607/</guid><description>hdu4607题目链接 题意：给出一棵树。。。边权都为1. m个查询。。每个查询给一个k,表示只访问k个点。。。问每次的最小路径和是多少。。。 思路：我们发现。。会使路径和变大的一个不利因素是折返。。也就是访问某景点后。。必须要回去才能继续前进。。这样的距离是2倍。。那为了使得路径和尽可能小。。我们就尽量不要访问这样的点。。。而不是这样的点一定在直径上。。。以及我们还发现。。。不在直径上的点。。 。。不管深度如何（深度的意思是说，与和该点最近的直径上的点的距离），距离的贡献是一样的。。都是2倍。。所以我们可以推出一个公式。。。如果树的直径是d,那么k&amp;lt;=d+1的时候，答案为k-1,否则答案为d+(k-d-1)*2。。。
因为bfs的时候忘记标记起点WA了一发蠢哭。。。。2A
/* *********************************************** Author :111qqz Created Time :2016年07月13日 星期三 14时33分29秒 File Name :code/poj/4607.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector&amp;lt; int &amp;gt;edge[N]; int n,m; int d[N]; int lst,beg; bool vis[N]; void bfs( int s) { ms(d,0); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 3310 Caterpillar (树的直径+并查集判环+dfs判断连通性)</title><link>http://example.org/2016/07/poj-3310/</link><pubDate>Wed, 13 Jul 2016 06:21:41 +0000</pubDate><guid>http://example.org/2016/07/poj-3310/</guid><description>poj3310 题目链接
题意：给出一个无向图。。。问是否满足。。联通，并且无环，并且能找到一条路径，图中所有的顶点要么在这条路径上，要么与这条路径上的顶点相邻。
思路：一个一个来。。。联通的话任意起点开始跑一遍dfs? 开一个bool数组标记走过的点。。最后扫一遍。。看是否有点没走过
环的话并查集就好。。
关键是第三个条件。。。根据题中题中的例子。。感觉如果存在这样的路径。。。那么这样的路径应该尽可能长？
于是想到求直径。。。然后在bfs的时候顺便记录路径。。。这样我就知道直径是哪些点。。。然后对于所有点。。判断是否在这条直径上或者与之相邻就好。。。
具体做法是。。。开了一个bool数组ok标记直径上的点。。。在存边的时候用一个to[]数组表示相连。。。to[u]=v,to[v]=u&amp;hellip;
然后只要ok[i]或者ok[to[i]]满足其一就好。。。
又是1A，蛤蛤蛤蛤蛤，我好神啊（误
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 20时27分28秒 File Name :code/poj/3310.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int n,m; vector &amp;lt; int &amp;gt;edge[N]; int f[N]; bool vis[N]; bool die; int d[N]; int to[N]; int pre[N];//记录最长的路径。。。 int lst,beg; bool ok[N]; struct Edge { int u,v; }e[N]; void init() { ms(to,-1); ms(pre,-1); ms(vis,false); //for dfs ms(ok,false); for ( int i = 1 ; i &amp;lt;= n ; i++) f[i] = i; for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>hdu 4514 湫湫系列故事——设计风景线 (无向图并查集判环+非联通图的最长路径)</title><link>http://example.org/2016/07/hdu4514/</link><pubDate>Tue, 12 Jul 2016 07:59:55 +0000</pubDate><guid>http://example.org/2016/07/hdu4514/</guid><description>hdu4514
题意：给出一个无向图。。问是否有环。。。有的话输出YES。。如果没有环的话。。输出最长路径。。
思路：无向图判环并查集就好。。。关于最长路径这里。。一开始以为就是树的直径。。。
但是需要注意的是。。。题目并没有保证图一定是联通的。。。所以gg了。。
也就是要在一个不联通的图中求最长路径。。。
没想出来。。搜了一下。。有树形dp的做法。。。有并查集的时候带权的做法。。。
不过感觉最容易想到的还是求多次直径的做法。。。
也就是。。每一个联通块求一次直径。。。取最大。。。
具体做的时候。。。加一个bool数组在bfs标记一下就好。。。
以及bfs的时候。。。由于我之后是要得到最大值。。。而图本身可能是不联通的。。所以要注意d数组初始化的问题。。。不能初始化成0x3f&amp;hellip;（这么说来即使联通也没必要初始化成0x3f。。。。)
还有一点，这道题数据量比较大。。。用vector存图会MLE &amp;hellip;
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 14时31分09秒 File Name :code/hdu/4514.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M=1E6+7; int n,m; int f[N]; int lst; int far; int cnt; bool cyc; struct Edge { int v,w; int nxt; }edge[M]; int d[N]; bool vis[N]; bool used[N]; int head[N]; int root ( int x) { if (x!</description></item><item><title>hdu 2196 Computer (树的直径||树形dp)</title><link>http://example.org/2016/07/hdu2196/</link><pubDate>Tue, 12 Jul 2016 06:02:39 +0000</pubDate><guid>http://example.org/2016/07/hdu2196/</guid><description>hdu2196
题意：给出一棵树。。。求距离每个点的最远距离是多少。。。
思路：最远距离什么的。。能想到树的直径。。。但是有什么关系呢？ 我们在求树的直径的时候。。。直径的两个端点是可以知道的。。。如果再从两个端点分别做两次bfs。。。每个点取两个距离的较大值就是答案。。。。？
1A.
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 13时29分49秒 File Name :code/hdu/2196.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; vector &amp;lt; pi &amp;gt;edge[N]; int d[N]; int ans[N]; bool vis[N]; int beg,lst; int far; void bfs( int s) { ms(d,0x3f); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 2631 Roads in the North (树的直径)</title><link>http://example.org/2016/07/poj2631/</link><pubDate>Tue, 12 Jul 2016 05:57:18 +0000</pubDate><guid>http://example.org/2016/07/poj2631/</guid><description>poj2631 题意：一棵树中求两个点的最远距离。。。 思路：就是求树的直径。。。裸体。。。。1A
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 13时03分39秒 File Name :code/poj/2631.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; vector &amp;lt; pi&amp;gt; edge[N]; int lst; int ans; int d[N]; bool vis[N]; void bfs( int s) { ms(d,0x3f); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 1985 Cow Marathon (树的直径模板题)</title><link>http://example.org/2016/07/poj1985/</link><pubDate>Tue, 12 Jul 2016 04:07:00 +0000</pubDate><guid>http://example.org/2016/07/poj1985/</guid><description>poj1985 题意：求树上两点的最长距离。。。也就是传说中的树的直径。。。
参考博客
实际写的时候，第一次bfs最后一个出队的点就是直径的一个端点。。。 好像错了。。。还是稳妥一点。。。最后扫一遍。。距离最远的一定是端点。。。 然后因为题目没有数据范围。。。？re多次orz。。。
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 11时26分41秒 File Name :code/poj/1985.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+5; int n,m; vector &amp;lt; pi &amp;gt;edge[N]; int d[N]; int lst; int ans; bool vis[N]; void bfs( int s) { ms(vis,false); ms(d,0x3f); queue&amp;lt;int&amp;gt;q; q.</description></item></channel></rss>