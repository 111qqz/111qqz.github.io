<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bitset优化 on 111qqz的小窝</title><link>http://example.org/tags/bitset%E4%BC%98%E5%8C%96/</link><description>Recent content in bitset优化 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 17 Nov 2016 02:29:19 +0000</lastBuildDate><atom:link href="http://example.org/tags/bitset%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>【叉姐的魔法训练第一课_初级魔法练习】poj 2443 Set Operation ( bitset加速)</title><link>http://example.org/2016/11/poj2443/</link><pubDate>Thu, 17 Nov 2016 02:29:19 +0000</pubDate><guid>http://example.org/2016/11/poj2443/</guid><description>poj 2443题目链接
题意：给出n个可重集&amp;hellip;以及集合中的元素。。。现在若干查询，每个查询给出一对数x,y，询问是否存在某个集合，同时拥有x,y两个元素（x,y可以相同）
思路：由于x,y最大时10000，容易想到对每一个元素开一个集合，记录这个元素出现的集合的标号，然后用 set_intersection 来做&amp;hellip;
就是询问的时候交一下两个集合，看是否为空，结果Tle了。。。
正解其实也是这个思路，不过用到了bitset加速一下。因为我求集合相交的时候，并不需要知道交了以后的结果，只需要知道是否为空，那么我们不妨用bitset
对每个元素开一个bitset,每个bitset上，第i位为1表示，该元素在第i个集中中出现了。
求相交的时候，只需要两个bitset 位与一下，然后看结果中是否有1出现就好了。
/* *********************************************** Author :111qqz Created Time :2016年11月17日 星期四 09时31分16秒 File Name :code/poj/2442.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; set&amp;lt;int&amp;gt;se[N]; bitset&amp;lt;1005&amp;gt;bse[N],tmp; set&amp;lt;int&amp;gt;myset; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5036 Explosion||2014 北京区域赛网络赛 (概率+bitset优化的状态压缩+floyd传递闭包)</title><link>http://example.org/2016/08/hdu-5036/</link><pubDate>Sun, 21 Aug 2016 11:18:49 +0000</pubDate><guid>http://example.org/2016/08/hdu-5036/</guid><description>题目链接
题意：有n扇门，n种钥匙，一一对应。每扇门打开后可能得到k把钥匙（k可能为0）。一扇门还可以用一颗炸弹炸开。现在问要开所有门，使用炸弹的期望个数。
思路：状态压缩。用一个二进制串表示每扇门能打开的门的信息，对应的位上为1表示能打开，为0表示不能打开。
状态是可以传递的。。
如果第i扇门能打开门k，那么能打开第i扇门的第j扇门也可以打开门k。
状态压缩以及传递的过程可以很容易用bitset来维护，这才是bitset的正确打开姿势相当于用floyd做了一个传递闭包。(floyd的有一层循环隐藏在了bitset中，复杂度没有改变，但是常数小)
最后对于期望的计算方法：统计能打开第i扇门的方案数计为cnt,这cnt的方案中，只有一种是用炸弹炸掉，因此用的炸弹数的期望数为1/cnt
由于期望的独立性，因此打开所有门所有的炸弹数的期望就是每个门的期望累加。
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 18时43分56秒 File Name :code/hdu/5036.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; bitset&amp;lt;N&amp;gt;b[N]; //b[i]表示第i扇门可以打开的门 int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2051 bitset (水)</title><link>http://example.org/2016/08/hdu-2051/</link><pubDate>Sun, 21 Aug 2016 08:32:08 +0000</pubDate><guid>http://example.org/2016/08/hdu-2051/</guid><description>题目链接
题意：把一个数n(n&amp;lt;1000)转化成二进制输出。。。
思路：。。。搜acm bitset 搜到这题。。。所以其实这并不是“bitset”优化的题。。。只是题目名字交这个了2333。
还是用bitset过掉了。。。不过不知道怎么处理高位0.。。
所以这是一次bitset的错误示范(逃
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 16时10分50秒 File Name :code/hdu/2051.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1};Explosion const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned long long n ; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>acm 奇技淫巧 bitset</title><link>http://example.org/2016/08/acm--bitset/</link><pubDate>Sun, 21 Aug 2016 07:39:56 +0000</pubDate><guid>http://example.org/2016/08/acm--bitset/</guid><description>1.定义与初始化 在定义 bitset 时，要明确 bitset 有多少位，这个位数是整形常量
(tips:如果长度和输入的数m有关，在做翻转操作以后再统计时候会多算，一个可以的做法是设置一个长度为m，所有位上都是1的位串，然后翻转之后先与一下。类似的技巧还有很多。)
（） bitsetb; //b 有 n 位，每位都是 0 bitsetb(u); //b 是 unsigned long 型 u 的一个副本 bitsetb(s); //b 是 string 对象 s 中含有的位串的副本，这个s 必须是位串，也就是二进制码串 bitsetb(s, pos, n); //b 是 s 中 从位置 pos 开始的 n 个位的副本
2.bitset 的操作 b.any() //b 中是否存在置为 1 的二进制位？ b.none() // 和b.any() 效果一样 b.count() //b 中不存在置为 1 的二进制位吗？
b.any() //b中存在置为1的二进制位吗？ b.size() //b 中置为 1 的二进制位的个数 b[pos] //访问 b 中在 pos 处二进制位 b.</description></item></channel></rss>