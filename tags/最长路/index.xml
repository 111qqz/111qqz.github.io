<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最长路 on 111qqz's blog</title><link>https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E8%B7%AF/</link><description>Recent content in 最长路 on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 24 May 2016 16:16:38 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E8%B7%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 1860 Currency Exchange (spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1860/</link><pubDate>Tue, 24 May 2016 16:16:38 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1860/</guid><description>
poj 1860 题目链接
题意：有n种货币，m个货币交易点，每个货币交易点只能是两种货币之间交换，给出两个方向的汇率和手续费。初始拥有数量v的货币s,问能否经过一些py交易，使得最后手里的货币s比v多。
思路：大概还是用spfa求最长路。。松弛那里需要注意一下算法。。。
1A。。。好爽啊。。。。。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 23时41分46秒 File Name :code/poj/1860.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n,m,s; double v; double d[N]; bool inq[N]; vector &amp;lt;pair&amp;lt;int,pair&amp;lt;double,double&amp;gt; &amp;gt; &amp;gt; edge[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>poj 1932 XYZZY (floyd传递闭包+spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1932/</link><pubDate>Tue, 24 May 2016 13:00:45 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1932/</guid><description>
poj1932题目链接
题意：初始在点1，有100点能量，然后每个点有一个能量值【-100,100】，经过某个点会加上这个点的能量值，问能否找到一条到点n且的路线，且路径任何点的能量值一直为正。一共不超过100个点。
思路：像样例中是直接联通，一路上的能量值都大于0，这是有解的一种情况。另一种是存在一个正环，可能一次路过后面的能量值不够，但是我们可以走多次啊。
因为要求每一步的能量值都大于0，那么我们可以初始化d[]数组为0，然后用spfa求最长路（只需要把那个三角形等式换个方向即可）
如果可以直接联通，也就是d[n]&amp;gt;0，那么有解。
还有可能是存在一个环（判断环的方法是用一个数组在spfa的时候统计每个点入队的次数，如果一个点的入队次数大于n，那么就存在环，且这个点在环中）
但是我们还要保证起点1和终点n是经过这个环的。
所以先跑一发floyd. 其实n才100也算给了提示吧，不用floyd的话没道理这么小的数据。。？
感觉这道题很棒，把spfa和floyd结合在了一起。
学到了判断环的方法，spfa求最长路的方法，复习了传递闭包。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 20时03分37秒 File Name :code/poj/1932.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; vector&amp;lt; int &amp;gt; edge[N]; int a[N]; bool conc[N][N]; int in[N]; //统计入队次数，大于n次表明有环。 bool inq[N]; int n; int d[N]; void floyd() //传递闭包 { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (conc[i][k]&amp;amp;&amp;amp;conc[k][j]) conc[i][j] = true; } bool spfa(int s) //spfa求最长路。 { ms(in,0); ms(d,0);//因为小于等于0就死，所以初始是0，这样更新的时候一定是正值才更新。 ms(inq,false); queue&amp;lt;int&amp;gt;q; q.</description></item></channel></rss>