<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>once_flag on 111qqz的小窝</title><link>https://111qqz.com/tags/once_flag/</link><description>Recent content in once_flag on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 20 Sep 2018 12:47:46 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/once_flag/index.xml" rel="self" type="application/rss+xml"/><item><title>std::call_once &amp;&amp; std::once_flag notes</title><link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link><pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate><guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid><description>
多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。
资源初始化一般遵循&amp;quot;lazy initialization&amp;quot;的原则，也就是在用到该资源最近的地方再初始化。
比较容易想到的办法是用std::mutex，将资源初始化的地方锁起来，如下:
1 std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; 2 std::mutex resource_mutex; 3 void foo() 4 { 5 std::unique_lock&amp;lt;std::mutex&amp;gt; lk(resource_mutex); 6 if(!resource_ptr) 7 { 8 resource_ptr.reset(new some_resource); 9 } 10 lk.unlock(); 11 resource_ptr-&amp;gt;do_something(); 12 } 13 这确实是一个办法。但是初始化时如果需要耗费比较多的时间，当有比较多的线程时，一个线程初始化时，其他线程会耗时间在不必要的等待上。
在c++11以后，我们可以使用std::once_flag和std::call_once来解决资源初始化时加锁的问题。比起显示调用std::mutex的好处是，资源消耗更少。
下面是两个例子:
1 std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; 2 std::once_flag resource_flag; 3 b 4 void init_resource() 5 { 6 resource_ptr.reset(new some_resource); 7 } 8 void foo() 9 { 10 std::call_once(resource_flag,init_resource); 11 resource_ptr-&amp;gt;do_something(); 12 } 13 14 15 16 17 class X 18 { 19 private: 20 connection_info connection_details; 21 connection_handle connection; 22 std::once_flag connection_init_flag; 23 void open_connection() 24 { 25 connection=connection_manager.</description></item></channel></rss>