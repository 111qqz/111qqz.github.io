<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>链式前向星 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</link><description>Recent content in 链式前向星 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 24 May 2016 11:36:07 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 1511 Invitation Cards (链式前向星存图+spfa)</title><link>https://111qqz.com/2016/05/poj-1511/</link><pubDate>Tue, 24 May 2016 11:36:07 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1511/</guid><description>
poj 1511 题目链接 题意：和那道奶牛的舞会类似，要求所有点到点1的距离和加上1点到所有点的距离和。 思路：正反存边建两次图，跑两次spfa. 然而用vector会TLE....所以去学习了新的建图方式。。。也就是链式前向星：链式前向星（边表）学习链接 也叫边表。
是一种几乎没有什么缺点的存图方式。。。？ 比起普通的前向星少了个排序。
哦，还有我发现貌似很多人把这个东西叫邻接表。。但是根据这里：几种建图方式
这个东西还是交边表或者链式前向星比较合适。。。？
/* *********************************************** Author :111qqz Created Time :2016年05月23日 星期一 20时31分19秒 File Name :code/poj/1511.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E7+7; LL d[N]; bool inq[N]; int n,m; struct Edge { int v,w; int nxt; }edge1[N],edge2[N]; //反向存一次 int head1[N],head2[N]; int cnt; void addedge(Edge *edge,int *head,int u,int v,int w) { edge[cnt].</description></item></channel></rss>