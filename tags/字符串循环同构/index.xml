<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字符串循环同构 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E5%90%8C%E6%9E%84/</link><description>Recent content in 字符串循环同构 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 12 Aug 2016 19:39:21 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E5%90%8C%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3374 String Problem (字符串的最小/大表示法+kmp)</title><link>https://111qqz.com/2016/08/hdu-3374/</link><pubDate>Fri, 12 Aug 2016 19:39:21 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3374/</guid><description>
hdu 3374 题目链接 题意：给出一个循环字符串，问最小表示出现的位置以及次数，最大表示出现的位置以及次数。 思路：之前只写过最小表示。。最大表示其实是一样的。。。把不等式方向变号即可。。。对于出现的次数。。。其实就等同于这个字符串是由几个子串组成。。。跑一遍kmp。。答案为len-nxt[len]，1A
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 03时22分47秒 File Name :code/hdu/3374.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; char s[N],tmp[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j +=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 2609 How many (字符串的最小表示法+set)</title><link>https://111qqz.com/2016/08/hdu-2609/</link><pubDate>Fri, 12 Aug 2016 19:07:37 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-2609/</guid><description>
hdu 2609 题目链接
题意：给出n个循环字符串，问有多少种。
思路：将每个字符串换成最小表示，然后set存一下即可。
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 02时44分21秒 File Name :code/hdu/2609.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; char s[N][105]; set&amp;lt;string&amp;gt;se; int minRep(char *s) { int n = strlen(s); int i = 0 ; int j = 1 ; int k = 0 ; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n] - s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 4162 Shape Number (字符串的最小表示法)</title><link>https://111qqz.com/2016/08/hdu-4162/</link><pubDate>Fri, 12 Aug 2016 18:42:04 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-4162/</guid><description>
hdu 4162
题意：给出一串代表8个方向的数字，求这串序列的一阶差分（the first difference）的字典序最小的表示。
思路：先做个变换，按照题意，第i位的一阶差分 s[i] = ((s[i+1]-s[i])+8)%8;
然后求出最小表示开始的位置。。输出即可。
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 02时17分45秒 File Name :code/poj/4162.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0 ; int j = 1; int k = 0 ; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>最小表示法学习笔记（同构问题+模板）</title><link>https://111qqz.com/2016/08/</link><pubDate>Fri, 12 Aug 2016 08:37:06 +0000</pubDate><guid>https://111qqz.com/2016/08/</guid><description>
首先放一波资料：叶子豪_最小表示法
周源_《浅谈最小表示法在字符串循环同构问题中的应用》 参考博客 对于字符串循环同构的最小表示法，其问题实质是求S串的一个位置，从这个位置开始循环输出S，得到的S’字典序最小。
一种朴素的方法是设计i,j两个指针。其中i指向最小表示的位置，j作为比较指针。
令i=0,j=1 如果S[i] S[j] i=j, j=i+1 如果S[i] S[j+k] i=j,j=i+1** _ 否则j++ **返回i** 注意到，朴素算法的缺陷在于斜体的情况下i指针的移动太少了。针对这一问题改进就得到了最小表示法的算法。最小表示法的算法思路是维护两个指针i,j。
令i=0,j=1 如果S[i] S[j] i=j, j=i+1 如果S[i] S[j+k] i=i+k ** 否则j++ **返回i****和j****的小者** 注意到上面两个算法唯一的区别是粗体的一行。这一行就把复杂度降到O(n)了。 值得一提的是，与KMP类似，最小表示法处理的是一个字符串S的性质，而不是看论文时给人感觉的处理两个字符串。 应用最小表示法判断两个字符串同构，只要将两个串的最小表示求出来，然后从最小表示开始比较。剩下的工作就不用多说了。
模板：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; const int N = 100000+10; char str[N]; int minimalRepresentation() { int n = strlen(str); int i = 0,j = 1, k = 0; while(i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;n &amp;amp;&amp;amp; k&amp;lt;n) { int t = str[(i+k)%n] - str[(j+k)%n] ; if(t == 0) k++; else { if(t&amp;gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k = 0; } } return i &amp;lt; j ?</description></item></channel></rss>