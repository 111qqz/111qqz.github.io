<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kmp on 111qqz的小窝</title><link>http://example.org/tags/kmp/</link><description>Recent content in kmp on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 13 Nov 2016 07:21:02 +0000</lastBuildDate><atom:link href="http://example.org/tags/kmp/index.xml" rel="self" type="application/rss+xml"/><item><title>【dp专题001】bzoj 1009: [HNOI2008]GT考试 (字符串上dp+kmp+矩阵加速线性递推式)</title><link>http://example.org/2016/11/bzoj-1009/</link><pubDate>Sun, 13 Nov 2016 07:21:02 +0000</pubDate><guid>http://example.org/2016/11/bzoj-1009/</guid><description>1009: [HNOI2008]GT考试 Time Limit: 1 Sec Memory Limit: 162 MB Submit: 3127 Solved: 1926 [Submit][Status][Discuss]
Description 　阿申准备报名参加GT考试，准考证号为N位数X1X2&amp;hellip;.Xn(0&amp;lt;=Xi&amp;lt;=9),他不希望准考证号上出现不吉利的数字。 他的不吉利数学A1A2&amp;hellip;Am(0&amp;lt;=Ai&amp;lt;=9)有M位，不出现是指X1X2&amp;hellip;Xn中没有恰好一段等于A1A2&amp;hellip;Am. A1和X1可以为 0
Input 　第一行输入N,M,K.接下来一行输入M位的数。 N&amp;lt;=10^9,M&amp;lt;=20,K&amp;lt;=1000
Output 　阿申想知道不出现不吉利数字的号码有多少种，输出模K取余的结果.
Sample Input 4 3 100 111
Sample Output 81
思路： 这次总算想对了状态表示：dp[i][j] 表示当前处理到第i位，最后j位与不吉利串相同的方案数。 然后此时考虑转移，也就是观察第i+1位。 根据第i+1位字符的不同，转移到的 位置也不相同。 从dp[i][j] 可以转移到dp[i+1][k]，这种转移表现为dp[i+1][k] += dp[i][j] (k取决于第i+1位字符) *我们可以用f[i+1][k]+=f[i][j]trans[j][k]，trans[j][k]表示串s后j位与不吉利串前j位相同， 添加一个字符后后k位与不吉利串前k位相同的方案数。
就是说中间的那一部式子可以化简成矩阵的形式。。因此整个递推式就成了矩阵乘法的形式。 tran数组可以用kmp预处理出来。 重点是注意体会在字符串上dp的思想。
/* *********************************************** Author :111qqz Created Time :2016年11月13日 星期日 13时54分33秒 File Name :code/bzoj/1009.</description></item><item><title>hdu 3374 String Problem (字符串的最小/大表示法+kmp)</title><link>http://example.org/2016/08/hdu-3374/</link><pubDate>Fri, 12 Aug 2016 19:39:21 +0000</pubDate><guid>http://example.org/2016/08/hdu-3374/</guid><description>hdu 3374 题目链接 题意：给出一个循环字符串，问最小表示出现的位置以及次数，最大表示出现的位置以及次数。 思路：之前只写过最小表示。。最大表示其实是一样的。。。把不等式方向变号即可。。。对于出现的次数。。。其实就等同于这个字符串是由几个子串组成。。。跑一遍kmp。。答案为len-nxt[len]，1A
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 03时22分47秒 File Name :code/hdu/3374.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; char s[N],tmp[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j +=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 4300 Clairewd’s message (kmp)</title><link>http://example.org/2016/08/hdu4300/</link><pubDate>Fri, 12 Aug 2016 07:34:47 +0000</pubDate><guid>http://example.org/2016/08/hdu4300/</guid><description>hdu 4300题目链接
吐槽：题意难懂的一逼，关键的地方根本没有说清好么。。。竟然还是多校题。。。。出题人英语是体育老师教的吧。。？本来挺傻逼一道题。。被这完全没有说清楚的题意搞得很不爽。。。
题意：给一个26个字母一一对应的密码表。
然后给出一个字符串，先是密文再是明文，明文可能不全。问最小的可能的密文+明文串是什么。。
思路：
把字符串按照密码表转化得到一个新的字符串，然后跑kmp得到原字符串a的后缀等于转化后的字符串b的前缀的最长长度的字符串。（需要注意的是,kmp匹配的时候，由于密文长度一定是大于等于明文的，并且如果字符串a和字符串b相等，匹配全部是没有意义的，所以我们从中间位置开始匹配，更具体的说，是从第一个后面的字符串的长度大于等于前面的字符串的长度的位置开始匹配）
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 13时55分42秒 File Name :code/hdu/4300.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N],b[N]; map&amp;lt;char,char&amp;gt;mp; char table[30]; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i] = ++ j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); getnxt(b); int i = 0; int j = 0; if (n%2==0) i = n/2; //明文可能残缺，因此密文长度大于等于明文，i要从一半往后开始，不然的话会匹配到自身 else i = n/2+1; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } if (i==n) return j; return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3336 Count the string （nxt函数的运用kmp+（dfs|dp )）</title><link>http://example.org/2016/08/hdu3336/</link><pubDate>Fri, 12 Aug 2016 05:33:08 +0000</pubDate><guid>http://example.org/2016/08/hdu3336/</guid><description>hdu 3336 题目链接
题意：给一个字符串，问这个字符串的所有前缀的出现次数的和。
思路：这道题需要完全理解nxt函数是干嘛的。。nxt[i]表示的是字符串的0..i-1位中，前缀和后缀相等的串的最长长度为nxt[i]
这东西对于这道题有什么用呢？
举个例子，对于字符串ababa：
s a b a b a i 0 1 2 3 4 5 next[i] -1 0 0 1 2 3
ans初始为len(因为长度为len的字符串有len个前缀，每个前缀至少出现一次) next[3] = 1，ans + 1 = 6，next[1] = 0 next[4] = 2，ans + 1 = 7，next[2] = 0 next[5] = 3，ans + 1 = 8，next[3] = 1，ans + 1 = 9
首先，我们不是很关心nxt[i]具体的值，只关心nxt[i]是否大于0.如果大于0，比如对于nxt[3]==1，说明字符串0..2位置中，存在一个后缀和前缀相等，因此答案+1.
其次，其实我们仍然关心nxt[i]具体的值，对于nxt[5]==3，具体对应的含义是有后缀“aba”和前缀“aba”相等
但是这就完了吗？因为nxt[3]仍然大于0，对应“aba&amp;quot;中有一个前缀”a“和后者”a“相等。。。你可能要问。。这个不是刚刚算过了吗。。。然而这里其实算的是字符串2..4的”aba&amp;quot;。
看到有人说这是dp&amp;hellip;不是很懂dp做法是什么鬼。。。忘记取模wa了一发。。智力-2.
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 12时59分12秒 File Name :code/hdu/3336.</description></item><item><title>hdu 2594 Simpsons’ Hidden Talent (kmp)</title><link>http://example.org/2016/08/hdu-2594/</link><pubDate>Thu, 11 Aug 2016 17:40:49 +0000</pubDate><guid>http://example.org/2016/08/hdu-2594/</guid><description>hdu 2594 题目链接
题意：given string s1,s2, find the longest prefix of s1 that is a suffix of s2.
思路：kmp。。。懒得说了。注意边界。
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 01时12分51秒 File Name :code/hdu/2594.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; char a[N],b[N]; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0; int j = 0; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } if (i==n) return j; return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 3746 Cyclic Nacklace (最小覆盖子串，kmp)</title><link>http://example.org/2016/08/hdu-3746/</link><pubDate>Thu, 11 Aug 2016 16:53:06 +0000</pubDate><guid>http://example.org/2016/08/hdu-3746/</guid><description>hdu 3746题目链接 题意：给定一个字符串，是一个环（首尾相连），问至少再添加多少个珠子才能使得整个串是循环的。。。
思路：一下子想到了最小覆盖子串的模型。。。我求出最小覆盖子串的长度（n-nxt[n]）。然后特判下最小覆盖子串的长度等于字符串长度的情况。。。试着叫了一发。。。竟然就A了2333.。。大概是所谓的题感吧（逃
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 00时41分19秒 File Name :code/hdu/3746.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N]; int n; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5763 || 2016 multi #4 1001 Another Meaning (kmp+dp)</title><link>http://example.org/2016/08/hdu-5763/</link><pubDate>Thu, 11 Aug 2016 15:41:57 +0000</pubDate><guid>http://example.org/2016/08/hdu-5763/</guid><description>hdu 5763 题目链接
题意：给定两个字符串A和B，每个出现在A中的B(可以overlap)都有两种含义，问A串一共可能有多少种含义。
思路：kmp+dp.
考虑dp[i]为前i个字符（也就是从开始长度为i，注意不是字符串的下标为i）的含义数。
我们考虑第i个字符对其他位置字符的贡献。
首先第i位的含义数可以无条件得转移到i+1位。也就是dp[i+1]+=dp[i];
此外，如果第i位是一个B串开始的位置，那么第i位对i+len2位就有贡献。也就是dp[i+len2]+=dp[i];
初始化dp[0]=1，其他为0.
剩下我们要做的就是处理出A串中的哪些位置是B串开始的位置。
kmp处理下就好，用一个布尔数组标记。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 11时07分24秒 File Name :code/hdu/5763.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD = 1E9+7; const int N=1E5+7; int nxt[N]; char a[N],b[N]; bool v[N]; int dp[N]; void getnxt(char *s) { int i = 0; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } void kmp( char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0 ; int j = 0 ; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) { v[i-m] = true;//长度为i的位置的下标是i-1,开始的位置是（i-1）+m+1,也就是i-m // cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; i-m:&amp;quot;&amp;lt;&amp;lt;i-m&amp;lt;&amp;lt;endl; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1867 A + B for you again （kmp，最短的字符串a+b）</title><link>http://example.org/2016/08/hdu-1867/</link><pubDate>Wed, 10 Aug 2016 22:03:19 +0000</pubDate><guid>http://example.org/2016/08/hdu-1867/</guid><description>hdu 1867 题意 题意：给两个字符串，将两个字符串首尾拼接之后得到一个长度最短的字符串，求这个最短的字符串（一个串的前缀可能是另一个串的后缀，这样的话只出现一次就行了）
思路：kmp。。注意和hdu 1841区分。那道题是只要得到一个串包含两个串即可。这道题是首尾拼接得到。
还要注意。。这道题要求了长度相同时按照字典序小的方法拼接。。。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 05时08分32秒 File Name :code/hdu/1867.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N],b[N]; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i] = ++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); int i = 0; int j = 0; getnxt(b); while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;m) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } if (i==n) //因为要保证，两个串是首尾拼接得到的，这样子必须是文本串的后缀和模式串的前缀相等。这是和hdu 1841的不同。 return j; return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1841 Find the Shortest Common Superstring (kmp)</title><link>http://example.org/2016/08/hdu1841/</link><pubDate>Wed, 10 Aug 2016 20:48:04 +0000</pubDate><guid>http://example.org/2016/08/hdu1841/</guid><description>hdu 1841题目链接 题意：给两个字符串，问包含这两个字符串的最小的字符串的长度（最小是因为，一个串的子串可能是另一个串的后缀，这样出现一次就可以了）
思路：其实这道题最关键的思想部分是和kmp没有关系的。。。
我们考虑最naive的匹配方式。
如果存在文本串的子串（之前写成了后缀，特此更正，不一定是首尾拼接，这是和hdu 1867的区别）等于模式串的前缀，那么这段子串或者后缀的长度为最后的j。
两个串各做一次模式串和文本串。
不过暴力匹配复杂度爆炸，所以用了kmp。。。
upd:代码新添加了注释。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 04时32分08秒 File Name :code/hdu/r1841.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n; char a[N],b[N]; int nxt[N]; void getnxt(char *s) { int i = 0; int j = -1; int n = strlen(s); nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0 ; int j = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;m) //由于不一定哪个是模式串，所以要记得判边界j&amp;lt;m,因为这个而wa了一发 { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; } return j; //这道题只要求得到一个串同时包含这两个字符串，不是首尾拼接也可以，所以不用判断文本串是否为后缀（i==n) return 0; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1358 Period (kmp，求字符串的周期)</title><link>http://example.org/2016/08/hdu-1358-period-kmp/</link><pubDate>Wed, 10 Aug 2016 19:41:13 +0000</pubDate><guid>http://example.org/2016/08/hdu-1358-period-kmp/</guid><description>hdu 1358 题目链接
题意：给一个字符串，求这个字符串的每个前缀（包括本身）的能否由k个子串组成（K&amp;gt;1）
思路：和poj 2406 比较类似。。
结论：字符编号从0开始，如果又i%(i-next[i])==0，则i前面的 串为一个轮回串，其中轮回子串出现i/(i-next[i])次。
证明类似之前最小覆盖中的，不断的等价交换，两两相等&amp;hellip;（这个证明在字符串这里总是遇到2333）
然而其实我。。。做的时候。。并没有想到去证明。。。而是打印出了nxt数组然后找规律求得2333.
之前一直觉得找规律不是什么拿的上台面的做法。。。但是今年打了几场多校。。尤其是电子科大的那场。。。我发现。。。其实有的题目的正解就是找规律，猜结论。。。
&amp;amp;nbs;
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 03时20分44秒 File Name :code/hdu/1358.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int nxt[N]; char a[N]; int n ; void getnxt( char *s) { int i = 0 ; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==a[j]) nxt[++i]=++j; else j = nxt[j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2087 剪花布条 (kmp，不允许重叠的匹配)</title><link>http://example.org/2016/08/hdu-2087/</link><pubDate>Wed, 10 Aug 2016 19:13:51 +0000</pubDate><guid>http://example.org/2016/08/hdu-2087/</guid><description>hdu 2087 题目链接
题意：问模式串在文本串中出现的次数，不允许重叠。
思路：kmp，关键在于不允许重叠。。。
其实只要每次找到的时候j=0一下就好咯。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 02时52分44秒 File Name :code/hdu/2087.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; char a[N],b[N]; int nxt[N]; void getnxt(char *s) { int i = 0; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp(char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0; int j = 0; int cnt = 0 ; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j=nxt[j]; if (j==m) { cnt++; j=0; //不允许重叠 } } return cnt; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1711 Number Sequence (kmp)</title><link>http://example.org/2016/08/hdu1711/</link><pubDate>Wed, 10 Aug 2016 18:52:00 +0000</pubDate><guid>http://example.org/2016/08/hdu1711/</guid><description>hdu 1711 题目链接
题意：给定两个数列，问第二个数列在第一个数列中出现的位置（第一个元素对应的位置）
思路：数列也可以看成字符串，然后左kmp，返回的答案是i+1-m。。。1A
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 02时30分23秒 File Name :code/hdu/1711.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; const int M=1E4+7; int a[N]; int b[M]; int nxt[M]; int n,m; void getnxt(int n) { int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||b[i]==b[j]) nxt[++i]=++j; else j = nxt[j]; } int kmp( int n,int m) { getnxt(m); int i = 0; int j = 0; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) return i+1-m; } return -1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3080 Blue Jeans (n个字符串的最长公共子串，暴力+kmp)</title><link>http://example.org/2016/08/poj-3080/</link><pubDate>Wed, 10 Aug 2016 17:54:27 +0000</pubDate><guid>http://example.org/2016/08/poj-3080/</guid><description>poj 3080 题目链接
题意：给出n个字符串（n&amp;lt;=10），字符串长度不超过70，问出现在全部n个字符串中的最长并且字典序最小的长度大于等于3的子串。
思路：数据范围很小。。。直接暴力枚举+kmp匹配一下。。。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 01时29分02秒 File Name :code/poj/3080.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=70; int nxt[N]; string dna[15]; int n ; void getnxt( string a) { int i = 0 ; int j = -1; int n = a.</description></item><item><title>poj 2185 Milking Grid (最小覆盖子矩形，kmp)</title><link>http://example.org/2016/08/poj-2185/</link><pubDate>Wed, 10 Aug 2016 16:54:11 +0000</pubDate><guid>http://example.org/2016/08/poj-2185/</guid><description>poj 2185 题目链接
题意：给出一个字符矩形，问一个面积最小的矩形，覆盖掉整个矩形。大概就是二维的最小覆盖子串。
思路：对于每一行做最小覆盖子串，然后求lcm，每一列也是如此。最后记得判断不能超过原有的n,m。
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 23时46分47秒 File Name :code/poj/2185.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char s[N][80]; int n,m; int nxt[N]; void getrownxt(int row,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[row][i]==s[row][j]) nxt[++i]=++j; else j = nxt[j]; } void getcolnxt(int col,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i][col]==s[j][col]) nxt[++i]=++j; else j = nxt[j]; } int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } int lcm(int a,int b) { return a/gcd(a,b)*b; //蒟蒻的自我修养 } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>KMP与最小覆盖子串</title><link>http://example.org/2016/08/kmp/</link><pubDate>Wed, 10 Aug 2016 16:28:58 +0000</pubDate><guid>http://example.org/2016/08/kmp/</guid><description>参考资料（本文大部分是参考这篇博客，附带一些证明步骤的解释） 首先明确一些概念： 最小覆盖子串：对于某个字符串s，它的最小覆盖子串指的是长度最小的子串p，p满足通过自身的多次连接得到q，最后能够使s成为q的子串。 比如： 对于s=&amp;ldquo;abcab&amp;rdquo;，它的最小覆盖子串p=&amp;ldquo;abc&amp;rdquo;，因为p通过在它后面再接上一个p（即重叠0个字符），可以得到q=&amp;ldquo;abcabc&amp;rdquo;，此时s是q的子串。 对于s=&amp;ldquo;ababab&amp;rdquo;，它的最小覆盖子串为p=&amp;ldquo;ab&amp;rdquo;。
pre[i]（或next[i]）的实质是串str[1..i]的最长且小于i的“相等前、后缀”分别为str[1..pre[i]]（前缀）与str[(i-pre[i]+1)..i]（后缀），通俗讲就是：使str[1..i]前k个字母与后k个字母相等的最大k值。
结论先行：最小覆盖子串（串尾多一小段时，用前缀覆盖）长度为n-next[n]（n-pre[n]），其中n为串长，串的最后一位为为s[n-1].
证明分两部分：
１－长为n-next[n]的前缀必为覆盖子串。
当next[n]&amp;lt;n-next[n]时，如图a，长为next[n]的前缀A与长为next[n]的后缀B相等，故长为n-next[n]的前缀C必覆盖后缀B；
当next[n]&amp;gt;n-next[n]时，如图b，将原串X向后移n-next[n]个单位得到Y串，根据next的定义，知长为next[n]的后缀串A与长为前缀串B相等，X串中的长为n-next[n]的前缀C与Y串中的前缀D相等，而X串中的串E又与Y串中的D相等……可见X串中的长为n-next[n]的前缀C可覆盖全串（其实是一个不断的等价交换的过程，用同样的方法可以证明每两个相邻的相等，所以可以覆盖全串）
２－长为n-next[n]的前缀是最短的。
如图c，串A是长为n-next[n]的前缀，串B是长为next[n]的后缀，假设存在长度小于n-next[n]的前缀C能覆盖全串，则将原串X截去前面一段C，得到新串Ｙ，则Ｙ必与原串长度大于next[n]的前缀相等，与next数组的定义（使str[1..i]前k个字母与后k个字母相等的最大k值。）矛盾。得证！有人问，为什么Ｙ与原串长大于next[n]的前缀相等？由假设知原串的构成必为CCC……E（E为C的前缀），串Ｙ的构成必为CC……E（比原串少一个Ｃ），懂了吧！</description></item><item><title>poj 2752 Seek the Name, Seek the Fame (kmp 理解nxt函数)</title><link>http://example.org/2016/08/poj-2752/</link><pubDate>Wed, 10 Aug 2016 13:25:59 +0000</pubDate><guid>http://example.org/2016/08/poj-2752/</guid><description>poj 2752题目链接
题意：求出所有的前缀和后缀相同的子串的长度。
思路:求出nxt函数，观察发现，从从len递归向前就是答案。
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 21时05分52秒 File Name :code/poj/2752.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E6+7; int n; string a; int nxt[N]; void getnxt( int n) { int i = 0 ; int j = -1 ; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||a[i]==a[j]) nxt[++i]=++j; else j = nxt[j]; } void print( int x) { if (nxt[x]!</description></item><item><title>hdu 1686 Oulipo (kmp模板题)</title><link>http://example.org/2016/08/hdu1686/</link><pubDate>Wed, 10 Aug 2016 12:38:43 +0000</pubDate><guid>http://example.org/2016/08/hdu1686/</guid><description>hdu1686
题意：给出模式串和文本串，问模式串在文本串中出现了多少次，可以overlap.
思路：思考naive的匹配过程。nxt函数不过是改进了当失配发生时，不是移动1位，而是移动多位。nxt函数的含义是当失配发生时，移动到的位置&amp;hellip;.所以有的教程管这个叫失配函数吧，也不是很难理解的样子。
学会kmp之后的第一道kmp，嘿嘿嘿（是的，poj2406的时候我并不会kmp 2333)
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 20时02分33秒 File Name :code/hdu/1686.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; string a,b; int ans; int nxt[N]; void getnxt( int n) { int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||b[i]==b[j]) nxt[++i]=++j; else j = nxt[j]; } void kmp( int n,int m) { int i = 0 ; int j = 0 ; getnxt(m); // for ( int i = 0 ; i &amp;lt; m ; i++) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;nxt[i]&amp;lt;&amp;lt;endl; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) ans++,j=nxt[j]; // cout&amp;lt;&amp;lt;&amp;quot;n:&amp;quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&amp;quot; i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; j:&amp;quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>KMP算法学习</title><link>http://example.org/2016/08/kmp-notes/</link><pubDate>Mon, 08 Aug 2016 11:26:45 +0000</pubDate><guid>http://example.org/2016/08/kmp-notes/</guid><description>20170801update:当时竟然没有强调next函数的含义？
next[i]的含义是,i之前的整个前缀中，最长的该前缀的前缀和后缀相同的长度。
看图：
KMP感觉是我学到现在最难懂的一个算法了QAQ 为什么你们都那么强啊，看几个小时就看懂了&amp;hellip;
先放一波我觉得值得看的资料： kmp算法讲解（配图比较全&amp;hellip;.） kmp学习资料2
说下我对kmp算法的理解：
理解kmp算法大概分成两个部分。
一部分是理解一个naive的kmp算法，可以叫&amp;quot;fast slide&amp;quot; algorithm
思想大概就是，当mismatch发生时，我们并不是一无所有，而是知道在mismatch发生前所匹配的字符的信息的。
然后知道这些信息我们可以做什么呢？
先观察一下最最暴力的求解字符串匹配的算法：
//*********************************************************** //brute force n = T.length(); m = P.length(); i0 = 0; // Line P up with the first character of T i = 0; // Start matching with first char in T j = 0; // Start matching with first char in P while ( i &amp;lt; n ) // Not all characters used { if ( T[i] == P[j] ) { /* =============================================== T[i] and P[j] match ==&amp;gt; try next pair =============================================== */ i++; // Match next pair j++; if ( j == m ) return ( i0 ); // Match found at position i0 !</description></item><item><title>poj 2406 Power Strings (后缀数组||kmp)</title><link>http://example.org/2016/08/poj-2406/</link><pubDate>Tue, 02 Aug 2016 13:49:47 +0000</pubDate><guid>http://example.org/2016/08/poj-2406/</guid><description>poj 2406
题意:给定一个字符串 L,已知这个字符串是由某个字符串 S 重复 R 次而得到的, 求 R 的最大值
思路:论文题.
转载论文中的题解:
最关键的在加黑的那句话:看 suffix(1)和 suffix(k+1)的最长公共 前缀是否等于 n-k
why???
转载一段证明:
虽然这道题不适合用后缀数组做,倍增会tle,dc3也是卡时间才能过,但是接触到了一个想法.
要看一个字符串s能否由一个较小的长度为k的字符串t重复若干次得到,除了要整除以外,
gengxin判断suffix(1)和 suffix(k+1)的最长公共****前缀是否等于 n-k即可.
下面是用倍增写的tle了的代码,价值在于那段没有用rmq,而是o(n)更新height数组到height[rk[0]]之间的最小值要怎么写.
/* *********************************************** Author :111qqz Created Time :2016年08月02日 星期二 19时41分08秒 File Name :code/poj/2406.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; char s[N]; int cmp( int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa( int n,int m) { int *x=t; int *y=t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[i]=s[i]]++; for ( int i = 1; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i ; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n- k; i &amp;lt; n ; i++) y[p++] =i; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt;m ; i ++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1; i &amp;lt;n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item></channel></rss>