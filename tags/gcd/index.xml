<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gcd on Clarity</title><link>https://111qqz.com/tags/gcd/</link><description>Recent content in gcd on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Mon, 05 Sep 2016 13:42:23 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/gcd/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces 474 F. Ant colony (线段树求gcd+统计区间中某数出现的次数的经典做法)</title><link>https://111qqz.com/2016/09/cf474f/</link><pubDate>Mon, 05 Sep 2016 13:42:23 +0000</pubDate><guid>https://111qqz.com/2016/09/cf474f/</guid><description>
题目链接
题意：给出n个数，m个查询，每组查询一个区间[l,r]，问[l,r]中会被吃掉多少个（区间[l,r]中的数只有当其是其他所有数的因数时才不会被吃掉,顺便问一句。。a divide b 是 a除b,也就是b除以a,b/a的意思嘛23333）
思路：我们知道，不会被吃掉的数其实就是区间[l,r]中所有数的gcd,求gcd可以很容易用线段树办到。。。关键是还要统计该区间中等于gcd的数有多少个。
并不会做。
大概有两种做法。。。？
一种是基哥@clq11111说的，将询问离线，然后从小到大排序插入，询问区间中等于x转化成询问区间中小于等于x的，和询问区间中小于等于x-1的，做差即为所求。
第二种办法是题解的讨论区部分的：
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: https://111qqz.com/wordpress/wp-content/uploads/2016/09/Screenshot-from-2016-09-05-21-04-42.png
Disk path: /static/https://111qqz.com/wordpress/wp-content/uploads/2016/09/Screenshot-from-2016-09-05-21-04-42.png
Using Page Bundles: false
想了一下感觉很有道理。。。
这种做法是说：建一个val和该val对应下标的pair，然后排序（pair默认按照val第一关键字，pair第二关键字升序排）
排序之后，val相同的都在一起了，我们只需要找一段最大的区间，使得这段区间中的第二关键字在[l,r]范围内，然后这段区间的长度就是[l,r]区间中该数出现的次数.
找这段最大的区间，两次二分就好。说起来二分得到区间这个做法之前写过两次。。。之前都是手写的。。。这次用了STL。
具体写法参见代码
1A开心哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 08:37:57 PM CST File Name :code/cf/problem/474F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int tree[N&amp;lt;&amp;lt;2]; int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } void PushUp( int rt) { tree[rt] = gcd(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void build(int l,int r,int rt) { if (l==r) { tree[rt] = a[l].</description></item><item><title>codeforces 16 C. Monitor</title><link>https://111qqz.com/2015/12/codeforces-16-c-monitor/</link><pubDate>Tue, 29 Dec 2015 05:21:06 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-16-c-monitor/</guid><description>
http://codeforces.com/contest/16/problem/C 题意：给定长宽a,b和分辨率x:y,注意分辨率x:y未必是最简比。问将现有的size裁剪成比例为x:y，使得面积最大的长宽是多少。 思路：可以通过找 x,y能扩大的倍数为k，找到一个最大的k使得k*x&amp;lt;=a&amp;amp;&amp;amp;k;*y&amp;lt;=b。可以二分搞，但其实也可以不用。能扩大的最大的倍数其实就是 min(a/x,b/y). ps:收获了gcd更简单的一种写法。 直接 return b?gcd(b,a%b):a;
/* *********************************************** Author :111qqz Created Time :2015年12月28日 星期一 22时50分23秒 File Name :code/cf/problem/16C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,x,y; LL ax=0,ay=0; LL ans = -1; LL GCD; LL gcd(LL a,LL b) { if (a&amp;lt;b) return gcd(b,a); if (a%b==0) return b; return gcd(b,a%b); // return b?</description></item></channel></rss>