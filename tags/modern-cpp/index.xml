<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>modern cpp on 111qqz的小窝</title><link>https://111qqz.com/tags/modern-cpp/</link><description>Recent content in modern cpp on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 23 Sep 2018 08:42:33 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/modern-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>[C++11]std::condition_variable notes</title><link>https://111qqz.com/2018/09/condition_variable-notes/</link><pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate><guid>https://111qqz.com/2018/09/condition_variable-notes/</guid><description>
condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_variable，也就是条件变量，是线程间通信的一种方式。
线程之间在很多时候需要通信，比如经典的生产者消费者问题
一个比较naive的方案是，用mutex来保护一个flag,然后另一线程不停得check这个flag的状态是否改变。以及在这个方案上的改进:让另一个线程check之后，可以先睡一段时间。
但是这两种方法都不够好。第一种不好的原因当然是不停得check，肯定会耗费大量的资源。而第二种，由于没办法准确估计要休眠的时间，因此不够实际。
这个时候我们可以考虑使用条件变量。
条件变量是可以用在如下场景: 一个或者多个线程在等某个条件的成立，而这个条件由另外的线程所控制。当该条件成立时，控制该条件的线程会主动通知这些线程，将这些线程唤醒。
如下是一个最简单的例子:
std::mutex mut; std::queue&amp;lt;data_chunk&amp;gt; data_queue; // 1 std::condition_variable data_cond; void data_preparation_thread() { while(more_data_to_prepare()) { data_chunk const data=prepare_data(); std::lock_guard&amp;lt;std::mutex&amp;gt; lk(mut); data_queue.push(data); // 2 data_cond.notify_one(); // 3 } } void data_processing_thread() { while(true) { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(mut); // 4 data_cond.wait( lk,[]{return !data_queue.empty();}); // 5 data_chunk data=data_queue.front(); data_queue.pop(); lk.unlock(); // 6 process(data); if(is_last_chunk(data)) break; } } 接下来是一个较为复杂的例子，一个线程安全的队列的实现,
#include &amp;lt;queue&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;lt;mutex&amp;gt; #include &amp;lt;condition_variable&amp;gt; template&amp;lt;typename T&amp;gt; class threadsafe_queue { private: mutable std::mutex mut; // 1 互斥量必须是可变的 std::queue&amp;lt;T&amp;gt; data_queue; std::condition_variable data_cond; public: threadsafe_queue() {} threadsafe_queue(threadsafe_queue const&amp;amp; other) { std::lock_guard&amp;lt;std::mutex&amp;gt; lk(other.</description></item><item><title>std::call_once &amp;&amp; std::once_flag notes</title><link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link><pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate><guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid><description>
多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。
资源初始化一般遵循&amp;quot;lazy initialization&amp;quot;的原则，也就是在用到该资源最近的地方再初始化。
比较容易想到的办法是用std::mutex，将资源初始化的地方锁起来，如下:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::mutex resource_mutex; void foo() { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(resource_mutex); if(!resource_ptr) { resource_ptr.reset(new some_resource); } lk.unlock(); resource_ptr-&amp;gt;do_something(); } 这确实是一个办法。但是初始化时如果需要耗费比较多的时间，当有比较多的线程时，一个线程初始化时，其他线程会耗时间在不必要的等待上。
在c++11以后，我们可以使用std::once_flag和std::call_once来解决资源初始化时加锁的问题。比起显示调用std::mutex的好处是，资源消耗更少。
下面是两个例子:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::once_flag resource_flag; b void init_resource() { resource_ptr.reset(new some_resource); } void foo() { std::call_once(resource_flag,init_resource); resource_ptr-&amp;gt;do_something(); } class X { private: connection_info connection_details; connection_handle connection; std::once_flag connection_init_flag; void open_connection() { connection=connection_manager.open(connection_details); } public:62 C HAPTER 3 Sharing data between threads X(connection_info const&amp;amp; connection_details_): connection_details(connection_details_) {} void send_data(data_packet const&amp;amp; data) { std::call_once(connection_init_flag,&amp;amp;X::open_connection,this); connection.</description></item><item><title>[C++11] promise &amp;&amp; future leanrning notes</title><link>https://111qqz.com/2018/08/promise-future-notes/</link><pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate><guid>https://111qqz.com/2018/08/promise-future-notes/</guid><description>
用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程返回的某个结果），需要通过主线程中的promise object 得到对应的future object(每个promise 对应一个 future),然后调用future 的get方法。如果附属线程没有执行作为参数传入的promise的set方法去返回结果，那么程序就会block住。
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月23日 星期四 10时37分07秒 File Name :future_sample.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; #include &amp;lt;future&amp;gt; void initiazer(std::promise&amp;lt;int&amp;gt; * promObj) { //std::cout&amp;lt;&amp;lt;&amp;quot;Inside Thread&amp;quot;&amp;lt;&amp;lt;std::endl; for ( int i = 1 ; i &amp;lt;= 2000000000 ; i++); //promObj-&amp;gt;set_value(35); } int main() { std::promise&amp;lt;int&amp;gt; promiseObj; std::future&amp;lt;int&amp;gt; futureObj = promiseObj.get_future(); std::thread th(initiazer, &amp;amp;promiseObj); std::cout&amp;lt;&amp;lt;futureObj.get()&amp;lt;&amp;lt;std::endl; th.join(); return 0; } 参考资料:</description></item><item><title>c++11 function 与bind 学习笔记</title><link>https://111qqz.com/2018/07/cpp11-function-bind-notes/</link><pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate><guid>https://111qqz.com/2018/07/cpp11-function-bind-notes/</guid><description>
C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作
见下面的例子
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月19日 星期四 17时41分00秒 File Name :bind.cpp ************************************************ */ #include &amp;lt;functional&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; float foo( int x,int y,int z){return x+y+z+1.;} int main() { function&amp;lt;int(int,int)&amp;gt;func = foo; int y = 10; function&amp;lt;int(int)&amp;gt;fun = [&amp;amp;]( int value)-&amp;gt;int { return 1+value+y; }; cout&amp;lt;&amp;lt;func(15,4,9)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;fun(8)&amp;lt;&amp;lt;endl; return 0; } std::bind 则是用来绑定函数调用的参数的,它解决的需求是我们有时候可 能并不一定能够一次性获得调用某个函数的全部参数,通过这个函数,我们可以将 部分调用参数提前绑定到函数身上成为一个新的对象,然后在参数齐全后,完成调 用
看下面的例子:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;functional&amp;gt; using namespace std; int FUN( int x,int y,int z) { return x+y+z; } int main() { using namespace std::placeholders; //int (*fp)(int ,int,int) = FUN; auto bindfoo = bind(FUN,_1,1,2); int ans = bindfoo(0); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>C++ 记录代码运行时间</title><link>https://111qqz.com/2018/07/Record-code-run-time-with-cpp/</link><pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate><guid>https://111qqz.com/2018/07/Record-code-run-time-with-cpp/</guid><description>
以前用的办法太老土啦
看到一个since C++11的方法，我觉得比较优雅
#include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms = t2 - t1; // integral duration: requires duration_cast auto int_ms = std::chrono::duration_cast&amp;lt;std::chrono::milliseconds&amp;gt;(t2 - t1); // converting integral duration to integral duration of shorter divisible time unit: // no duration_cast needed std::chrono::duration&amp;lt;long, std::micro&amp;gt; int_usec = int_ms; std::cout &amp;lt;&amp;lt; &amp;quot;f() took &amp;quot; &amp;lt;&amp;lt; fp_ms.</description></item></channel></rss>