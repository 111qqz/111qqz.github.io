<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆序对 on 111qqz的小窝</title><link>http://example.org/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/</link><description>Recent content in 逆序对 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 20 Sep 2016 12:07:02 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)</title><link>http://example.org/2016/09/cf540e/</link><pubDate>Tue, 20 Sep 2016 12:07:02 +0000</pubDate><guid>http://example.org/2016/09/cf540e/</guid><description>题目链接
题意：一个无穷数列，从1开始，初始第i个位置上为i，给出n个swap，每次交换两个位置的数。问交换n次以后得到的数列中，逆序对的数。
思路：
官方题解：
2
2 6
4 8
The global sequence will look as follows: [1 6 3 8 5 2 7 4 9 &amp;hellip;], and here is the array of swapped elements: [6 8 2 4].
Let&amp;rsquo;s understand with which numbers the number 8 forms the inversions. The only elements that could do that are the elements between the initial position of the number 8 (where the number 4 is now) and its current position: [5 2 7].</description></item><item><title>codeforces 220 E. Little Elephant and Inversions (树状数组+尺取)</title><link>http://example.org/2016/09/cf220e/</link><pubDate>Thu, 15 Sep 2016 08:13:56 +0000</pubDate><guid>http://example.org/2016/09/cf220e/</guid><description>题目链接
题意：
how many pairs of integers l and r are there, such that 1 ≤ l &amp;lt; r ≤ n and sequence b = _a_1_a_2&amp;hellip; a__l__a__r__a__r + 1&amp;hellip; a__n has no more than k inversions.
我花了两个小时才看懂题。。。。一直没懂b数列中a[l]和a[r]怎么就挨着了。。。
其实意思是。。。只保留a数列中1..l和r..n的。。。构成b数列。。。然后b数列的逆序对数小于等于k.问这样的l,r的对数。
思路：尺取+树状数组。
枚举l,每次找到最小的满足题意的r，对答案的贡献是n-r+1,然后用两个树状数组，分别维护增加或者减少一个树的时候，前半段和后半段对逆序数的影响。
/* *********************************************** Author :111qqz Created Time :Wed 14 Sep 2016 04:23:06 PM CST File Name :code/cf/problem/220E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int tree[2][N]; int a[N],p[N]; int n; LL k; int lowbit( int x) { return x&amp;amp;(-x); } void update (int o, int x,int delta) { if (!</description></item><item><title>codeforces 61 E. Enemy is weak (离散化+线段树求逆序三元组)</title><link>http://example.org/2016/09/cf61e/</link><pubDate>Mon, 05 Sep 2016 08:35:49 +0000</pubDate><guid>http://example.org/2016/09/cf61e/</guid><description>题目链接 题意：给出n个数，求满足 i&amp;lt;j&amp;lt;k且a[i]&amp;gt;a[j]&amp;gt;a[k]的三元组有多少个。
思路：对于这种要求三个数满足条件的题目，老司机的经验是考虑中间那个数，这道题也不例外。
我们枚举j，通过求两次逆序对求出对于每个a[j]，满足a[i]&amp;gt;a[j]的i的个数，以及满足a[j]&amp;gt;a[k]的个数。
两个个数的乘积就是j作为中间数满足的三元组的个数，这样把所有的j累加就是答案。
其他的就是，要离散化，以及最后答案可能会爆long long?
1A，好爽啊哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 03:40:20 PM CST File Name :code/cf/problem/61E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int a[N]; int A[N]; int H[N]; int n; int m; int tree1[N&amp;lt;&amp;lt;2],tree2[N&amp;lt;&amp;lt;2]; pair&amp;lt;LL,LL&amp;gt;ans[N]; void PushUp(int rt,int *tree) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt,int *tree) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson,tree); else update(p,rson,tree); PushUp(rt,tree); } int query(int L,int R,int l,int r,int rt,int *tree) { // cout&amp;lt;&amp;lt;&amp;quot;L:&amp;quot;&amp;lt;&amp;lt;L&amp;lt;&amp;lt;&amp;quot; R:&amp;quot;&amp;lt;&amp;lt;R&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; if (L&amp;gt;R) return 0; if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0 ; if (L&amp;lt;=m) { int res = query(L,R,lson,tree); ret+=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson,tree); ret +=res; } return ret; } int Hash( int x) { return lower_bound(H,H+m,x)-H; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 459 D. Pashmak and Parmida's problem (离散化+线段树求逆序对数)</title><link>http://example.org/2016/09/cf459d/</link><pubDate>Mon, 05 Sep 2016 07:23:18 +0000</pubDate><guid>http://example.org/2016/09/cf459d/</guid><description>题目链接 题意：定义_f_(l, r, x)为区间[l,r]中x出现的次数。现在要求calculate the number of pairs of indicies i, j (1 ≤ i &amp;lt; j ≤ n) such that_f_(1, i, a__i) &amp;gt; f(j, n, a__j).
思路：可以通过o(n)预处理出f(1,i,a[i])和f[j,n,a[j]]，其实预处理的过程就是离散化的过程呢。。。
分别得到
1 1 2 3 2 3 4
4 3 3 2 2 1 1
所以答案其实就是第一组数在第二组数中找逆序数的过程。。。
我们不妨倒序处理。
需要注意的是，线段树维护的区间是0..mx，我整体增加了1.
线段树求逆序对和树状数组求逆序对是同样的思想。。。注意体会。。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 02:06:05 PM CST File Name :code/cf/problem/459D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; map&amp;lt;int,int&amp;gt;mp; int n ; int a[N],b[N]; int tmp[N]; int tree[N&amp;lt;&amp;lt;2];//tree[i]表示的是以i节点为根节点的子树所代表的区间中数的个数。 void PushUp( int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson); else update(p,rson); PushUp(rt); } int query(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0; if (L&amp;lt;=m) { int res = query(L,R,lson); ret +=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson); ret +=res; } return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1394 Minimum Inversion Number (树状数组 逆序对)</title><link>http://example.org/2015/10/hdu1394/</link><pubDate>Wed, 28 Oct 2015 14:00:00 +0000</pubDate><guid>http://example.org/2015/10/hdu1394/</guid><description>题目链接
题意：
这题是问一个长度为n的循环数组中，逆序对最少的个数。。。
我们可以先用树状数组求出初始的数列的逆序对。。。
然后其他的可以通过递推得到。。。。
当a[i]从处于位置1而被放到最后的时候。。。
cnt = cnt -a[i]+n-a[i]+1;
然后取所有cnt的最大值就行。
/************************************************************************* &amp;gt; File Name: code/hud/1394.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年10月28日 星期三 21时16分47秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) using namespace std; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E3+7; int c[N]; int n,a[N]; int lowbit( int x) { return x&amp;amp;(-x); } void update ( int x,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) c[i] = c[i] + delta; } int Sum( int x) { int res = 0 ; for ( int i = x ;i &amp;gt;= 1; i = i - lowbit(i)) { res = res + c[i]; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item></channel></rss>