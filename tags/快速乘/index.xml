<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>快速乘 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/</link><description>Recent content in 快速乘 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 30 Sep 2017 12:50:42 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/index.xml" rel="self" type="application/rss+xml"/><item><title>快速乘</title><link>https://111qqz.com/2017/09/fast-multiply-notes/</link><pubDate>Sat, 30 Sep 2017 12:50:42 +0000</pubDate><guid>https://111qqz.com/2017/09/fast-multiply-notes/</guid><description>
16年北京网络赛遇到了这个技巧...但是竟然忘记记了下来？
快速乘是为了解决 计算a_b % mod 时a_b溢出LL 的问题
比如a=1E16,b=1E16,mod=1E18，虽然最后的结果没有溢出，但是中间溢出了。
原理和快速幂很类似，具体可以参考 晴川大爷的专栏
ll fastMultiplication(ll a,ll b,ll mod){ ll ans = 0; while(b){ if(b%2==1){ b--; ans = ans + a; ans %= mod; }else{ b /= 2; a = a + a; a %= mod; } } return ans; } 完全就是把快速幂中的乘法变成加法了嘛（从记忆角度考虑orz
inline long long multi(long long x,long long y,long long mod) { long long tmp=(x*y-(long long)((long double)x/mod*y+1.0e-8)*mod); return tmp&amp;lt;0 ? tmp+mod : tmp; }</description></item></channel></rss>