<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>优先队列 on 111qqz的小窝</title><link>http://example.org/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link><description>Recent content in 优先队列 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 09 Oct 2017 06:01:23 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 4347 The Closest M Points (kd-tree+优先队列，求M近邻)</title><link>http://example.org/2017/10/hdu-4347/</link><pubDate>Mon, 09 Oct 2017 06:01:23 +0000</pubDate><guid>http://example.org/2017/10/hdu-4347/</guid><description>题目链接
题意： 给出若干个点，在给出一个定点，求距离该定点最近的m个点。
思路： 我们已经知道kd-tree可以得到最近邻，实际上M近邻，只需要维护一个size为M的优先队列就可以了。
需要注意，优先队列的元素一定要先定义小于关系orz
以及这次采用了轮盘转的策略划分维度，也就是按照深度，所有维度轮流作为split-method（实际用起来效果还是挺棒的orz
/* *********************************************** Author :111qqz Created Time :2017年10月08日 星期日 23时18分42秒 File Name :4347.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; const int M = 10; int n,m,k,t; int idx; struct Point { LL coor[M]; int id; void print() { for ( int i = 1 ; i &amp;lt;= k ; i++) printf(&amp;quot;%lld%c&amp;quot;,coor[i],i==k?</description></item><item><title>poj 3687 Labeling Balls</title><link>http://example.org/2015/12/poj3687/</link><pubDate>Sat, 19 Dec 2015 09:18:52 +0000</pubDate><guid>http://example.org/2015/12/poj3687/</guid><description>http://poj.org/problem?id=3687 题意：给定几个标签球的重量大小关系，求每个球是第几重的(即每个球在所有球的重量中由小到大排名是多少)。 （输出是每个球第几重，而不是几号球比几号球重！）。一开始理解错了QAQ 思路：反向拓扑+优先队列。因为正向不好用。。。所以我们连边的时候由重的指向轻的。。这样最先出队的就是最重的。。和上道题差不多？
/* *********************************************** Author :111qqz Created Time :2015年12月19日 星期六 16时32分59秒 File Name :code/poj/3687.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=203; int n,m; bool conc[N][N]; bool ok; int in[N]; int ans[N]; void topo() { priority_queue&amp;lt;int &amp;gt;q; for ( int i = 1 ; i &amp;lt;= n ; i++) if (in[i]==0) q.</description></item><item><title>hdoj 1285 确定比赛名次</title><link>http://example.org/2015/12/hdoj1285/</link><pubDate>Tue, 08 Dec 2015 13:06:06 +0000</pubDate><guid>http://example.org/2015/12/hdoj1285/</guid><description>http://acm.hdu.edu.cn/showproblem.php?pid=1285 题意：
有N个比赛队（1&amp;lt;=N&amp;lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。
Input
输入有若干组，每组中的第一行为二个数N（1&amp;lt;=N&amp;lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。
拓扑排序模板题。刷dfs的时候遇到的。干脆来学习下。
注意可能有重边。
由于要求输出顺序按照序号从小到达，所以这里用了优先队列。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 20时43分24秒 File Name :code/hdu/1285.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; int n,m; int in[N]; bool con[N][N]; priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt; &amp;gt; q; void toporder() { for ( int i = 1 ; i &amp;lt;= n ; i++) if (in[i]==0) q.</description></item><item><title>poj 3481 double queues</title><link>http://example.org/2015/07/poj3481/</link><pubDate>Fri, 03 Jul 2015 04:10:00 +0000</pubDate><guid>http://example.org/2015/07/poj3481/</guid><description>http://acm.hdu.edu.cn/showproblem.php?pid=1908
看到有两个优先级，然后题目中又有queue。。。就想到了优先队列。。。
但是优先队列的cmp函数没搞懂，因为比较的是结构体，好像要重载&amp;lt; 什么的。
然而并不会。
其实用map就可以做。。。
map在插入的时候可以自动按关键字排序，简直好评如潮！
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 15时44分06秒 File Name :3481.cpp ************************************************ */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; typedef long long LL; const int inf = 8E8; int cmd; map&amp;lt;int,int&amp;gt;a; int p,k; int main() { while (scanf(&amp;#34;%d&amp;#34;,&amp;amp;cmd)!=EOF&amp;amp;&amp;amp;cmd) { if (cmd==1) { scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;k,&amp;amp;p); a[p]=k; } if (cmd==2) { if (a.</description></item></channel></rss>