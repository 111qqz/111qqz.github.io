<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>number theory on 111qqz的小窝</title><link>https://111qqz.com/tags/number-theory/</link><description>Recent content in number theory on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 02 Apr 2017 06:26:02 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/number-theory/index.xml" rel="self" type="application/rss+xml"/><item><title>BZOJ 2257: [Jsoi2009]瓶子和燃料 (裴蜀定理)</title><link>https://111qqz.com/2017/04/bzoj-2257/</link><pubDate>Sun, 02 Apr 2017 06:26:02 +0000</pubDate><guid>https://111qqz.com/2017/04/bzoj-2257/</guid><description>
2257: [Jsoi2009]瓶子和燃料 Time Limit: 10 Sec Memory Limit: 128 MB Submit: 1246 Solved: 756 [Submit][Status][Discuss]
Description jyy就一直想着尽快回地球，可惜他飞船的燃料不够了。 有一天他又去向火星人要燃料，这次火星人答应了，要jyy用飞船上的瓶子来换。jyy 的飞船上共有 N个瓶子(1&amp;lt;=N&amp;lt;=1000) ，经过协商，火星人只要其中的K 个 。 jyy 将 K个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只 在瓶口标注了容量，第i个瓶子的容量为Vi（Vi 为整数，并且满足1&amp;lt;=Vi&amp;lt;=1000000000 ） 。 火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料 库里鼓捣一通，弄出一小点燃料来交差。jyy当然知道他们会来这一手，于是事先了解了火 星人鼓捣的具体内容。火星人在燃料库里只会做如下的3种操作：1、将某个瓶子装满燃料； 2、将某个瓶子中的燃料全部倒回燃料库；3、将燃料从瓶子a倒向瓶子b，直到瓶子b满 或者瓶子a空。燃料倾倒过程中的损耗可以忽略。火星人拿出的燃料，当然是这些操作能 得到的最小正体积。 jyy知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy希望找 到最优的瓶子组合，使得火星人给出尽量多的燃料。
Input 第1行：2个整数N,K， 第2..N 行：每行1个整数，第i+1 行的整数为Vi
Output 仅1行，一个整数，表示火星人给出燃料的最大值。
Sample Input 3 2 3 4 4
Sample Output 4
HINT 选择第2 个瓶子和第 个瓶子，火星人被迫会给出4 体积的容量。
思路:
思路完全错掉了orz...想去贪心来着....
因为自己脑算的例子错掉了...容量3和容量7的瓶子,能得到的最小是1不是2(因为忘了可以从瓶子中倒回燃料库的操作)...
样例一错毁所有orz..
正确的思路是,容量为a,b的两个瓶子能鼓捣出的体积一定是ax+by的形式
根据裴蜀定理,ax+by能得到的最小正数解就是(a,b),也就是gcd(a,b)
由此可以推广到多个瓶子,容量分别为x1,x2,...xn,能得到的最小体积就是gcd(x1,x2..xn)
(能推广的原因还是多说一句吧,假设现在只有两个瓶子x1,x2,称出了gcd(x1,x2),那么其实和只有一个容量为gcd(x1,x2)的瓶子在效果上是等价的)
因为剩下我们要做的就是,统计每个容量的因子统计,找到最大的并且出现此处大于等于k次的...</description></item><item><title>codeforces #382 div2 D. Taxes(哥德巴赫猜想)</title><link>https://111qqz.com/2016/11/cf375d-2/</link><pubDate>Tue, 29 Nov 2016 11:16:28 +0000</pubDate><guid>https://111qqz.com/2016/11/cf375d-2/</guid><description>
题目链接
题意：一个人有n元前，他要交的税是n的最大因子（除n外)，现在这个投机倒把者想把前分成k部分(k为大于等于１的任意值）每部分不能为１，分别交税，问最少交多少税。
思路：要说因子小。。很容易想到素数。。。然后就很容易想到了维基百科_哥德巴赫猜想
内容是：任何一个大于２的偶数可以写成两个素数的和。
（虽然是一个猜想没有被证明。。。但是1E9这种级别正确性还是很显然的２３３３
那么任何大于２的偶数，答案就是２
奇数可以分成一个３和一个偶数，答案为３．
不过这可能还不够优，这也是这道题的两个trick所在：
如果该数本身为素数，那么不用分（k取１），答案为１
如果该数减去２为素数，那么答案为２．
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 11时36分56秒 File Name :code/cf/#382/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; bool prime( LL x) { for ( LL i = 2 ; i*i &amp;lt;= x ; i++) { if (x%i==0) return false; } return true; } LL solve( LL x) { if (prime(x)) return 1; if (x%2==0) return 2; if (x%2==1) { if (prime(x-2)) return 2; else return 3; } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10692 Huge Mods (欧拉函数，指数循环节)</title><link>https://111qqz.com/2016/10/uva-10692/</link><pubDate>Wed, 26 Oct 2016 12:24:10 +0000</pubDate><guid>https://111qqz.com/2016/10/uva-10692/</guid><description>
题目链接
题意：求一个楼梯数%m的大小。
思路：指数循环节。
需要注意的是，模数只有最外层是m，每往里一层，模数都变成m=phi(m)
所以可以写个dfs或者先预处理出每一层m存一下。
记得考虑n=1的特殊情况。
/* *********************************************** Author :111qqz Created Time :Wed 26 Oct 2016 07:07:27 PM CST File Name :code/uva/10692.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char st[20]; LL n,m; LL a[15]; LL ksm( LL a,LL b,LL k) { LL res = 1; while (b&amp;gt;0) { if (b&amp;amp;1) res = (res * a )% k; b = b &amp;gt;&amp;gt; 1; a = ( a * a) % k; } return res; } LL euler( LL x) { LL ret = 1 ; for ( LL i = 2 ; i*i &amp;lt;= x ; i++) { if (x%i==0) { x/=i; ret*=(i-1); while (x%i==0) { x/=i; ret*=i; } } } if (x&amp;gt;1) ret*=(x-1); return ret; } LL phi[20]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4704 Sum (隔板法，指数循环节，费马小定理)</title><link>https://111qqz.com/2016/10/hdu-4704-sum-/</link><pubDate>Wed, 26 Oct 2016 10:42:21 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-4704-sum-/</guid><description>
题目链接
题意：定义s(k)为将n分成k个正整数的划分数，给出n，问s(1) + s(2) + ... + s(n-1) + s(n)是多少，结果9+7，其中n&amp;lt;=10^100000。
思路：首先化简要求的式子。
根据隔板法_维基百科
现在有10个球，要放进3个盒子里 ●●●●●●●●●● 隔2个板子，把10个球被隔开成3个部分
●|●|●●●●●●●●、●|●●|●●●●●●●、●|●●●|●●●●●●、●|●●●●|●●●●●、●|●●●●●|●●●●、●|●●●●●●|●●●、...... 如此类推，10个球放进3个盒子的方法总数为{ n个球放进k个盒子的方法总数为{ 问题等价于求{ 的可行解数，其中 为正整数。
于是问题转化成：
n个木棍，n-1个缝， 分成1份则是C(n-1,0);
分成2份则是C(n-1,1);
分成3份则是C(n-1,2);
...
分成n份则是C(n-1,n-1);
ans = sum( C(n-1,i) ) (0&amp;lt;=i&amp;lt;=n-1)
=2^(n-1);
这是我能理解的得到2^(n-1)的方式。。。
看到有好多人说这个结论是显然的。。。求指教（说这是个结论记住就好的就算了23333）
接下来，就是求A=2^(n-1)9+7的问题了。。。
根据指数循环节公式A=2^((n-1)%(mod-1))*2^(mod-1)%mod (其中mod=1E9+7)
由于gcd(2,1E9+7)=1,根据费马小定理2^(mod-1)%mod=1，因此A=2^((n-1)%(mod-1))
然后快速幂搞之。
/* *********************************************** Author :111qqz Created Time :Wed 26 Oct 2016 06:22:39 PM CST File Name :code/hdu/4704.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const LL mod = 1E9+7; char st[N]; int len; LL n; LL ksm(LL a,LL b) { LL res = 1LL; while (b&amp;gt;0) { if (b&amp;amp;1) res = (res * a) % mod; b = b &amp;gt;&amp;gt; 1LL; a = ( a*a ) % mod; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4549 M斐波那契数列 (矩阵快速幂+费马小定理+指数循环节)</title><link>https://111qqz.com/2016/10/hdu4549/</link><pubDate>Wed, 26 Oct 2016 09:12:43 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu4549/</guid><description>
题意：M斐波那契数列F[n]是一种整数数列，它的定义如下：
F[0] = a F[1] = b F[n] = F[n-1] * F[n-2] ( n &amp;gt; 1 )
现在给出a, b, n，你能求出F[n]的值吗？
思路：观察发现。。。F[n] = a^(fib(n-1)) * b ^ (fib(n))
此处要用到指数循环节的知识：
111qqz_指数循环节学习笔记
a^n ≡ a^(n % Phi(M) + Phi(M)) (mod M) (n &amp;gt;= Phi(M))
然后 因为1000000007是质数，对于任意的x,有gcd(x,1000000007) = 1，所以可以结合费马小定理化简上式：
a^n ≡ a^(n%(m-1)) * a^(m-1)≡ a^(n%(m-1)) (mod m)
记得特判一下n为0和1的情况。
xiaodingli
/* *********************************************** Author :111qqz Created Time :Wed 26 Oct 2016 09:16:22 AM CST File Name :code/hdu/4549.</description></item><item><title>指数循环节学习笔记</title><link>https://111qqz.com/2016/10/</link><pubDate>Wed, 26 Oct 2016 08:59:48 +0000</pubDate><guid>https://111qqz.com/2016/10/</guid><description>
资料先行：
指数循环节证明
指数循环节2
对指数循环节的一些理解
挂了一点题目，写完来写总结。
vjudge_不会指数循环节的111qqz
写完了。
首先要注意的是：
首先我们知道指数循环节公式，也就是所谓的降幂公式为：**a^x = a^(x mod phi(c)+phi(c)) (mod c) x=phi(c)，（ps:后面的限制条件，在x）** 括号里的话是错误的。当x&amp;lt;phi(c)时，该式子是错误的。
之前一直没出问题是因为数据水。
参考题目：hdu3221解题报告</description></item><item><title>poj 2891 Strange Way to Express Integers (扩展欧几里得算法解一般线性同余方程组)</title><link>https://111qqz.com/2016/10/poj-2891/</link><pubDate>Fri, 14 Oct 2016 19:16:55 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-2891/</guid><description>
题目链接
题意：给出k个方程，形式为 x==r1,求最小的正数x，无解输出-1.
思路：首先很容易让人联想到crt.
然而crt的使用条件是，所有的m(也就是这道题中的a)两两互质，这道题并不满足，因此不能使用crt.
X mod m1=r1 X mod m2=r2 ... ... ... X mod mn=rn 首先，我们看两个式子的情况 X mod m1=r1……………………………………………………………(1) X mod m2=r2……………………………………………………………(2) 则有 X=m1k1+r1………………………………………………………………() X=m2k2+r2 那么 m1k1+r1=m2k2+r2 整理，得 m1k1-m2*k2=r2-r1 令(a,b,x,y,m)=(m1,m2,k1,k2,r2-r1)，原式变成 ax+by=m 熟悉吧？此时，因为GCD(a,b)=1不一定成立，GCD(a,b) | m 也就不一定成立。所以应该先判 若 GCD(a,b) | m 不成立，则方程无解。（理论依据：裴蜀定理） 否则，继续往下。
解出(x,y)，将k1=x反代回（），得到X。 于是X就是这两个方程的一个特解，通解就是 X'=X+kLCM(m1,m2) 这个式子再一变形，得 X' mod LCM(m1,m2)=X 这个方程一出来，说明我们实现了(1)(2)两个方程的合并。 令 M=LCM(m1,m2)，R=r2-r1  （注意这里原博客写错了，应该为R=x*m1+r1） 就可将合并后的方程记为 X mod M = R。
然后，扩展到n个方程。 用合并后的方程再来和其他的方程按这样的方式进行合并，最后就能只剩下一个方程 X mod M=R，其中 M=LCM(m1,m2,...,mn)。 那么，X便是原模线性方程组的一个特解，通解为 X'=X+k*M。
如果，要得到X的最小正整数解，就还是原来那个方法：</description></item><item><title>poj 1006 Biorhythms (中国剩余定理模板题)</title><link>https://111qqz.com/2016/10/poj-1006-biorhythms-/</link><pubDate>Thu, 13 Oct 2016 12:39:27 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-1006-biorhythms-/</guid><description>
题目链接：
**题意：**人自出生起就有体力，情感和智力三个生理周期，分别为23，28和33天。一个周期内有一天为峰值，在这一
天，人在对应的方面（体力，情感或智力）表现最好。通常这三个周期的峰值不会是同一天。现在给出三个日
期，分别对应于体力，情感，智力出现峰值的日期。然后再给出一个起始日期，要求从这一天开始，算出最少
再过多少天后三个峰值同时出现。
思路：解一个线性同余方程。crt的模板题。
关于crt的讲解：中国剩余定理学习笔记
几年前就A过了，现在重新写题解复习一下。
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 08:00:04 PM CST File Name :code/poj/1006.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int p,e,i,d; int a[5],m[5]; void exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y) { if (b==0) { x = 1; y = 0; return; } exgcd(b,a%b,x,y); int tmp = x; x = y; y = tmp - a/b*y; } int crt(int a[],int m[],int n) { int M = 1; int ans = 0 ; for ( int i = 1 ; i &amp;lt;= n; i++) M*=m[i]; for ( int i = 1 ; i &amp;lt;= n ; i++) { int x,y; int Mi = M/m[i]; exgcd(Mi,m[i],x,y); ans = ( ans + Mi * x * a[i])%M; } if (ans&amp;lt;0) ans+=M; return ans; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2142 The Balance (扩展欧几里得算法)</title><link>https://111qqz.com/2016/10/poj-2142/</link><pubDate>Thu, 13 Oct 2016 11:34:08 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-2142/</guid><description>
题目链接
题意：给出a,b,d，分别表示a,b两种刻度的砝码，以及要称量的物体重量为d.现在保证能称量出给定重量的物体，问两种砝码个数的和最小的时候，两种砝码分别有多少。如果有多组解，那么要求weight of(ax + by) 最小。
思路：求特解直接扩展欧几里得...
关键是怎么找到绝对值和最小的。。
我就是两个方向跑了下。。。
一开始因为把weight of (ax+by) （求得还是绝对值最小）理解成了 ax+by最小。。导致WA了半天。。。。sigh....
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 04:23:13 PM CST File Name :code/poj/2142.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,d; LL exgcd( LL a,LL b,LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1; y = 0; return a; } LL ret = exgcd(b,a%b,x,y); LL tmp = x; x = y; y = tmp - a/b*y; return ret; } LL num ( LL x) { if (x&amp;lt;0) return -x; return x; } LL cal( LL x,LL y) { return a*num(x)+b*num(y); } bool ok( LL x,LL y,LL gx,LL gy) { if (num(x)+num(y)&amp;gt;num(x+gx)+num(y-gy)) return true; if (num(x)+num(y)==num(x+gx)+num(y-gy)&amp;amp;&amp;amp;cal(x,y)&amp;gt;cal(x+gx,y-gy)) return true; return false; } bool ok2( LL x,LL y,LL gx,LL gy) { if (num(x) + num(y) &amp;gt; num(x-gx) + num(y+gy)) return true; if (num(x) + num(y) ==num (x-gx) + num(y+gy)&amp;amp;&amp;amp;cal(x,y)&amp;gt;cal(x-gx,y+gy)) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2115 C Looooops (扩展欧几里得算法)</title><link>https://111qqz.com/2016/10/poj-2115-c-looooops-/</link><pubDate>Thu, 13 Oct 2016 08:11:17 +0000</pubDate><guid>https://111qqz.com/2016/10/poj-2115-c-looooops-/</guid><description>
题目链接
题意： 问 循环for ( int i = a ; i !=b; i+=c)在% （2^k）的意义下循环了多少次。
思路：
一般的思路是：
列方程...
化成扩展欧几里得算法的形式。。。
根据裴蜀定理判断解是否存在...
然后用对用扩展欧几里得算法求出的X,Y按照题目要求调整。
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 03:57:06 PM CST File Name :code/poj/2115.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL a,b,c,k; LL exgcd(LL a,LL b,LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1; y = 0; return a; } LL ret = exgcd(b,a%b,x,y); LL tmp = x; x = y; y = tmp - a/b*y; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2669 Romantic (扩展欧几里得模板题)</title><link>https://111qqz.com/2016/10/hdu-2669/</link><pubDate>Wed, 12 Oct 2016 12:30:21 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-2669/</guid><description>
题目链接
题意：问ax+by=1的一组x&amp;gt;0的解，如果无解输出sorry.
思路：根据裴蜀定理， ax+by=1有解当且gcd(a,b)=1。
然后根据扩展欧几里得算法，我们可以得到一组x,y。需要注意的是，这只是其中一组解。
x,y的通解为：**(x+kgx , y-kgy ） 其中：gx= b/gcd(a,b),gy = a/gcd(a,b),k为任意整数 **
/* *********************************************** Author :111qqz Created Time :Wed 12 Oct 2016 07:30:20 PM CST File Name :code/hdu/2669.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int exgcd( int a,int b,int &amp;amp;x,int &amp;amp;y) { if (b==0) { x = 1; y = 0; return a; } int ret = exgcd(b,a%b,x,y); int tmp = x; x = y; y = tmp - a/b*y; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>中国剩余定理(crt)学习笔记</title><link>https://111qqz.com/2016/10/crt/</link><pubDate>Tue, 11 Oct 2016 13:04:54 +0000</pubDate><guid>https://111qqz.com/2016/10/crt/</guid><description>
前置技能点：
维基百科_裴蜀定理（贝祖等式）
对任何[整数](https://zh.wikipedia.org/wiki/)![a](https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc) ， ![b](https://wikimedia.org/api/rest_v1/media/math/render/svg/f11423fbb2e967f986e36804a8ae4271734917c3) 和它们的[最大公约数](https://zh.wikipedia.org/wiki/)![d](https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab) ，关于未知数![x](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4) 和![y](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) 的[线性](https://zh.wikipedia.org/wiki/)[丢番图方程](https://zh.wikipedia.org/wiki/)（称为**裴蜀等式**）：![ax+by=m](https://wikimedia.org/api/rest_v1/media/math/render/svg/a3386cf2b30d74a8dc65ec168ef326cf2ece3de0) 有整数解时当且仅当_m_是_d_的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解 、 都称为裴蜀数，可用扩展欧几里得算法求得。
特别地，方程 有整数解当且仅当整数_a_和_b_互素。（kk:因为1(m=1)只可能是1(d=1)的倍数，也就是说gcd(a,b)=1，即a,b互质）
维基百科_扩展欧几里得算法
已知整数a、b，扩展欧几里得算法**可以在求得a、b的[最大公约数](https://zh.wikipedia.org/wiki/)的同时，能找到整数x、y**（其中一个很可能是负数），使它们满足[贝祖等式](https://zh.wikipedia.org/wiki/) ![ax + by = \gcd(a, b).](https://wikimedia.org/api/rest_v1/media/math/render/svg/72fe07a990a7ce59a499626f59b1ce588c8f6cda) 通常谈到[最大公约数](https://zh.wikipedia.org/wiki/)时，我们都会提到一个非常基本的事实：**给予二整数a、b，必存在有整数x、y使得ax + by = gcd(a,b)**[[1]](https://zh.wikipedia.org/wiki/#cite_note-1)。 有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。
例子：
求二元一次不定方程 的整数解。
* 47 = 30 * 1 + 17 * 30 = 17 * 1 + 13 * 17 = 13 * 1 + 4 * 13 = 4 * 3 + 1 然后把它们改写成“余数等于”的形式</description></item><item><title>二次剩余（Cipolla's algorithm）学习笔记</title><link>https://111qqz.com/2016/10/cipollas-algorithm/</link><pubDate>Mon, 10 Oct 2016 12:08:41 +0000</pubDate><guid>https://111qqz.com/2016/10/cipollas-algorithm/</guid><description>
先放资料。
前置技能点： 剩余系
剩余系**:设模为m,则根据余数可将所有的整数分成m类，分别记成[0],[1],[2],…[m-1]****，**
这m个数**{0,1,2,****…****m-1}**称为一个完全剩余系，
每个数称为相应类的代表元。
当m=10（偶数）时候，则{0,1,2,3,4,5,6,7,8,9}是最小非负完全剩余系
{-5,-4,-3,-2,-1,0,1,2,3,4,5} 是绝对值最小完全剩余系
{-4,-3,-2,-1,0,1,2,3,4,5} 绝对值最小
{1,2,3,4,5,6,7,8,9,10}是最小正完全剩余系
简化剩余系:在每个剩余类选取至1个与m互素代表元构成简化剩余系。
当m=10则,{0,1,2,3,4,5,6,7,8,9} 完全剩余系
{1,3,7,9}是简化剩余系(x,10)=1
当m=5则，{0,1,2,3,4}为完全剩余系,
{1,2,3,4}是简化剩余系，因为除去余0(正好是倍数)外，其它都互素。
f(m)=欧拉函数=|{t|0&amp;lt;t&amp;lt;m, (t, m)=1}|
=简化剩余系的元素个数
维基百科_高斯引理
设_p_为奇[质数](https://zh.wikipedia.org/wiki/)，_a_是一个与_p_[互质](https://zh.wikipedia.org/wiki/)的整数。考虑以下数组：![{\displaystyle a,2a,3a,\dots ,{\frac {p-1}{2}}a}](https://wikimedia.org/api/rest_v1/media/math/render/svg/82941c63fd5e49cf0b57612ee5e895d1e1c9096c) 以及它们对_p_的[最小非负剩余](https://zh.wikipedia.org/w/index.php?title=&amp;action=edit&amp;redlink=1)。这些剩余两两不等（**kk:这些剩余两两不等的证明：可以考虑反证，假设两个不同的数x,y对于p同余， 那么x-y和0关于p同余，而x-y同时关于a同余，a与p互质，矛盾。因此这些剩余两两不等**），因此我们共有![\frac{p-1}{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a733b8495b0d55ed5bc9d795b7b6821efb1d858b) 个两两不等的介于1和_p（_**kk:这里似乎有问题，如果剩余是在1..p之间，那么前面应该是说最小正剩余而不是最小非负剩余，最小非负剩余应该是在0..p-1之间**_）_之间的整数：![{\displaystyle t_{1},t_{2},t_{3},\dots ,t_{\frac {p-1}{2}}}](https://wikimedia.</description></item><item><title>bestcoder #88 || hdu 5908 Abelian Period(暴力)</title><link>https://111qqz.com/2016/10/hdu-5908/</link><pubDate>Sat, 01 Oct 2016 16:11:33 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-5908/</guid><description>
题目链接
题意：一段数字串，如果一个数字k满足，将该串分成若干个长度为K的子串，这些子串两两满足每个字符出现的次数一样多，那么称为k是一个阿贝尔周期。现在问所有合法的阿贝尔周期。
思路：
* 首先我们发现，所有的阿贝尔周期一定是数字串长度（设为n)的因数。 * 然后我们还发现。。。如果某个因子是阿贝尔周期，那么该因子的整数倍中恰好也是n的因子的也一定是阿贝尔周期，类似筛法。 * 然后我们还发现。。。最小的阿贝尔周期一定比数字串中的元素个数大。。。
然而其实后面两个不管也可以过吧。。。因为有点忘了n的约数个数的上界了。。。。
还是太保守了。。。
不过hack了四发哈哈哈。。。要是大号的话今天就紫了呜呜呜
/* *********************************************** Author :111qqz Created Time :2016年10月01日 星期六 18时58分00秒 File Name :code/bc/#88/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; vector &amp;lt;int&amp;gt;factor; int cnt[N]; set&amp;lt;int&amp;gt;se; bool vis[N]; int a[N]; set&amp;lt;int&amp;gt;ans; bool solve(int st,int en) { bool ret = true; for ( int i = st ; i &amp;lt;= en ; i++) { cnt[a[i]]--; if (cnt[a[i]]&amp;lt;0) ret = false; } for ( int i = st ; i &amp;lt;= en ; i++) cnt[a[i]]++; return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 594 D. REQ (树状数组+欧拉函数+逆元)</title><link>https://111qqz.com/2016/09/cf594d/</link><pubDate>Thu, 22 Sep 2016 07:48:00 +0000</pubDate><guid>https://111qqz.com/2016/09/cf594d/</guid><description>
题目链接
题意：给出n个数,q个查询，每组一个区间，询问区间中所有数的乘积的欧拉函数9+7的答案是多少。
思路：这道题需要一点欧拉函数的知识。
phi(n)是欧拉函数，意义为小于等于n并且与n互质的数的个数。
To calculate the answer on every query let's use the formula , where _p_1, p_2, ..., p__k — all prime numbers which divided_n.
如果知道欧拉函数的这个公式。。。那么这道题就成了水题。。。。
考虑两个数a,b的欧拉函数。
一开始考虑也许有什么性质。。。查了下欧拉函数的wiki 欧拉函数_维基百科 欧拉函数是积性函数（但不是完全积性函数。。因此必须phi(ab) =phi(a)*phi(b)成立当且仅当gcd(a,b)==1)
然而这里并不一定满足互质的条件。。。
再想一下。。。发现完全没必要由phi(a)和phi(b)得到phi(a*b)
直接把a*b看成一个数就好了。。。。
后面质因子乘积部分只需要把两部分的并在一起就好了。。。
所以根据上面欧拉函数的公式。。。答案分为两部分。。。
一部分是区间中所有数的乘积。。。
一部分是区间中所有数的不相同的素因子的p-1/p形式的乘积。。。
第一部分预处理前缀积即可。。。由于有%运算。。。所以除的时候需要计算逆元。。。
第二部分的做法同spoj_dquery解题报告
也是离线处理，把询问按照区间右端点排序升序排列，然后lst数组记录上次该数出现的位置。。。用bit维护一个从1到某个数的乘积。。。在撤销的时候同样需要逆元。。。
还要注意。。。太长的式子一定要分开写。。。。
因为写错括号顺序调了半天orz...
/* *********************************************** Author :111qqz Created Time :Thu 22 Sep 2016 02:07:39 PM CST File Name :code/cf/problem/594D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; const int M=1E6+7; const LL MOD = 1E9+7; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { return r&amp;lt;b.</description></item><item><title>bzoj 1053: [HAOI2007]反素数ant</title><link>https://111qqz.com/2016/09/bzoj-1053/</link><pubDate>Wed, 21 Sep 2016 12:31:01 +0000</pubDate><guid>https://111qqz.com/2016/09/bzoj-1053/</guid><description>
1053: [HAOI2007]反素数ant Time Limit: 10 Sec Memory Limit: 162 MB Submit: 2750 Solved: 1559 [Submit][Status][Discuss]
Description 　对于任何正整数x，其约数的个数记作g(x)。例如g(1)=1、g(6)=4。如果某个正整数x满足：g(x)&amp;gt;g(i) 0&amp;lt;i&amp;lt;x
，则称x为反质数。例如，整数1，2，4，6等都是反质数。现在给定一个数N，你能求出不超过N的最大的反质数么
？
Input 　一个数N（1&amp;lt;=N&amp;lt;=2,000,000,000）。
Output 　不超过N的最大的反质数。
Sample Input 1000
Sample Output 840
HINT Source 思路：dfs然后剪一下。。。和ural 1748同样的做法。。。。
还可以。。。打表。。。。
有表不打和咸鱼有什么区别呢
（oi赛制不可以带纸质材料，所以打表大概算是恶习...不过acm不一样啊orz。。。反素数表1..1E18也才167个。。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 08:15:41 PM CST File Name :code/bzoj/1053.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL anti_prime[]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2095133040,2205403200,2327925600,2793510720,3491888400,4655851200,5587021440,6983776800,10475665200,13967553600,20951330400,27935107200,41902660800,48886437600,64250746560,73329656400,80313433200,97772875200,128501493120,146659312800,160626866400,240940299600,293318625600,321253732800,481880599200,642507465600,963761198400,1124388064800,1606268664000,1686582097200,1927522396800,2248776129600,3212537328000,3373164194400,4497552259200,6746328388800,8995104518400,9316358251200,13492656777600,18632716502400,26985313555200,27949074753600,32607253879200,46581791256000,48910880818800,55898149507200,65214507758400,93163582512000,97821761637600,130429015516800,195643523275200,260858031033600,288807105787200,391287046550400,577614211574400,782574093100800,866421317361600,1010824870255200,1444035528936000,1516237305382800,1732842634723200,2021649740510400,2888071057872000,3032474610765600,4043299481020800,6064949221531200,8086598962041600,10108248702552000,12129898443062400,18194847664593600,20216497405104000,24259796886124800,30324746107656000,36389695329187200,48519593772249600,60649492215312000,72779390658374400,74801040398884800,106858629141264000,112201560598327200,149602080797769600,224403121196654400,299204161595539200,374005201994424000,448806242393308800,673209363589963200,748010403988848000,897612484786617600,1122015605983272000,1346418727179926400,1795224969573235200,2244031211966544000,2692837454359852800,3066842656354276800,4381203794791824000,4488062423933088000,6133685312708553600,8976124847866176000,9200527969062830400}; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 27 E. Number With The Given Amount Of Divisors (dfs，反素数（假）)</title><link>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</link><pubDate>Wed, 21 Sep 2016 09:02:26 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</guid><description>
题目链接
题意：求约数个数恰好为n个的最小的x
思路：这道题是作为反素数的例题出现在acdreamer的博客里的。
但是实际上，这道题应该和反素数没有关系。
如果题目问的是最小的约数个数大于等于n的x，那么答案一定是反素数...打表就行了。。。
但是问的是**恰好，**比如如果n为5，那么最小的x是16，但是x不是反素数。
所以其实就是个dfs啦。
理论依据是：
一个数 A 可以分解成 p1k1 * p2k2 * …… * pnkn 其中p为素数。这样分解之后，A的因子个数
S = （k1+1） *（ k2+1） * …… *（ kn+1）
以及要找的是一个最小的x，满足约数个数等于n。
那么关于反素数的两个性质依然是满足的：
（1）一个反素数的所有质因子必然是从2开始的连续若干个质数，因为反素数是保证约数个数为![](http://img.blog.csdn.net/20140505150741093) 的这个数![](http://img.blog.csdn.net/20140505145329656) 尽量小 （2）同样的道理，如果 ，那么必有 /* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 04:48:42 PM CST File Name :code/cf/problem/27E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47}; int n; LL ans = 1LL&amp;lt;&amp;lt;60; void dfs( int depth,LL val,int num) { if (num&amp;gt;n) return; if (num==n&amp;amp;&amp;amp;val&amp;lt;ans) ans = val; for ( int i = 1 ; i &amp;lt;=63 ; i++) //最多63个质数。。。因为2^64&amp;gt;1E18 { if (val*prime[depth]&amp;gt;ans) break; dfs(depth+1,val*=prime[depth],num*(i+1)); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2521 反素数</title><link>https://111qqz.com/2016/09/hdu-2521/</link><pubDate>Wed, 21 Sep 2016 08:27:48 +0000</pubDate><guid>https://111qqz.com/2016/09/hdu-2521/</guid><description>
题目链接
题意：求区间[a,b]中约数最多的那个数，如果有多个，输出最小的。
思路：看起来好像和反素数没什么关系...只是打个约数个数的表...
但是实际上，所有的答案恰好都是反素数。。。
我们回顾反素数的定义：设f(x)为x的约数个数，那么如果f(n)&amp;gt;f(i) (0&amp;lt;i&amp;lt;n),n就被称为反素数.
换句话说，对于所有f(x)==k的x组成的集合，最小的那个x就是反素数。
需要注意的是，因数个数并不单调。。因此上面那句话并不准确。。。
举个例子，16虽然有5个因子，是第一个有5个因子的数，但是16不是反素数，因为比16小的12有6个因子。
那么这个东西有什么用呢。。。。
我们发现。。。反素数的分布很稀疏。。。因此。。。可以直接打表。。。
一张反素数的表(一共167个)：
{1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2095133040,2205403200,2327925600,2793510720,3491888400,4655851200,5587021440,6983776800,10475665200,13967553600,20951330400,27935107200,41902660800,48886437600,64250746560,73329656400,80313433200,97772875200,128501493120,146659312800,160626866400,240940299600,293318625600,321253732800,481880599200,642507465600,963761198400,1124388064800,1606268664000,1686582097200,1927522396800,2248776129600,3212537328000,3373164194400,4497552259200,6746328388800,8995104518400,9316358251200,13492656777600,18632716502400,26985313555200,27949074753600,32607253879200,46581791256000,48910880818800,55898149507200,65214507758400,93163582512000,97821761637600,130429015516800,195643523275200,260858031033600,288807105787200,391287046550400,577614211574400,782574093100800,866421317361600,1010824870255200,1444035528936000,1516237305382800,1732842634723200,2021649740510400,2888071057872000,3032474610765600,4043299481020800,6064949221531200,8086598962041600,10108248702552000,12129898443062400,18194847664593600,20216497405104000,24259796886124800,30324746107656000,36389695329187200,48519593772249600,60649492215312000,72779390658374400,74801040398884800,106858629141264000,112201560598327200,149602080797769600,224403121196654400,299204161595539200,374005201994424000,448806242393308800,673209363589963200,748010403988848000,897612484786617600,1122015605983272000,1346418727179926400,1795224969573235200,2244031211966544000,2692837454359852800,3066842656354276800,4381203794791824000,4488062423933088000,6133685312708553600,8976124847866176000,9200527969062830400}​ 当然这道题数据小可以直接打因数个数的表...
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 04:00:39 PM CST File Name :code/hdu/2521.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5005; int num[N]; int factor( int n) { if (n==1) return 1; int res = 2 ; int mx = n; for ( int i = 2 ; i &amp;lt; mx ; i++) if (n%i==0) res = n/i==i?</description></item><item><title>反素数学习笔记</title><link>https://111qqz.com/2016/09/</link><pubDate>Wed, 21 Sep 2016 07:24:41 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
acdreamer的博客
wiki上的反素数是什么鬼orz...完全不是一个东西吧。。。。
反素数直观得理解。。。就是一个约数特别多的数。。。因为素数的约数最少。。。所以约数多的数就叫反素数（？随便口胡的...
由于1E18之前的反素数大概只有167个。。。所以打表可以很方便。。。
反素数是第一个约数“增长”到某个数的数，必须是“增长”，而不是第一个约数个数为某个数的数。
因为16是第一个约数个数为5的个数，但是16不是反素数，因为比16小的12有6的约数。。。
反素数的两个性质非常好用。。。
一个是反素数分解的质因子一定是连续的。。。
另一个是反素数分解的质因子的指数一定不增。。。
这两个性质都很显然。。。。证明没啥必要。。。
这两个性质可以用来dfs的时候剪枝。。。</description></item><item><title>codeforces 474 F. Ant colony (线段树求gcd+统计区间中某数出现的次数的经典做法)</title><link>https://111qqz.com/2016/09/cf474f/</link><pubDate>Mon, 05 Sep 2016 13:42:23 +0000</pubDate><guid>https://111qqz.com/2016/09/cf474f/</guid><description>
题目链接
题意：给出n个数，m个查询，每组查询一个区间[l,r]，问[l,r]中会被吃掉多少个（区间[l,r]中的数只有当其是其他所有数的因数时才不会被吃掉,顺便问一句。。a divide b 是 a除b,也就是b除以a,b/a的意思嘛23333）
思路：我们知道，不会被吃掉的数其实就是区间[l,r]中所有数的gcd,求gcd可以很容易用线段树办到。。。关键是还要统计该区间中等于gcd的数有多少个。
并不会做。
大概有两种做法。。。？
一种是基哥@clq11111说的，将询问离线，然后从小到大排序插入，询问区间中等于x转化成询问区间中小于等于x的，和询问区间中小于等于x-1的，做差即为所求。
第二种办法是题解的讨论区部分的：
想了一下感觉很有道理。。。
这种做法是说：建一个val和该val对应下标的pair，然后排序（pair默认按照val第一关键字，pair第二关键字升序排）
排序之后，val相同的都在一起了，我们只需要找一段最大的区间，使得这段区间中的第二关键字在[l,r]范围内，然后这段区间的长度就是[l,r]区间中该数出现的次数.
找这段最大的区间，两次二分就好。说起来二分得到区间这个做法之前写过两次。。。之前都是手写的。。。这次用了STL。
具体写法参见代码
1A开心哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 08:37:57 PM CST File Name :code/cf/problem/474F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int tree[N&amp;lt;&amp;lt;2]; int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } void PushUp( int rt) { tree[rt] = gcd(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void build(int l,int r,int rt) { if (l==r) { tree[rt] = a[l].</description></item><item><title>hdu 2853 Assignment (二分图最佳匹配，KM算法+数论，做法太神)</title><link>https://111qqz.com/2016/06/hdu-2853/</link><pubDate>Fri, 03 Jun 2016 07:36:50 +0000</pubDate><guid>https://111qqz.com/2016/06/hdu-2853/</guid><description>
hdu 2853题目链接
题意：n个公司，m个任务（m&amp;gt;=n),一个公司只能对应一个任务，一个任务也只能对应一个公司。给出一个n*m的mat,表示每个公司对应每个任务产生的val。 然后给出n个数，表示初始钦定（雾）这n个公司分别做哪些任务。 但是可能初始的安排得到的val表示最大的。我们现在想得到最大的val,并且保证改变的安排数最少。求安排后得到的 val比初始安排大多少，以及需要改变的安排数量。
思路：最大val很好求，KM就好。。。但是，怎么才能保证改变的安排数最少呢？ 尤其是当两个安排val一样的时候，如何才能保证优先选已经安排好的，而不取选另一个呢？
并没有想出来，看了题解T T
太神辣。
由于KM算法会根据权值来选取，权值大的会优先。
如果我们把每个权值*k(k&amp;gt;n)，然后对于已经钦定的安排，每个权值再+1.
这样，钦定的安排就会有更高的优先级，最后统计的时候除以k,那么权值答案不会有影响（利用到了初等数论的整除知识。。。？）
然后这样做该有一个好处。
不除以k的权值和再模k,就是没有改变的安排数。
原因是由于没有钦定的安排的权值每个都乘了k,最后%k都为0，只有那些钦定的安排每个会贡献1.
又由于k&amp;gt;n,这样就保证了正确性。
这做法太神了。。。。。吓傻了。。。。
我试着推广一下。。。？
对于根据权值来决定优先顺序，但是权值相同的时候还是需要对一些赋有更高的优先权的模型。。。？
除了再增加一维的大家都能想到的做法。。。这样的做法是不是有通用性呢。。。？
做法太神，我得慢慢体会。。
/* *********************************************** Author :111qqz Created Time :2016年06月03日 星期五 14时35分46秒 File Name :code/hdu/2853.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 55; int n,m; int w[N][N]; int id[N]; int lx[N],ly[N]; int link[N]; bool visx[N],visy[N]; int slk[N]; int num; bool find( int u) { visx[u] = true; for ( int v = 1 ; v &amp;lt;= m ;v++) { if(visy[v]) continue; int tmp = lx[u] + ly[v] - w[u][v]; if (tmp==0) { visy[v] = true; if (link[v]==-1||find(link[v])) { link[v] = u; return true; } }else if (tmp&amp;lt;slk[v]) slk[v] = tmp; } return false; } int KM() { ms(link,-1); ms(lx,0); ms(ly,0); for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= m ; j++) lx[i] = max(lx[i],w[i][j]); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(slk,0x3f); while (1) { ms(visx,false); ms(visy,false); if (find(i)) break; int d = inf; for ( int j = 1 ; j &amp;lt;= m ; j++) if (!</description></item><item><title>poj 2356 Find a multiple (剩余类，抽屉原理)</title><link>https://111qqz.com/2016/02/poj2356/</link><pubDate>Mon, 29 Feb 2016 13:06:00 +0000</pubDate><guid>https://111qqz.com/2016/02/poj2356/</guid><description>
http://poj.org/problem?id=2356
题意：有n个数，从中选取若干个（1..n），和能被n整除。问是否有解，无解输出0，有解的话，输出个数以及选择的ai
由抽屉原理可知一定有解： 做一个带模的前缀和 sum[i]=(sum[i-1]+a[i])%n n个数，sum[i]最多有n种。 如果某个sum[i]为0，那么表示从1到i的和能被n整除。 如果所有的sum[i]不为0，那么一共有n个sum[i]，n-1个值（1..n-1），一定有sum[i]==sumj 那么a[i]到a[j]的和一定能被n整除。
/************************************************************************* &amp;gt; File Name: code/poj/2356.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月21日 星期五 13时43分41秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x3f3f3f3f; const int N=2E4+7; int a[N]; int sum[N]; int n; int p[N]; int main() { scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); sum[0]= 0; for ( int i = 1 ; i &amp;lt;= n ; i++){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]); sum[i] = (sum[i-1] + a[i])%n; } memset(p,0,sizeof(p)); for ( int i = 1 ; i &amp;lt;= n ; i++){ if (sum[i]==0){ printf(&amp;quot;%d\n&amp;quot;,i); for ( int j = 1 ; j &amp;lt;= i ; j++){ printf(&amp;quot;%d\n&amp;quot;,j); } break; } if (p[sum[i]]){ // cout&amp;lt;&amp;lt;&amp;quot;111qqz&amp;quot;&amp;lt;&amp;lt;endl; printf(&amp;quot;%d\n&amp;quot;,i-p[sum[i]]); for ( int j = p[sum[i]]+1 ; j &amp;lt;= i ; j++){ printf(&amp;quot;%d\n&amp;quot;,j); } break; } p[sum[i]] = i; } return 0; }</description></item><item><title>cf 611 B ||codeforces goodbye 2015 B. New Year and Old Property (数学或者数位dp)</title><link>https://111qqz.com/2016/01/cf611b/</link><pubDate>Fri, 01 Jan 2016 13:03:22 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611b/</guid><description>
http://codeforces.com/contest/611/problem/B 题意：问a到b（1E18），二进制表示中只有一个0的数有多少个。 思路：这么大的数。。。不是有循环节就是math problems.  UD:20160318讲道理还有可能是数位dp好不好。。。 我们发现可以很容易得算出1到x的二进制表示中只有一个0 的数有多少个。
problem solved.
20160318update:学了数位dp后又看到这题。。。这题显然是数位dp啊。。。亏我找规律搞了出来2333.
后面附上数位dp方法AC的代码
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 22时49分02秒 File Name :code/cf/goodbye2015/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const int N=1E4+7; LL a,b; LL p[N]; LL c[N]; LL cal( LL x) { return ((x-1LL)*x)/2LL; } LL solve (LL x) { if (x==0LL) return 0; LL res= 0LL; LL cnt = 0LL; LL xx = x; while (xx) { cnt++; p[cnt] = xx%2LL; xx/=2LL; } ms(c,0); res+=cal(cnt-1LL); LL tmp = (1LL&amp;lt;&amp;lt;cnt)-1LL; for ( LL i = 0 ; i &amp;lt;cnt-1 ; i++) { LL happ = 1LL&amp;lt;&amp;lt;i; c[i]=tmp-happ; } sort(c,c+cnt-1); for ( LL i = 0 ; i&amp;lt; cnt -1 ; i++) { if (x&amp;gt;=c[i]) res++; } return res; } int main() { cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; LL ans = solve(b)-solve(a-1LL); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; } 数位dp的方法：</description></item><item><title>poj 2909 Goldbach's Conjecture （哥德巴赫猜想）</title><link>https://111qqz.com/2015/08/poj2909/</link><pubDate>Sat, 22 Aug 2015 06:43:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2909/</guid><description>
水题
写一遍的目的是。。。复习一下快速筛的写法　喵呜
/************************************************************************* &amp;gt; File Name: code/poj/2909.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月22日 星期六 14时25分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x3f3f3f3f; const int N=1&amp;lt;&amp;lt;16; bool not_prime[N]; int prime[N]; int prime_num; int n; void init(){ not_prime[0] = true; not_prime[1] = true; for ( int i =2 ; i &amp;lt; N ; i++){ if (!</description></item><item><title>poj 1305 (毕达哥拉斯三元组，构造勾股数)</title><link>https://111qqz.com/2015/08/poj1305/</link><pubDate>Sat, 22 Aug 2015 06:18:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj1305/</guid><description>
题意是说，能构造多少本元勾股数和勾股数，要求构造的数&amp;lt;=n
所谓本元勾股数，就是三个勾股数没有公因数，两两互质。
由本元勾股数扩大k倍，就可以得到其他勾股数。
而构造本元勾股数的方法如下：
***a=st,b=(s^2-t^2)/2,c=(s^2+t^2)/2
其中s&amp;gt;t&amp;gt;=1是任意没有公因数的奇数！
引用一段构造正确性的证明：
本原勾股数组（PPT)是一个三元组（a，b，c),其中a，b，c无公因数，且满足a² +b² =c²。
很明显存在无穷多个勾股数组（abc同乘以n），下面研究abc没有公因数的情况，先写出一些本原勾股数组：
case:(3,4,5) (5,12,13) (8,15,17) (7,24,25) (20,21,29)(9,40,41)(12,35,37)(11,60,61)(28,45,53) (33,56,65) (16,63,65)
观察可以看出a，b奇偶性不同且c总是奇数。（用一点技巧可以证明这是正确的）
3² = 5² - 4² = (5-4)(5+4) = 1 × 9
15² = 17²-8² = (17-8)(17+8) = 9 ×25
35² = 37² - 12² = (37-12)(37+12) = 25 ×49
......
很神奇的是似乎c-b与c+b总是平方数，并且c-b与c+b木有公因数。证明一下下：假设有公因数，设d是c-b与c+b的公因数，则d也整除(c+b)+(c-b)=2c, (c+b)-(c-b) = 2b,所以d整除2c，2b，但是b，c木有公因数，又假设了（a，b，c)是本原勾股数组，从而d等于1或2，又因为d整除（c-b)(c+b)=a².</description></item><item><title>poj 3370 Halloween treats (剩余类,抽屉原理)</title><link>https://111qqz.com/2015/08/poj3370halloweentreats/</link><pubDate>Fri, 21 Aug 2015 05:36:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3370halloweentreats/</guid><description>
昨天那道签到的数学题没搞出来不开心.
是时候刷一波数学了
这题题意是说,从n个数中任选m个,使得m个的和为c的倍数.
如果有解,输出选的数的下标,否则输出无解字符串.
抽屉原理的原始描述是,如果有n+1个物品,有n个抽屉,那么至少有一个抽屉有2个物品.
由抽屉原理我们可以退出一个结论,对于任意 n个自然数,一定有连续的一段和为n的倍数.
证明如下:
　设这n个自然数分别为a1,a2,a3,a4....an
　处理一个前缀和sum[i] = (sum[i-1] + a[i])%n
　因为n的剩余类有n种,分别为0,1,2...n-1
　所以sum[1],sum[2],sum[3]..sum[n]
　那么sum[1],sum[2],sum[3]...sum[n]最多也有n种.
　我们分情况讨论:
　(1)sum[1],sum[2],sum[3]...sum[n]互不相同,那么一定存在sum[i]=0,也就是前i个数的和为n的倍数.
　(2)情况(1)的反面,也就是存在sum[i]==sum[j] (i&amp;lt;j),那么 从a[i+1] 到 a[j]的和就是n的倍数.
因为题目中的数据 c&amp;lt;=n ,所以解一定存在.
具体做法就是处理出来一个前缀和%c
然后如果有0,则为解,输出.
否则记录sum[i]%d出现的位置,存在一个数组里
如果sum[i]%d第二次出现,就输出这段下标.
嘛,大括号换风格了....
都写开代码太长了==
/************************************************************************* &amp;gt; File Name: code/poj/3370.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月21日 星期五 13时06分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N]; LL sum[N]; int p[N]; int n,c; int main() { while (~scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;c,&amp;amp;n)){ if (c==0&amp;amp;&amp;amp;n==0) break; sum[0] = 0; for ( int i = 1 ; i &amp;lt;= n ;i++){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]); a[i] = a[i] % c; sum[i] = (sum[i-1] + a[i])%c; } memset(p,0,sizeof(p)); for ( int i = 1 ; i &amp;lt;= n ; i++ ){ if (sum[i]==0){ for ( int j = 1 ; j &amp;lt;= i ; j++){ cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;quot; &amp;quot;; // cout&amp;lt;&amp;lt;&amp;quot;wang wang wang !</description></item><item><title>hdu 2138 How many prime numbers</title><link>https://111qqz.com/2015/02/hdu2138/</link><pubDate>Tue, 17 Feb 2015 00:58:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu2138/</guid><description>
ACM STEPS里的...这题前面一道是求LCM....结果接下来就是这么一道。。。 朴素会超....筛法会爆....题目顺序真是按照难度来的？ 于是想到 Miller-Rabin素数测试....... 这个方法是基于费马小定理 我的理解就是... 如果我要判断n是否为素数 只要取k个数 如果满足 a^(n-1)mod n =1 那么n就很可能为素数。 证明什么的...暂时还是算了吧...论文里貌似扯了一大堆 第一次用，竟然真的A了。。。。 感觉更好的办法也许是先打一个比较小的素数表，然后每次random选取若干个进行判断...那样应该更可靠些？ 本来想WA掉之后再改的。。。没想到这么写就A掉了。。。。杭电数据略水？
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月19日 星期五 16时54分19秒 5File Name :code/hdu/2138.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cmath&amp;gt;10 #include &amp;lt;stdio.h&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 13 using namespace std; 14 15 typedef long long LL; 16 LL power(LL m,LL n,LL k) 17 { 18 int b = 1; 19 while (n &amp;gt; 0) 20 { 21 if (n &amp;amp; 1) 22 b = (b*m)%k; 23 n = n &amp;gt;&amp;gt; 1 ; 24 m = (m*m)%k; 25 } 26 return b; 27 } 28 bool judge(LL n) 29 { 30 LL i; 31 if (n&amp;lt;=3) return true; 32 for (i=2;i&amp;lt;=ceil(sqrt(n))+1;i++) 33 if (n %i==0) return false; 34 return true; 35 } 36 37 int main() 38 { 39 LL i,n,x; 40 41 while (scanf(&amp;#34;%I64d&amp;#34;,&amp;amp;n)!</description></item></channel></rss>