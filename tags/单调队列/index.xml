<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>单调队列 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</link><description>Recent content in 单调队列 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 05 Aug 2016 12:32:50 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3415 Max Sum of Max-K-sub-sequence (单调队列)</title><link>https://111qqz.com/2016/08/hdu-3415/</link><pubDate>Fri, 05 Aug 2016 12:32:50 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3415/</guid><description>
hdu 3415 题意：给出n个整数，是一个环（也就是a[n]右边是a[1]）求一段长度不超过k的数使得和最大，问最大和是多少并给出这段数的位置。
思路：为了处理环，先把n个数复制一下就好，然后求前缀和sum[i]
由于区间[l,r]的和可以用前缀和表示为sum[r]-sum[l-1]
因此在区间长度小于等于k的前提下，我要求sum[r]-sum[l-1]的最大值，如果我们考虑把端点r固定，那么就是要求[l-1,r-1]中的sum的最小值。
因此我们考虑用单调队列来维护sum[i-k]到sum[i-1]的最小值。
我们的做法是：枚举区间右端点i，同时用单调队列维护i之前的k个数[i-k,i-1]的最小值。
由于要求“If there are more than one result, output the minimum start position, if still more than one , output the minimum length of them.”，因此从后面出队的判断条件是严格的sum[dq.back()]&amp;gt;sum[i-1]
/* *********************************************** Author :111qqz Created Time :2016年08月05日 星期五 18时02分36秒 File Name :code/hdu/3415.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N],sum[N]; int n,k; int on; deque&amp;lt;int&amp;gt;dq; inline bool read(int &amp;amp;num) { char in; bool ISN = false; in=getchar(); if (in==EOF) return false; while (in!</description></item><item><title>ural 1126. Magnetic Storms (单调队列模板题)</title><link>https://111qqz.com/2016/08/ural1126/</link><pubDate>Thu, 04 Aug 2016 16:04:14 +0000</pubDate><guid>https://111qqz.com/2016/08/ural1126/</guid><description>
ural 1126 题意：n个数，求从第k个元素开始，求每k个元素的最大值（一共求n-k+1次） 思路：单调队列。 单调队列学习链接 其实单调队列挺容易的理解的。。。当时觉得写不明白大概是因为看到的代码写得太丑了2333
说下我的理解：
单调队列的尾端（就是后进入元素的那一端）其实和单调栈类似。
首端加了个元素期限的概念，不断删除“过期”的元素。
所谓过期的元素，对于这道题来说，当我往前移动到第k+1个元素的时候，第1个元素就是过期了的元素，堆答案不会再有贡献。
理论上单调队列中的元素是&amp;lt;元素的期限，元素&amp;gt;的二元组。
而一般元素的&amp;quot;期限&amp;quot;是由下标的位置决定的，而得到下标就可以知道元素。
所以我们实际操作的时候只需要将下标存入单调队列中就行了。
那么查询最大值呢？ 队首元素就是最大值。
以及，用到了stl的双端队列deque(double end queue)，头文件是#include
由于每次的答案是队首元素，因此设置哨兵而使得队列不为空就使得问题变得繁琐。
所以这里不同于单调栈的写法，我们不设置哨兵，而是.empty()判断双端队列是否为空。
也正是因为这个原因，没有办法像单调栈一样写成for的样子（因为没有哨兵，初始x=dq.front()的时候可能dp中还没有元素，导致RE），而是写成while的样子。。具体见代码。
/* *********************************************** Author :111qqz Created Time :2016年08月04日 星期四 23时08分34秒 File Name :code/ural/1126.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;deque&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E4+7; int a[N]; int f[N]; int n,k; deque&amp;lt;int&amp;gt;dq; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2823 Sliding Window (单调队列)</title><link>https://111qqz.com/2015/07/poj2823/</link><pubDate>Wed, 29 Jul 2015 13:03:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj2823/</guid><description>
Sliding Window
看这个问题：An array of size n ≤ 106 is given to you. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves rightwards by one position.Your task is to determine the maximum and minimum values in the sliding window at each position.</description></item></channel></rss>