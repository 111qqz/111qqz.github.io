<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最大连续和 on Clarity</title><link>https://111qqz.com/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/</link><description>Recent content in 最大连续和 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Mon, 18 Jul 2016 12:06:00 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C/index.xml" rel="self" type="application/rss+xml"/><item><title>whust 2016 warm up C ||codeforces 682 C. Alyona and the Tree (最大连续和,树形dp)</title><link>https://111qqz.com/2016/07/cf682c/</link><pubDate>Mon, 18 Jul 2016 12:06:00 +0000</pubDate><guid>https://111qqz.com/2016/07/cf682c/</guid><description>
cf682C题目链接
题意：给一棵树。。有点权和边权。。。如果一个点v的子树中存在某点u,满足dis(u,v)&amp;gt;a[u]，那么点v就非常sad...
dis(u,v)表示点u到v的距离。。。a[u]是u的点权。。现在问最少要删除多少个叶子节点才能使得没有点节点感到sad..
思路：dfs一下。。。需要注意的是边权有负数。。。所以类似于区间的最大连续区间和。。。我们也也可以维护在树上的最大连续和。。。只需要如果当前为负就变成0即可。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 14时27分58秒 File Name :code/2016whust/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,long long &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL a[N]; LL sum[N]; bool vis[N]; vector &amp;lt; pi&amp;gt; edge[N]; int ans; int n; void dfs( int u,int pre,LL d) { if (d&amp;gt;a[u]) return ; ans++; int siz = edge[u].</description></item></channel></rss>