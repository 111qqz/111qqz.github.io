<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>Recent content in 数据结构 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 15 Dec 2015 13:24:50 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces 466 C. Number of Ways</title><link>https://111qqz.com/2015/12/cf466c/</link><pubDate>Tue, 15 Dec 2015 13:24:50 +0000</pubDate><guid>https://111qqz.com/2015/12/cf466c/</guid><description>
http://codeforces.com/problemset/problem/466/C 题意：给定一个序列。要将序列分成三个非零的连续部分，使得三部分的和相等。问有多少中分法。 思路：首先可以知道，如果是序列的和不为3的倍数，那么一定无解，输出0.设序列的和为sum,那么每一部分的和就应该为sum/3。我们可以预处理出从1开始的和为sum/3的点（我开了数组表示前缀和。。想了下其实不用。。我只需要点的信息。。所以用一个变量表示即可），将点的下标存在p[i]里。对于每一个p[i]，我想要知道比p[i]大且补与p[i]相邻的点中，有多少个j，使得从j到n的和为sum/3。因为如果有两部分的和都为sum/3，那么剩下的那部分也一定为sum/3.然后要知道有多少个满足题意的j,我们可以从后往前扫一遍，标记从n开始往前扫，和为sum/3的点，可以用一个0,1数组表示。如果和为sum/3，那么标记为1，否则为0.然后再用一个类似前缀和的思路。再开一个数组c记录从j到n有的和为多少，也就是从j到n有多少个点满足该点到n的和为sum/3.
预处理完这些之后。只需要从前往后扫一遍p[i]，然后ans+=c[p[i]+2]即可。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 20时28分44秒 File Name :code/cf/problem/466C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int n; int a[N]; LL sum[N],rsum[N]; int p[N],rp[N]; int cnt,rcnt; int b[N]; int c[N]; LL ans; LL solve() { LL total = sum[n]; if (total%3!</description></item><item><title>hdoj 1754 I hate it</title><link>https://111qqz.com/2015/12/hdoj1754/</link><pubDate>Tue, 15 Dec 2015 05:55:54 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj1754/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1754 题意：给定一个区间，有m组操作，操作可以是改变单点，或者查询区间最大值。对于每组查询，输出。 思路：分块。这篇博客说得很不错。http://www.cnblogs.com/sweetsc/archive/2012/08/15/2639395.html
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 11时25分17秒 File Name :code/hdu/1754.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N]; int mx[N]; int n ,m; int magic; void pre() { magic = int(sqrt(n)); ms(mx,-1); //把i%magic去掉试试。 for ( int i = 0 ; i &amp;lt;n ; i++ ) //从0开始比较方便。 { // if (a[i]&amp;gt;mx[i/magic]) // mx[i/magic] = a[i]; mx[i/magic] = max(mx[i/magic],a[i]); } } int query( int l,int r) { int ret = a[l]; for ( int j = l ; j &amp;lt;= r;) { if (j%magic==0&amp;amp;&amp;amp;j+magic-1&amp;lt;=r) { ret = max(ret,mx[j/magic]); // if (mx[j/magic]&amp;gt;ret) ret= mx[j/magic]; j+= magic; } else //首尾两段不够magic的部分直接暴力 { ret = max(a[j],ret); //if (a[j]&amp;gt;ret) ret = a[j]; j++; } } return ret; } void update( int x,int delta) { a[x] = delta; int l = x/magic*magic; int r = l+magic; //找到x对应的哪个块。 for ( int i = l ; i &amp;lt; r ; i++) { // if (i%magic==0||a[i]&amp;gt;mx[i/magic]) mx[i/magic] = a[i]; mx[i/magic] = max(mx[i/magic],a[i]); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item></channel></rss>