<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>树形dp on 111qqz的小窝</title><link>http://example.org/tags/%E6%A0%91%E5%BD%A2dp/</link><description>Recent content in 树形dp on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 01 Dec 2016 13:44:50 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%A0%91%E5%BD%A2dp/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces #382 div 2 E. Ostap and Tree (树形dp)</title><link>http://example.org/2016/12/codeforces-382-div-2-e-ostap-and-tree-dp/</link><pubDate>Thu, 01 Dec 2016 13:44:50 +0000</pubDate><guid>http://example.org/2016/12/codeforces-382-div-2-e-ostap-and-tree-dp/</guid><description>题目链接
题意：将一棵树的若干点染成黑色，要求满足对于任何一个点u,至少存在一个距离其k以内的点v被染成黑色，问染色方案数。
思路：还没完全搞懂。。。记录一些idea&amp;hellip;
参考题解
以及：该题解中说的children指的是子树全体。。。坑死好吗。。。坑了一晚上。。气啊。
如果是贡献，j为负数
转移的话，考虑不断合并子树,假如说当前处理x为根的子树
不妨把它的儿子按照输入顺序从左往右编号1~N
**一开始到x的时候，初始状态f[x][-k] = f[x][1] = 1 **
然后不断把儿子的信息合并给x
做法是x与儿子枚举每一个可能的j值然后判断一下这样的状态转移后如何，添加到辅助数组里
最后把辅助数组的值copy给f[x]，，
/* *********************************************** Author :111qqz Created Time :2016年12月07日 星期三 02时10分34秒 File Name :code/cf/#382/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD = 1E9+7; const int N=105; int n,k,ans,f[N][50],g[50]; vector&amp;lt;int&amp;gt;edge[N]; int F( int x) { return x+k; } int Add(LL x,LL y) { return (x+y)%MOD; } int Mul(LL x,LL y) { return x*y%MOD; } void dfs( int u,int pre) { f[u][F(-k)]=f[u][F(1)] = 1; for ( auto v:edge[u]) { if (v==pre) continue; dfs(v,u); ms(g,0); for ( int i = -k ; i &amp;lt;= k ; i++) { if (!</description></item><item><title>hdu 1520 Anniversary party (树形dp模板题)</title><link>http://example.org/2016/11/hdu-1520/</link><pubDate>Wed, 30 Nov 2016 12:55:30 +0000</pubDate><guid>http://example.org/2016/11/hdu-1520/</guid><description>题目链接 题意：一个舞会，每个人有一个val，给出n个人之间的领导和被领导关系，一个人不愿意与他的领导同时参加，问一种安排方案，使得参加的人的val和最大，问这个最大的和是多少。
思路：树形dp模板题。
dp1[v]表示包含v节点的子树的最大值。
dp2[v]表示，不包含v节点的子树的最大值。
下面讲得很清楚。。
So, we can write a recursion by defining maximum of two cases. .
As we see in most DP problems, multiple formulations can give us optimal answer. Here, from an implementation point of view, we can define an easier solution using DP. We define two DPs, and , denoting maximum coins possible by choosing nodes from subtree of node V and if we include node V in our answer or not, respectively.</description></item><item><title>树形dp学习资料</title><link>http://example.org/2016/11/dp/</link><pubDate>Wed, 30 Nov 2016 12:10:49 +0000</pubDate><guid>http://example.org/2016/11/dp/</guid><description>资料１</description></item><item><title>whust 2016 warm up C ||codeforces 682 C. Alyona and the Tree (最大连续和,树形dp)</title><link>http://example.org/2016/07/cf682c/</link><pubDate>Mon, 18 Jul 2016 12:06:00 +0000</pubDate><guid>http://example.org/2016/07/cf682c/</guid><description>cf682C题目链接
题意：给一棵树。。有点权和边权。。。如果一个点v的子树中存在某点u,满足dis(u,v)&amp;gt;a[u]，那么点v就非常sad&amp;hellip;
dis(u,v)表示点u到v的距离。。。a[u]是u的点权。。现在问最少要删除多少个叶子节点才能使得没有点节点感到sad..
思路：dfs一下。。。需要注意的是边权有负数。。。所以类似于区间的最大连续区间和。。。我们也也可以维护在树上的最大连续和。。。只需要如果当前为负就变成0即可。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 14时27分58秒 File Name :code/2016whust/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,long long &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL a[N]; LL sum[N]; bool vis[N]; vector &amp;lt; pi&amp;gt; edge[N]; int ans; int n; void dfs( int u,int pre,LL d) { if (d&amp;gt;a[u]) return ; ans++; int siz = edge[u].</description></item><item><title>hdu 2196 Computer (树的直径||树形dp)</title><link>http://example.org/2016/07/hdu2196/</link><pubDate>Tue, 12 Jul 2016 06:02:39 +0000</pubDate><guid>http://example.org/2016/07/hdu2196/</guid><description>hdu2196
题意：给出一棵树。。。求距离每个点的最远距离是多少。。。
思路：最远距离什么的。。能想到树的直径。。。但是有什么关系呢？ 我们在求树的直径的时候。。。直径的两个端点是可以知道的。。。如果再从两个端点分别做两次bfs。。。每个点取两个距离的较大值就是答案。。。。？
1A.
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 13时29分49秒 File Name :code/hdu/2196.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; vector &amp;lt; pi &amp;gt;edge[N]; int d[N]; int ans[N]; bool vis[N]; int beg,lst; int far; void bfs( int s) { ms(d,0x3f); ms(vis,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 2342 Anniversary party (基础树形dp)</title><link>http://example.org/2016/06/poj2342/</link><pubDate>Fri, 24 Jun 2016 06:31:14 +0000</pubDate><guid>http://example.org/2016/06/poj2342/</guid><description>题目链接
题意：n个人的上下级关系形成一棵树..每一个人有一个val（可正可负），要选若干个人参加一个party,要求是一个人和他的直接上级不能同时在场。问参加party的人最大的val之和。
思路：树形dp入门题。
dp[i][0]和dp[i][1]分别表示第i个人不参加和参加party对应的val和。
注意dp转移方程是放在每次dfs之后的回溯位置的。。。
这样做的话访问是从根节点到叶子节点，更新就成了从叶子节点到根节点。。。
联想到数字三角形&amp;hellip;其实是一样的。。
sad&amp;hellip;dp苦手如我也开始刷dp了吗。。。。
/* *********************************************** Author :111qqz Created Time :2016年06月24日 星期五 13时07分51秒 File Name :code/poj/2342.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=6E3+7; int n; int a[N]; int in[N]; vector &amp;lt;int&amp;gt; edge[N]; int dp[N][2]; int root; void debug() { for ( int i = 1 ; i &amp;lt;= n ; i++) printf(&amp;quot;%d %d %d\n&amp;quot;,i,dp[i][0],dp[i][1]); } void dfs ( int u,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;endl; int siz = edge[u].</description></item></channel></rss>