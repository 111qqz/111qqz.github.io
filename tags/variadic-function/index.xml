<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Variadic Function on 111qqz的小窝</title><link>https://111qqz.com/tags/variadic-function/</link><description>Recent content in Variadic Function on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 01 Feb 2019 11:19:29 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/variadic-function/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
&lt;p&gt;说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Stdarg.h#.3Cvarargs.h.3E"&gt;stdarg.h&lt;/a&gt; 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考&lt;a href="https://111qqz.com/2019/01/x86-calling-conventions/"&gt;x86-calling-conventions&lt;/a&gt;   简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **&lt;/p&gt;</description></item></channel></rss>