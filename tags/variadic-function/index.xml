<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>variadic function on Clarity</title><link>https://111qqz.com/tags/variadic-function/</link><description>Recent content in variadic function on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Fri, 01 Feb 2019 11:19:29 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/variadic-function/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。
stdarg.h 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考x86-calling-conventions 简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **
在实现上，需要了解的是：
* va_list，一个类型，可以看做是变长参数列表； * [va_start](http://en.cppreference.com/w/cpp/utility/variadic/va_start)，用来初始化变长参数列表的宏，声明为void va_start( va_list ap, parm_n ); ap为va_list变量，parm_n为变长参数前一个变量（C语言要求至少有一个named variable作为函数的parameter) * [va_arg](http://en.cppreference.com/w/cpp/utility/variadic/va_arg),用来得到下一个参数的宏，声明为T va_arg( va_list ap, T ); **返回的类型取决于传入的类型T。特别注意:&amp;quot;If `va_arg` is called when there are no more arguments in `ap`, the behavior is undefined.&amp;quot;** * [va_end](http://en.cppreference.com/w/cpp/utility/variadic/va_end) ,用来将va_list释放的宏。 下面看一个例子就明白怎么用了orz
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* print all args one at a time until a negative argument is seen; all args are assumed to be of int type */ void printargs(int arg1, .</description></item></channel></rss>