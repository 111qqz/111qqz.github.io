<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最小表示法 on 111qqz的小窝</title><link>http://example.org/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</link><description>Recent content in 最小表示法 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 04 Nov 2017 06:58:49 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 1509 Glass Beads (后缀自动机求最小循环表示)</title><link>http://example.org/2017/11/poj-1509/</link><pubDate>Sat, 04 Nov 2017 06:58:49 +0000</pubDate><guid>http://example.org/2017/11/poj-1509/</guid><description>题意： 给定一个循环字符串，问字典序最小的串的开始位置。
思路： 之前用poj 1509 解题报告-字符串的最小表示法 A过
字符串的最小表示法的复杂度是O(n)，代码也不是很难写，不过由于最近在学SAM,所以用SAM写了一下。
参照张天扬的论文：
从初始状态开始，每次走字典序最小的转移，走|S|之后得到的就是最小循环表示。
如果求的是最小后缀，就在原串后加入一个比字符集中所有字符的字典序都小的字符作为终止后，再添加一遍原串。/* *********************************************** Author :111qqz Created Time :2017年11月03日 星期五 18时20分42秒 File Name :2774_SAM.cpp ************************************************ */ //#include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cstring&amp;gt; #define PB push_back #define fst first #define sec second #define lnxt l,m,rt&amp;lt;&amp;lt;1 #define rnxt m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int maxn = 5E5; struct node{ node*nxt[26],*fail; LL len,cnt; }; struct SAM{ node no[maxn]; node*root; int cnt; node*newnode(){ ms(no[cnt].</description></item><item><title>hdu 3374 String Problem (字符串的最小/大表示法+kmp)</title><link>http://example.org/2016/08/hdu-3374/</link><pubDate>Fri, 12 Aug 2016 19:39:21 +0000</pubDate><guid>http://example.org/2016/08/hdu-3374/</guid><description>hdu 3374 题目链接 题意：给出一个循环字符串，问最小表示出现的位置以及次数，最大表示出现的位置以及次数。 思路：之前只写过最小表示。。最大表示其实是一样的。。。把不等式方向变号即可。。。对于出现的次数。。。其实就等同于这个字符串是由几个子串组成。。。跑一遍kmp。。答案为len-nxt[len]，1A
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 03时22分47秒 File Name :code/hdu/3374.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; char s[N],tmp[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j +=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 2609 How many (字符串的最小表示法+set)</title><link>http://example.org/2016/08/hdu-2609/</link><pubDate>Fri, 12 Aug 2016 19:07:37 +0000</pubDate><guid>http://example.org/2016/08/hdu-2609/</guid><description>hdu 2609 题目链接
题意：给出n个循环字符串，问有多少种。
思路：将每个字符串换成最小表示，然后set存一下即可。
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 02时44分21秒 File Name :code/hdu/2609.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; char s[N][105]; set&amp;lt;string&amp;gt;se; int minRep(char *s) { int n = strlen(s); int i = 0 ; int j = 1 ; int k = 0 ; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n] - s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>hdu 4162 Shape Number (字符串的最小表示法)</title><link>http://example.org/2016/08/hdu-4162/</link><pubDate>Fri, 12 Aug 2016 18:42:04 +0000</pubDate><guid>http://example.org/2016/08/hdu-4162/</guid><description>hdu 4162
题意：给出一串代表8个方向的数字，求这串序列的一阶差分（the first difference）的字典序最小的表示。
思路：先做个变换，按照题意，第i位的一阶差分 s[i] = ((s[i+1]-s[i])+8)%8;
然后求出最小表示开始的位置。。输出即可。
/* *********************************************** Author :111qqz Created Time :2016年08月13日 星期六 02时17分45秒 File Name :code/poj/4162.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0 ; int j = 1; int k = 0 ; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>poj 1509 Glass Beads (字符串的最小表示法)</title><link>http://example.org/2016/08/poj-1509/</link><pubDate>Fri, 12 Aug 2016 17:21:21 +0000</pubDate><guid>http://example.org/2016/08/poj-1509/</guid><description>poj 1509 题目链接
题意&amp;amp;思路：同uva 1314
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 18时48分29秒 File Name :code/uva/1314.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>ural 1314 Hidden Password (字符串的最小表示法模板题)</title><link>http://example.org/2016/08/ural-1314-hidden-password-/</link><pubDate>Fri, 12 Aug 2016 17:14:46 +0000</pubDate><guid>http://example.org/2016/08/ural-1314-hidden-password-/</guid><description>uva 1314 题目链接
题意：给定一个循环字符串，问字典序最小的串的开始位置。最小表示法裸题。
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 18时48分29秒 File Name :code/uva/1314.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; char s[N]; int minRep(char *s) { int n = strlen(s); int i = 0; int j = 1; int k = 0; while (i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;n&amp;amp;&amp;amp;k&amp;lt;n) { int t = s[(i+k)%n]-s[(j+k)%n]; if (t==0) k++; else { if (t&amp;gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k = 0 ; } } return i&amp;lt;j?</description></item><item><title>最小表示法学习笔记（同构问题+模板）</title><link>http://example.org/2016/08/</link><pubDate>Fri, 12 Aug 2016 08:37:06 +0000</pubDate><guid>http://example.org/2016/08/</guid><description>首先放一波资料：叶子豪_最小表示法
周源_《浅谈最小表示法在字符串循环同构问题中的应用》 参考博客 对于字符串循环同构的最小表示法，其问题实质是求S串的一个位置，从这个位置开始循环输出S，得到的S’字典序最小。
一种朴素的方法是设计i,j两个指针。其中i指向最小表示的位置，j作为比较指针。
注意到，朴素算法的缺陷在于斜体的情况下i指针的移动太少了。针对这一问题改进就得到了最小表示法的算法。最小表示法的算法思路是维护两个指针i,j。
注意到上面两个算法唯一的区别是粗体的一行。这一行就把复杂度降到O(n)了。 值得一提的是，与KMP类似，最小表示法处理的是一个字符串S的性质，而不是看论文时给人感觉的处理两个字符串。 应用最小表示法判断两个字符串同构，只要将两个串的最小表示求出来，然后从最小表示开始比较。剩下的工作就不用多说了。
模板：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; const int N = 100000+10; char str[N]; int minimalRepresentation() { int n = strlen(str); int i = 0,j = 1, k = 0; while(i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;n &amp;amp;&amp;amp; k&amp;lt;n) { int t = str[(i+k)%n] - str[(j+k)%n] ; if(t == 0) k++; else { if(t&amp;gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k = 0; } } return i &amp;lt; j ?</description></item></channel></rss>