<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>观察者模式 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 观察者模式 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 01 Sep 2018 09:27:40 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>[设计模式] 观察者( Observer )模式学习笔记</title><link>https://111qqz.com/2018/09/observer-pattern-notes/</link><pubDate>Sat, 01 Sep 2018 09:27:40 +0000</pubDate><guid>https://111qqz.com/2018/09/observer-pattern-notes/</guid><description>
最近在学习node.js，里面讲到node.js的事件机制使用了观察者模式，因此来学习一下。
观察者模式的目的是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
因此观察者模式又叫发布-订阅模式。
下面放一个简化之后的例子:
1 2 3 #include &amp;lt;iostream&amp;gt;4 #include &amp;lt;vector&amp;gt;5 #include &amp;lt;string&amp;gt;6 using namespace std; 7 class Secretary; 8 // 看股票的同事类（观察对象，观察者） 9 class StockObserver 10 { 11 public: 12 StockObserver(string strName, Secretary* strSub) 13 { 14 name = strName; 15 sub = strSub; 16 } 17 18 void Update(); 19 20 private: 21 string name; 22 Secretary* sub;我所理解的设计模式（C++实现）——观察者模式（Observer Pattern） 23 }; 24 25 // 秘书类（主题对象，通知者） 26 class Secretary 27 { 28 29 public: 30 string action; 31 void Add(StockObserver ob) { observers.</description></item></channel></rss>