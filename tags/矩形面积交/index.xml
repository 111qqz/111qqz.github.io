<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>矩形面积交 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/</link><description>Recent content in 矩形面积交 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 27 Sep 2017 13:20:23 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 1255 覆盖的面积 (扫描线+线段树 求矩形面积交)</title><link>https://111qqz.com/2017/09/hdu1255/</link><pubDate>Wed, 27 Sep 2017 13:20:23 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu1255/</guid><description>
题目链接
题意： 求n（1000）个矩形的面积交，也就是至少有2个矩形覆盖的区域的面积。
思路： 和矩形面积并_hdu1542解题报告  类似
面积并问题中，线段树len维护的是至少覆盖一次的区域的长度
在面积交的问题中，我们需要多维护一个&amp;quot;至少覆盖两次的区域的长度&amp;quot;的域（设为double two;）
同时也要维护至少覆盖一次的区域的长度（设为double one;），是因为至少覆盖两次的区域的长度可以由至少覆盖一次的区域长度得到（好像是废话）
PushUp的时候要格外注意当前节点被完整覆盖一次的情况。
此时tree[rt].two 可以由两个子区间的one的情况想加得到
（因为rt节点被完整覆盖了至少一次，那么如果rt儿子区间中被覆盖了至少一次，对于rt区间中被rt&amp;lt;&amp;lt;1和rt&amp;lt;&amp;lt;1|1覆盖至少一次的区间在对于rt区间就已经覆盖了至少2次）
以及要注意题意说得不够清楚。最后保留2位小数是四舍五入。
读入的实际上是左下角和右上角的点。。。。
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 19时10分37秒 File Name :1255.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n; struct Seg { double l,r,h; int d; Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp; rhs)const { return h&amp;lt;rhs.</description></item></channel></rss>