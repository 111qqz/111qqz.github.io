<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>括号匹配 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</link><description>Recent content in 括号匹配 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 07 Aug 2016 17:29:31 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/index.xml" rel="self" type="application/rss+xml"/><item><title>whust 2016 #1 H - Pair: normal and paranormal</title><link>https://111qqz.com/2016/08/whust-2016-1-h-pair-normal-and-paranormal/</link><pubDate>Sun, 07 Aug 2016 17:29:31 +0000</pubDate><guid>https://111qqz.com/2016/08/whust-2016-1-h-pair-normal-and-paranormal/</guid><description>
题目链接
其实就是括号匹配的模型。。用栈即可。。被我写挂好几发。。该死该死。。。
/* *********************************************** Author :111qqz Created Time :2016年08月07日 星期日 17时34分13秒 File Name :code/whust2016/#1/HH.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;cctype&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char st[N]; int s[N]; int n; int plow[N]; int pup[N]; int ans[N]; stack&amp;lt;int&amp;gt;stk; bool ok(int x, int y) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; if (plow[x]&amp;gt;0&amp;amp;&amp;amp;pup[y]&amp;gt;0) { ans[pup[y]] = plow[x]; return true; } if (plow[y]&amp;gt;0&amp;amp;&amp;amp;pup[x]&amp;gt;0) { ans[pup[x]] = plow[y]; return true; } return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1141 Brackets Sequence (区间dp,括号匹配，记录路径)</title><link>https://111qqz.com/2016/07/poj-1141/</link><pubDate>Mon, 25 Jul 2016 08:29:03 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-1141/</guid><description>
poj 1141题目链接
题意：给出一个括号序列，要求添加最少的括号，使得这个序列变成合法的括号匹配，输出最后的序列。
思路：区间dp。。。有了那么一点思路。。。我们可以用dp[i][j]表示区间[i,j]的序列最少需要添加几个符号使得匹配。。转移的话。。。和之前差不多。。dp[i][j] = dp[i+1][j-1] (s[i]与s[j])匹配。。。不匹配的话也是找中间某个点。。。初始化的话。。要变成最大值。。。比较没思路的是输出括号序列这部分。。。
参考了这篇题解：参考题解
记录路径的思路是。。。记录转移的点。。。
cut[i][j]表示的是区间[i,j]的最优值是由点cut[i][j]这里划分得到的。。。
cut[i][j]为-1表示区间[i,j]的最优值不是从中间分成两部分得到。。。
打印路径的时候。。。如果[i,j]的长度小于等于0.。直接return.
如果长度为1.。。直接输出。。。
如果长度大于1.。。。要分这段区间是否中间有划分两种情况。。具体见代码。。。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 15时55分47秒 File Name :code/poj/1141.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char s[105]; int dp[105][105]; //dp[i][j]表示区间[i,j]最少需要添加多少字符达到匹配。 int cut[105][105] ; //记录一段区间是在哪里断开最优，是为了记录路径，打印括号 bool check(char a,char b) { if (a=='['&amp;amp;&amp;amp;b==']') return true; if (a=='('&amp;amp;&amp;amp;b==')') return true; return false; } void print(int i ,int j) { if (i&amp;gt;j) return ; if (i==j) { if (s[i]=='('||s[i]==')') printf(&amp;quot;()&amp;quot;); if (s[i]=='['||s[i]==']') printf(&amp;quot;[]&amp;quot;); return ; } if (cut[i][j]==-1) { printf(&amp;quot;%c&amp;quot;,s[i]); print(i+1,j-1); printf(&amp;quot;%c&amp;quot;,s[j]); } else { print(i,cut[i][j]); print(cut[i][j]+1,j); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item></channel></rss>