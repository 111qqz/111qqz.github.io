<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>binary search tree on 111qqz的小窝</title><link>https://111qqz.com/tags/binary-search-tree/</link><description>Recent content in binary search tree on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 21 Feb 2017 11:14:48 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/binary-search-tree/index.xml" rel="self" type="application/rss+xml"/><item><title>leetcode 108. Convert Sorted Array to Binary Search Tree（有序数组转化成bst）</title><link>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</link><pubDate>Tue, 21 Feb 2017 11:14:48 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</guid><description>
leetcode108
题意：把有一个有序的数组转化成一课高度尽量小的bst(二叉搜索树)
思路：我竟然忘记了什么是bst........我好傻啊...不过想想可能是因为...最朴素的二叉搜索树几乎用不到...所以很容易忘记吧2333
bst是 binary search tree的缩写..
具体见 维基百科_二叉搜索树
想起来概念就好搞了...直接递归建树即可...类似线段树的build的过程
/* *********************************************** Author :111qqz Created Time :2017年02月21日 星期二 13时08分04秒 File Name :108.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* dfs( int l,int r,vector&amp;lt;int&amp;gt;&amp;amp;nums) { int n = r-l+1; if (n&amp;lt;=0) return NULL; int m = n/2; cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; TreeNode* rt = new TreeNode(nums[l+m]); rt-&amp;gt;left = dfs(l,l+m-1,nums); rt-&amp;gt;right = dfs(l+m+1,r,nums); return rt; } TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item></channel></rss>