<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分块 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%88%86%E5%9D%97/</link><description>Recent content in 分块 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 23 Jul 2017 12:41:46 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%88%86%E5%9D%97/index.xml" rel="self" type="application/rss+xml"/><item><title>BSGS（Baby steps giant steps）算法学习笔记</title><link>https://111qqz.com/2017/07/bsgs-algorithm-notes/</link><pubDate>Sun, 23 Jul 2017 12:41:46 +0000</pubDate><guid>https://111qqz.com/2017/07/bsgs-algorithm-notes/</guid><description>
离散对数（Discrete Logarithm）问题是这样一个问题，它是对于模方程
a^x=b(mod prime)，求满足条件的X，或者得出不存在这样的X
最暴力的思路，那么就是枚举x? 根据费马小定理，只需要枚举[0,p-1)
但是还是很大...我们不禁想到把x写成x=A*m+B的形式，m=ceil(sqrt(p))
因此有 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2017/07/bsgs-algorithm-notes/http://blog.miskcoo.com/wp-content/plugins/latex/cache/tex_e074c544474c0974ac48e4130a8a298a.gif
Disk path: /content/post/ACM-ICPC/http://blog.miskcoo.com/wp-content/plugins/latex/cache/tex_e074c544474c0974ac48e4130a8a298a.gif
Using Page Bundles: true
，变形得到 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2017/07/bsgs-algorithm-notes/http://blog.miskcoo.com/wp-content/plugins/latex/cache/tex_b5b97e06b3a3e9d53d25bb32966b7887.gif
Disk path: /content/post/ACM-ICPC/http://blog.miskcoo.com/wp-content/plugins/latex/cache/tex_b5b97e06b3a3e9d53d25bb32966b7887.gif
Using Page Bundles: true</description></item><item><title>spoj DQUERY - D-query (询问区间中不同数的个数，线段树(离线) or 莫队算法（离线） or 主席树（在线）)</title><link>https://111qqz.com/2016/09/spoj-dquery/</link><pubDate>Sat, 17 Sep 2016 12:01:43 +0000</pubDate><guid>https://111qqz.com/2016/09/spoj-dquery/</guid><description>
题目链接 题意：给出n个数，然后m个询问，每个询问一个区间[l,r],问该区间中不同的数有多少个。
思路：离线处理+线段树的做法不多说了：
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 11:34:32 PM CST File Name :code/spoj/dquery.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E4+7; const int M=2E5+7; int n,Q; int a[N]; int tree[N&amp;lt;&amp;lt;2]; map&amp;lt;int,int&amp;gt;mp; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (r==b.</description></item><item><title>bzoj2002: [Hnoi2010]Bounce 弹飞绵羊 (分块)</title><link>https://111qqz.com/2016/02/bzoj2002/</link><pubDate>Sat, 20 Feb 2016 18:52:55 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj2002/</guid><description>
http://www.lydsy.com/JudgeOnline/problem.php?id=2002
题意+思路： 同codeforces 13 E holes.
/* *********************************************** Author :111qqz Created Time :2016年02月21日 星期日 02时29分39秒 File Name :code/bzoj/2002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; int siz = 450; //sqrt(2E5) int a[N]; int pos[N]; int cnt[N]; int nxt[N]; int end[N]; void go( int x) { int ans = 0 ; while (1) { if (x&amp;gt;=n) { printf(&amp;quot;%d\n&amp;quot;,ans); break; } ans +=cnt[x]; x = nxt[x]; // cout&amp;lt;&amp;lt;&amp;quot;nxt[x]:&amp;quot;&amp;lt;&amp;lt;nxt[x]&amp;lt;&amp;lt;endl; } } void update ( int i,int j) { if (j&amp;gt;=n) { cnt[i]=1; nxt[i]=n; end[i]=i; } else { if (pos[i]==pos[j]) { cnt[i] = cnt[j] + 1; nxt[i] = nxt[j]; end[i]=end[j]; } else { cnt[i] = 1; nxt[i] = j; end[i] = end[j]; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 13 E. Holes (分块)</title><link>https://111qqz.com/2016/02/cf13e/</link><pubDate>Sat, 20 Feb 2016 18:10:19 +0000</pubDate><guid>https://111qqz.com/2016/02/cf13e/</guid><description>
http://codeforces.com/problemset/problem/13/E 题意：给你n个洞，进入某个洞后会跑到另一个洞，到了另一个洞之后又可能会继续到下一个洞，问你从一个洞进去，钻了几个洞才会出来，在哪个洞出来
n 个整数a[i] 表示进入i这个洞之后会跑到 i+a[i]....
思路：分块大法好。具体见代码注释。以及。。。cin加速之后还是很慢。。。能不用就不用吧。
/* *********************************************** Author :111qqz Created Time :2016年02月20日 星期六 23时48分28秒 File Name :code/cf/problem/13E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int cnt[N];//cnt[i]表示第i个洞的球跳出所在块所需要的步数 int end[N]; //end[i]表示第i个洞的球跳出序列之前所经历的最后一个洞的序号 int jmp[N]; //jmp[i]表示第i个洞的球跳出所在的块到下一个块的洞的序号。 int a[N]; int siz = 313; //sqrt(1E5) int pos[N]; void go ( int x) { int ans = 0 ; int e; while (1) { if (x&amp;gt;n) { //cout&amp;lt;&amp;lt;e&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; printf(&amp;quot;%d %d\n&amp;quot;,e,ans); break; } ans +=cnt[x]; e = end[x]; x = jmp[x]; } // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; cnt[x] :&amp;quot;&amp;lt;&amp;lt;cnt[x]&amp;lt;&amp;lt;endl; // cout&amp;lt;&amp;lt;e&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; } void update( int i,int j) { if (j&amp;gt;n)//跳出所有洞 { cnt[i] = 1; end[i] = i; jmp[i] = n+1;//只要是一个大于n的数表示跳出就可以了 } else { if (pos[i]==pos[j]) //在同一块 { cnt[i]=cnt[j]+1; end[i]=end[j]; jmp[i]=jmp[j]; } else { cnt[i] = 1; end[i]=end[j]; jmp[i] = j; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4638 Group</title><link>https://111qqz.com/2016/02/hdu4638/</link><pubDate>Wed, 17 Feb 2016 19:39:18 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu4638/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4638 题意：给定一个序列，序列由1-N个元素全排列而成，求任意区间连续的段数。例如序列2,3,5,6,9就是三段(2, 3) (5, 6)(9)。 思路：增加一个元素，如果它两边的元素都出现了，那么段数-1（相当于把两段连接起来合并成了一段），如果两边元素都没有出现，那么段数+1.反过来，减少一个元素时，如果两边元素都出现了，俺么段数+1（相当于把完整的一段断开成两段），如果两边元素都没有出现，那么段数-1.操作可以O(1)完成。。。上莫队。 因为id大小最大才100000，所以判断某个元素是否出现开一个100000大小的布尔数组即可（我竟然傻逼得去用set....然后华丽丽得TLE了2333）
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2016/02/hdu4638/https://111qqz.com/wordpress/wp-content/uploads/2016/02/选区_019.png
Disk path: /content/post/ACM-ICPC/https://111qqz.com/wordpress/wp-content/uploads/2016/02/选区_019.png
Using Page Bundles: true
/* *********************************************** Author :111qqz Created Time :2016年02月18日 星期四 03时03分48秒 File Name :code/hdu/4638.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int pos[N]; int a[N]; int ans[N]; int sum; bool vis[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>hdu 5213 lucky （莫队算法）</title><link>https://111qqz.com/2016/02/hdu5213/</link><pubDate>Mon, 15 Feb 2016 08:58:30 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5213/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5213 题意：n个数，m个查询，每个查询由4个数l1,r1,l2,r2构成，询问分别从[l1,r1]和[l2,r2]中各取一个数，和为给定的常数k的方案数。
思路：首先分别由两个区间取数不好搞，我们可以用容斥原理对区间变换。这是这道题最关键的一步。
官方题解：这道题需要一些莫队算法的知识 定义记号f(A,B)f(A,B)表示询问区间A，B时的答案 用记号＋表示集合的并 利用莫队算法我们可以计算出任意f(A,A)f(A,A)的值 不妨假设A=[l1,r1],B=[l2,r2],C=[r1+1,l2-1]A=[l1,r1],B=[l2,r2],C=[r1+1,l2−1]容易知道（并没有很容易）f(A,B)=f(A+B+C,A+B+C)+f(C,C)-f(A+C,A+C)-f(C+B,C+B)f(A,B)=f(A+B+C,A+B+C)+f(C,C)−f(A+C,A+C)−f(C+B,C+B) 因此一个询问被拆成四个可以用莫队算法做的询问 总的时间复杂度为O(msqrt(n))O(msqrt(n)) 然后就是莫队算法的内容**。值得一提的是，被拆成的四个子询问不必做四次莫队，可以合在一起，因为每一次询问对答案的贡献都不会受顺序影响，而且这样用时更短。**
然后初始构造的时候用构造函数比赋值要方便许多。
还要记得多组数据记得清空各种数组。。。（因为忘记清空ans数组wa到死。。。）
最最关键的是，对于求两个数a+b==k这类问题（不一定是加，就是和两个数满足一个关系的时候），我们可以转换思维。a==k-b.也就是统计的时候是cnt[b]++,更新答案的时候，由于现在是b,我需要找有多少个a，也就是多少个k-b,所以是ans+=cnt[k-b];（要注意保证k-b&amp;gt;0) /* *********************************************** Author :111qqz Created Time :2016年02月14日 星期日 09时50分10秒 File Name :code/hdu/5213.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=6E4+7; int a[N]; int n,k; int m; int sum; int ans[N]; int pos[N]; int cnt[N]; struct node { int l,r; int add; int id; node(){} node(int a,int b,int c,int d){l=a,r=b,add=c,id = d;} bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>codeforces 220 B. Little Elephant and Array</title><link>https://111qqz.com/2016/02/codeforces-220-b-little-elephant-and-array/</link><pubDate>Sat, 13 Feb 2016 17:27:22 +0000</pubDate><guid>https://111qqz.com/2016/02/codeforces-220-b-little-elephant-and-array/</guid><description>
http://codeforces.com/contest/220/problem/B
题意：n个数，m个查询区间，对于每一个区间[l,r]输出区间中cnt[x]==x的数的个数。 思路：首先，a[i]很大。。。但是n最大才1e5...每个a[i]最多出现1E5次。。所以对于大于1E5的a[i]对答案没有贡献。其次，上莫队算法。
/* *********************************************** Author :111qqz Created Time :2016年02月14日 星期日 00时47分18秒 File Name :code/cf/problem/220B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int a[N]; int pos[N]; int sum; int ans[N]; int cnt[N]; struct node { int l,r; int id; bool operator&amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>codeforces 86 D. Powerful array （莫队算法）</title><link>https://111qqz.com/2016/02/cf86d/</link><pubDate>Sat, 13 Feb 2016 15:59:22 +0000</pubDate><guid>https://111qqz.com/2016/02/cf86d/</guid><description>
http://codeforces.com/problemset/problem/86/D 题意：Ks为区间内s的数目，求区间[L,R]之间所有KsKss的和 思路：莫队算法，和小z的袜子差不多。不明白第一次tle#54是什么情况。把每一块的大小改成了常数之后就过了。 再交一遍就过了。。不过貌似根据最大数据把siz大小设置成一个常数比根号n要块很多==
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2016/02/cf86d/https://111qqz.com/wp-content/uploads/2016/02/选区_016-300x46.png
Disk path: /content/post/ACM-ICPC/https://111qqz.com/wp-content/uploads/2016/02/选区_016-300x46.png
Using Page Bundles: true
/* *********************************************** Author :111qqz Created Time :2016年02月13日 星期六 23时17分58秒 File Name :code/cf/problem/86D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int t,n; int a[N]; int pos[N]; LL sum; LL ans[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>（莫队算法的学习）bzoj 2038 [2009国家集训队]小Z的袜子(hose)</title><link>https://111qqz.com/2016/02/bzoj-2038/</link><pubDate>Wed, 10 Feb 2016 08:51:04 +0000</pubDate><guid>https://111qqz.com/2016/02/bzoj-2038/</guid><description>
2038: [2009国家集训队]小Z的袜子(hose)
Time Limit: 20 Sec Memory Limit: 259 MB Submit: 5327 Solved: 2461 [Submit][Status][Discuss] Description
作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。
Input
输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。
Output
包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）
Sample Input
6 4
1 2 3 3 3 2
2 6
1 3
3 5
1 6
Sample Output
2/5
0/1
1/1
4/15
【样例解释】
询问1：共C(5,2)=10种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为(1+3)/10=4/10=2/5。
询问2：共C(3,2)=3种可能，无法抽到颜色相同的袜子，概率为0/3=0/1。
询问3：共C(3,2)=3种可能，均为抽出两个3，概率为3/3=1/1。
注：上述C(a, b)表示组合数，组合数C(a, b)等价于在a个不同的物品中选取b个的选取方案数。
【数据规模和约定】
30%的数据中 N,M ≤ 5000；
60%的数据中 N,M ≤ 25000；
100%的数据中 N,M ≤ 50000，1 ≤ L &amp;lt; R ≤ N，Ci ≤ N。</description></item><item><title>hdoj4391 Paint The Wall</title><link>https://111qqz.com/2015/12/hdoj4391/</link><pubDate>Tue, 15 Dec 2015 08:52:37 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj4391/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4391 题意：有 n 个点，每个点有一种颜色（可能相同），两种操作：1、将区间 [a,b] 染成颜色 c ; 2、询问区间 [a,b] 中颜色为 c 的点有多少个。 思路：因为颜色种类很多。。。没办法通过建很多棵线段树解决。我们用分块的办法。。。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 15时00分34秒 File Name :code/hdoj/4391.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; //sqrt(n),n最大100000 int n,q,c[N]; int len ,cnt; struct HashBlock{ int siz; //块的大小，因为最后一个快的长度可能不足len, int col;//整块的颜色。当快没有被标记成统一的颜色的时候，为-1 map&amp;lt;int,int&amp;gt;mp; }a[400]; void init() { len = (int)sqrt(n*1.</description></item><item><title>hdoj 1754 I hate it</title><link>https://111qqz.com/2015/12/hdoj1754/</link><pubDate>Tue, 15 Dec 2015 05:55:54 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj1754/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=1754 题意：给定一个区间，有m组操作，操作可以是改变单点，或者查询区间最大值。对于每组查询，输出。 思路：分块。这篇博客说得很不错。http://www.cnblogs.com/sweetsc/archive/2012/08/15/2639395.html
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 11时25分17秒 File Name :code/hdu/1754.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N]; int mx[N]; int n ,m; int magic; void pre() { magic = int(sqrt(n)); ms(mx,-1); //把i%magic去掉试试。 for ( int i = 0 ; i &amp;lt;n ; i++ ) //从0开始比较方便。 { // if (a[i]&amp;gt;mx[i/magic]) // mx[i/magic] = a[i]; mx[i/magic] = max(mx[i/magic],a[i]); } } int query( int l,int r) { int ret = a[l]; for ( int j = l ; j &amp;lt;= r;) { if (j%magic==0&amp;amp;&amp;amp;j+magic-1&amp;lt;=r) { ret = max(ret,mx[j/magic]); // if (mx[j/magic]&amp;gt;ret) ret= mx[j/magic]; j+= magic; } else //首尾两段不够magic的部分直接暴力 { ret = max(a[j],ret); //if (a[j]&amp;gt;ret) ret = a[j]; j++; } } return ret; } void update( int x,int delta) { a[x] = delta; int l = x/magic*magic; int r = l+magic; //找到x对应的哪个块。 for ( int i = l ; i &amp;lt; r ; i++) { // if (i%magic==0||a[i]&amp;gt;mx[i/magic]) mx[i/magic] = a[i]; mx[i/magic] = max(mx[i/magic],a[i]); } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #319 div 2 E C. Points on Plane (分块)</title><link>https://111qqz.com/2015/09/codeforces319div2ec-pointsonplane/</link><pubDate>Fri, 18 Sep 2015 14:16:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces319div2ec-pointsonplane/</guid><description>
初识分快.
引一段题解：
Let's split rectangle 106 × 106 by vertical lines into 1000 rectangles 103 × 106. Let's number them from left to right. We're going to pass through points rectangle by rectangle. Inside the rectangle we're going to pass the points in increasing order of y-coordinate if the number of rectangle is even and in decreasing if it's odd.
Let's calculate the maximum length of such a way.</description></item></channel></rss>