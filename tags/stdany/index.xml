<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>std::any on 111qqz的小窝</title><link>https://111qqz.com/tags/stdany/</link><description>Recent content in std::any on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 05 Mar 2022 16:02:36 +0800</lastBuildDate><atom:link href="https://111qqz.com/tags/stdany/index.xml" rel="self" type="application/rss+xml"/><item><title>[c++17] std::any 笔记</title><link>https://111qqz.com/2022/03/std-any-notes/</link><pubDate>Sat, 05 Mar 2022 16:02:36 +0800</pubDate><guid>https://111qqz.com/2022/03/std-any-notes/</guid><description>
背景 一种很常见的背景是，需要表示未知类型的数据。 比如可能是用户提供的数据，比如是一个Cache的实现， value想支持任意类型的数据
对于这种场景，c语言的出身的开发者通常会使用void*来实现
1struct day { 2 // ...things... 3 void* user_data; 4}; 5 6struct month { 7 std::vector&amp;lt;day&amp;gt; days; 8 void* user_data; 9}; 10 了解cpp11的开发者可能会使用std::shared_ptr&amp;lt;void&amp;gt; 来实现
1struct day { 2 // ...things... 3 std::shared_ptr&amp;lt;void&amp;gt; user_data; 4}; 5 6struct month { 7 std::vector&amp;lt;day&amp;gt; days; 8 std::shared_ptr&amp;lt;void&amp;gt; user_data; 9}; 10 那么有没有更好的实现办法呢？是有的，c++17中提供了std::any
std::any含义 The class any describes a type-safe container for single values of any copy constructible type. Tip 重点是提供了类型安全。</description></item></channel></rss>