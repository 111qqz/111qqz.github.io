<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>模拟 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%A8%A1%E6%8B%9F/</link><description>Recent content in 模拟 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Mon, 06 Nov 2017 09:42:38 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%A8%A1%E6%8B%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 4782 | 2013 Asia Chengdu Regional Contest B (模拟)</title><link>https://111qqz.com/2017/11/hdu-4782/</link><pubDate>Mon, 06 Nov 2017 09:42:38 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-4782/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=4782
题意： 将格式混乱的html代码输出成标准格式。
思路： 模拟。
说下细节：
* 遇到open tag,先打印，后dep++ * 遇到close tag,先dep--,再打印 * 遇到空标签，直接在当前深度打印 * 遇到空白字符时，只有当前面出现了text以及后面也出现了text的时候才打印。**也就是说第一个string和最后一个string都是紧邻标签的。** 最坑的一点是...虽然题目给了数据组数，但是在所在行的同一行，可能出现下一组的开始
最坑的一点是...虽然题目给了数据组数，但是在所在行的同一行，可能出现下一组的开始
最坑的一点是...虽然题目给了数据组数，但是在所在行的同一行，可能出现下一组的开始
说好的多组数据呢...
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long LL; const int N = 1E5+10; const double eps = 1e-8; #define ms(a,x) memset(a,x,sizeof(a)) #define lowbit(x) (x&amp;amp;(-x)) char buff[N]; int len = 0; char ch; void skip() { while (ch=='\n'||ch==' '||ch=='\t') ch =getchar(); } void TAG() { len = 0; ch =getchar(); while (ch!</description></item><item><title>codeforces #413 A. Carrot Cakes (模拟)</title><link>https://111qqz.com/2017/05/codeforces-div2-413a/</link><pubDate>Fri, 12 May 2017 13:12:30 +0000</pubDate><guid>https://111qqz.com/2017/05/codeforces-div2-413a/</guid><description>
题目链接
题意：初始有一个锅，每t分钟可以做好k个饼，现在需要N个饼。还可以另外建一个锅，花费d时间，建好以后两个锅可以并行烙饼。问是否应该建锅？（以期减少烙饼时间）
思路：求出两种情况下的总时间，比较一下。
只有一个锅的情况很好求。
两个锅的情况比较麻烦，不如模拟时间流逝？
反正最多也就1E6的时间。。。模拟一下。。。稳。。
/* *********************************************** Author :111qqz Created Time :2017年05月11日 星期四 15时29分43秒 File Name :A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hihocoder 1197 Give My Text Back (模拟)</title><link>https://111qqz.com/2017/03/hihocoder-1197/</link><pubDate>Fri, 31 Mar 2017 08:36:23 +0000</pubDate><guid>https://111qqz.com/2017/03/hihocoder-1197/</guid><description>
#1197 : Give My Text Back 时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述 To prepare for the English exam Little Ho collected many digital reading materials. Unfortunately the materials are messed up by a malware.
It is known that the original text contains only English letters (a-zA-Z), spaces, commas, periods and newlines, conforming to the following format:
Each sentence contains at least one word, begins with a letter and ends with a period.</description></item><item><title>hdu 2522 A simple problem (模拟，求小数循环节)</title><link>https://111qqz.com/2016/11/hdu-2522/</link><pubDate>Tue, 01 Nov 2016 12:21:12 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-2522/</guid><description>
题目链接
题意：求一个小数的循环节...
思路：其实直接模拟就好...
模拟竖式计算...
这里用到一个小技巧。
由于多组数据，每次都memset一个bool会很慢，导致超时。
我们可以用一个人int数组来代替每次重置的bool数组,
/* *********************************************** Author :111qqz Created Time :Tue 01 Nov 2016 08:00:49 PM CST File Name :code/hdu/2522.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int vis[N]; int n; int cnt = 0; void solve( int n) { if (n&amp;lt;0) { printf(&amp;quot;-&amp;quot;); n = -n; } if (n==1) { printf(&amp;quot;1&amp;quot;); return; } int x; printf(&amp;quot;0.</description></item><item><title>2017 小米 软件工程师 校招 笔试题 (模拟)</title><link>https://111qqz.com/2016/09/2017-----/</link><pubDate>Fri, 23 Sep 2016 15:51:41 +0000</pubDate><guid>https://111qqz.com/2016/09/2017-----/</guid><description>
题意：一串电话号码，每个数字+8取各位后，把每个数字写成对应的大写英文，从&amp;quot;ZERO&amp;quot;和“NINE”，然后打乱字母的顺序。现在给出打乱的字母顺序，问可能的字典序最小的电话号码是是多少（可能有前导0）
思路：分析0..9 每个数字的英文组成。。。然后大概类似解方程。。可以根据字母的个数确定每个数字的个数。。。
然后-8。。。存一下排个序就好了。。。1A
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char st[N]; int len; int a[30]; int cnt[15]; //0.</description></item><item><title>hdu 5835 || ccpc 2016 网络赛 1004 Danganronpa (模拟)</title><link>https://111qqz.com/2016/08/hdu-5835/</link><pubDate>Sun, 14 Aug 2016 11:24:01 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5835/</guid><description>
hdu 5835 题目链接 题意：n种礼物，每种a[i]个。现在有无穷个小朋友排成一排，分给每个人一个“普通”的礼物，一个“昂贵”的礼物（哪个普通哪个昂贵是自己定的，或者说，任意的） 要求是相邻的小朋友的普通的礼物不能是同一种。现在问最多能给多少小朋友分礼物。。。
思路：容易知道，因为昂贵的礼物是没有限制的。。所以没什么用。。考虑礼物总数sum..那么最多只可能分给sum/2个小朋友。。。然后再两个指针模拟一下。。记得特判n=1的情况。1A
/* *********************************************** Author :111qqz Created Time :2016年08月14日 星期日 12时46分56秒 File Name :code/ccpc2016/1004.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=11; int n; int a[N]; int total; bool bian[N]; bool cmp(int a,int b) { return a&amp;gt;b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust 2016 #1 D Zhenya moves from the dormitory (贪心，模拟)</title><link>https://111qqz.com/2016/08/whust-2016-1-d-zhenya-moves-from-the-dormitory-/</link><pubDate>Sun, 07 Aug 2016 17:32:21 +0000</pubDate><guid>https://111qqz.com/2016/08/whust-2016-1-d-zhenya-moves-from-the-dormitory-/</guid><description>
题目链接 傻逼模拟。。读完题就ac了。。。
/* *********************************************** Author :111qqz Created Time :2016年08月07日 星期日 18时04分18秒 File Name :code/whust2016/#1/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=280; int n,m; int total,adva,advb; struct Friend { int money; int adv; }f[N]; struct Room { int type; int cost; int adv; }r[N]; struct Ans { int val; int rid; int fid; bool operator &amp;lt; (Ans b)const { return val&amp;gt;b.</description></item><item><title>whust 2016 warm up E||codeforces 689 A. Mike and Cellphone (模拟)</title><link>https://111qqz.com/2016/07/cf689a/</link><pubDate>Mon, 18 Jul 2016 12:12:44 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689a/</guid><description>
cf689A
思路：一个老式的电话键盘。。。。给出一个拨号的移动路径。。。问这个路径是否唯一。
思路：如果唯一就说明。。。不能平移。。。否则不唯一。。
平移可以上下左右。。所以先写4个常亮数组。。。标记平移后的结果。。。设置不合法位就可以了。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 12时56分28秒 File Name :code/2016whust/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int up[15]={8,-1,-1,-1,1,2,3,4,5,6}; const int down[15]={-1,4,5,6,7,8,9,-1,0,-1}; const int l[15]={-1,-1,1,2,-1,4,5,-1,7,8}; const int r[15]={-1,2,3,-1,5,6,-1,8,9,-1}; int n; string st; bool solve() { bool flag = true; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = st[i]-'0'; // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; x+up[x]&amp;quot;&amp;lt;&amp;lt;x+up[x]&amp;lt;&amp;lt;endl; x = up[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;uuuuu&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; flag = true; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = st[i]-'0'; x = down[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;ddd&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; flag = true; for ( int i = 0 ; i &amp;lt; n; i++) { int x = st[i]-'0'; x = l[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;lll&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; flag = true; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = st[i]-'0'; x = r[x]; if (x==-1) { flag = false; // cout&amp;lt;&amp;lt;&amp;quot;rrr:::&amp;quot;&amp;lt;&amp;lt;endl; break; } } if (flag) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1689: [Usaco2005 Open] Muddy roads 泥泞的路 （模拟）</title><link>https://111qqz.com/2016/05/bzoj1689/</link><pubDate>Tue, 10 May 2016 13:26:29 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj1689/</guid><description>
1689: [Usaco2005 Open] Muddy roads 泥泞的路 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 311 Solved: 227 [Submit][Status][Discuss]
Description Farmer John has a problem: the dirt road from his farm to town has suffered in the recent rainstorms and now contains (1 &amp;lt;= N &amp;lt;= 10,000) mud pools. Farmer John has a collection of wooden planks of length L that he can use to bridge these mud pools. He can overlap planks and the ends do not need to be anchored on the ground.</description></item><item><title>bzoj1603: [Usaco2008 Oct]打谷机 (纱布题)</title><link>https://111qqz.com/2016/03/bzoj1603/</link><pubDate>Thu, 31 Mar 2016 13:10:27 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1603/</guid><description>
Time Limit: 5 Sec Memory Limit: 64 MB Submit: 774 Solved: 593 [Submit][Status][Discuss]
Description Farmer John有一个过时的打谷机（收割小麦），它需要带子来带动。发动机驱动轮1总是顺时针旋转的，用来带动转轮2，转轮2来带动转轮3，等等。一共有n（2&amp;lt;=n&amp;lt;=1000）个转轮（n-1条带子）。上面的图解描述了转轮的两种连接方式，第一种方式使得两个轮子旋转的方向相同，第二种则相反。 给出一串带子的信息： *Si—驱动轮 *Di—被动轮 *Ci—连接的类型（0=直接连接，1=交叉连接） 不幸的是，列出的信息是随即的。 作为样例，考虑上面的图解，n=4，转轮1是驱动轮，可以得知最后转轮4是逆时针旋转的。
Input *第一行：一个数n *第二行到第n行：每一行有三个被空格隔开的数：Si，Di，Ci
Output *第一行：一个单独的数，表示第n个转轮的方向，0表示顺时针，1表示逆时针。
Sample Input 4 2 3 0 3 4 1 1 2 0
Sample Output 1
思路：傻逼模拟题。。。。排下序。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 21时04分09秒 File Name :code/bzoj/1603.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; struct node { int s,d,c; bool operator &amp;lt; (node b)const { return s&amp;lt;b.</description></item><item><title>hdu 5611 || BC #69 div2 1002 Baby Ming and phone number</title><link>https://111qqz.com/2016/01/hdu5611/</link><pubDate>Sat, 23 Jan 2016 14:43:26 +0000</pubDate><guid>https://111qqz.com/2016/01/hdu5611/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5611 题意：给出n个电话号码（长度为11的字符串），满足特殊条件的价格为a，否则为b.特殊条件为最后5位数字一样，最后5位严格递增或者严格递减，最后8位是一个1980年1月一日到2016年12月31日的合法日期。问最后的价值。
思路：直接搞....结果死在cin了。。。原来3E6的cin就会TLE。。。。。q神说1E5有的也会tle.....
所以方案是，能不用cin就不要用cin...
如果要读string的话。。。一个解决办法是把数据流同步关掉（是叫这个名字吗。。）
std::ios::sync_with_stdio(false); 会快很多。。。
还有一个办法是先用scanf读 char[] 然后再转化？ 没试过== 哦哦还要注意要判闰年。 还有要开long long
/* *********************************************** Author :111qqz Created Time :2016年01月23日 星期六 18时58分10秒 File Name :code/bc/#69/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; string str; LL a,b; bool good1(string x) { int len = x.</description></item><item><title>cf 611 A||codeforces goodbye 2015 C. New Year and Domino</title><link>https://111qqz.com/2016/01/cf611a/</link><pubDate>Fri, 01 Jan 2016 12:57:19 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611a/</guid><description>
http://codeforces.com/contest/611/problem/C 题意：给出一个n*m的地图，.表示可以空，#表示墙。一个东西需要占两个相邻的格子，问给定一个矩形，放一个东西的方案数。 思路：q很大。。应该是先预处理出来直接调用答案。。。计数问题累加性。。应该是前缀和之类。。需要做的就是怎么标记。。我的做法是竖着放和横着放的个数分开来存。从左往右从上往下，每次标记到后一个点。然后二维的前缀和。然后每次询问的时候，去掉最上边和最左边两条边界上对应的多加的点。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N=5E2+7; char maze[N][N]; int n,m; int q; int a[N][N],b[N][N]; int sum[N][N]; int sum2[N][N]; int main() { cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for ( int i = 0 ; i&amp;lt; n ;i++ ) scanf(&amp;quot;%s&amp;quot;,maze[i]); for ( int i = 1 ; i &amp;lt; n ; i++) { for (int j = 0 ; j&amp;lt; m ;j++) { if (maze[i][j]=='.</description></item><item><title>codeforces 31 C. Schedule</title><link>https://111qqz.com/2015/12/cf31c/</link><pubDate>Tue, 29 Dec 2015 14:35:18 +0000</pubDate><guid>https://111qqz.com/2015/12/cf31c/</guid><description>
http://codeforces.com/problemset/problem/31/C 题意：给出n个借用教室的时间安排，可能会有冲突。要求恰好去掉一个时间安排使得剩下的时间安排不冲突。问多多少种方案。 思路：首先一个直觉是。。除非初始就没有任何冲突。。不然这个答案不会很大。。
如果没有任何冲突，那么答案为n，直接输出一遍就好。
以l为第一关键字，r为第二关键字升序sort下。
如果有一个冲突，那么要看是否有包含关系，如果有，需要去掉大的这个，方案数为1.如果只是相交，那么可以去掉任意一个。方案数为2.
如果有两个冲突，我要看这两个冲突涉及到几个时间安排，如果涉及到4个或者时间安排，那么不可能全部解决，die掉。
如果这两个冲突涉及到三个时间安排，也就是说中间的和两段的相交，那么可以取消中间的这个时间安排来解决冲突。方案数为1.
需要注意的是输出的时候要按照原来的顺序。。所以存的时候记得存一下id.因为排序以后会打乱原有。输出之前还要sort下。 忘了这个。。WA#22/。因为按照id未必是从小到大输出的。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 21时37分11秒 File Name :code/cf/problem/31C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E3+7; int n ; int ans[N]; struct node { int fst,sec; int id; bool operator &amp;lt;(node b)const { if (fst&amp;lt;b.</description></item><item><title>codeforces 1 B. Spreadsheets</title><link>https://111qqz.com/2015/12/cf1b/</link><pubDate>Mon, 14 Dec 2015 05:33:07 +0000</pubDate><guid>https://111qqz.com/2015/12/cf1b/</guid><description>
http://codeforces.com/problemset/problem/1/B 题意：给出了两种表格的表示方法。要求互相转化。 思路：直接模拟即可。注意和一般的进制转化不同的是，26进制对应的是1到26而不是0到25，所以要记得处理下借位。
/* *********************************************** Author :111qqz Created Time :2015年12月13日 星期日 19时46分09秒 File Name :code/cf/problem/1B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char st[100]; int a26[100]; int a10[100]; void pre() { a26[0]=1; for ( int i = 1 ;i&amp;lt;=5; i++) { a26[i] = a26[i-1]*26; // cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;a26[i]&amp;lt;&amp;lt;endl; } a10[0] = 1; for ( int i = 1 ; i&amp;lt;=7 ; i++) { a10[i] = a10[i-1]*10; } } void solve() { cin&amp;gt;&amp;gt;st; int len = strlen(st); int p1=-1,p2=-1; for ( int i = 0 ; i &amp;lt; len ; i++) { char ch = st[i]; if (ch&amp;gt;='A'&amp;amp;&amp;amp;ch&amp;lt;='Z') { if (p1==-1) { p1 = i ; } else { p2 = i; break; } } } if (p2-p1==1||p2==-1) { int dig = 0 ; int alp = 0; int sum = 0 ; int sum2 = 0 ; for ( int i = len -1 ; i&amp;gt;= 0 ; i--) { char ch = st[i]; if (!</description></item><item><title>codeforces 158 B. Taxi</title><link>https://111qqz.com/2015/12/158b/</link><pubDate>Sun, 06 Dec 2015 12:46:06 +0000</pubDate><guid>https://111qqz.com/2015/12/158b/</guid><description>
http://codeforces.com/problemset/problem/158/B 题意：n组人，每组有si个（1&amp;lt;=si&amp;lt;=4），每辆车能装4个人。问最少需要多少辆车装下所有人并且保证同一组的人在一辆车里。 思路：统计人数分别为1,2,3,4的人数。对于4的直接加到答案。贪心的思路是：优先用人数少的去填人数多的。
/* *********************************************** Author :111qqz Created Time :2015年12月06日 星期日 17时34分21秒 File Name :code/cf/problem/158B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int s[N]; int ans; int cnt[5]; void print() { printf(&amp;quot;%d %d %d %d %d\n&amp;quot;,cnt[1],cnt[2],cnt[3],cnt[4],ans); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdoj 5479 || bestcoder #57 div 2 A Scaena Felix(模拟)</title><link>https://111qqz.com/2015/09/hdoj5479/</link><pubDate>Sat, 26 Sep 2015 17:25:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdoj5479/</guid><description>
模拟．
直接搞...
并不明白坑在哪里．．．
排在我前面被hack了１００多人...
/************************************************************************* &amp;gt; File Name: code/bc/#57/1001.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月26日 星期六 19时04分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E3+7; char str[N]; int len; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces # 317 div 2 B. Order Book（模拟）</title><link>https://111qqz.com/2015/08/codeforces317div2b-orderbook/</link><pubDate>Sun, 23 Aug 2015 08:13:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces317div2b-orderbook/</guid><description>
B. Order Book
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
In this task you need to process a set of stock exchange orders and use them to create order book.
An order is an instruction of some participant to buy or sell stocks on stock exchange. The order number i has price p__i, direction d__i -- buy or sell, and integer q__i.</description></item><item><title>bc #52 div 2 A ||hdoj5417 Victor and Machine (模拟)</title><link>https://111qqz.com/2015/08/hdoj5417/</link><pubDate>Sat, 22 Aug 2015 15:19:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdoj5417/</guid><description>
傻逼模拟题
我做了半小时....
sssssad
/************************************************************************* &amp;gt; File Name: code/bc/#52/1001.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月22日 星期六 18时51分44秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E6+7; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces 560 B. Gerald is into Art　（模拟）</title><link>https://111qqz.com/2015/08/codeforces560b-geraldisintoart/</link><pubDate>Sun, 16 Aug 2015 22:53:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces560b-geraldisintoart/</guid><description>
/************************************************************************* &amp;gt; File Name: code/cf/#313/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: Wed 22 Jul 2015 09:52:54 PM CST ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; int a1,b1,a2,b2,a3,b3; bool judge (int x2,int y2,int x3,int y3) { if (x2&amp;lt;=a1&amp;amp;&amp;amp;x3&amp;lt;=a1&amp;amp;&amp;amp;y2+y3&amp;lt;=b1) return true; if (y2&amp;lt;=b1&amp;amp;&amp;amp;y3&amp;lt;=b1&amp;amp;&amp;amp;x2+x3&amp;lt;=a1) return true; return false; } int main() { cin&amp;gt;&amp;gt;a1&amp;gt;&amp;gt;b1&amp;gt;&amp;gt;a2&amp;gt;&amp;gt;b2&amp;gt;&amp;gt;a3&amp;gt;&amp;gt;b3; if (judge(a2,b2,a3,b3)||judge(b2,a2,a3,b3)||judge(b2,a2,b3,a3)||judge(a2,b2,b3,a3)) { puts(&amp;quot;YES&amp;quot;); } else { puts(&amp;quot;NO&amp;quot;); } return 0; }</description></item><item><title>codeforces 314 D One-Dimensional Battle Ships (模拟)</title><link>https://111qqz.com/2015/08/codeforces314/</link><pubDate>Sat, 15 Aug 2015 17:02:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces314/</guid><description>
比赛的时候没搞出来，really sad. 其实这题很容易啊．．．． 首先，对于lie 的判断应该基于能放的船的个数． 能放的船的个数是随着射的点数的增加而减少的． 射完每个点后更新能放的船的个数，如果这个时候已经无法放下k条船了，说明lie了． 如果所有都射完也没发生，那么就-1.
由于船与串不能相邻，除了最后一条船，每条船实际占的size 应该为a+1 那么很容易知道对于长度为l的区间，能放的船的个数为（l+1）/(a+1) 这是初始能放的船的个数，为最大值． 当射了点b之后，破坏的是b所在的一段最大的没有被射过点的区间的连续性． 做法是找到距离b点最近的左端和右端的被射过的点． 可以用set 搞，找的时候upper_bound 记得初始化的时候把　0点和　n+1 点当成射过的．
/************************************************************************* &amp;gt; File Name: code/cf/#314/D.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 00时27分54秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; set&amp;lt;int&amp;gt; se; int n,k,a,m,b; set&amp;lt;int&amp;gt;::iterator it; int cal (int x,int y) //cal 函数计算出当射了b之后，因此减少的能放船的个数． { int res; res = (y-x)/(a+1)-(y-b)/(a+1)-(b-x)/(a+1);//由于射了b点，相当于之前连续的区间(x,y)被分成了（x,b）和（b,y) //(x,y)区间能放的船的数量由之前变成了被分成的两个小区间能放的船的数量的和． return res; } int main() { scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;n,&amp;amp;k,&amp;amp;a); scanf(&amp;quot;%d&amp;quot;,&amp;amp;m); se.</description></item><item><title>cf #314 B. Berland National Library (模拟)</title><link>https://111qqz.com/2015/08/cf314b-berlandnationallibrary/</link><pubDate>Wed, 05 Aug 2015 19:00:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf314b-berlandnationallibrary/</guid><description>
给出一个图书馆人员进出情况，问图书馆满足题意的最小容量是多少。
注意在初始之前图书馆里面可能就有人了，也就是说不是所有进入图书馆的人都会被给出。
我的做法是先统计出图书馆里面初始的人数，开一个布尔数组，初始全为false,如果一个人标记为 false 而且从 图书馆里出来了，就说明这个人初始是在图书馆里的。
然后就正常模拟，图书馆的人数由初始的和后来的两部分组成。
/************************************************************************* &amp;gt; File Name: code/cf/#314/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月06日 星期四 00时23分26秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E2+5;moni int n; int r[N]; bool vis[1000060]; char ch[N]; int main() { cin&amp;gt;&amp;gt;n; char cmd; int mx = -1; int cur = 0; int beforein = 0; memset(vis,false,sizeof(vis)); for ( int i = 0 ; i &amp;lt; n ; i++) { cin&amp;gt;&amp;gt;ch[i]&amp;gt;&amp;gt;r[i]; if (ch[i]=='+') { vis[r[i]] = true; } if (ch[i]=='-') { if (!</description></item><item><title>sgu 463 - Walking around Berhattan</title><link>https://111qqz.com/2015/07/sgu463/</link><pubDate>Thu, 30 Jul 2015 12:04:00 +0000</pubDate><guid>https://111qqz.com/2015/07/sgu463/</guid><description>
简单模拟,n,m貌似给反了(两个地方给的不一致 ) 害我wa了两发
1 2 /************************************************************************* 3&amp;gt; File Name: code/2015summer/#5/K.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月30日 星期四 14时00分56秒 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 #define y0 abc111qqz 22 #define y1 hust111qqz 23 #define yn hez111qqz 24 #define j1 cute111qqz 25 #define tm crazy111qqz 26 #define lr dying111qqz 27 using namespace std; 28 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 29 typedef long long LL; 30 typedef unsigned long long ULL; 31 const int inf = 0x7fffffff; 32 const int N=1e2+5; 33 int b[N][N]; 34 int n,m; 35 char cmd[505]; 36 bool vis[N][N]; 37 int nx,ny; 38 int dx[4]={-1,0,1,0}; 39 int dy[4]={0,1,-0,-1}; 40 char ch[N][N]; 41 int main() 42 { 43 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; 44 nx = 0; 45 ny = 0; 46 for ( int i = 0 ; i &amp;lt; n ; i++) 47 cin&amp;gt;&amp;gt;ch[i]; 48 for ( int i = 0 ; i &amp;lt;n ; i++ ) 49 { 50 for ( int j = 0 ; j &amp;lt; m ; j++ ) 51 { 52 b[i+1][j+1]=(int)(ch[i][j]-&amp;#39;0&amp;#39;); 53 } 54 } 55 int ans = 0; 56 memset(vis,false,sizeof(vis)); 57 int dir = 1; 58 cin&amp;gt;&amp;gt;cmd; 59 int len = strlen(cmd); 60 for ( int i = 0 ; i &amp;lt; len ; i ++ ) 61 { 62 // cout&amp;lt;&amp;lt;&amp;#34;ans:&amp;#34;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 63 // cout&amp;lt;&amp;lt;&amp;#34;nx:&amp;#34;&amp;lt;&amp;lt;nx&amp;lt;&amp;lt;&amp;#34; ny:&amp;#34;&amp;lt;&amp;lt;ny&amp;lt;&amp;lt;endl; 64 if (cmd[i]==&amp;#39;L&amp;#39;) 65 { 66 dir = (dir+3)%4; 67 } 68 if (cmd[i]==&amp;#39;R&amp;#39;) 69 { 70 dir = (dir+1)%4; 71 } 72 if (cmd[i]==&amp;#39;M&amp;#39;) 73 { 74 if (dir==0) 75 { 76 if (vis[nx][ny]) 77 { 78 ans = ans + b[nx][ny]/2; 79 } 80 else 81 { 82 ans = ans + b[nx][ny]; 83 } 84 if (vis[nx][ny+1]) 85 { 86 ans = ans + b[nx][ny+1]/2; 87 } 88 else 89 { 90 ans = ans + b[nx][ny+1]; 91 } 92 vis[nx][ny]=true; 93 vis[nx][ny+1]=true; 94 nx = nx +dx[dir]; 95 ny = ny +dy[dir]; 96 } 97 if (dir==2) 98 { 99 nx = nx + dx[dir]; 100 ny = ny + dy[dir]; 101 if (vis[nx][ny]) 102 { 103 ans = ans + b[nx][ny]/2; 104 } 105 else 106 { 107 ans = ans + b[nx][ny]; 108 } 109 if (vis[nx][ny+1]) 110 { 111 ans = ans + b[nx][ny+1]/2; 112 } 113 else 114 { 115 ans = ans + b[nx][ny+1]; 116 } 117 vis[nx][ny]=true; 118 vis[nx][ny+1]=true; 119 } 120 if (dir==1) 121 { 122 nx = nx + dx[dir]; 123 ny = ny + dy[dir]; 124 if (vis[nx][ny]) 125 { 126 ans = ans + b[nx][ny]/2; 127 } 128 else 129 { 130 ans = ans + b[nx][ny]; 131 } 132 if (vis[nx+1][ny]) 133 { 134 ans = ans + b[nx+1][ny]/2; 135 } 136 else 137 { 138 ans = ans + b[nx+1][ny]; 139 } 140 vis[nx][ny]=true; 141 vis[nx+1][ny]=true; 142 143 } 144 if (dir==3) 145 { 146 147 if (vis[nx][ny]) 148 { 149 ans = ans + b[nx][ny]/2; 150 } 151 else 152 { 153 ans = ans + b[nx][ny]; 154 } 155 if (vis[nx+1][ny]) 156 { 157 ans = ans + b[nx+1][ny]/2; 158 } 159 else 160 { 161 ans = ans + b[nx+1][ny]; 162 } 163 vis[nx][ny]=true; 164 vis[nx+1][ny]=true; 165 nx = nx +dx[dir]; 166 ny = ny +dy[dir]; 167 } 168 } 169 170 } 171 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 172 173 return 0; 174 } 175 176</description></item><item><title>hdu 1050 Moving Tables</title><link>https://111qqz.com/2015/03/hdu1050/</link><pubDate>Thu, 26 Mar 2015 11:01:00 +0000</pubDate><guid>https://111qqz.com/2015/03/hdu1050/</guid><description>
一开始算法想的有点问题。
坑点在于走廊两侧都有房间
也就是说room1和room2对应的位置是一样的
1 to 3 4to6 是没法同时完成的。
做法就是整个扫一遍，看哪个位置的重复次数最大，*10就是答案。
1 2 #include &amp;lt;iostream&amp;gt;3 #include &amp;lt;algorithm&amp;gt;4 #include &amp;lt;cmath&amp;gt;5 #include&amp;lt;cstdio&amp;gt;6 #include &amp;lt;cstring&amp;gt;7 8 using namespace std; 9 10 int main() 11 { 12 int t,n,a[300],b[300]; 13 int p[300]; 14 int ans; 15 scanf(&amp;#34;%d&amp;#34;,&amp;amp;t); 16 while (t--) 17 { 18 19 scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); 20 memset(p,0,sizeof(p)); 21 memset(a,0,sizeof(a)); 22 memset(b,0,sizeof(b)); 23 for (int i=1;i&amp;lt;=n;i++) 24 { 25 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a[i],&amp;amp;b[i]); 26 if (a[i]&amp;gt;b[i]) 27 swap(a[i],b[i]); 28 for (int j=(a[i]+1)/2;j&amp;lt;=(b[i]+1)/2;j++) 29 p[j]++; 30 } 31 ans=0; 32 for (int i=1;i&amp;lt;=200;i++) 33 if (p[i]&amp;gt;ans) 34 ans=p[i]; 35 printf(&amp;#34;%d\n&amp;#34;,ans*10); 36 } 37 return 0; 38 } 39</description></item><item><title>hdu 5113 Black And White</title><link>https://111qqz.com/2015/02/hdu5113/</link><pubDate>Tue, 17 Feb 2015 09:01:00 +0000</pubDate><guid>https://111qqz.com/2015/02/hdu5113/</guid><description>
题意是说用k重颜色填充n*m的方格，第i种颜色要用ci次，保证ci（i属于1..k）的和为n&amp;quot;m，问是否有可行解，若有，输出任意一种。 第一感觉是dfs.。。而且数据范围还那么小。但是鉴于我上次dfs写成汪的经历....嗯 不过群里有学长说似乎剪枝不太好想？ 我一开始分了四类，o行o列，e行e列，e行o列，o行e列，（o是odd，e是even）然后将c[i]排序，先填大的C[I]，感觉这样应该更容易找到解。交了一发,WA掉了。。发现当k较小的时候，也就是c[i]都相对较大的时候，先填大的C[I]的策略会出现错误。于是我换了下....按c[i]的大小从两边往中间...然后我还发现其实o行o列和e行e列可以归为一类，同理，后两种也可以归为一类。又交，又WA2333333 然后想了好久。。。 发现对于上面说的两类的处理顺序不同会得到不同的结果.......只有一种是对的。于是加了个judge函数判断冲突...如果冲突就换个顺序.....再交，A了。
过程中出现了两个语法上的错误....**一个是=写成了==(从来都是把==写成=。。。) 另一个是无参数的函数依然要写（）。。。。。。
确实不难....的确是我生疏了。
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月19日 星期五 16时20分07秒 6File Name :code/hdu/5113.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 13 using namespace std; 14 15 int c[100],cc[100]; 16 int ans[10][10]; 17 int colorid[100]; 18 int n,m,k; 19 void look(); 20 bool judge(); 21 22 23 int main() 24 { 25 int tt; 26 int t; 27 int kk; 28 29 cin&amp;gt;&amp;gt;t; 30 tt=t; 31 32 33 int i,j; 34 int head; 35 int flag; 36 while (t--) 37 { head=1; 38 flag=1; 39 memset(ans,0,sizeof(ans)); 40 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;k; 41 kk=k; 42 for (i=1;i&amp;lt;=k;i++) 43 cin&amp;gt;&amp;gt;c[i]; 44 45 for (i=1;i&amp;lt;=k;i++) 46 colorid[i]=i; 47 for (i=1;i&amp;lt;k;i++) 48 for (j=i+1;j&amp;lt;=k;j++) 49 if (c[i]&amp;gt;c[j]) 50 { 51 swap(c[i],c[j]); 52 swap(colorid[i],colorid[j]); 53 } 54 for (i=1;i&amp;lt;=k;i++) 55 cc[i]=c[i]; 56 57 58 59 if (c[k]&amp;gt;(n*m+1)/2) { cout&amp;lt;&amp;lt;&amp;#34;Case #&amp;#34;&amp;lt;&amp;lt;tt-t&amp;lt;&amp;lt;&amp;#34;:&amp;#34;&amp;lt;&amp;lt;endl;cout&amp;lt;&amp;lt;&amp;#34;NO&amp;#34;&amp;lt;&amp;lt;endl;continue;} 60 61 for (i=1;i&amp;lt;=n;i++) 62 for (j=1;j&amp;lt;=m;j++) 63 if ((i%2+j%2)%2==1) 64 { 65 if (flag%2==1) 66 { 67 68 69 ans[i][j]=colorid[k]; 70 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[k]&amp;lt;&amp;lt;endl; 71 72 c[k]--; 73 if (c[k]==0) 74 { 75 k--; 76 flag++; 77 78 } 79 } 80 else 81 { 82 ans[i][j]=colorid[head]; 83 84 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[head]&amp;lt;&amp;lt;endl; 85 c[head]--; 86 if (c[head]==0) 87 { 88 head++; 89 flag++; 90 91 } 92 } 93 // look(); 94 } 95 96 97 for (i=1;i&amp;lt;=n;i++) 98 for (j=1;j&amp;lt;=m;j++) 99 if ((i%2+j%2)%2==0) 100 { 101 102 103 if (flag%2==1) 104 { 105 106 107 ans[i][j]=colorid[k]; 108 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[k]&amp;lt;&amp;lt;endl; 109 c[k]--; 110 if (c[k]==0) 111 { 112 k--; 113 flag++; 114 } 115 } 116 else 117 { 118 ans[i][j]=colorid[head]; 119 // cout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;j:&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;colorid[head]&amp;lt;&amp;lt;endl; 120 c[head]--; 121 if (c[head]==0) 122 { 123 head++; 124 flag++; 125 } 126 } 127 // look(); 128 } 129 cout&amp;lt;&amp;lt;&amp;#34;Case #&amp;#34;&amp;lt;&amp;lt;tt-t&amp;lt;&amp;lt;&amp;#34;:&amp;#34;&amp;lt;&amp;lt;endl; 130 cout&amp;lt;&amp;lt;&amp;#34;YES&amp;#34;&amp;lt;&amp;lt;endl; 131 132 if (!</description></item></channel></rss>