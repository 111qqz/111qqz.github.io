<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>brute force on 111qqz's blog</title><link>https://111qqz.com/tags/brute-force/</link><description>Recent content in brute force on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 30 Jul 2017 06:46:23 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/brute-force/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces #425 B. Petya and Exam (暴力)</title><link>https://111qqz.com/2017/07/codeforces-div2-425b/</link><pubDate>Sun, 30 Jul 2017 06:46:23 +0000</pubDate><guid>https://111qqz.com/2017/07/codeforces-div2-425b/</guid><description>
题目链接
题意： 给出由小写字母，'?'和'*'组成的字符串s，仅由小写字母组成的字符串t,问按照规则s能否变成t.
规则如下：首先给出定义的[好字母]的字符串，[好字母]之外的都是[坏字母],对于s中每个‘?’，规定其必须替换为一个[好字母]
对于s中的每个‘*’，规定其必须替换为0个或者多个坏字母。
思路： 显然带的会比较难搞。所以只说带的情况
我WA了好多次，原因是一开始读错题（或者题意不太清楚？），认为*只能最多替换一个[坏字母]
后来在这个思路上改，越改越复杂orz
仔细想一下，关键点有两个，一个是当前位置有三种情况{没有经过*,经过且仍在的作用域内，经过且已经出了的作用域}
如何知道的作用域呢？由于的替换是连续的，因此只要对比s和t的长度差就可以了。
对于不同的作用域，普通字母的判断位置是不同的，在经过*的作用域之后，普通字母（包括‘？’）记得加一个offset
所以第二个关键点就是，对于*的替换，一次判断完多个。
除此之外，注意下*可能为空的特殊情况，特判一下比较保险。
/* *********************************************** Author :111qqz Created Time :Mon 24 Jul 2017 10:32:44 PM CST File Name :B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string good; int len,len2; vector&amp;lt;char&amp;gt;go; string st; int n; string tmp; vector&amp;lt;int&amp;gt;zimu; //字母的位置 vector&amp;lt;int&amp;gt;fuhao; //符号的位置 bool star; bool vis[26]; bool solve() { len2 = tmp.</description></item><item><title>leetcode 437. Path Sum III</title><link>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</link><pubDate>Fri, 24 Feb 2017 03:45:38 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</guid><description>
题目链接
题意：求一棵二叉树中，所有一段连续路径之和等于给定值的路径数目。
思路：想了半天就只能想到暴力。。。复杂度大概O(n^2)。。。也不是不可以接受。。。但是感觉这也太暴力了。。就去看了题解。。。发现题解就还真是暴力orz。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { //思路：枚举每个起点？？？好暴力啊。。。卧槽。。正解就是这样。。。 public: int dfs(TreeNode* root,int sum) { int res = 0 ; if (root==NULL) return res; if (root-&amp;gt;val==sum) res++; res += dfs(root-&amp;gt;left,sum-root-&amp;gt;val)+dfs(root-&amp;gt;right,sum-root-&amp;gt;val); return res; } int pathSum(TreeNode* root, int sum) { if (root==NULL) return 0; return dfs(root,sum)+pathSum(root-&amp;gt;left,sum)+pathSum(root-&amp;gt;right,sum); } };</description></item><item><title>bestcoder #88 || hdu 5908 Abelian Period(暴力)</title><link>https://111qqz.com/2016/10/hdu-5908/</link><pubDate>Sat, 01 Oct 2016 16:11:33 +0000</pubDate><guid>https://111qqz.com/2016/10/hdu-5908/</guid><description>
题目链接
题意：一段数字串，如果一个数字k满足，将该串分成若干个长度为K的子串，这些子串两两满足每个字符出现的次数一样多，那么称为k是一个阿贝尔周期。现在问所有合法的阿贝尔周期。
思路：
* 首先我们发现，所有的阿贝尔周期一定是数字串长度（设为n)的因数。 * 然后我们还发现。。。如果某个因子是阿贝尔周期，那么该因子的整数倍中恰好也是n的因子的也一定是阿贝尔周期，类似筛法。 * 然后我们还发现。。。最小的阿贝尔周期一定比数字串中的元素个数大。。。 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2016/10/hdu-5908/https://111qqz.com/wordpress/wp-content/uploads/2016/10/2016-10-02-00-07-21-的屏幕截图-1-300x7.png
Disk path: /content/post/ACM-ICPC/https://111qqz.com/wordpress/wp-content/uploads/2016/10/2016-10-02-00-07-21-的屏幕截图-1-300x7.png
Using Page Bundles: true
然而其实后面两个不管也可以过吧。。。因为有点忘了n的约数个数的上界了。。。。
还是太保守了。。。
不过hack了四发哈哈哈。。。要是大号的话今天就紫了呜呜呜
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2016/10/hdu-5908/https://111qqz.com/wordpress/wp-content/uploads/2016/10/2016-10-01-21-11-30-的屏幕截图-300x73.png
Disk path: /content/post/ACM-ICPC/https://111qqz.</description></item><item><title>seerc 2014 A Banks (暴力)</title><link>https://111qqz.com/2016/08/seerc-2014-a-banks-/</link><pubDate>Sat, 27 Aug 2016 06:42:17 +0000</pubDate><guid>https://111qqz.com/2016/08/seerc-2014-a-banks-/</guid><description>
题目链接
题意：n个数围成一圈，对于负数可以进行magic操作，也就是取反，但是会影响到左右相邻的，加上这个负数。问最少进行多少次magic操作，使得所有数都是非负。
思路：我们知道，如果一个负数想变成整数的话，只能通过magic 操作。唯一可能影响次数的就是顺序。
不过手动写了几个发现顺序好像无关紧要？
于是大胆猜测，写了发暴力2333。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int maxn = 1e4+10; int n,a[maxn]; void work(){ queue&amp;lt;int&amp;gt; Q; int cnt = 0; while(!</description></item><item><title>codeforces #368 div 2 B. Bakery (暴力)</title><link>https://111qqz.com/2016/08/707b/</link><pubDate>Sun, 21 Aug 2016 06:17:59 +0000</pubDate><guid>https://111qqz.com/2016/08/707b/</guid><description>
题目链接
题意：n个城市，m条双向路，要从k条中选择一个，使得到其他n-k个城市中的某个城市的距离最短。
思路：直接暴力 枚举。1A
/* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时02分14秒 File Name :code/cf/#368/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =1E5+7; int n,m,k; vector &amp;lt;pair &amp;lt;int,LL&amp;gt; &amp;gt;edge[N]; int b[N]; bool cangku[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #368 div 2 A. Brain's Photos (暴力)</title><link>https://111qqz.com/2016/08/cf707a/</link><pubDate>Sun, 21 Aug 2016 06:10:35 +0000</pubDate><guid>https://111qqz.com/2016/08/cf707a/</guid><description>
题目链接
。。。这题也能成hack题。。。。有毒啊。。然后我room里所有人都写对了。。。是我看这道题看得太早了？
/* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时01分57秒 File Name :code/cf/#368/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>whust 2016 warm up G ||codeforces 689C. Mike and Chocolate Thieves</title><link>https://111qqz.com/2016/07/cf689c/</link><pubDate>Mon, 18 Jul 2016 12:29:16 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689c/</guid><description>
cf689C
题意：给出一个m。。问恰好使得不超过某个n的a*b^3（a,b是正整数）的方案数为m的n是多少。。。
思路：暴力+二分。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 15时58分55秒 File Name :code/2016whust/G.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL m,n; LL ans; LL cal( LL x) { LL res = 0LL; for ( LL i =2 ; i * i * i &amp;lt;= x ; i++) res+=x/(i*i*i); return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3368 Frequent values （暴力+rmq，分类讨论）</title><link>https://111qqz.com/2016/05/poj3368/</link><pubDate>Wed, 18 May 2016 07:47:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj3368/</guid><description>
poj 3368 题目链接
题意：给出n个非减的数a[i],求区间[l,r]中出现次数最多的数的出现的次数。
思路：由于数列非减，那么相等的数一定相邻。很容易系哪个到构造另一个数组f[i]，表示从当前位置向左边延伸最多延伸几个相等的数。
f[i] = f[i-1] + 1 (iff a[i]==a[i-1])
然后查询的时候。
如果直接用ST算法查询rmq的话。。。
可能产生错误结果，原因是f[i]是从左边1到i这段连续区间里当前数出现的次数。
但是查询区间不一定是从1开始，所以查询区间内的第一段连续相等的数可能不完整。。。想了半天。。最后看了题解，发现是这部分暴力来搞。但是如果所有数列中所有数都相等，这样的复杂度就达到了o(1E10)?。。。2s应该过不了吧。。。但是所有题解都是这么写的。。。不是很懂。。。所谓的面向数据编程？
不过还是有启示的：分类讨论的思想。一道题未必用一种算法解。如果因为一小部分导致某算法不能用的话，不妨暴力搞之然后再用这个算法。
/* *********************************************** Author :111qqz Created Time :2016年05月18日 星期三 13时44分47秒 File Name :code/poj/3368.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int q; int dp[N][20]; void init_rmq() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp[i][0] = a[i].</description></item><item><title>hdu 3183 A Magic Lamp ( 暴力)</title><link>https://111qqz.com/2016/05/hdu3183/</link><pubDate>Mon, 16 May 2016 05:40:38 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3183/</guid><description>
hdu3183题目链接
题意：n位长的数字串（n&amp;lt;=1000),删掉m个（m&amp;lt;=n），使得剩下的数字串表示的数字最小。 忽略前导0.
思路：暴力搞就可以。要注意每位数字是有一定位置的范围的。比如当前是第i位数字，后面还要取n-m-i位数字，那么第i位数字最多只能取到第k位，k=m+i,因为这样才能保证后面还有n-m-i位数字。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 13时15分44秒 File Name :code/hdu/3183.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; int ans[N]; char st[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1653: [Usaco2006 Feb]Backward Digit Sums(暴力)</title><link>https://111qqz.com/2016/04/bzoj1653/</link><pubDate>Thu, 14 Apr 2016 07:12:27 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1653/</guid><description>
1653: [Usaco2006 Feb]Backward Digit Sums Time Limit: 5 Sec Memory Limit: 64 MB Submit: 349 Solved: 258 [Submit][Status][Discuss]
Description FJ and his cows enjoy playing a mental game. They write down the numbers from 1 to N (1 &amp;lt;= N &amp;lt;= 10) in a certain order and then sum adjacent numbers to produce a new list with one fewer number. They repeat this until only a single number is left. For example, one instance of the game (when N=4) might go like this: 3 1 2 4 4 3 6 7 9 16 Behind FJ's back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number N.</description></item><item><title>BZOJ 1622: [Usaco2008 Open]Word Power 名字的能量 (暴力)</title><link>https://111qqz.com/2016/04/bzoj1622/</link><pubDate>Sun, 03 Apr 2016 18:23:10 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1622/</guid><description>
1622: [Usaco2008 Open]Word Power 名字的能量 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 462 Solved: 228 [Submit][Status][Discuss]
Description  约翰想要计算他那N(1≤N≤1000)只奶牛的名字的能量．每只奶牛的名字由不超过1000个字待构成，没有一个名字是空字体串， 约翰有一张“能量字符串表”，上面有M(1≤M≤100)个代表能量的字符串．每个字符串由不超过30个字体构成，同样不存在空字符串．一个奶牛的名字蕴含多少个能量字符串，这个名字就有多少能量．所谓“蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现（不一定一个紧接着一个）．
 所有的大写字母和小写字母都是等价的．比如，在贝茜的名字“Bessie”里，蕴含有“Be”
“sI”“EE”以及“Es”等等字符串，但不蕴含“lS”或“eB”．请帮约翰计算他的奶牛的名字的能量．
Input  第1行输入两个整数N和M，之后N行每行输入一个奶牛的名字，之后M行每行输入一个能量字符串．
Output  一共N行，每行一个整数，依次表示一个名字的能量．
Sample Input 5 3 Bessie Jonathan Montgomery Alicia Angola se nGo Ont
INPUT DETAILS:
There are 5 cows, and their names are &amp;quot;Bessie&amp;quot;, &amp;quot;Jonathan&amp;quot;, &amp;quot;Montgomery&amp;quot;, &amp;quot;Alicia&amp;quot;, and &amp;quot;Angola&amp;quot;. The 3 good strings are &amp;quot;se&amp;quot;, &amp;quot;nGo&amp;quot;, and &amp;quot;Ont&amp;quot;.
Sample Output 1 1 2 0 1</description></item><item><title>bzoj 1599: [Usaco2008 Oct]笨重的石子 (暴力)</title><link>https://111qqz.com/2016/03/bzoj1599/</link><pubDate>Thu, 31 Mar 2016 13:22:31 +0000</pubDate><guid>https://111qqz.com/2016/03/bzoj1599/</guid><description>
1599: [Usaco2008 Oct]笨重的石子 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 886 Solved: 614 [Submit][Status][Discuss]
Description 贝西喜欢棋盘游戏和角色扮演类游戏所以她说服Farmer John把她带到玩具店，在那里，她购买了三个不同的骰子，这三个质量均匀的骰子，分别有S1,S2,S3个面。(2 &amp;lt;= S1 &amp;lt;= 20; 2 &amp;lt;= S2 &amp;lt;= 20; 2 &amp;lt;= S3 &amp;lt;= 40). 贝西掷啊掷啊掷啊，想要知道出现几率最大的和是多少。 问题给出三个骰子的面数，让你求出出现几率最大的和是多少。如果有很多种和出现的几率相同，那么就输出小的那一个。
Input *第一行：三个由空格隔开的整数：s1,s2,s3
Output *第一行：所要求的解
Sample Input 3 2 3
Sample Output 5
输出详解:
这里是所有可能的情况.
1 1 1 -&amp;gt; 3 1 2 1 -&amp;gt; 4 2 1 1 -&amp;gt; 4 2 2 1 -&amp;gt; 5 3 1 1 -&amp;gt; 5 3 2 1 -&amp;gt; 6</description></item><item><title>codeforces #346 div 2 C. Tanya and Toys (暴力乱搞)</title><link>https://111qqz.com/2016/03/codeforces-346-div-2-c-tanya-and-toys-/</link><pubDate>Thu, 31 Mar 2016 08:36:59 +0000</pubDate><guid>https://111qqz.com/2016/03/codeforces-346-div-2-c-tanya-and-toys-/</guid><description>
题目链接 题意:有1E9个礼物，第i个礼物价钱是i,然后现在已经有n个不重复的礼物，a[i],m元钱，想尽可能多得买不同种类的礼物，还能买多少个。 思路：先不考虑已经买的，从1连续买到k,然后考虑子啊这个区间内已经买的，等于实际上没有花钱。 反正就是暴力搞啊搞啊。。我也不知道怎么搞。。 结果最后。。方案数为0的时候。。。最后一个答案我是单独输出的。。忘了判断了。。。所以会输出两个0.宝宝心里苦啊。。。。。。。。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 00时00分03秒 File Name :code/cf/#346/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; LL n,m; LL a[N]; LL sum[N]; set&amp;lt;LL&amp;gt;se; LL ans[N]; bool vis[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 334 B. Eight Point Sets (暴力)</title><link>https://111qqz.com/2016/03/cf334b/</link><pubDate>Thu, 31 Mar 2016 05:56:12 +0000</pubDate><guid>https://111qqz.com/2016/03/cf334b/</guid><description>
题目链接 题意：给出8个点，问能否构成一个8元素集合，使得x1/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 13时39分27秒 File Name :code/cf/problem/334B.cpp ************************************************ */
#include #include #include #include #include #include #include #include #include #include #include #include #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair
using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; pi a[N]; set&amp;lt; pi &amp;gt;se;</description></item><item><title>codeforces croc2016 A. Amity Assessment (暴力)</title><link>https://111qqz.com/2016/03/cf645a/</link><pubDate>Mon, 21 Mar 2016 14:36:49 +0000</pubDate><guid>https://111qqz.com/2016/03/cf645a/</guid><description>
题目链接 题意：2×2的格子，有三个位置分别放”A“ &amp;quot;B&amp;quot; &amp;quot;C&amp;quot; ，一个位置为空。只有和空位相邻位置上的字母能移动到空位。没有其他移动规则。现在给出两个状态。问能否互相转化。 思路： 貌似可以dfs...？但是一共才2*2，可以直接暴力枚举。 手写一种变换最多能有12种。
/* *********************************************** Author :111qqz Created Time :2016年03月19日 星期六 00时21分02秒 File Name :code/cf/croc2016/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string a,b,c,d; int kind (string a,string b) { if (a==&amp;quot;AB&amp;quot;) return 1; if (a==&amp;quot;BC&amp;quot;) return 1; if (a==&amp;quot;CA&amp;quot;) return 1; if (b==&amp;quot;AC&amp;quot;) return 1; if (b==&amp;quot;BA&amp;quot;) return 1; if (b==&amp;quot;CB&amp;quot;) return 1; return 2; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #345 div 2 B. Beautiful Paintings （暴力）</title><link>https://111qqz.com/2016/03/cf651b/</link><pubDate>Tue, 08 Mar 2016 08:40:35 +0000</pubDate><guid>https://111qqz.com/2016/03/cf651b/</guid><description>
题目链接 题意：给出一个数列，按照最好的策略排序使得a[i+1]&amp;gt;a[i]的对数尽可能多，问最多的对数是多少。 思路：类似计数排序？
/* *********************************************** Author :111qqz Created Time :2016年03月07日 星期一 17时06分48秒 File Name :code/cf/#345/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n ; int a[N]; int cnt[N]; int num[N]; int sum[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5630 Rikka with Chess （暴力 ，计数问题）</title><link>https://111qqz.com/2016/03/hdu5630/</link><pubDate>Thu, 03 Mar 2016 12:53:20 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5630/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5630 题意：nm的棋盘，相邻格子的颜色相反，每次可以翻转一个任意大小矩形的格子，问最少需要翻转多少次使得棋盘的nm个格子颜色相同。（翻转的意思是颜色反色）
思路：手写了下。。发现。。答案就是n/2+m/2. 对应的最优策略是。。翻偶数行和偶数列，都翻一遍，颜色就一样了。
/* *********************************************** Author :111qqz Created Time :2016年03月03日 星期四 20时47分47秒 File Name :code/hdu/5630.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #341 div2 A. Die Roll</title><link>https://111qqz.com/2016/02/cf621a/</link><pubDate>Mon, 01 Feb 2016 12:56:14 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621a/</guid><description>
http://codeforces.com/contest/621/problem/A
A. Wet Shark and Odd and Even
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Today, Wet Shark is given n integers. Using any of these integers no more than once, Wet Shark wants to get maximum possible even (divisible by 2) sum. Please, calculate this value for Wet Shark.
Note, that if Wet Shark uses no integers from the n integers, the sum is an even integer 0.</description></item><item><title>codeforces #341 div 2 B. Wet Shark and Bishops</title><link>https://111qqz.com/2016/02/cf621b/</link><pubDate>Mon, 01 Feb 2016 12:53:03 +0000</pubDate><guid>https://111qqz.com/2016/02/cf621b/</guid><description>
http://codeforces.com/contest/621/problem/B
B. Wet Shark and Bishops
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Today, Wet Shark is given n bishops on a 1000 by 1000 grid. Both rows and columns of the grid are numbered from 1 to 1000. Rows are numbered from top to bottom, while columns are numbered from left to right.
Wet Shark thinks that two bishops attack each other if they share the same diagonal.</description></item><item><title>uva 120 Stacks of Flapjacks</title><link>https://111qqz.com/2016/01/uva120/</link><pubDate>Mon, 25 Jan 2016 06:09:57 +0000</pubDate><guid>https://111qqz.com/2016/01/uva120/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=56
题意：给出一个长度为n的序列（无重复元素），询问经过多少次flip(i)操作，使得序列升序排列。定义flip(i)为将1到n-i+1的元素反转... 思路：先离散化，然后注意读入....
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 10时42分46秒 File Name :code/uva/120.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; string in; struct node { int value; int id; }q[N]; int pos[N]; bool cmp1(node a,node b) { return a.</description></item><item><title>codeforces 27 C. Unordered Subsequence</title><link>https://111qqz.com/2015/12/cf27c/</link><pubDate>Tue, 29 Dec 2015 12:06:06 +0000</pubDate><guid>https://111qqz.com/2015/12/cf27c/</guid><description>
http://codeforces.com/contest/27/problem/C 题意：给出一个序列，问是否存在一个disordered的子序列。。输出长度并输出组成子序列的下表（1..n）。如果有多组，输出任意一组。 disordered的意思是。。升序或者降序（不严格也可以)之外的情况。 思路： 首先我们可以知道，我们要找的子序列至少需要三个点。因为两个点怎么看都是有序的。而如果有k个点（k&amp;gt;3）组成的子序列存在。。那么机智得去掉其中一些点，可以只剩三个 ，同样满足题意。所以我们只需要找到三个点即可。如果把点以下标为横坐标，值为纵坐标花在坐标系上，就是找一个v型或者倒v型的三个点。
第二，我们可以将找三个点的问题转化成用第一个点+找两个点的问题。我们可以证明，如果解存在，那么包含第一个点的解也一定存在。我们可以用反证法证明，如果我们选了第1个点，然后从第2个点到第n个点。。我们找不到两个点与第一个点构成一个v型，那么整个序列一定是升序或者降序，无解，与前提矛盾。
**需要注意的，判断方向的时候我用了乘，可能会爆int,记得用long long **
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 19时36分55秒 File Name :code/cf/problem/27C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL a[N]; int n; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces 612 A. The Text Splitting</title><link>https://111qqz.com/2015/12/cf612a/</link><pubDate>Sun, 27 Dec 2015 09:46:17 +0000</pubDate><guid>https://111qqz.com/2015/12/cf612a/</guid><description>
http://codeforces.com/contest/612/problem/A 水题...直接枚举就好。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 22时58分26秒 File Name :code/cf/edu4/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,p,q; char st[N]; bool v[10005]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #336 div 2 A. Saitama Destroys Hotel</title><link>https://111qqz.com/2015/12/cf608a/</link><pubDate>Wed, 23 Dec 2015 18:48:03 +0000</pubDate><guid>https://111qqz.com/2015/12/cf608a/</guid><description>
http://codeforces.com/contest/608/problem/A 题意：一个电梯，从s到0层，单项，给出n个人，每个人在某时间出现在某层，问要花多长时间把所有人运到0。初始电梯在s，每下一层话费时间1，上来人不花时间。 思路：由于电梯只能是单项，那么到达某一层的时候，一定要等到把这层中最晚来的那个接走。所以排序的时候按照楼层高到低为第一关键字，等待时间长到短为第二关键字。对于同一楼层出现的，只考虑第一个即可，也就是最后出现的。需要注意的是最后接完最后一个人以后把电梯运行道0层。
/* *********************************************** Author :111qqz Created Time :2015年12月24日 星期四 00时32分24秒 File Name :code/cf/#336/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int s; struct node { int f,t; bool operator &amp;lt;(node b)const { if (f&amp;gt;b.</description></item><item><title>codeforces 466 C. Number of Ways</title><link>https://111qqz.com/2015/12/cf466c/</link><pubDate>Tue, 15 Dec 2015 13:24:50 +0000</pubDate><guid>https://111qqz.com/2015/12/cf466c/</guid><description>
http://codeforces.com/problemset/problem/466/C 题意：给定一个序列。要将序列分成三个非零的连续部分，使得三部分的和相等。问有多少中分法。 思路：首先可以知道，如果是序列的和不为3的倍数，那么一定无解，输出0.设序列的和为sum,那么每一部分的和就应该为sum/3。我们可以预处理出从1开始的和为sum/3的点（我开了数组表示前缀和。。想了下其实不用。。我只需要点的信息。。所以用一个变量表示即可），将点的下标存在p[i]里。对于每一个p[i]，我想要知道比p[i]大且补与p[i]相邻的点中，有多少个j，使得从j到n的和为sum/3。因为如果有两部分的和都为sum/3，那么剩下的那部分也一定为sum/3.然后要知道有多少个满足题意的j,我们可以从后往前扫一遍，标记从n开始往前扫，和为sum/3的点，可以用一个0,1数组表示。如果和为sum/3，那么标记为1，否则为0.然后再用一个类似前缀和的思路。再开一个数组c记录从j到n有的和为多少，也就是从j到n有多少个点满足该点到n的和为sum/3.
预处理完这些之后。只需要从前往后扫一遍p[i]，然后ans+=c[p[i]+2]即可。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 20时28分44秒 File Name :code/cf/problem/466C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int n; int a[N]; LL sum[N],rsum[N]; int p[N],rp[N]; int cnt,rcnt; int b[N]; int c[N]; LL ans; LL solve() { LL total = sum[n]; if (total%3!</description></item><item><title>codeforces 522 A. Vanya and Table</title><link>https://111qqz.com/2015/12/cf552a/</link><pubDate>Mon, 14 Dec 2015 06:44:28 +0000</pubDate><guid>https://111qqz.com/2015/12/cf552a/</guid><description>
http://codeforces.com/problemset/problem/552/A 题意：一个100*100的网格。然后给n个矩形。每个格子中填上包含这个格子的矩形的个数。最后问所有格子的和。 思路：树状数组搞得...然而..直接求所有矩形面积的和就可以啊喂。。o(n)。。。111qqz你个炒鸡大菜鸡。
/* *********************************************** Author :111qqz Created Time :2015年12月14日 星期一 14时01分14秒 File Name :code/cf/problem/552A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n; int c[N][N]; struct Point { int x1,y1,x2,y2; void input() { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x1,&amp;amp;y1); scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x2,&amp;amp;y2); } }p[N]; int lowbit( int x) { return x&amp;amp;(-x); } void update( int x,int y,int delta) { for ( int i = x ; i &amp;lt;= 105 ; i += lowbit(i)) { for ( int j = y ; j &amp;lt;= 105 ; j +=lowbit(j)) { c[i][j] +=delta; } } } int sum ( int x,int y) { int res = 0 ; for ( int i = x; i&amp;gt;= 1 ; i-=lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j-=lowbit(j)) { res += c[i][j]; // cout&amp;lt;&amp;lt;&amp;quot;res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; } } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 574B Bear and Three Musketeers</title><link>https://111qqz.com/2015/12/cf-574b/</link><pubDate>Fri, 11 Dec 2015 06:43:54 +0000</pubDate><guid>https://111qqz.com/2015/12/cf-574b/</guid><description>
http://codeforces.com/problemset/problem/574/B 题意：给定一个无相图。选出三个点，使得这三个点之间互相有边相连，且三个点的度数之和最小。 思路：暴力出奇迹。复杂度o(n2+n*m)
/* *********************************************** Author :111qqz Created Time :2015年12月09日 星期三 21时33分28秒 File Name :code/cf/problem/574B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E3+7; int n ,m; vector&amp;lt;int&amp;gt;edge[N]; int ans; bool conc[N][N]; int d[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 505 B. Mr. Kitayuta's Colorful Graph</title><link>https://111qqz.com/2015/12/cf505b/</link><pubDate>Mon, 07 Dec 2015 03:11:13 +0000</pubDate><guid>https://111qqz.com/2015/12/cf505b/</guid><description>
http://codeforces.com/contest/505/problem/B 题意；给一个图，边有颜色。给q个查询，每个查询一对点x,y。问只经过某种颜色的边使得x能到y颜色数目。 思路：存颜色的时候卡了下。。本来打算开一个二维的set用来存颜色。。。没想明白。。后来发现。。还是用vecotr就好啊。。。多开一维度vector。。或者。。vector 用 pair 都是可以的。。。因为颜色数不多。。可以暴力枚举每种颜色做一遍dfs 看只走有这条颜色的边x能否到y。。
/* *********************************************** Author :111qqz Created Time :2015年12月07日 星期一 09时52分33秒 File Name :code/cf/problem/505B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) #define pi pair&amp;lt;int ,int &amp;gt; typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m,q; vector&amp;lt;pi&amp;gt;edge[N]; bool vis[N]; void dfs (int x,int y,int col) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; col:&amp;quot;&amp;lt;&amp;lt;col&amp;lt;&amp;lt;endl; vis[x] = true; if (x==y) return; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 475 B. Strongly Connected City</title><link>https://111qqz.com/2015/12/cf475b/</link><pubDate>Mon, 07 Dec 2015 01:38:26 +0000</pubDate><guid>https://111qqz.com/2015/12/cf475b/</guid><description>
http://codeforces.com/problemset/status 题意：n行m列的道路网络。共n*m条道路。每条道路都是单向的.问从任何一个路口出发能否到达其他的任何一个路口。
思路：需要注意的是。我从A点能到达B点，不代表B也能到达A.也就是说，某些点满足可以遍历所有点是不够的，只有当所有点都满足才可以。
/* *********************************************** Author :111qqz Created Time :2015年12月07日 星期一 08时55分48秒 File Name :code/cf/problem/475B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=25; int n,m; bool vis[N][N]; char hor[N],ver[N]; bool direrror (char ch,int d) { if (ch=='v'&amp;amp;&amp;amp;d==3) return true; if (ch=='^'&amp;amp;&amp;amp;d==0) return true; if (ch=='&amp;lt;'&amp;amp;&amp;amp;d==2) return true; if (ch=='&amp;gt;'&amp;amp;&amp;amp;d==1) return true; return false; } bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m&amp;amp;&amp;amp;!</description></item><item><title>codeforces #322 div 2　D. Three Logos (枚举)</title><link>https://111qqz.com/2015/09/codeforces322div2d-threelogos/</link><pubDate>Wed, 30 Sep 2015 17:41:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces322div2d-threelogos/</guid><description>
D. Three Logos
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Three companies decided to order a billboard with pictures of their logos. A billboard is a big square board. A logo of each company is a rectangle of a non-zero area.
Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left.</description></item><item><title>HUST team contest #2 A An Industrial Spy ||poj 3842 (筛)</title><link>https://111qqz.com/2015/08/poj3842/</link><pubDate>Thu, 20 Aug 2015 15:28:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj3842/</guid><description>
蠢了。
这道题显然可以搜。。
然后自己搜索的姿势果然还是不怎么地。。
最后是蔡大神过掉的。
他的思路是枚举素数，然后把素数的各位拆开，看这些数字是否在给出的字符串中出现过。
一开始TLE掉了。
后来又预处理出来一个标记数组，如果字符串中没有数字2，那么20w+的素数就可以直接跳过去，然后A掉了。
其实因为数字的位数最多才7位。。
暴力也不是不可以。。。。
STL中求全排列的那个函数我也不是没用过。。。比赛的时候怎么就没想到==
再开个map判重
然后素数打表部分。
队友是打了个30000+行的表。。。。
说起来。。。我好像还没用C++写过筛法求素数。。。
说来惭愧啊。。。。
pascal的时候倒是写过几次呢。
再复习下。。。
http://blog.csdn.net/dinosoft/article/details/5829550
写的是快速筛。
/************************************************************************* &amp;gt; File Name: code/2015summer/0821/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月20日 星期四 22时17分14秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E7+7; using namespace std; bool not_prime[N]; int prime[N],pri_num; map&amp;lt;int,bool&amp;gt; mp; int a[N]; int ans; map&amp;lt;int,bool&amp;gt;::iterator it; char st[15]; int len; void init() { not_prime[0] =true; not_prime[1] = true; for(int i = 2;i &amp;lt; N; ++i) { if(!</description></item><item><title>codeforces 520 A. Pangram (暴力)</title><link>https://111qqz.com/2015/08/codeforces520a-pangram/</link><pubDate>Sun, 16 Aug 2015 20:15:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces520a-pangram/</guid><description>
给一个字符串，问这个字符串中是否26个字母都出现过（大小写只出现一个就算出现过） 开个布尔数组，扫一遍即可。 嘛，做两道水题放松下== 反正也是要清的。
/************************************************************************* &amp;gt; File Name: code/cf/#295/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 04时05分12秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; bool v[30]; int main() { int n; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); memset(v,false,sizeof(v)); string st; cin&amp;gt;&amp;gt;st; for ( int i = 0 ; i &amp;lt; n ; i ++) { if (islower(st[i])) { v[st[i]-'a'] = true; } else { v[st[i]-'A'] = true; } } for ( int i = 0 ; i &amp;lt; 26 ; i++) { if (!</description></item><item><title>codeforces 569 C Primes or Palindromes? (暴力)</title><link>https://111qqz.com/2015/08/codeforces569/</link><pubDate>Fri, 14 Aug 2015 21:41:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces569/</guid><description>
先预处理出来比小于等于n的素数的个数和回文数的个数...
素数不筛竟然也可以过
然后暴力就好.
需要注意的是,比值并不单调,找最大的n,可能之前某个数开始不满足条件,之后又有满足条件的了.
我们可以倒着扫来找,第一个满足条件的就是最大的.
/************************************************************************* &amp;gt; File Name: code/cf/#315/C.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月11日 星期二 00时54分13秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E6+5; int f[N],g[N]; bool prime( int x) { if (x==1) return false; if (x&amp;lt;=3) return true; for ( int i = 2 ; i*i&amp;lt;=x ; i ++) { if (x%i==0) return false; } return true; } bool pal( int x) { int a[100]; int len=0; while(x) { len++; a[len]=x; x = x/ 10; } for ( int i = 1 ;i &amp;lt;= len/2 ; i++) { if (a[i]!</description></item><item><title>codeforces #314 A. Lineland Mail</title><link>https://111qqz.com/2015/08/cf314a/</link><pubDate>Wed, 05 Aug 2015 18:51:00 +0000</pubDate><guid>https://111qqz.com/2015/08/cf314a/</guid><description>
给一个有序序列，问对于没一个数，和它相差最少和最多的数的位置。
/************************************************************************* &amp;gt; File Name: code/cf/#314/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月06日 星期四 00时01分51秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E5+7; LL a[N]; int main() { int n; cin&amp;gt;&amp;gt;n; a[0]=-inf; a[n+1]=inf; for ( int i = 1 ; i &amp;lt;= n ; i ++ ) { cin&amp;gt;&amp;gt;a[i]; } int mx = -1; int mi = inf; cout&amp;lt;&amp;lt;a[2]-a[1]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;a[n]-a[1]&amp;lt;&amp;lt;endl; for ( int i = 2 ; i &amp;lt;= n-1 ; i++ ) { cout&amp;lt;&amp;lt;min(abs(a[i]-a[i-1]),abs(a[i+1]-a[i]))&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;max(abs(a[i]-a[1]),abs(a[n]-a[i]))&amp;lt;&amp;lt;endl; } cout&amp;lt;&amp;lt;a[n]-a[n-1]&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;a[n]-a[1]&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>(bc #45) A - Dylans loves numbers (hdu 5272)</title><link>https://111qqz.com/2015/07/bc45a-dylanslovesnumbershdu5272/</link><pubDate>Wed, 29 Jul 2015 06:28:00 +0000</pubDate><guid>https://111qqz.com/2015/07/bc45a-dylanslovesnumbershdu5272/</guid><description>
快要炸了..
tle成狗
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2015/07/bc45a-dylanslovesnumbershdu5272/https://111qqz.com/wp-content/uploads/2015/11/291423556423808.png
Disk path: /content/post/ACM-ICPC/https://111qqz.com/wp-content/uploads/2015/11/291423556423808.png
Using Page Bundles: true
因为是tle,看了下自己没有写cin cout,估计就是算法的问题...
我是先存了二进制的每一位到数组,然后扫一遍...
嗯,这都tle...
那我不存不扫,直接记录当前二进制位和之前二进制位..
logn的复杂度总可以了吧啊?
还TLE..........
嗯,其实已经发现 n是小于等于1e18的,没开long long
但是一位没开long long 会是wa...就没理...
之后实在黔驴技穷,改了下,竟然过了...
然后想明白了.
因为存二进制的时候有一个while
没开long long 的话就炸了,不知道读进去的是什么,while就出不来,于是就tle了.T T
果然太年轻.
1 2 3 4 /************************************************************************* 5&amp;gt; File Name: code/bc/#45/1001.cpp 6&amp;gt; Author: 111qqz 7&amp;gt; Email: rkz2013@126.com 8&amp;gt; Created Time: 2015年07月29日 星期三 13时25分01秒 9************************************************************************/ 10 11 #include&amp;lt;iostream&amp;gt;12 #include&amp;lt;iomanip&amp;gt;13 #include&amp;lt;cstdio&amp;gt;14 #include&amp;lt;algorithm&amp;gt;15 #include&amp;lt;cmath&amp;gt;16 #include&amp;lt;cstring&amp;gt;17 #include&amp;lt;string&amp;gt;18 #include&amp;lt;map&amp;gt;19 #include&amp;lt;set&amp;gt;20 #include&amp;lt;queue&amp;gt;21 #include&amp;lt;vector&amp;gt;22 #include&amp;lt;stack&amp;gt;23 #define y0 abc111qqz 24 #define y1 hust111qqz 25 #define yn hez111qqz 26 #define j1 cute111qqz 27 #define tm crazy111qqz 28 #define lr dying111qqz 29 using namespace std; 30 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 31 typedef long long LL; 32 typedef unsigned long long ULL; 33 const int inf = 0x7fffffff; 34 const int N=1E3+5; 35 int a[N]; 36 LL n,nn; 37 int main() 38 { 39 int T; 40 cin&amp;gt;&amp;gt;T; 41 while (T--) 42 { 43 scanf(&amp;#34;%lld&amp;#34;,&amp;amp;n); 44 nn = n ; 45 int k = 0; 46 while (nn) 47 { 48 k++; 49 a[k]=nn&amp;amp;1; 50 nn = nn &amp;gt;&amp;gt;1; 51 } 52 int ans = 0; 53 // for ( int i = 1 ; i &amp;lt;= k ; i++ ) 54 // cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl; 55 for ( int i = 1 ; i &amp;lt;= k ; i++ ) 56 { 57 if (a[i]==1&amp;amp;&amp;amp;a[i-1]==0) 58 ans++; 59 } 60 printf(&amp;#34;%d\n&amp;#34;,ans); 61 } 62 return 0; 63 } 64 65 66</description></item><item><title>cf 443B Kolya and Tandem Repeat</title><link>https://111qqz.com/2015/07/cf443b/</link><pubDate>Tue, 28 Jul 2015 16:07:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf443b/</guid><description>
B. Kolya and Tandem Repeat
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Kolya got string s for his birthday, the string consists of small English letters. He immediately added k more characters to the right of the string.
Then Borya came and said that the new string contained a tandem repeat of length l as a substring. How large could l be?</description></item><item><title>(BC 一周年)hdu 5311 Hidden String</title><link>https://111qqz.com/2015/07/hdu5311/</link><pubDate>Tue, 28 Jul 2015 14:22:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdu5311/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5311 题意：问能否从一个给定的字符串中拿出三个不相交的字串（原串可以有剩余），组成字符串“anniversary” 思路：暴力。
比赛的时候没做出来,sad 我发现我有一个问题,就是不敢跑暴力 有不少题其实正解就是暴力 或者有的题,暴力不是标解,但是绝对可A,可我就不敢写... 就觉得不会是这样.. 说到底还是不自信吧...
思路是枚举两个间隔点,将 string tar=&amp;quot;anniversary&amp;quot;分成三个不为空的部分 然后在给的字符串中按顺序查找这三部分 如果都能找到,直接YES 如果任何一种间隔的分段都无法YES 就NO...
妈蛋,if语句后面多写了个分号,调了半个多小时才发现(为啥总是这种傻逼错误....) 还有一点,因为是多组数据,而对于每组数据,将tar拆分的方法都是一样的,可以先预处理一下存到数组里.
1 2 #define yn hez111qqz 3 #define j1 cute111qqz 4 #define tm crazy111qqz 5 #define lr dying111qqz 6 using namespace std; 7 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 8 typedef long long LL; 9 typedef unsigned long long ULL; 10 const int N=1E2+5; 11 int d[N]; 12 int len; 13 string st,tar,s1,s2,s3; 14 bool flag; 15 16 void solve (string x,string y,string z) 17 { 18 int lx = x.</description></item><item><title>poj 3279 Fliptile (搜索..暴力？)</title><link>https://111qqz.com/2015/07/poj3279/</link><pubDate>Thu, 23 Jul 2015 14:56:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj3279/</guid><description>
http://poj.org/problem?id=3279
反转类问题.
有N*M个方格,每个上面有数字0或者1
操作一个方格,这个方格即其相邻的四个方格(有公共边)会改变状态(由0变1或者由1变0)
问至少需要多少次操作,所有的状态都为0
如果有多组,输出字典序小的那一组.
跟开关灯的那题相似.
因为每个开关灯的动作还影响其他相邻灯的状态.所以对于这种题,一般思路是,先定住一部分,再由已知定住的这部分去确定其他部分.
对于这道题而言
首先我们可以很容易发现,操作数为偶数和为0是等价的.
操作数为1和为奇数是等价的.
对于这道题而言,我们可以首先枚举第一行的状态,一共有 2&amp;lt;
然后如果 a[i-1][j]为1,因为i-1行的状态已经确定,无法改变,所以能影响到a[i-1][j]的只有a[i][j]
那么a[i][j]一定要操作一次
最后判断最后一行是否都为0,如果为0,表示这种情况是合法的
然后找到操作数最小的一组.
字典序的话,只要是枚举的时候按照数的大小顺序就可以保证.
学会了用memcpy函数.
1 2 #include&amp;lt;iostream&amp;gt;3 #include&amp;lt;iomanip&amp;gt;4 #include&amp;lt;cstdio&amp;gt;5 #include&amp;lt;algorithm&amp;gt;6 #include&amp;lt;cmath&amp;gt;7 #include&amp;lt;cstring&amp;gt;8 #include&amp;lt;string&amp;gt;9 #include&amp;lt;map&amp;gt;10 #include&amp;lt;set&amp;gt;11 #include&amp;lt;queue&amp;gt;12 #include&amp;lt;vector&amp;gt;13 #include&amp;lt;stack&amp;gt;14 #define y0 abc111qqz 15 #define y1 hust111qqz 16 #define yn hez111qqz 17 #define j1 cute111qqz 18 #define tm crazy111qqz 19 #define lr dying111qqz 20 using namespace std; 21 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 22 typedef long long LL; 23 typedef unsigned long long ULL; 24 const int N=20; 25 int a[N][N],ans[N][N],op[N][N]; 26 int m,n; 27 int dirx[10]={0,0,0,-1,1}; 28 int diry[10]={0,1,-1,0,0}; 29 int rec[N][N]; 30 void solve(int x,int y) 31 { 32 for ( int i = 0 ; i &amp;lt; 5 ; i++ ) 33 { 34 int newx = x + dirx[i]; 35 int newy = y + diry[i]; 36 if (newx&amp;gt;=1&amp;amp;&amp;amp;newx&amp;lt;=m&amp;amp;&amp;amp;newy&amp;gt;=1&amp;amp;&amp;amp;newy&amp;lt;=n) 37 { 38 a[newx][newy]=a[newx][newy]^1; 39 } 40 } 41 } 42 bool on (int x,int y) 43 { 44 int res = a[x][y]; 45 for ( int i = 0 ; i &amp;lt; 5 ; i++ ) 46 { 47 int newx = x + dirx[i]; 48 int newy = y + diry[i]; 49 if (newx&amp;gt;=1&amp;amp;&amp;amp;newx&amp;lt;=m&amp;amp;&amp;amp;newy&amp;gt;=1&amp;amp;&amp;amp;newy&amp;lt;=n) 50 { 51 res = res+op[newx][newy]; 52 } 53 54 } 55 return res&amp;amp;1; 56 } 57 int main() 58 { 59 cin&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n; 60 int mi = 9999999; 61 memset(rec,0,sizeof(rec)); 62 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 63 { 64 for (int j = 1 ; j &amp;lt;= n ; j++) 65 { 66 cin&amp;gt;&amp;gt;a[i][j]; 67 } 68 } 69 bool flag = false; 70 for ( int i = 0 ; i &amp;lt; (1&amp;lt;&amp;lt;n); i++ ) //枚举第一行的好改变情况 71 { 72 int tmp=i; 73 int num=0; 74 memset(op,0,sizeof(op)); 75 memset(ans,0,sizeof(ans)); 76 int k = n; 77 while (tmp) 78 { 79 op[1][k]=tmp%2; 80 if (op[1][k]==1) num++; 81 tmp = tmp / 2; 82 k--; 83 } 84 // cout&amp;lt;&amp;lt;&amp;#34;********************&amp;#34;&amp;lt;&amp;lt;endl; 85 // for ( int i = 1 ; i &amp;lt;= n ; i++) 86 // { 87 // cout&amp;lt;&amp;lt;op[1][i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; 88 // } 89 // cout&amp;lt;&amp;lt;endl; 90 // cout&amp;lt;&amp;lt;&amp;#34;*************************&amp;#34;&amp;lt;&amp;lt;endl; 91 92 93 for ( int j = 2 ; j &amp;lt;= m ; j++ ) 94 { 95 for ( int k = 1 ; k &amp;lt;= n ; k++ ) 96 { 97 if (on(j-1,k)) 98 { 99 op[j][k]=1; 100 num++; 101 } 102 } 103 } 104 bool ok = true; 105 for ( int j = 1 ; j &amp;lt;= n ; j++ ) 106 { 107 if (on(m,j)) 108 { 109 ok=false; 110 break; 111 } 112 } 113 if (ok) 114 { 115 flag = true; 116 if (num&amp;lt;mi) 117 { 118 mi = num; 119 memcpy(rec,op,sizeof(op)); 120 // for ( int j = 1 ; j &amp;lt;= m ; j ++ ) 121 // { 122 // for ( int k = 1 ; k &amp;lt;= n ; k++ ) 123 // { 124 // rec[j][k]=ans[j][k]; 125 // } 126 // } 127 } 128 } 129 } 130 if (flag) 131 { 132 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 133 { 134 cout&amp;lt;&amp;lt;rec[i][1]; 135 for ( int j = 2 ; j &amp;lt;= n ; j++ ) 136 { 137 cout&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;rec[i][j]; 138 } 139 cout&amp;lt;&amp;lt;endl; 140 } 141 } 142 else 143 { 144 printf(&amp;#34;IMPOSSIBLE\n&amp;#34;); 145 } 146 147 return 0; 148 } 149</description></item><item><title>codeforces 558c Amr and Chemistry (贪心)</title><link>https://111qqz.com/2015/07/cf558c/</link><pubDate>Tue, 21 Jul 2015 03:00:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf558c/</guid><description>
http://codeforces.com/contest/558/problem/C
题目大意是说，给定N个数，可以对任意数进行任意次两种操作，×2，和/2（整除）
问最少操作多少次，可以让所有数相等。
嘛，前半个小时A掉了前两个提，d E貌似都是线段树。。并不会。。。就一直搞C。。。。
然而并没有做出来。位运算是什么神奇的黑魔法。
转载一份题解：http://blog.csdn.net/qq_24451605/article/details/46906813
思路是声明两个数组，一个数组表示到达i的步数，另一个数组表示n个数中能够达到i的数的个数（包括本身）
1 2 /************************************************************************* 3&amp;gt; File Name: code/#312C.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: Mon 20 Jul 2015 11:36:50 PM CST 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 using namespace std; 22 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 23 typedef long long LL; 24 typedef unsigned long long ULL; 25 const int N= 1E5+7; 26 const int inf = 0x7fffffff; 27 int a[N]; 28 int vis[N],step[N]; 29 bool cmp (int a,int b) 30 { 31 if (a&amp;gt;b) return true; 32 return false; 33 } 34 int main() 35 { 36 int n; 37 cin&amp;gt;&amp;gt;n; 38 int mx = -1; 39 memset(vis,0,sizeof(vis)); 40 memset(step,0,sizeof(step)); 41 42 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 43 { 44 cin&amp;gt;&amp;gt;a[i]; 45 if (a[i]&amp;gt;mx) 46 mx = a[i]; 47 } 48 for ( int i = 1 ; i &amp;lt;= n ; i++ )f 49 { 50 int tmp = a[i]; 51 int num = 0; 52 while (tmp&amp;lt;=mx) 53 { 54 step[tmp]+=num; //到达tmp需要的操作数是之前的数到达tmo的操作数加上当前 55 vis[tmp]++; //能够到达i的数的个数存在vis数组 56 num++; 57 tmp = tmp &amp;lt;&amp;lt; 1; 58 } 59 num = 0; 60 int tmpa = a[i]; 61 while (tmpa) 62 { 63 if (tmpa&amp;amp;1&amp;amp;&amp;amp;tmpa!</description></item><item><title>codeforces 548B Mike and Fun</title><link>https://111qqz.com/2015/05/cf548b/</link><pubDate>Wed, 27 May 2015 14:45:00 +0000</pubDate><guid>https://111qqz.com/2015/05/cf548b/</guid><description>
http://codeforces.com/problemset/problem/548/B
比赛的时候不懂为什么就没做出来.... 其实很容易想到一个o(q*(n+m))的做法... 就是每次更新，要同时更新当前更新行的最大连续和....O（m）可以完成...然后在O（n）扫一遍，找到所有行中的最大值。 然后需要注意的是，在第一次更改之前就要把每个行的最大值处理出来l.. 然后cf机器真是够快，O(nmq)的1.2S过。。。。
1 2 3 4 5 6 7 8 /* *********************************************** 9Author :111qqz 10Created Time :2016年02月19日 星期五 17时01分58秒 11File Name :code/cf/problem/548B.cpp 12************************************************ */ 13 14 #include &amp;lt;algorithm&amp;gt;15 #include &amp;lt;cstdio&amp;gt;16 #include &amp;lt;iostream&amp;gt;17 #include &amp;lt;cstring&amp;gt;18 #include &amp;lt;string&amp;gt;19 #include &amp;lt;cmath&amp;gt;20 #include &amp;lt;map&amp;gt;21 22 using namespace std; 23 const int N=5E2+5; 24 int a[N][N]; 25 int fans; 26 int n,m,q,x,y,cur,ans[N]; 27 int main() 28 { 29 cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;q; 30 for (int i = 1 ; i &amp;lt;= n;i++ ) 31 { 32 for (int j = 1; j &amp;lt;= m ; j++ ) 33 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i][j]); 34 cur = 0; 35 for (int j = 1; j &amp;lt;=m ;j++ ) 36 if (a[i][j]==1) 37 { 38 cur++; 39 ans[i]=max(cur,ans[i]); 40 } 41 else 42 { 43 cur = 0; 44 } 45 } 46 for ( int i = 1 ; i &amp;lt;= q; i++ ) 47 { 48 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;x,&amp;amp;y); 49 a[x][y]=a[x][y]^1; 50 // if (i==3) cout&amp;lt;&amp;lt;a[x][y]&amp;lt;&amp;lt;&amp;#34;sadsadasd&amp;#34;&amp;lt;&amp;lt;endl; 51 cur = 0; 52 ans[x]=0; 53 for (int j = 1; j &amp;lt;=m ;j++ ) 54 if (a[x][j]==1) 55 { 56 cur++; 57 ans[x]=max(cur,ans[x]); 58 } 59 else 60 { 61 cur = 0; 62 } 63 fans=-1; 64 for (int j = 1;j &amp;lt;= n ; j++ ) 65 if (ans[j]&amp;gt;fans) 66 { 67 fans=ans[j]; 68 } 69 cout&amp;lt;&amp;lt;fans&amp;lt;&amp;lt;endl; 70 } 71 72 73 return 0; 74 } 75 76 77</description></item></channel></rss>