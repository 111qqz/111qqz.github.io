<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nms on 111qqz的小窝</title><link>http://example.org/tags/nms/</link><description>Recent content in nms on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 16 Mar 2018 02:56:14 +0000</lastBuildDate><atom:link href="http://example.org/tags/nms/index.xml" rel="self" type="application/rss+xml"/><item><title>非极大值抑制（Non-Maximum Suppression，NMS）</title><link>http://example.org/2018/03/non-maximum-suppression/</link><pubDate>Fri, 16 Mar 2018 02:56:14 +0000</pubDate><guid>http://example.org/2018/03/non-maximum-suppression/</guid><description>NMS是为了在诸多CV任务如边缘检测，目标检测等，找到局部最大值
其主要思想是先设定一个阈值，然后计算检测框的IOU(所谓IOU，也就是intersection-over-union，指的是相交面积除以相并面积，是来衡量overlap程度的指数）。如果IOU大于阈值，说明overlap过大，我们要通过某种算法来将其剔除。
比如下图，在经典的人脸识别任务中，出现了多个检测框，每个检测框有一个置信度confidence，我们通过某个算法，保留一个最好的。
顺便说一下算法的实现步骤把，其实不太重要。就是贪心。
* 首先，计算每一个 bounding box 的面积： * (x1, y1) ⇒ 左上点的坐标，(x2, y2) ⇒ 右下点的坐标； * (x2-x1+1)x(y2-y1+1) * 根据 scores 进行排序（一般从小到大），将 score 最大的bounding box置于队列，接下来计算其余 bounding box 与当前 score 最大的 bounding box 的 IoU，抑制（忽略也即去除）IoU大于设定阈值的 bounding box； * 重复以上过程，直至候选 bounding boxes 为空； 最后上一段python代码吧&amp;hellip;也很简单，直接转载了别人的&amp;hellip;
def nms(dets, thresh): x1 = dets[:, 0] y1 = dets[:, 1] x2 = dets[:, 2] y2 = dets[:, 3] scores = dets[:, 4] areas = (x2 - x1 + 1) * (y2 - y1 + 1) # 每个boundingbox的面积 order = scores.</description></item></channel></rss>