<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>尺取 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%B0%BA%E5%8F%96/</link><description>Recent content in 尺取 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 25 Sep 2015 05:27:00 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%B0%BA%E5%8F%96/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 2739 Sum of Consecutive Prime Numbers (尺取法)</title><link>https://111qqz.com/2015/09/poj2739/</link><pubDate>Fri, 25 Sep 2015 05:27:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2739/</guid><description>
一开始迷之wa...
先找出素数下标的上界就可以A...
然后纠结了２０分钟．．．
然后发现是预处理的素数少了一个素数．．
我预处理是处理到＜１０００５的素数．．．
最大数１００００,而超过１００００的第一个素数是１０００７
这样判断终止条件就会死循环...
sad
/************************************************************************* &amp;gt; File Name: code/poj/2739.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月25日 星期五 01时32分43秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; int pri[10005]; int n ; int mx; bool prime ( int n) { if (n&amp;lt;=3) return true; for ( int i = 2 ; i*i&amp;lt;= n ; i++) { if (n%i==0) return false; } return true; } void solve() { int head = 1; int tail = 1; int sum = 0 ; int ans = 0 ; while (pri[tail]&amp;lt;=n) { cout&amp;lt;&amp;lt;&amp;quot;asd&amp;quot;&amp;lt;&amp;lt;endl; sum = sum + pri[tail]; if (sum&amp;gt;=n) { while (sum&amp;gt;n) { sum = sum - pri[head]; head++; } if (sum==n) { ans++; } } tail++; } printf(&amp;quot;%d\n&amp;quot;,ans); } int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;in.</description></item><item><title>poj 2100 Graveyard Design (two pointers ，尺取法)</title><link>https://111qqz.com/2015/09/poj2100/</link><pubDate>Thu, 24 Sep 2015 17:29:00 +0000</pubDate><guid>https://111qqz.com/2015/09/poj2100/</guid><description>
不多说，直接代码。
/************************************************************************* &amp;gt; File Name: code/poj/2100.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月25日 星期五 00时42分49秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; LL n; LL maxn; vector&amp;lt;LL&amp;gt;ans; void solve() { LL head = 1,tail = 1; LL sum = 0 ; while (tail&amp;lt;=maxn) { sum = sum + tail*tail; if (sum&amp;gt;=n) { while (sum&amp;gt;n)//主要是while，因为可能要减掉多个才能小于n { sum -= head*head; head++; } if (sum==n) {//因为要先输出答案个数.</description></item></channel></rss>