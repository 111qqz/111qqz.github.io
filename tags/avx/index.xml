<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>avx on 111qqz的小窝</title><link>http://example.org/tags/avx/</link><description>Recent content in avx on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 22 Jul 2021 20:01:50 +0800</lastBuildDate><atom:link href="http://example.org/tags/avx/index.xml" rel="self" type="application/rss+xml"/><item><title>一次avx2在gcc上core dump的排查经历</title><link>http://example.org/2021/07/core-dump-on-gcc-4-with-avx2/</link><pubDate>Thu, 22 Jul 2021 20:01:50 +0800</pubDate><guid>http://example.org/2021/07/core-dump-on-gcc-4-with-avx2/</guid><description>背景 起因是同事在实现int4的功能，结果流水线有一条死活过不了(gcc版本为4.8.5),一直core dump 经过初步排查，找出了如下最小可以复现的代码:
#include &amp;lt;immintrin.h&amp;gt; class Test{ public: Test(){ tmp = _mm256_set_epi32(0,0,0,0,0,0,0,0); } private: __m256i tmp; }; int main(){ auto *tmp = new Test(); return 0; } gcc版本为4.8.5 其中编译选项为
g++ -std=c++11 -mavx2 a.cpp 现象为会core在 tmp = _mm256_set_epi32(0,0,0,0,0,0,0,0);
但是同样的代码，同样的编译选项，在gcc7.3上就不会发生core的问题。
初步排查 查看汇编代码,gcc4.8.5生成的如下:
main: push rbp mov rbp, rsp mov edi, 32 call operator new(unsigned long) vpxor xmm0, xmm0, xmm0 vmovdqa YMMWORD PTR [rax], ymm0 mov eax, 0 pop rbp ret 链接在这里</description></item></channel></rss>