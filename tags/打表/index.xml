<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>打表 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%89%93%E8%A1%A8/</link><description>Recent content in 打表 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 02 Nov 2017 02:33:54 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%89%93%E8%A1%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>HDU 5970 | 2016 CCPC HeFei onsite J 最大公约数 (打表找规律)</title><link>https://111qqz.com/2017/11/hdu5970/</link><pubDate>Thu, 02 Nov 2017 02:33:54 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu5970/</guid><description>
题意： 有这样一个有关最大公约数的函数: 函数 f(x, y):
{ c=0 当 y&amp;gt;0: { c +=1 t = x % y x = y y = t } 返回 c * x * x } 给出三个正整数n,m,p，你需要计算:
$$ \sum_{i=1}^{n} \sum_{j=1}^{m} \left \lfloor \frac{i*j}{f(i,j))} \right \rfloor $$
n &amp;lt;= 666,666,666, m &amp;lt;= 666, p &amp;lt;= 666,666,666。
思路： 打表找规律。
但是找规律也要按照基本法
观察到m比较小，对于固定的j,容易看出f(i,j)和f(i+j*k,k)是等价的。
比赛的时候没做出来，因为纠结取整的问题...
解决办法竟然是....通过循环节观察orz
转载一篇靠谱的题解：
一开始，我自己假设先不考虑c。那么就变成了ΣΣi/gcd*j/gcd=Σj/gcd*Σi/gcd，如此一来，由于m比较小，我就可以枚举j，然后对应求出j所有的因子作为gcd，gcd确定之后再根据容斥来统计i/gcd的和。具体统计方法和15年沈阳regional的frog那题类似，用n的因子来进行暴力的容斥。但是很显然这样子很难把c的影响带进来，而且这里的c还要向下取整，更加的麻烦。 于是打表找规律，首先很容易知道f(i,j)=f(i+kj,j)。根据这个，在不考虑向下取整的情况下，对于同一个j，我们就可以列出一个等差数列，其中首项是ij/f(i,j)，公差为jj/f(i,j)。但是这里要考虑这个向下取整。我们设i为模9为7的数j为9，可以打出如下i*j/f(i,j)的表，括号内为相邻值的差：
可以发现，每c组i*j/f(i,j)是一个循环节，也就是说可以看作c个等差数列，然后对于每一个等差数列，它的首项我们可以暴力算出，而公差也很容易求出。利用等差数列求和公式可以很快速的计算出结果。复杂度的话，我们需要枚举j和在j剩余系下的i，然后还有c个等差数列，复杂度为O(m^2logN)在接受范围之内。具体见代码：
以及。。膜真的很浪费生命啊？
一开始取了5个%，TLE,4个%,50%概率AC,3个%就比较稳得过了...
一个%大概300ms orz
/* *********************************************** Author :111qqz Created Time :2017年11月02日 星期四 09时38分56秒 File Name :5970.</description></item><item><title>今日头条笔试题_或与加(打表,构造)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-03/</link><pubDate>Thu, 30 Mar 2017 03:04:06 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-03/</guid><description>
给定 x, k ，求满足 x + y = x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。
比如当 x=5，k=1时返回 2，因为5+1=6 不等于 5|1=5，而 5+2=7 等于 5 | 2 = 7。
输入描述: 每组测试用例仅包含一组数据，每组数据为两个正整数 x , k。 满足 0 &amp;lt; x , k ≤ 2,000,000,000。
输出描述: 输出一个数y。
输入例子: 5 1 输出例子: 达标2 一看就是数学题...? 打表观察...
1 0000001 2 0000010 3 0000011 4 0000100 5 0000101 6 0000110 7 0000111 8 0001000 9 0001001 10 0001010 11 0001011 12 0001100 13 0001101 14 0001110 15 0001111 16 0010000 17 0010001 18 0010010 19 0010011 20 0010100 21 0010101 22 0010110 23 0010111 24 0011000 25 0011001 26 0011010 27 0011011 28 0011100 29 0011101 30 0011110 31 0011111 32 0100000 33 0100001 34 0100010 35 0100011 36 0100100 37 0100101 38 0100110 39 0100111 40 0101000 41 0101001 42 0101010 43 0101011 44 0101100 45 0101101 46 0101110 47 0101111 48 0110000 49 0110001 50 0110010 51 0110011 52 0110100 53 0110101 54 0110110 55 0110111 56 0111000 57 0111001 58 0111010 59 0111011 60 0111100 61 0111101 62 0111110 63 0111111 64 1000000 65 1000001 66 1000010 67 1000011 68 1000100 69 1000101 70 1000110 71 1000111 72 1001000 73 1001001 74 1001010 75 1001011 76 1001100 77 1001101 78 1001110 79 1001111 80 1010000 81 1010001 82 1010010 83 1010011 84 1010100 85 1010101 86 1010110 87 1010111 88 1011000 89 1011001 90 1011010 91 1011011 92 1011100 93 1011101 94 1011110 95 1011111 96 1100000 97 1100001 98 1100010 99 1100011 100 1100100 发现如果x的二进制表示中,如果某位为1,那么对应的y的位置上一定为0.</description></item></channel></rss>