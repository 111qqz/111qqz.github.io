<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dfs on Clarity</title><link>https://111qqz.com/tags/dfs/</link><description>Recent content in dfs on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sun, 30 Jul 2017 17:45:18 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/dfs/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3078 Network (LCA)</title><link>https://111qqz.com/2017/07/hdu-3078/</link><pubDate>Sun, 30 Jul 2017 17:45:18 +0000</pubDate><guid>https://111qqz.com/2017/07/hdu-3078/</guid><description>
题目链接
题意： 一棵树，给出点权，问一条树链上第k大的点权，点权可以动态修改。
思路： 暴力即可orz(数据是真的水啊。
求路径上的点的时候需要用到LCA
/* *********************************************** Author :111qqz Created Time :2017年07月31日 星期一 01时12分54秒 File Name :3078.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=8E4+7; int n,q; int val[N]; vector &amp;lt; pi &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int fa[N]; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; fa[u] = pre; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>codeforces #425 D. Misha, Grisha and Underground (dfs+rmq在线求LCA,讨论了一年)</title><link>https://111qqz.com/2017/07/codeforces-div2-425d/</link><pubDate>Sun, 30 Jul 2017 12:05:30 +0000</pubDate><guid>https://111qqz.com/2017/07/codeforces-div2-425d/</guid><description>
题目链接
题意： 给出一棵树，以及三个点（可能重合），问两两组成的3条路径中，哪2条路径重合部分最长。
思路： LCA还是一下就能想到的，rmq+dfs在线求。
然后我开始分情况讨论，讨论了一年也没讨论完，哭哭
结论是：求出三个lca，并取深度最大的那个，就是我们要的三岔路口K，然后分别求出K到a，b，c三点的路径长度，取最大值+1就是答案。
所以我的问题在于，没有试图往一般性的方向考虑，以为讨论一下就可以了...
这大概就是所谓的猜结论？
感性的理解的话，LCA越深，意味着另一个点到LCA的距离越远，也就是相交的路径越长
但是我的话，估计还是很难在短短不到一个小时内得出这样一般性的结论orz...
这大概就是数学方面的天赋差距把...T T
/* *********************************************** Author :111qqz Created Time :2017年07月30日 星期日 15时12分34秒 File Name :D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,q; vector &amp;lt; pi &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>leetcode 39. Combination Sum (dfs，求所有的组合，和为定值，每个数可以重复用)</title><link>https://111qqz.com/2017/04/leetcode-39-combination-sum/</link><pubDate>Thu, 13 Apr 2017 02:47:49 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-39-combination-sum/</guid><description>
Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
The same repeated number may be chosen from C unlimited number of times.
Note:
* All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations. 题意：给n个数，求所有的组合，和为定值，每个数可以重复用)
思路：。。。。一开始用顺着枚举子集的思路。。。发现。。并不好搞。。。？还不如直接dfs...
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 00时06分12秒 File Name :39.</description></item><item><title>leetcode 79. Word Search (dfs)</title><link>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</link><pubDate>Fri, 07 Apr 2017 06:59:26 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</guid><description>
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;quot;adjacent&amp;quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
思路：dfs即可。记得要回溯一下...
/* *********************************************** Author :111qqz Created Time :2017年04月07日 星期五 14时32分54秒 File Name :79.cpp ************************************************ */ class Solution { public: int n,m; const int dx4[4]={1,-1,0,0}; const int dy4[4]={0,0,-1,1}; bool vis[1005][1005]; int len; bool yes( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;=n-1&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;=m-1) return true; return false; } bool dfs( int x,int y,int cur,vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt; &amp;amp; maze,string &amp;amp; st) { // printf(&amp;quot;x:%d y:%d cur : %d\n&amp;quot;,x,y,cur); if (cur&amp;gt;=len) return true; for ( int i = 0 ; i &amp;lt; 4 ; i++) { int nx = x + dx4[i]; int ny = y + dy4[i]; if (!</description></item><item><title>codeforces #375 D. Lakes in Berland (dfs)</title><link>https://111qqz.com/2016/10/cf375d/</link><pubDate>Mon, 03 Oct 2016 18:03:37 +0000</pubDate><guid>https://111qqz.com/2016/10/cf375d/</guid><description>
题目链接
题意：nm个格子，有和.两种类型。定义一个湖为边相邻的只有.组成的最大点集合，且任何一个.不在边界上。现在给出一个nm的图保证至少有k个湖。问填多少个.成，才能使得恰好有k个湖。
思路：贪心，先处理出所有的湖的大小，然后从小往大填。
注意dfs的时候如果某个“可能”的湖遇到了边界，要把之前打的标记撤销掉。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 21时18分03秒 File Name :code/cf/#375/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0};tanxin const int inf = 0x3f3f3f3f; const int N=55; char maze[N][N]; int n,m,k; int vis[N][N]; int lake_cnt=0; int siz; struct node { int id; int val; bool operator &amp;lt; (node b)const { return val&amp;lt;b.</description></item><item><title>codeforces 27 E. Number With The Given Amount Of Divisors (dfs，反素数（假）)</title><link>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</link><pubDate>Wed, 21 Sep 2016 09:02:26 +0000</pubDate><guid>https://111qqz.com/2016/09/codeforces-27-e-number-with-the-given-amount-of-divisors-dfs/</guid><description>
题目链接
题意：求约数个数恰好为n个的最小的x
思路：这道题是作为反素数的例题出现在acdreamer的博客里的。
但是实际上，这道题应该和反素数没有关系。
如果题目问的是最小的约数个数大于等于n的x，那么答案一定是反素数...打表就行了。。。
但是问的是**恰好，**比如如果n为5，那么最小的x是16，但是x不是反素数。
所以其实就是个dfs啦。
理论依据是：
一个数 A 可以分解成 p1k1 * p2k2 * …… * pnkn 其中p为素数。这样分解之后，A的因子个数
S = （k1+1） *（ k2+1） * …… *（ kn+1）
以及要找的是一个最小的x，满足约数个数等于n。
那么关于反素数的两个性质依然是满足的：
（1）一个反素数的所有质因子必然是从2开始的连续若干个质数，因为反素数是保证约数个数为![](http://img.blog.csdn.net/20140505150741093) 的这个数![](http://img.blog.csdn.net/20140505145329656) 尽量小 （2）同样的道理，如果 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://img.blog.csdn.net/20140505151209203
Disk path: /static/http://img.blog.csdn.net/20140505151209203
Using Page Bundles: false
，那么必有 Image not found a.</description></item><item><title>hdu 3336 Count the string （nxt函数的运用kmp+（dfs|dp )）</title><link>https://111qqz.com/2016/08/hdu3336/</link><pubDate>Fri, 12 Aug 2016 05:33:08 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu3336/</guid><description>
hdu 3336 题目链接
题意：给一个字符串，问这个字符串的所有前缀的出现次数的和。
思路：这道题需要完全理解nxt函数是干嘛的。。nxt[i]表示的是字符串的0..i-1位中，前缀和后缀相等的串的最长长度为nxt[i]
这东西对于这道题有什么用呢？
举个例子，对于字符串ababa：
s a b a b a i 0 1 2 3 4 5 next[i] -1 0 0 1 2 3
ans初始为len(因为长度为len的字符串有len个前缀，每个前缀至少出现一次) next[3] = 1，ans + 1 = 6，next[1] = 0 next[4] = 2，ans + 1 = 7，next[2] = 0 next[5] = 3，ans + 1 = 8，next[3] = 1，ans + 1 = 9
首先，我们不是很关心nxt[i]具体的值，只关心nxt[i]是否大于0.如果大于0，比如对于nxt[3]==1，说明字符串0..2位置中，存在一个后缀和前缀相等，因此答案+1.
其次，其实我们仍然关心nxt[i]具体的值，对于nxt[5]==3，具体对应的含义是有后缀“aba”和前缀“aba”相等
但是这就完了吗？因为nxt[3]仍然大于0，对应“aba&amp;quot;中有一个前缀”a“和后者”a“相等。。。你可能要问。。这个不是刚刚算过了吗。。。然而这里其实算的是字符串2..4的”aba&amp;quot;。
看到有人说这是dp...不是很懂dp做法是什么鬼。。。
忘记取模wa了一发。。智力-2.
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 12时59分12秒 File Name :code/hdu/3336.</description></item><item><title>poj 3310 Caterpillar (树的直径+并查集判环+dfs判断连通性)</title><link>https://111qqz.com/2016/07/poj-3310/</link><pubDate>Wed, 13 Jul 2016 06:21:41 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-3310/</guid><description>
poj3310 题目链接
题意：给出一个无向图。。。问是否满足。。联通，并且无环，并且能找到一条路径，图中所有的顶点要么在这条路径上，要么与这条路径上的顶点相邻。
思路：一个一个来。。。联通的话任意起点开始跑一遍dfs? 开一个bool数组标记走过的点。。最后扫一遍。。看是否有点没走过
环的话并查集就好。。
关键是第三个条件。。。根据题中题中的例子。。感觉如果存在这样的路径。。。那么这样的路径应该尽可能长？
于是想到求直径。。。然后在bfs的时候顺便记录路径。。。这样我就知道直径是哪些点。。。然后对于所有点。。判断是否在这条直径上或者与之相邻就好。。。
具体做法是。。。开了一个bool数组ok标记直径上的点。。。在存边的时候用一个to[]数组表示相连。。。to[u]=v,to[v]=u...
然后只要ok[i]或者ok[to[i]]满足其一就好。。。
又是1A，蛤蛤蛤蛤蛤，我好神啊（误
/* *********************************************** Author :111qqz Created Time :2016年07月12日 星期二 20时27分28秒 File Name :code/poj/3310.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; int n,m; vector &amp;lt; int &amp;gt;edge[N]; int f[N]; bool vis[N]; bool die; int d[N]; int to[N]; int pre[N];//记录最长的路径。。。 int lst,beg; bool ok[N]; struct Edge { int u,v; }e[N]; void init() { ms(to,-1); ms(pre,-1); ms(vis,false); //for dfs ms(ok,false); for ( int i = 1 ; i &amp;lt;= n ; i++) f[i] = i; for ( int i = 1 ; i &amp;lt;= n ; i++) edge[i].</description></item><item><title>hdu 3225 Flowers Placement （dfs+匈牙利算法剪枝，太神了）</title><link>https://111qqz.com/2016/05/hdu-3225/</link><pubDate>Fri, 27 May 2016 12:38:07 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-3225/</guid><description>
hdu 3225题目链接
题意：给出一个n*m的矩阵。每个格子有一个数。每行1..n必须每个出现一次。每列1..n每个数最多出现一次。现在要添加一行，并且补违反上述规则。问添加的方案中字典序第k小的方案。如果一共不足k种方案，那么输出-1.
思路：有点像八皇后。。。就是纯搜。。。不过n好大。。。这么搜会TLE...
想了半天也没思路。。。看了题解。。发现是用二分图匹配来剪枝。。
比较重要的一点是。。。
n个数的某种排列，可以看做是一个位置集合{1..n}和数字集合{1..n}的二分图最大匹配。
我们可以根据这个来剪枝。
具体做法：
**我们先求出一个完备匹配，然后搜索每个位置能够种的花，假设当前位k置种了花i,那么判断k+1--n位置能不能形成一个完备匹配（即能否种出满足条件的花），若能那么当前位置可以种该花，继续搜索，若不能这返回** 然后把一个false写了true.调了一个小时。。。。。。。。。。。。。。无语凝噎。
/* *********************************************** Author :111qqz Created Time :2016年05月27日 星期五 00时42分16秒 File Name :code/hdu/3225.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=305; bool lie[N][N]; bool hang[N]; int n,m,k; int cnt; //vector &amp;lt;int&amp;gt;ans[N]; //不用每个都存，只存第k个就好。。。前面的随便覆盖。。。 int cur[N]; int link[N],tmp[N]; bool vis[N]; bool g[N][N]; bool findgirl( int x,int limit) { if (x&amp;lt;=limit) return false;//找到的匹配位置一定要在当前的后面。 for ( int i = 1 ; i &amp;lt;= n ; i++) { if (g[x][i]&amp;amp;&amp;amp;!</description></item><item><title>poj 1470 Closest Common Ancestors (lca,rmq+dfs,读入技巧)</title><link>https://111qqz.com/2016/05/poj1470/</link><pubDate>Thu, 19 May 2016 08:42:05 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1470/</guid><description>
poj1470题目链接
题意：求两点的lca. 思路：dfs+rmq. 读入技巧。 读入比较坑爹。。。 学会了一种新的读入技巧。
scanf(&amp;quot;%2s&amp;quot;,st);
表示读一个长度为2的字符串。。。读的时候会忽略各种空白字符。
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 15时44分12秒 File Name :code/poj/1470.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=905; int n; vector &amp;lt;int&amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N]; int depth[2*N]; int p; int dp[2*N][12]; int cnt[N]; void dfs( int u,int dep) { p++; E[p] = u ; depth[p] = dep; R[u] = p; int siz = edge[u].</description></item><item><title>poj 1330 Nearest Common Ancestors (lca,用dfs+rmq在线求解)</title><link>https://111qqz.com/2016/05/poj1330/</link><pubDate>Thu, 19 May 2016 07:39:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1330/</guid><description>
poj1330题目链接
题意：给出一棵树，求两点的lca. 思路：将lca转化成rmq在线求解。
代码部分参考了：参考代码
感觉实现得很巧妙。。。 把树存成了有向图，dfs遇到的时候一定是第一次遇到，此时更新R. 然后第二次遇到某个点就是在回溯的时候了。
算法学习链接
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 15时05分31秒 File Name :code/poj/1330.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; vector &amp;lt;int&amp;gt;edge[N]; int n; int in[N]; int cur; int E[2*N]; int R[N]; int depth[2*N]; int dp[2*N][16]; void dfs ( int u,int dep) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;endl; cur++; E[cur] = u; depth[cur] = dep; R[u] = cur; //有向图存的话，在这里访问的一定是第一次经过。 int siz = edge[u].</description></item><item><title>BZOJ 1648: [Usaco2006 Dec]Cow Picnic 奶牛野餐 (dfs)</title><link>https://111qqz.com/2016/04/bzoj-1648/</link><pubDate>Mon, 11 Apr 2016 08:36:25 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1648/</guid><description>
1648: [Usaco2006 Dec]Cow Picnic 奶牛野餐 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 562 Solved: 352 [Submit][Status][Discuss]
Description The cows are having a picnic! Each of Farmer John's K (1 &amp;lt;= K &amp;lt;= 100) cows is grazing in one of N (1 &amp;lt;= N &amp;lt;= 1,000) pastures, conveniently numbered 1...N. The pastures are connected by M (1 &amp;lt;= M &amp;lt;= 10,000) one-way paths (no path connects a pasture to itself).</description></item><item><title>BZOJ1621: [Usaco2008 Open]Roads Around The Farm分岔路口 (DFS)</title><link>https://111qqz.com/2016/04/bzoj1621/</link><pubDate>Sun, 03 Apr 2016 17:58:35 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1621/</guid><description>
1621: [Usaco2008 Open]Roads Around The Farm分岔路口 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 698 Solved: 513 [Submit][Status][Discuss]
Description 约翰的N(1≤N≤1,000,000,000)只奶牛要出发去探索牧场四周的土地．她们将沿着一条路走，一直走到三岔路口（可以认为所有的路口都是这样的）．这时候，这一群奶牛可能会分成两群，分别沿着接下来的两条路继续走．如果她们再次走到三岔路口，那么仍有可能继续分裂成两群继续走． 奶牛的分裂方式十分古怪：如果这一群奶牛可以精确地分成两部分，这两部分的牛数恰好相差K(1≤K≤1000)，那么在三岔路口牛群就会分裂．否则，牛群不会分裂，她们都将在这里待下去，平静地吃草． 请计算，最终将会有多少群奶牛在平静地吃草．
Input 两个整数N和K.
Output 最后的牛群数．
Sample Input 6 2
INPUT DETAILS:
There are 6 cows and the difference in group sizes is 2.
Sample Output 3
OUTPUT DETAILS:
There are 3 final groups (with 2, 1, and 3 cows in them).
6 /
2 4 /
1 3</description></item><item><title>BZOJ1619: [Usaco2008 Nov]Guarding the Farm 保卫牧场 （BFS）</title><link>https://111qqz.com/2016/04/bzoj1619-usaco2008-novguarding-the-farm-bfs/</link><pubDate>Sun, 03 Apr 2016 17:23:04 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1619-usaco2008-novguarding-the-farm-bfs/</guid><description>
1619: [Usaco2008 Nov]Guarding the Farm 保卫牧场 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 661 Solved: 292 [Submit][Status][Discuss]
Description The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows. He wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 &amp;lt; N &amp;lt;= 700) rows and M (1 &amp;lt; M &amp;lt;= 700) columns.</description></item><item><title>hdu 5416 CRB and Tree ( 2015 多校 #10 )</title><link>https://111qqz.com/2016/02/hdu5416/</link><pubDate>Fri, 19 Feb 2016 07:05:18 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5416/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5416 题意：给出一棵树（n&amp;lt;=1E5），定义二元函数函数f(u,v) (u可以等于v)表示节点u到节点v经过的路径的权值的异或和。给出q组查询（q&amp;lt;=10），每组一个s,问有多少对无序点对（u,v）满足f(u,v)=s. 思路：类似codeforces #340 div 2 E XOR and Favorite Number 先dfs,处理出从根节点都任意节点的异或前缀和。然后对于每个询问o(n)扫一遍，统计sum[i]^s出现多少次。 总的时间复杂度为O(Tqn);
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 13时52分32秒 File Name :code/hdu/5416.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector&amp;lt;pi&amp;gt;edge[N]; int n; LL sum[N]; LL cnt[N*10]; int q; void dfs( int x,LL val) { sum[x] = val; for ( int i = 0 ; i&amp;lt; edge[x].</description></item><item><title>hdoj 5606 ||bc #68 div 2 B tree</title><link>https://111qqz.com/2016/01/hdoj5606/</link><pubDate>Sat, 02 Jan 2016 13:44:50 +0000</pubDate><guid>https://111qqz.com/2016/01/hdoj5606/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5606 题意：一棵树，边权为0或者1，问对于每个点，距离它最近的点（包括自身）的个数是多少。输出将所有点的答案异或后的值。 思路：由于包括自身，自己与自己距离为0，那么最近的点一定也距离为0，所以就是找对于每个点与它相连的边权为0 的点的个数**。建图的时候可以不管边权为1的点。。因为这样的点不会对任何点的答案有贡献。**正解貌似是冰茶几。。我就是dfs搞了下。。找到每一个联通快的点数。。然后把某个联通快的所有点的答案都更新成点的个数。。。
/* *********************************************** Author :111qqz Created Time :2016年01月02日 星期六 18时56分17秒 File Name :code/bc/#68/1002.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; vector&amp;lt;int&amp;gt;Edge[N]; int cnt; bool vis[N]; int ans[N]; int sum[N]; int path[N]; void print() { for ( int i =1 ; i &amp;lt;= n ; i++) { cout&amp;lt;&amp;lt;Edge[i].</description></item><item><title>codeforces 29 C. Mail Stamps</title><link>https://111qqz.com/2015/12/cf29c/</link><pubDate>Wed, 30 Dec 2015 12:27:15 +0000</pubDate><guid>https://111qqz.com/2015/12/cf29c/</guid><description>
http://codeforces.com/contest/29/problem/C 题意：给出n个边的关系，保证可以构成一条链。正向或者反向输出这个链。 思路：由于下标很大(1E9)，而关系个数只有1E5..需要离散化。。而且离散化的同时不能丢失边的关系。。。实际上。。直接用vector+map就好了。。。 map &amp;gt;e;即可。然后找到一个度为1的点。。做个dfs...
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 19时55分15秒 File Name :code/cf/problem/29C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; map&amp;lt;int,vector&amp;lt;int&amp;gt; &amp;gt;e; map&amp;lt;int,bool&amp;gt;vis; map&amp;lt;int,int&amp;gt;in; map&amp;lt;int,int&amp;gt;::iterator it; int beg; int n ; void dfs( int x) { vis[x] = true; printf(&amp;quot;%d &amp;quot;,x); for ( int i = 0 ; i &amp;lt; e[x].</description></item><item><title>codeforces #334 div 2 D.Moodular Arithmetic</title><link>https://111qqz.com/2015/12/cf604d/</link><pubDate>Tue, 22 Dec 2015 05:09:32 +0000</pubDate><guid>https://111qqz.com/2015/12/cf604d/</guid><description>
http://codeforces.com/contest/604/problem/D 题意：一个恒等式 f(kx%p)=kf(x)%p ,k,p为常数，且满足x对于定义域为0..p-1的p的整数，值域也在0..p-1范围（不一定一一对应）。问满足题意的f有多少个。 思路： f(0)=0,对于其他的值，当f（x）确定时，f（kx%p）也随之确定，那么把kx%p看做新的x,f（kkx%p）也随之确定...相当于【1，p-1】被分为r个小环，确定每个环可以任选一个数字，ans=p^r。环的个数可以用dfs跑一遍得到r. 注意当k=1的时候是特殊情况，f(x)恒等于f(x)那么答案应该有p的p次方种。因为对于p个f(0..p-1)，每一个都可以任意取p种值。
/* *********************************************** Author :111qqz Created Time :2015年12月22日 星期二 12时31分09秒 File Name :code/cf/#334/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD =1E9+7; const int N=1E6+7; LL p,k; LL ans; bool v[N]; void dfs( int x) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; v[x] = true; int y = (k*x)%p; if (!</description></item><item><title>codeforces 505 B. Mr. Kitayuta's Colorful Graph</title><link>https://111qqz.com/2015/12/cf505b/</link><pubDate>Mon, 07 Dec 2015 03:11:13 +0000</pubDate><guid>https://111qqz.com/2015/12/cf505b/</guid><description>
http://codeforces.com/contest/505/problem/B 题意；给一个图，边有颜色。给q个查询，每个查询一对点x,y。问只经过某种颜色的边使得x能到y颜色数目。 思路：存颜色的时候卡了下。。本来打算开一个二维的set用来存颜色。。。没想明白。。后来发现。。还是用vecotr就好啊。。。多开一维度vector。。或者。。vector 用 pair 都是可以的。。。因为颜色数不多。。可以暴力枚举每种颜色做一遍dfs 看只走有这条颜色的边x能否到y。。
/* *********************************************** Author :111qqz Created Time :2015年12月07日 星期一 09时52分33秒 File Name :code/cf/problem/505B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) #define pi pair&amp;lt;int ,int &amp;gt; typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m,q; vector&amp;lt;pi&amp;gt;edge[N]; bool vis[N]; void dfs (int x,int y,int col) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; col:&amp;quot;&amp;lt;&amp;lt;col&amp;lt;&amp;lt;endl; vis[x] = true; if (x==y) return; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 475 B. Strongly Connected City</title><link>https://111qqz.com/2015/12/cf475b/</link><pubDate>Mon, 07 Dec 2015 01:38:26 +0000</pubDate><guid>https://111qqz.com/2015/12/cf475b/</guid><description>
http://codeforces.com/problemset/status 题意：n行m列的道路网络。共n*m条道路。每条道路都是单向的.问从任何一个路口出发能否到达其他的任何一个路口。
思路：需要注意的是。我从A点能到达B点，不代表B也能到达A.也就是说，某些点满足可以遍历所有点是不够的，只有当所有点都满足才可以。
/* *********************************************** Author :111qqz Created Time :2015年12月07日 星期一 08时55分48秒 File Name :code/cf/problem/475B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=25; int n,m; bool vis[N][N]; char hor[N],ver[N]; bool direrror (char ch,int d) { if (ch=='v'&amp;amp;&amp;amp;d==3) return true; if (ch=='^'&amp;amp;&amp;amp;d==0) return true; if (ch=='&amp;lt;'&amp;amp;&amp;amp;d==2) return true; if (ch=='&amp;gt;'&amp;amp;&amp;amp;d==1) return true; return false; } bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m&amp;amp;&amp;amp;!</description></item><item><title>codeforces 510 B. Fox And Two Dots</title><link>https://111qqz.com/2015/12/cf510b/</link><pubDate>Sun, 06 Dec 2015 07:10:27 +0000</pubDate><guid>https://111qqz.com/2015/12/cf510b/</guid><description>
http://codeforces.com/contest/510/problem/B 题意：给定一个maze,用不同的字母代表不同的颜色。问能否找到一个颜色相同的环（失少四个点组成） 思路：dfs一遍，如果遇到之前已经访问过的点，说明成环。需要注意的是，要注意由一个点向某方向移动，然后由反方向移动到该点所造成的误判。所以dfs除了要知道当前的坐标x,y，还要记录之前的坐标px,py.
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 21时35分07秒 File Name :code/cf/problem/510B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n,m; char maze[N][N]; bool vis[N][N]; bool flag; bool inmaze( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m) return true; return false; } void dfs( int x,int y,int px,int py) //要记录当前的x,y是由哪里来的。把因为由px,py到x,y再回到px,py引起的误判剔除。 { //判cycle方式为：到达一个之前已经到达过的点。 vis[x][y] = true; // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; y:&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; if (flag) return; for ( int i = 0 ; i &amp;lt; 4 ; i++) { int nx = x + dx4[i] ; int ny = y + dy4[i] ; if (nx==px&amp;amp;&amp;amp;ny==py) continue; if (inmaze(nx,ny)&amp;amp;&amp;amp;maze[nx][ny]==maze[x][y]) { if (!</description></item><item><title>codeforces 277 A. Learning Languages</title><link>https://111qqz.com/2015/12/cf277a/</link><pubDate>Sat, 05 Dec 2015 13:28:36 +0000</pubDate><guid>https://111qqz.com/2015/12/cf277a/</guid><description>
http://codeforces.com/contest/277/problem/A
题意：有n个人，每个人会一定数目的语言（可能为0），一个人学一门语言的代价为1，人和人之间沟通可以通过任意个中间人翻译。问最少的代价使得这n个人可以相互沟通。
思路：建图方式如下：第i个人会语言j，那么连上i和j+n。然后跑一遍dfs,使得1..n这n个点都被访问过。
结果wa4...觉得算法没问题。。看了官方题解。。发现果然有情况没有考虑到。如果所有的人都什么语言都不会的话，那么答案是不能-1的。。因为。。语言和语言之间不能连边。。改了之后A了。。有点开心。。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 20时55分14秒 File Name :code/cf/problem/277A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E2+5; int n,m; vector&amp;lt;int&amp;gt;edge[N]; bool vis[N]; void dfs( int x) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; vis[x] = true; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 217A ice skating</title><link>https://111qqz.com/2015/12/cf217a/</link><pubDate>Sat, 05 Dec 2015 12:34:50 +0000</pubDate><guid>https://111qqz.com/2015/12/cf217a/</guid><description>
http://codeforces.com/problemset/problem/217/A 题意：有n个雪漂（那是啥？，从某个雪漂出发走直线，只有到达另一个雪飘才能停下来。问最少需要添加多少个雪漂，才能使得可以到达任何一个雪漂。 思路：横坐标相同或者纵坐标相同的两个点之间是可以到达的。先O(N2)扫一遍建图。记录这个森林中数的个数为cnt,cnt-1即为答案。因为对于任意两个不能相互到达的点。我们只需要再来一个雪漂就可以使得这两个点相互到达。
一遍AC，有点爽。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 20时18分23秒 File Name :code/problem/217A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; bool vis[N]; int x[N],y[N]; vector&amp;lt;int&amp;gt;edge[N]; void dfs( int x) { vis[x] = true; for ( int i = 0 ; i &amp;lt; edge[x].</description></item><item><title>codeforces 445 B. DZY Loves Chemistry</title><link>https://111qqz.com/2015/12/cf445b/</link><pubDate>Sat, 05 Dec 2015 10:26:11 +0000</pubDate><guid>https://111qqz.com/2015/12/cf445b/</guid><description>
http://codeforces.com/contest/445/problem/B
题意：一共有n种化学药品。m对关系，每对关系表示为x,y表示x和y相互反应。初始容器的danger值为1，当向容器中加入一个化学药品A,如果容器中存在化学药品和A反应，那么容器的danger值翻倍。否则不变。问一个最优的放置药品的顺序。
思路：容易发现。如果两个药品相互反应就连一条边。实际上这些药品构成了一个森林。而一个节点只要不是树的根节点，那么它在任何位置，对答案的贡献度都是*2.反过来说。所有的节点，只有根节点是对答案没有贡献的。那实际上，我们只需要dfs一遍，得到树的数目，用n减去树的数目，就是对答案有贡献的点的数目。
要注意开long long 。。。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 17时13分51秒 File Name :code/cf/problem/445/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; bool vis[N]; int n,m; vector&amp;lt;int&amp;gt;edge[N]; LL ans; LL tree_num; void dfs( int cur) { vis[cur] = true; for ( int i = 0 ; i &amp;lt; edge[cur].</description></item><item><title>codeforces 522 A. Reposts</title><link>https://111qqz.com/2015/12/cf522a/</link><pubDate>Sat, 05 Dec 2015 09:08:16 +0000</pubDate><guid>https://111qqz.com/2015/12/cf522a/</guid><description>
http://codeforces.com/problemset/problem/522/A 题意：给定某条消息的传播路径。问最远传播的距离。。 思路：其实就是问树的深度。。直接dfs就行了。。
存的时候用map&amp;lt;string,vector &amp;gt; mp;的方式存即可。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 16时41分41秒 File Name :code/cf/problem/522A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E2+7; map&amp;lt;string,vector&amp;lt;string&amp;gt; &amp;gt; mp; map&amp;lt;string,bool&amp;gt;vis; string from,to,nouse; int ans; int n; void dfs(string cur,int depth) { // cout&amp;lt;&amp;lt;&amp;quot;cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; depth:&amp;quot;&amp;lt;&amp;lt;depth&amp;lt;&amp;lt;endl; vis[cur] = true; ans = max(ans,depth); for ( int i = 0 ; i &amp;lt; mp[cur].</description></item><item><title>codeforces 377 A maze</title><link>https://111qqz.com/2015/12/cf377a/</link><pubDate>Sat, 05 Dec 2015 06:34:40 +0000</pubDate><guid>https://111qqz.com/2015/12/cf377a/</guid><description>
http://codeforces.com/contest/377/problem/A 题意：给定一个n*m的maze. ‘.’代表空，‘#’代表墙。要求构造一种方案，使得将k个空格填成墙壁后不影响当前的连通性（即没有被填充的空格之间可以相互到达） 思路：一开始想从上往下从左往右构造。错误的认为四个角一定是可以变成墙的。
但其实只要是可能在某条路径上的点，就都不一定可以变成墙。。而四个角显然可以被某条路径经过。
正确的解法很巧妙。以任意一个空格开始跑一遍dfs，设空格一共有sum个，那么就dfs到(sum-k)个。可以做好标记。通过dfs得到的这（sum-k）之间一定是联通的。那么只要填充剩下的就可以了。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 14时06分54秒 File Name :code/cf/problem/377A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; char maze[N][N]; bool vis[N][N]; int n,m,k; int sx,sy; int sum; int num; bool flag = false; bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;=n-1&amp;amp;&amp;amp;y&amp;lt;=m-1&amp;amp;&amp;amp;maze[x][y]=='.</description></item><item><title>codeforces 580 C. Kefa and Park</title><link>https://111qqz.com/2015/12/cf580c/</link><pubDate>Sat, 05 Dec 2015 02:40:03 +0000</pubDate><guid>https://111qqz.com/2015/12/cf580c/</guid><description>
http://codeforces.com/contest/580/problem/C
题意：给出一棵树。每个叶子节点上有一个饭店。某些节点上有cat.现在问从根节点出发可以到达多少个饭店，保证在到达饭店的路径中补连续遇到m个以上的cat.
思路：建图，然后dfs..判断为叶子节点（饭店）的方法是某个点的叶子节点数为0.
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 10时17分01秒 File Name :580C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int m,n; bool vis[N]; vector&amp;lt;int&amp;gt;edge[N]; int hascat[N]; int ans; void dfs( int cur,int num) { vis[cur] = true; if (hascat[cur]) num++; else num = 0 ; // cout&amp;lt;&amp;lt;&amp;quot;cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; num:&amp;quot;&amp;lt;&amp;lt;num&amp;lt;&amp;lt;endl; if (num&amp;gt;m) return; int leafnum = 0; for ( int i = 0 ; i &amp;lt;edge[cur].</description></item><item><title>codeforces 115A A. Party</title><link>https://111qqz.com/2015/12/cf115a/</link><pubDate>Sat, 05 Dec 2015 01:56:30 +0000</pubDate><guid>https://111qqz.com/2015/12/cf115a/</guid><description>
http://codeforces.com/problemset/problem/115/A 题意：给出n个人之间的上级下级关系。问如何分得最少的组，使得没一组中的人不存在上下级关系。 思路：用树的观点来考虑会很容易。可以看成给了一棵森冷。对于不同的树的相同层的点，不存在上下级关系，可以放在一个group.对于同一棵树，每一层要单独放一个group.所以答案是所有树的深度的最大值。
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 21时31分38秒 File Name :code/cf/problem/115A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int p[N]; int f[N]; int n; int ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces edu1 D. Igor In the Museum</title><link>https://111qqz.com/2015/12/codeforces-edu1-d-igor-in-the-museum/</link><pubDate>Fri, 04 Dec 2015 08:29:50 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-edu1-d-igor-in-the-museum/</guid><description>
http://codeforces.com/contest/598/problem/D
题意：给第一个地图。 ‘.’是能走的，‘’是不能走的。**每个‘.’和''之间有一幅画，**给出k个起点，问对于每组起点，最多能观察到多少副画。
思路：dfs.要注意即使只有一个‘*’，从不同方向访问仍然算不同的画。这样就不用标记画是否访问过了。一开始直接暴力dfs..TLE 10
然后发现，如果是在同一个联通快内，能看到的画的最大值是确定的。。如果之前有同一个联通快内的其他点dfs过得到过答案，那么下次就不用再dfs了。。。记得把之前的记过保存下来。。
我具体的写法是把某一次dfs进过的点的恒纵坐标都存起来。。。然后dfs结束后把更新这些沿途中经过的点的答案。。结果还是TLE 10
果然是记忆化写残了。。也不是写残了。。看了几个别人的代码。。。记忆化存的时候是按照某一次来存答案。。而我是按照某个点的坐标。。来存答案。果然还是要提高姿势水平啊。。。SAD
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 15时08分22秒 File Name :code/cf/edu1/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+3; int n,m,k; char maze[N][N]; bool pic[N][N]; int v[N][N]; int ans[N*N]; int res; int cnt = 0 ; bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m&amp;amp;&amp;amp;v[x][y]==-1) return true; return false; } int dfs ( int x,int y,int kk) { if (!</description></item><item><title>poj 2688 Cleaning Robot (tsp问题)</title><link>https://111qqz.com/2015/08/poj2688/</link><pubDate>Sat, 15 Aug 2015 20:16:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj2688/</guid><description>
＿＿＿＿＿＿
好蠢，竟然没看出来这道题的不同之处，以为就是个搜
然后样例什么的都过了．．．
结果显然wa...
然后才发现，这道题应该是tsp问题．
解法是先跑一遍bfs,
对于所有的脏点和起点，得到没两个点之间的距离．
然后跑一遍dfs，枚举出所有的组合，同时更新答案．
晚安．
/************************************************************************* &amp;gt; File Name: code/poj/rr2688.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 03时39分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=25; int w,h; char maze[N][N]; int dist[N][N]; int cnt;//机器人与脏地的个数 int tag[N][N];//标记 bool vist[N][N]; struct node { int x,y; int step; bool ok () { if (x&amp;lt;1||x&amp;gt;h||y&amp;lt;1||y&amp;gt;w||vist[x][y]||maze[x][y]=='x') return false; return true; } }pos[N*N]; node robot; int dir[4][2]={0,-1,0,1,-1,0,1,0}; void bfs(node p,int po) { vist[p.</description></item><item><title>hdu 5305 Friends　（dfs）</title><link>https://111qqz.com/2015/08/hdu5305/</link><pubDate>Wed, 05 Aug 2015 15:36:00 +0000</pubDate><guid>https://111qqz.com/2015/08/hdu5305/</guid><description>
dfs 1A
/************************************************************************* &amp;gt; File Name: code/whust/#9/K.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月05日 星期三 15时02分30秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; int n ,m,ans; int d[50]; int on[50],off[50]; int u[50],v[50]; bool ok(int x,int y) { if ( !</description></item><item><title>uva 12442 . Forwarding Emails</title><link>https://111qqz.com/2015/07/uva12442/</link><pubDate>Tue, 28 Jul 2015 07:51:00 +0000</pubDate><guid>https://111qqz.com/2015/07/uva12442/</guid><description>
&amp;quot;... so forward this to ten other people, to prove that you believe the emperor has
题意是说发短信,每个人只会给一个人发,问从哪个人开始发,能传到的人最多
思路是每个人开始做一遍dfs...
毫无意外的TLE了
一个容易想到的剪枝是,如果在第i次之前的路径上的点,在之后以它作为起点遍历一定不优.
我们可以用一个数组vis标记上(注意不要和为了dfs的标记数组vis2混淆,vis2标记的主要作用是判断是否成环)
sad,看来还是要提高自己的搜索姿势啊....
1 2 3 4 /************************************************************************* 5&amp;gt; File Name: code/2015summer/sea#2/B.cpp 6&amp;gt; Author: 111qqz 7&amp;gt; Email: rkz2013@126.com 8&amp;gt; Created Time: 2015年07月28日 星期二 14时59分16秒 9************************************************************************/ 10 11 #include&amp;lt;iostream&amp;gt;12 #include&amp;lt;iomanip&amp;gt;13 #include&amp;lt;cstdio&amp;gt;14 #include&amp;lt;algorithm&amp;gt;15 #include&amp;lt;cmath&amp;gt;16 #include&amp;lt;cstring&amp;gt;17 #include&amp;lt;string&amp;gt;18 #include&amp;lt;map&amp;gt;19 #include&amp;lt;set&amp;gt;20 #include&amp;lt;queue&amp;gt;21 #include&amp;lt;vector&amp;gt;22 #include&amp;lt;stack&amp;gt;23 #define y0 abc111qqz24 #define y1 hust111qqz25 #define yn hez111qqz26 #define j1 cute111qqz27 #define tm crazy111qqz28 #define lr dying111qqz29 using namespace std; 30 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 31 typedef long long LL; 32 typedef unsigned long long ULL; 33 const int N=5E4+7; 34 int a[N]; 35 bool vis[N],vis2[N]; 36 int u,v,n; 37 int dfs(int x) 38 { 39 int res=0; 40 vis2[x]=true; 41 int tmp = a[x]; 42 if (!</description></item><item><title>hdoj 1241 Oil Deposits (dfs)</title><link>https://111qqz.com/2015/07/hdoj-1241/</link><pubDate>Sat, 25 Jul 2015 07:47:00 +0000</pubDate><guid>https://111qqz.com/2015/07/hdoj-1241/</guid><description>
Oil Deposits **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 17683 Accepted Submission(s): 10172
**
Problem Description
The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil.</description></item><item><title>POJ 1564 Sum It Up (DFS+剪枝）</title><link>https://111qqz.com/2015/07/poj1564/</link><pubDate>Fri, 17 Jul 2015 07:17:00 +0000</pubDate><guid>https://111qqz.com/2015/07/poj1564/</guid><description>
http://poj.org/problem?id=1564
dfs
三个参数 x,sum,k, x表示开始的坐标,sum表示当前的和,k表示这是一组答案中的第几个数,是用来记录路径的...
调了好久没写出来...我写完之后答案会有重复.一开始想开一个boolean数组记录,这样第一组样例的3+1就只会输出一遍,但是这样,2+2就不会被记录到答案中了.
然后看了下别人的代码...
卧槽,只是加了个判断...当前的数和上一个如果不同,就继续dfs....
我为何就没想到...这特么是判断重复的直译啊....
1 2 /************************************************************************* 3&amp;gt; File Name: code/2015summer/0714/K.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: 2015年07月16日 星期四 01时03分01秒 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 using namespace std; 22 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) 23 typedef long long LL; 24 typedef unsigned long long ULL; 25 const int N=20; 26 int n,t; 27 int a[N]; 28 int ans; 29 int k; 30 int rec[N]; 31 bool vis[105]; 32 bool ok; 33 void dfs(int x,int sum,int k) 34 { 35 if (sum==t) 36 { 37 ok=true; 38 for ( int i = 0 ; i &amp;lt; k ; i++) 39 { 40 if (i) 41 { 42 printf(&amp;#34;+%d&amp;#34;,rec[i]); 43 } 44 else 45 { 46 printf(&amp;#34;%d&amp;#34;,rec[i]); 47 } 48 } 49 printf(&amp;#34;\n&amp;#34;); 50 return; 51 } 52 int pre = -1; 53 for ( int i = x ; i &amp;lt; n ; i++) 54 { 55 if (sum+a[i]&amp;lt;=t&amp;amp;&amp;amp;a[i]!</description></item></channel></rss>