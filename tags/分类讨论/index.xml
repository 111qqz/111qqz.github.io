<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分类讨论 on 111qqz的小窝</title><link>http://example.org/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/</link><description>Recent content in 分类讨论 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 18 May 2016 07:47:48 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 3368 Frequent values （暴力+rmq，分类讨论）</title><link>http://example.org/2016/05/poj3368/</link><pubDate>Wed, 18 May 2016 07:47:48 +0000</pubDate><guid>http://example.org/2016/05/poj3368/</guid><description>poj 3368 题目链接
题意：给出n个非减的数a[i],求区间[l,r]中出现次数最多的数的出现的次数。
思路：由于数列非减，那么相等的数一定相邻。很容易系哪个到构造另一个数组f[i]，表示从当前位置向左边延伸最多延伸几个相等的数。
f[i] = f[i-1] + 1 (iff a[i]==a[i-1])
然后查询的时候。
如果直接用ST算法查询rmq的话。。。
可能产生错误结果，原因是f[i]是从左边1到i这段连续区间里当前数出现的次数。
但是查询区间不一定是从1开始，所以查询区间内的第一段连续相等的数可能不完整。。。想了半天。。最后看了题解，发现是这部分暴力来搞。但是如果所有数列中所有数都相等，这样的复杂度就达到了o(1E10)?。。。2s应该过不了吧。。。但是所有题解都是这么写的。。。不是很懂。。。所谓的面向数据编程？
不过还是有启示的：分类讨论的思想。一道题未必用一种算法解。如果因为一小部分导致某算法不能用的话，不妨暴力搞之然后再用这个算法。
/* *********************************************** Author :111qqz Created Time :2016年05月18日 星期三 13时44分47秒 File Name :code/poj/3368.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int q; int dp[N][20]; void init_rmq() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp[i][0] = a[i].</description></item></channel></rss>