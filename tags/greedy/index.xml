<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>greedy on Clarity</title><link>https://111qqz.com/tags/greedy/</link><description>Recent content in greedy on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Fri, 12 May 2017 13:18:06 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/greedy/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces #413 B T-shirt buying (贪心)</title><link>https://111qqz.com/2017/05/codeforces-div2-413b/</link><pubDate>Fri, 12 May 2017 13:18:06 +0000</pubDate><guid>https://111qqz.com/2017/05/codeforces-div2-413b/</guid><description>
题目链接
题意：有n个Ｔ恤，每个价格都不同，有三种颜色，分别用1,2,3表示，每件Ｔ恤给出前xiong和后背的颜色。现在有m个顾客排成一队，对于每个顾客，给出他喜欢的颜色，只要一个Ｔ恤的前xiong或者后背的颜色之一满足该颜色即可。顾客总希望买符合他喜欢颜色的Ｔ恤中价格最低的。现在问每个顾客买到的Ｔ恤的价格，如果某个顾客没有买Ｔ恤，输出-1
思路：贪一下？
对于每个颜色，找到价格最低的。记录的时候顺便记录id，以标记某件有２个颜色的衣服是否卖出去了。
１A美滋滋
/* *********************************************** Author :111qqz Created Time :2017年05月11日 星期四 15时29分58秒 File Name :B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; bool vis[N]; //表示某个id的是否被卖出。 vector&amp;lt; pair&amp;lt;int,int&amp;gt;&amp;gt;v[4]; //pair&amp;lt;price,id&amp;gt;,id是为了标记是否卖出去了，卖出去就继续找下一个。 //虽然价格本身唯一，但是太大不适合做标记？ struct node { int p,a,b; int id; }A[N]; bool cmp(node x,node y) { return x.</description></item><item><title>今日头条2017秋招笔试_1</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-04/</link><pubDate>Thu, 30 Mar 2017 05:53:33 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-04/</guid><description>
头条校招（今日头条2017秋招真题）
题目描述 头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队。每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来。在选题之前，我们对题目进行了盲审，并定出了每道题的难度系数。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a, b, c，我们希望这3道题能满足下列条件：
a＜= b＜= c b - a＜= 10 c - b＜= 10
所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求。然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？
输入输入的第一行包含一个整数n，表示目前已经出好的题目数量。
第二行给出每道题目的难度系数 d1, d2, …, dn。
样例输入4
20 35 23 40
输出输出只包括一行，即所求的答案。
样例输出2
时间限制C/C++语言：1000MS其它语言：3000MS
内存限制C/C++语言：65536KB其它语言：589824K
div2 A的难度...直接贪就好,不给数据范围的都是耍流氓...
/* *********************************************** Author :111qqz Created Time :2017年03月30日 星期四 12时55分21秒 File Name :code/toutiao/1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; vector&amp;lt;int&amp;gt;vec; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>今日头条笔试题-最大映射(贪心)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-01/</link><pubDate>Wed, 29 Mar 2017 12:47:29 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-01/</guid><description>
有 n 个字符串，每个字符串都是由 A-J 的大写字符构成。现在你将每个字符映射为一个 0-9 的数字，不同字符映射为不同的数字。这样每个字符串就可以看做一个整数，唯一的要求是这些整数必须是正整数且它们的字符串不能有前导零。现在问你怎样映射字符才能使得这些字符串表示的整数之和最大？ 输入描述:每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n ， 接下来有 n 行，每行一个长度不超过 12 且仅包含大写字母 A-J 的字符串。 n 不大于 50，且至少存在一个字符不是任何字符串的首字母。 输出描述:输出一个数，表示最大和是多少。 输入例子: 2 ABC BCA 输出例子: 1875 一开始看漏了首位不能映射到0的条件...直接贪了..结果发现不太对...
哦贪心的方法就是算每个字母的权值和...用pair 搞一下...
处理的办法是如果10个字母都出现,那么先把没有在首位出现过的字母中权重最小的那个映射到0,再搞剩下的...
一个trick是...map映射到0..和某个key没有被映射过..产生了二义性....
窝的做法就是整体+1,最后再减回来..
然后因为某处手残卡了1个小时...???.
哎我果然是个废k了.....傻逼贪心都写不对QAQ
/* *********************************************** Author :111qqz Created Time :2017年03月29日 星期三 16时28分18秒 File Name :toutiao1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n; string st[N]; pair &amp;lt;long long ,int &amp;gt; cnt[20]; LL ten[25]; map&amp;lt;char,int&amp;gt;mp; set&amp;lt;char&amp;gt;Nhead; bool head[25]; set&amp;lt;char&amp;gt;all; set&amp;lt;char&amp;gt;used; set&amp;lt; pair &amp;lt;long long ,char&amp;gt; &amp;gt; se; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #375 D. Lakes in Berland (dfs)</title><link>https://111qqz.com/2016/10/cf375d/</link><pubDate>Mon, 03 Oct 2016 18:03:37 +0000</pubDate><guid>https://111qqz.com/2016/10/cf375d/</guid><description>
题目链接
题意：nm个格子，有和.两种类型。定义一个湖为边相邻的只有.组成的最大点集合，且任何一个.不在边界上。现在给出一个nm的图保证至少有k个湖。问填多少个.成，才能使得恰好有k个湖。
思路：贪心，先处理出所有的湖的大小，然后从小往大填。
注意dfs的时候如果某个“可能”的湖遇到了边界，要把之前打的标记撤销掉。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 21时18分03秒 File Name :code/cf/#375/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0};tanxin const int inf = 0x3f3f3f3f; const int N=55; char maze[N][N]; int n,m,k; int vis[N][N]; int lake_cnt=0; int siz; struct node { int id; int val; bool operator &amp;lt; (node b)const { return val&amp;lt;b.</description></item><item><title>codeforces #375 C. Polycarp at the Radio (贪心)</title><link>https://111qqz.com/2016/10/cf375c/</link><pubDate>Mon, 03 Oct 2016 17:57:53 +0000</pubDate><guid>https://111qqz.com/2016/10/cf375c/</guid><description>
题目链接
题意：给出n,m，n个数，对其中的一些数进行修改，要求1..m中出现次数最少的数最大，输出这个最少的数最大是多少，以及修改的次数。
思路：最小的数最多出现n/m次。
竟然因为排序后下标变乱不知所措40分钟。。。我也是醉了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 19时29分52秒 File Name :code/cf/#375/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2005; int n,m; int a[N]; struct node { int id; int val; bool operator &amp;lt; (node b)const { return val&amp;lt;b.</description></item><item><title>whust 2016 #1 D Zhenya moves from the dormitory (贪心，模拟)</title><link>https://111qqz.com/2016/08/whust-2016-1-d-zhenya-moves-from-the-dormitory-/</link><pubDate>Sun, 07 Aug 2016 17:32:21 +0000</pubDate><guid>https://111qqz.com/2016/08/whust-2016-1-d-zhenya-moves-from-the-dormitory-/</guid><description>
题目链接 傻逼模拟。。读完题就ac了。。。
/* *********************************************** Author :111qqz Created Time :2016年08月07日 星期日 18时04分18秒 File Name :code/whust2016/#1/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=280; int n,m; int total,adva,advb; struct Friend { int money; int adv; }f[N]; struct Room { int type; int cost; int adv; }r[N]; struct Ans { int val; int rid; int fid; bool operator &amp;lt; (Ans b)const { return val&amp;gt;b.</description></item><item><title>BZOJ 1640/1692 : [Usaco2007 Nov]Best Cow Line 队列变换 (贪心)</title><link>https://111qqz.com/2016/04/bzoj-1640/</link><pubDate>Sat, 09 Apr 2016 12:29:38 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1640/</guid><description>
1640: [Usaco2007 Nov]Best Cow Line 队列变换 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 710 Solved: 373 [Submit][Status][Discuss]
Description FJ打算带着他可爱的N (1 ≤ N ≤ 2,000)头奶牛去参加”年度最佳老农”的比赛.在比赛中,每个农夫把他的奶牛排成一列,然后准备经过评委检验. 比赛中简单地将奶牛的名字缩写为其头字母(the initial letter of every cow),举个例子,FJ带了Bessie, Sylvia,和Dora,那么就可以缩写为BSD. FJ只需将奶牛的一个序列重新排列,然后参加比赛.他可以让序列中的第一头奶牛,或者最后一头走出来,站到新队列的队尾. 利欲熏心的FJ为了取得冠军,他就必须使新队列的字典序尽量小. 给你初始奶牛序列(用头字母)表示,然后按照上述的规则组成新序列,并使新序列的字典序尽量小.
Input 第1行:一个整数N.
第2行至第N+1行:每行一个大写字母,表示初始序列中该奶牛的头字母.
Output 得到的最小字典序的序列.每输出80个字母需要一个换行!
Sample Input 6 A C D B C B
Sample Output ABCBCD
HINT Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !</description></item><item><title>BZOJ 1634: [Usaco2007 Jan]Protecting the Flowers 护花(贪心)</title><link>https://111qqz.com/2016/04/bzoj1634/</link><pubDate>Thu, 07 Apr 2016 05:52:49 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1634/</guid><description>
1634: [Usaco2007 Jan]Protecting the Flowers 护花 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 605 Solved: 383 [Submit][Status][Discuss]
Description Farmer John went to cut some wood and left N (2 &amp;lt;= N &amp;lt;= 100,000) cows eating the grass, as usual. When he returned, he found to his horror that the cows were in his garden eating his beautiful flowers. Wanting to minimize the subsequent damage, FJ decided to take immediate action and transport the cows back to their barn.</description></item><item><title>BZOJ 1629: [Usaco2007 Demo]Cow Acrobats (贪心)</title><link>https://111qqz.com/2016/04/bzoj1629/</link><pubDate>Mon, 04 Apr 2016 09:27:55 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1629/</guid><description>
1629: [Usaco2007 Demo]Cow Acrobats Time Limit: 5 Sec Memory Limit: 64 MB Submit: 771 Solved: 398 [Submit][Status][Discuss]
Description Farmer John's N (1 &amp;lt;= N &amp;lt;= 50,000) cows (numbered 1..N) are planning to run away and join the circus. Their hoofed feet prevent them from tightrope walking and swinging from the trapeze (and their last attempt at firing a cow out of a cannon met with a dismal failure). Thus, they have decided to practice performing acrobatic stunts.</description></item><item><title>BZOJ 1623: [Usaco2008 Open]Cow Cars 奶牛飞车 (贪心)</title><link>https://111qqz.com/2016/04/bzoj1623/</link><pubDate>Sun, 03 Apr 2016 18:44:56 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1623/</guid><description>
1623: [Usaco2008 Open]Cow Cars 奶牛飞车 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 386 Solved: 266 [Submit][Status][Discuss]
Description  编号为1到N的N只奶牛正各自驾着车打算在牛德比亚的高速公路上飞驰．高速公路有M(1≤M≤N)条车道．奶牛i有一个自己的车速上限Si(l≤Si≤1,000,000)．
 在经历过糟糕的驾驶事故之后，奶牛们变得十分小心，避免碰撞的发生．每条车道上，如果某一只奶牛i的前面有K只奶牛驾车行驶，那奶牛i的速度上限就会下降K*D个单位，也就是说，她的速度不会超过Si - kD(O≤D≤5000)，当然如果这个数是负的，那她的速度将是0．牛德比亚的高速会路法规定，在高速公路上行驶的车辆时速不得低于/(1≤L≤1,000,000)．那么，请你计算有多少奶牛可以在高速公路上行驶呢？
Input 第1行输入N，M，D，L四个整数，之后N行每行一个整数输入Si．
N&amp;lt;=50000
Output  输出最多有多少奶牛可以在高速公路上行驶．
Sample Input 3 1 1 5//三头牛开车过一个通道.当一个牛进入通道时，它的速度V会变成V-D*X(X代表在它前面有多少牛),它减速后，速度不能小于L 5 7 5
INPUT DETAILS:
There are three cows with one lane to drive on, a speed decrease of 1, and a minimum speed limit of 5.
Sample Output 2
OUTPUT DETAILS:
Two cows are possible, by putting either cow with speed 5 first and the cow with speed 7 second.</description></item><item><title>BZOJ 1620: [Usaco2008 Nov]Time Management 时间管理 (贪心)</title><link>https://111qqz.com/2016/04/bzoj-1620/</link><pubDate>Sun, 03 Apr 2016 17:44:02 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1620/</guid><description>
1620: [Usaco2008 Nov]Time Management 时间管理 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 636 Solved: 387 [Submit][Status][Discuss]
Description Ever the maturing businessman, Farmer John realizes that he must manage his time effectively. He has N jobs conveniently numbered 1..N (1 &amp;lt;= N &amp;lt;= 1,000) to accomplish (like milking the cows, cleaning the barn, mending the fences, and so on). To manage his time effectively, he has created a list of the jobs that must be finished.</description></item><item><title>codeforces 137 C. History (sorting,贪心)</title><link>https://111qqz.com/2016/03/cf137c/</link><pubDate>Thu, 31 Mar 2016 05:33:39 +0000</pubDate><guid>https://111qqz.com/2016/03/cf137c/</guid><description>
题目链接 题意：给出n个时间的开始和截止时间，保证没有两个时间的开始或者截止时间相同，问有多少个时间被包含在其他事件中。即aj &amp;lt; ai and bi &amp;lt; bj.
思路：没有两个事件的时间相同很关键。 那么我们可以直接按照开始时间为关键字排序，然后结束时间取之前发生了的（可能还没发生完）时间的结束时间的最大值即可。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 13时23分21秒 File Name :code/cf/problem/137C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5646 ||bc #76 div 2 (贪心)</title><link>https://111qqz.com/2016/03/hdu5646/</link><pubDate>Wed, 23 Mar 2016 08:16:05 +0000</pubDate><guid>https://111qqz.com/2016/03/hdu5646/</guid><description>
题目链接
题意：将正整数n(n&amp;lt;=1E9)，拆分成k个（k&amp;lt;=1E9）个**互不相等的正整数，**并且使得k个正整数的乘积最大。如果可以拆分，输出最大乘积，否则输出-1.
思路：其实是道贪心。。容易知道，k个互不相同的正整数的最小的和为sum=(k+1)*k/2，以此来判断是否有解。如果有解。那么找到最大的i，使得从i 开始的连续k个正整数相加的和小于等于n.
由于k不会超过1E5(否则一定无解)，所以可以开个数组存一下拆分的每个数。
然后设此时还需要添加r才能到n,那么贪心得想，一定是给最大的r个每个增加1最后的乘积会最大。这等效于直接将第k-r+1个直接增加r.
注意全程long long
以及：
开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 开了同步以后scanf/puts/printf 和 cin/cout 后会导致WA!!! 原因是puts也是&amp;lt;stdio.h&amp;gt;里的。。
c和c++各有一套指针。。随时同步，所以cin会慢。。关掉同步会快，但是由于已经关掉同步了，混用就会有问题。 以前不知道puts也是不能混用的QAQ
/* *********************************************** Author :111qqz Created Time :2016年03月22日 星期二 20时43分37秒 File Name :code/hdu/r5646.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; const LL MOD = 1E9+7; LL n,k; LL a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces croc 2016 B. Mischievous Mess Makers (贪心)</title><link>https://111qqz.com/2016/03/cf645b/</link><pubDate>Mon, 21 Mar 2016 14:41:12 +0000</pubDate><guid>https://111qqz.com/2016/03/cf645b/</guid><description>
题目链接 题意：长度为n的初始为1，2,3...n的序列，最多进行k次两个数交换，变换后的序列中最懂能有多少逆序对。 思路：贪心得想。。每次变最外层的对答案贡献最多。 以及，最能能变化n/2次。
/* *********************************************** Author :111qqz Created Time :2016年03月19日 星期六 00时21分20秒 File Name :code/cf/croc2016/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n,k; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #345 div2 A. Joysticks (贪心)</title><link>https://111qqz.com/2016/03/cf651a/</link><pubDate>Tue, 08 Mar 2016 08:31:34 +0000</pubDate><guid>https://111qqz.com/2016/03/cf651a/</guid><description>
题目链接 题意：两个手柄？ 初始的电量给出，只有一个充电器，每经过一秒，充着电的手柄电量增加1，没有充电的手柄电量减少2，允许电量充到0以上，当有电量为0的时候，或者当某一分钟开始的时候有手柄电量为1，游戏立即结束。问最多能玩多少时间游戏。
思路：贪心。。每次给电量少的充电。 坑点在于当某一时刻有手柄电量为1，那么游戏在进行这一分钟之前就结束。
/* *********************************************** Author :111qqz Created Time :2016年03月07日 星期一 17时06分41秒 File Name :code/cf/#345/A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>nthu 10925 - Advanced Heap Sort</title><link>https://111qqz.com/2016/02/nthu-10925-advanced-heap-sort/</link><pubDate>Mon, 22 Feb 2016 09:13:55 +0000</pubDate><guid>https://111qqz.com/2016/02/nthu-10925-advanced-heap-sort/</guid><description>
http://140.114.86.238/problem/10925/ Description 有兩個序列S1和S2，各有N個元素。當我們在S1,S2各取一個數字時，總共會有NN這麼多可能的”和”(sum)。請找出這NN這麼多和裡最小的N個值，並將它們加總後輸出。
Input 只有一筆測資。
測試資料第一行為一個正整數N。 第二行有N個數字，以空白隔開，代表序列S1。 第二行有N個數字，以空白隔開，代表序列S2。 數字範圍：
0 &amp;lt; N &amp;lt; 10000
Output 輸出一行，N個最小的可能的和的加總。
Sample Input 5 1 3 5 7 9 2 4 6 8 10
EOF Sample Output 27 EOF
思路：贪心。先分别升序排列，枚举第一个数组，当枚举到第i个的时候，第二个数组的int(n*1.0/i+0.5)显然都没用。
/* *********************************************** Author :111qqz Created Time :2016年02月22日 星期一 16时26分18秒 File Name :yzy.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; int a[N]; int b[N]; int ans[N]; multiset&amp;lt;int&amp;gt;se; multiset&amp;lt;int&amp;gt;::iterator it; int main() {// #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces #339 div2 D</title><link>https://111qqz.com/2016/02/cf613b/</link><pubDate>Sat, 20 Feb 2016 12:59:29 +0000</pubDate><guid>https://111qqz.com/2016/02/cf613b/</guid><description>
http://codeforces.com/contest/613/problem/B 题意：有n个技能，初始每个技能的level为a[i]，每个技能最大level为A(不妨称为满级技能)，设满级技能个数为maxnum,最小的技能level为minval,问如何将m个技能点分配到n个技能上使得cfmaxsum+cmminval (n&amp;lt;=1E5,a[i],A&amp;lt;=1E9,cf,cm&amp;lt;=1E3,m&amp;lt;=1E15)
思路：贪心。如果让有限的maxsum个技能满级的话，那么一定是让初始最大的maxsum技能满级更优。我们O(n)可以预处理一个c[i]数组，表示将i个技能变成最大值的最小花费。 然后再预处理一个前缀和数组，sum[i]表示初始最小的i个的技能的花费之和。 然后从0到n枚举变成最大值的技能的个数，在剩下的技能中二分能达到的最小值。 注意要按照原来顺序输出，所以记得记录id.
/* *********************************************** Author :111qqz Created Time :2016年02月20日 星期六 13时11分30秒 File Name :code/cf/#339/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL n,A,cf,cm,m; LL b[N]; LL c[N]; //c[i]表示将i个变为最大值需要的最少花费 LL sum[N] ; //sum[i]表示花费最少的i个的价值和 struct node { LL val; int id; bool operator &amp;lt; (node b)const { return val&amp;gt;b.</description></item><item><title>zoj 3693 Happy Great BG</title><link>https://111qqz.com/2016/02/zoj3693/</link><pubDate>Thu, 18 Feb 2016 09:03:10 +0000</pubDate><guid>https://111qqz.com/2016/02/zoj3693/</guid><description>
http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3693 题意： n+2个人取吃饭，每人w元，每k个人可以少付一个人的钱，问最后两个教练每人要付多少钱。
思路：贪心。坑点在读题。。选手n个人，不要忘记两个教练，以及，钱数是两个教练平分。
/* *********************************************** Author :111qqz Created Time :2016年02月18日 星期四 15时16分59秒 File Name :code/zoj/3693.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,k; double ans,w; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>codeforces 373 C. Counting Kangaroos is Fun</title><link>https://111qqz.com/2016/02/cf373c/</link><pubDate>Thu, 18 Feb 2016 06:39:04 +0000</pubDate><guid>https://111qqz.com/2016/02/cf373c/</guid><description>
http://codeforces.com/contest/373/problem/C 题意：n个袋鼠，每个袋鼠的size为a[i],一只袋鼠的size至少是另一只两倍时才能将它装下，被装下的袋鼠不能再装别的袋鼠且不能被看见。问能看见的袋鼠最少是多少。 思路：贪心。最多有n/2个袋鼠被装下。先排序，然后贪心即可。
/* *********************************************** Author :111qqz Created Time :2016年02月18日 星期四 14时32分29秒 File Name :code/cf/problem/373C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10785 The Mad Numerologist</title><link>https://111qqz.com/2016/01/uva10785/</link><pubDate>Wed, 27 Jan 2016 14:13:44 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10785/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1726 题意：给出26个大写字母的权值，要求构造一个长度为n（n不超过210）的字符串。并且满足奇数位置只能放元音字母，偶数位置只能放辅音字母，且每个元音字母最多放21次，每个辅音字母最多放5次，要求构造的字符串的权值之和最小，在权值最小的前提下字典序最小。
思路：贪心。一开始错误得以为不是完整得不能交换（也就是不完整的字母只能放在最后，这是错误的）。但实际上只要每个字母的数量不变，那么就不影响权值。所以做法是，奇数位置偶数位置分别搞，先把构成字符串的字母按次存入，然后排序一下，输出即可。
/* *********************************************** Author :111qqz Created Time :2016年01月26日 星期二 15时10分28秒 File Name :code/uva/10785.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char a[30],b[30]; char oddans[210],evenans[210]; int n; void pre() { a[1]='A'; a[2]='U'; a[3]='E'; a[4]='O'; a[5]='I'; b[1]='J'; b[2]='S'; b[3]='B'; b[4]='K'; b[5]='T'; b[6]='C'; b[7]='L'; b[8]='D'; b[9]='M'; b[10]='V'; b[11]='N'; b[12]='W'; b[13]='F'; b[14]='X'; b[15]='G'; b[16]='P'; b[17]='Y'; b[18]='H'; b[19]='Q'; b[20]='Z'; b[21]='R'; } void solve () { int odd = (n+1)/2; int even = n/2; int vowa = odd/21; int vowr = odd; int cona = even/5; int conr = even%5; int cnt = 0 ; for ( int i = 1 ; i &amp;lt;= vowa ; i++) { for ( int j =1 ; j &amp;lt;=21 ; j++) { cnt++; oddans[cnt] = a[i]; } } for ( int i = 1 ; i &amp;lt;=vowr ; i++) { cnt++; oddans[cnt]=a[vowa+1]; } cnt = 0 ; for ( int i = 1 ; i &amp;lt;= cona ; i++) { for ( int j = 1 ; j &amp;lt;= 5 ; j++) { cnt++; evenans[cnt]=b[i]; } } for ( int i = 1 ; i &amp;lt;=conr ; i++) { cnt++; evenans[cnt]=b[cona+1]; } sort(oddans+1,oddans+odd+1); sort(evenans+1,evenans+even+1); for ( int i = 1 ;i &amp;lt;= n ; i++) { if (i%2==1) { printf(&amp;quot;%c&amp;quot;,oddans[i/2+1]); } else { printf(&amp;quot;%c&amp;quot;,evenans[i/2]); } } puts(&amp;quot;&amp;quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 12 C. Fruits</title><link>https://111qqz.com/2015/12/cf12c/</link><pubDate>Tue, 29 Dec 2015 08:05:19 +0000</pubDate><guid>https://111qqz.com/2015/12/cf12c/</guid><description>
http://codeforces.com/contest/12/problem/C 题意：有n个价格价格，m个要买的东西（可能有相同的种类，设为k种），把n个标签中拿出k个给个贴上。。。问最大价钱和最少价钱分别是多少。 思路：贪心。不过要按照map的value排序。。然后发现其实不用排序。。因为map的key值其实不影响。
vector降序排列的话。。直接 sort(v.rbegin(),v.rend());就好。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 15时30分54秒 File Name :code/cf/problem/12C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n,m; map&amp;lt;string,int&amp;gt;mp; int a[N]; map&amp;lt;string,int&amp;gt;::iterator it; vector&amp;lt;int &amp;gt;v; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 526 B Om Nom and Dark Park</title><link>https://111qqz.com/2015/12/codeforces-526-b-om-nom-and-dark-park/</link><pubDate>Fri, 11 Dec 2015 09:08:45 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-526-b-om-nom-and-dark-park/</guid><description>
http://codeforces.com/contest/526/problem/B 题意：有一棵完全二叉树。每条边上有一定数量的路灯。问最少需要添加多少个路灯。使得根节点道叶子节点的每一条路径上的路灯数量一样。 思路：同叶子节点网上更新即可。
/* *********************************************** Author :111qqz Created Time :2015年12月11日 星期五 16时57分27秒 File Name :code/cf/problem/526B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E3+7; int n; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>cf 596 B. Wilbur and Array</title><link>https://111qqz.com/2015/12/cf596b/</link><pubDate>Tue, 08 Dec 2015 10:06:44 +0000</pubDate><guid>https://111qqz.com/2015/12/cf596b/</guid><description>
http://codeforces.com/problemset/problem/596/B 题意：初始序列全为0，问经过多少次变换，能变成序列b。一次变换是指，选定一个i，从i一直到最后每个元素都增加1，或者每个元素都减少1. 思路：很容易发现。后面的变换补影响前面的变换。每一个数字可以唯一由之前的增加和减少次数决定。所以我们用两个变量，记录之前做的增加和减少变换的次数。然后扫一遍即可。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 17时53分58秒 File Name :code/cf/problem/596B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; LL a[N],b[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 600 C. Make Palindrome</title><link>https://111qqz.com/2015/12/cf600c/</link><pubDate>Tue, 08 Dec 2015 09:44:29 +0000</pubDate><guid>https://111qqz.com/2015/12/cf600c/</guid><description>
http://codeforces.com/problemset/problem/600/C 题意：给定一个字符串。要求用最少的变换得到一个回文串。且在变换次数相同时要字典序最小的。输出变换后的字符串。 思路：对不能构成会文串有影响的是出现奇数次的字母。所以我们先统计每个字母出现的次数。然后按照出现奇数次的字母的个数分奇偶分别搞。偶数的话直接把后面一半变成前面一半。奇数的话，也是这样。输出的时候按照字母从a扫到z，如果有就输出一半。然后再倒着扫一遍。 输出另一半。这样可以保证是字典序最小。需要注意的是奇数的时候的输出情况。不要忘记中间那个字母。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 16时39分56秒 File Name :code/cf/problem/600C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char st[N]; int len; int cnt[30]; int odd[30]; int k; int mappd[30]; char ans[N]; void solve() { // cout&amp;lt;&amp;lt;&amp;quot;k:&amp;quot;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl; if (k==0) { for ( int i = 0 ; i &amp;lt; 26 ; i++) { for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } for ( int i = 25 ; i &amp;gt;= 0 ; i--) for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); return ; } if (k%2==0) { for ( int i = 1 ; i &amp;lt;= k/2 ; i++) { cnt[odd[i]]++; cnt[odd[i+k/2]]--; } int num = 0; for ( int i = 0 ; i &amp;lt; 26 ; i++) { for ( int j = 0 ; j &amp;lt; cnt[i]/2; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } for ( int i = 25 ; i &amp;gt;=0 ; i--) { for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } printf(&amp;quot;\n&amp;quot;); } if (k%2==1) { // cout&amp;lt;&amp;lt;&amp;quot;what the fuck?</description></item><item><title>codeforces 158 B. Taxi</title><link>https://111qqz.com/2015/12/158b/</link><pubDate>Sun, 06 Dec 2015 12:46:06 +0000</pubDate><guid>https://111qqz.com/2015/12/158b/</guid><description>
http://codeforces.com/problemset/problem/158/B 题意：n组人，每组有si个（1&amp;lt;=si&amp;lt;=4），每辆车能装4个人。问最少需要多少辆车装下所有人并且保证同一组的人在一辆车里。 思路：统计人数分别为1,2,3,4的人数。对于4的直接加到答案。贪心的思路是：优先用人数少的去填人数多的。
/* *********************************************** Author :111qqz Created Time :2015年12月06日 星期日 17时34分21秒 File Name :code/cf/problem/158B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int s[N]; int ans; int cnt[5]; void print() { printf(&amp;quot;%d %d %d %d %d\n&amp;quot;,cnt[1],cnt[2],cnt[3],cnt[4],ans); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #334 div 2 B. More Cowbell</title><link>https://111qqz.com/2015/12/codeforces-334-div-2-b-more-cowbell/</link><pubDate>Wed, 02 Dec 2015 08:27:12 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-334-div-2-b-more-cowbell/</guid><description>
题意是说。给n个balls,k个箱子。保证（n&amp;lt;=2*k） 一个箱子中中最多放两个balls，size为两个balls的size之和。 所有的箱子的size都要一样。 问size最小是多少。
只要让最大的size尽可能小即可。 容易想到一组贪心策略。 可以先看有几个多出来的位置 （2*k-n） 然后把最大的几个size的ball装在多余的位置里。。更新答案。 然后对于剩下的。。。最小的和最大的一组状进去。。。扫一遍更新答案。
/* *********************************************** Author :111qqz Created Time :2015年12月02日 星期三 00时00分22秒 File Name :code/cf/#334/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,k; int s[N]; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>best coder #56 div 2 A　Clarke and minecraft（贪心）</title><link>https://111qqz.com/2015/09/bestcoder56div2aclarkeandminecraft/</link><pubDate>Tue, 22 Sep 2015 02:39:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bestcoder56div2aclarkeandminecraft/</guid><description>
贪心．．尽量把一样的材料放在一起．．． 然后写蠢了．．妈蛋．．． 详情见代码
/************************************************************************* &amp;gt; File Name: code/bc/#56/1001.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月19日 星期六 18时55分49秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E2+7; int a[N],b[N]; int ans,cnt; int p[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces 558c Amr and Chemistry (贪心)</title><link>https://111qqz.com/2015/07/cf558c/</link><pubDate>Tue, 21 Jul 2015 03:00:00 +0000</pubDate><guid>https://111qqz.com/2015/07/cf558c/</guid><description>
http://codeforces.com/contest/558/problem/C
题目大意是说，给定N个数，可以对任意数进行任意次两种操作，×2，和/2（整除）
问最少操作多少次，可以让所有数相等。
嘛，前半个小时A掉了前两个提，d E貌似都是线段树。。并不会。。。就一直搞C。。。。
然而并没有做出来。位运算是什么神奇的黑魔法。
转载一份题解：http://blog.csdn.net/qq_24451605/article/details/46906813
思路是声明两个数组，一个数组表示到达i的步数，另一个数组表示n个数中能够达到i的数的个数（包括本身）
1 2 /************************************************************************* 3&amp;gt; File Name: code/#312C.cpp 4&amp;gt; Author: 111qqz 5&amp;gt; Email: rkz2013@126.com 6&amp;gt; Created Time: Mon 20 Jul 2015 11:36:50 PM CST 7************************************************************************/ 8 9 #include&amp;lt;iostream&amp;gt;10 #include&amp;lt;iomanip&amp;gt;11 #include&amp;lt;cstdio&amp;gt;12 #include&amp;lt;algorithm&amp;gt;13 #include&amp;lt;cmath&amp;gt;14 #include&amp;lt;cstring&amp;gt;15 #include&amp;lt;string&amp;gt;16 #include&amp;lt;map&amp;gt;17 #include&amp;lt;set&amp;gt;18 #include&amp;lt;queue&amp;gt;19 #include&amp;lt;vector&amp;gt;20 #include&amp;lt;stack&amp;gt;21 using namespace std; 22 #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i)23 typedef long long LL; 24 typedef unsigned long long ULL; 25 const int N= 1E5+7; 26 const int inf = 0x7fffffff; 27 int a[N]; 28 int vis[N],step[N]; 29 bool cmp (int a,int b) 30 { 31 if (a&amp;gt;b) return true; 32 return false; 33 } 34 int main() 35 { 36 int n; 37 cin&amp;gt;&amp;gt;n; 38 int mx = -1; 39 memset(vis,0,sizeof(vis)); 40 memset(step,0,sizeof(step)); 41 42 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 43 { 44 cin&amp;gt;&amp;gt;a[i]; 45 if (a[i]&amp;gt;mx) 46 mx = a[i]; 47 } 48 for ( int i = 1 ; i &amp;lt;= n ; i++ )f 49 { 50 int tmp = a[i]; 51 int num = 0; 52 while (tmp&amp;lt;=mx) 53 { 54 step[tmp]+=num; //到达tmp需要的操作数是之前的数到达tmo的操作数加上当前 55 vis[tmp]++; //能够到达i的数的个数存在vis数组 56 num++; 57 tmp = tmp &amp;lt;&amp;lt; 1; 58 } 59 num = 0; 60 int tmpa = a[i]; 61 while (tmpa) 62 { 63 if (tmpa&amp;amp;1&amp;amp;&amp;amp;tmpa!</description></item><item><title>codeforces 479D. Long Jumps</title><link>https://111qqz.com/2015/04/cf479d/</link><pubDate>Wed, 08 Apr 2015 11:52:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf479d/</guid><description>
http://codeforces.com/problemset/problem/479/D
题意是说有一把尺子，本身有一些刻度，然后需要测量x和y，问最少需要添加多少个刻度，如果需要，这些刻度分别添加在什么位置。
一开始没有看清题目，以为答案最多为4，但是发现，a[1]=0 a[n]=l这两个是确定的，所以答案最多为2，
而不会出现中间有两个刻度，无论是往前刻还是往后都会越界的情况。
先去看看已知的刻度里有没有直接满足的。
除此之外，如果在已知的刻度下无法测量x也无法测量y，我们还可以找找是否能有公用点使得只刻一个刻度就可以满足题意。公用点分两种情况，一种是在两个刻度之间，另一种是在两个刻度的同侧。
前一种没什么坑，后一种要判断是否越界！！！
如果在已知的刻度下能测量x或者能测量出y但不能同时测量的话，就没有必要找公用点。
还有就是查找的话如果线性找复杂度是O(n2)，会TLE在第27个点。
我们用二分...
话说STL里竟然连二分查找也有。。。。简直orz。。。。真是省时省力。
代码：
1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月22日 星期一 23时42分46秒 6File Name :code/cf/problem/479D.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 #include &amp;lt;cstdio&amp;gt;13 #include &amp;lt;cmath&amp;gt;14 15 using namespace std; 16 17 int n,l,x,y; 18 const int N=1E5+7; 19 int a[N]; 20 int ans,p,q; 21 bool flag1,flag2,flag3,flag4; 22 23 int main() 24 { 25 scanf(&amp;#34;%d %d %d %d&amp;#34;,&amp;amp;n,&amp;amp;l,&amp;amp;x,&amp;amp;y); 26 flag1 = false; 27 flag2 = false; 28 flag3 = false; 29 flag4 = false; 30 31 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 32 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); 33 ans = 2; 34 p = -1; 35 q = 0; 36 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 37 { 38 if(binary_search(a,a+n+1,a[i]+x)) 39 { 40 flag1 = true; 41 42 } 43 if (binary_search(a,a+n+1,a[i]+y)) 44 { 45 flag2 = true; 46 } 47 if (binary_search(a,a+n+1,a[i]+x+y)) 48 { 49 flag3 = true; 50 p = a[i]; 51 } 52 if (binary_search(a,a+n+1,a[i]+y-x)&amp;amp;&amp;amp;((a[i]+y&amp;lt;=l)||(a[i]-x&amp;gt;=0))) 53 { 54 flag4 = true; 55 p = a[i]; 56 } 57 } 58 59 if ( flag1) {ans--;q = 1 ;} 60 if ( flag2 ){ ans--;q = 2 ;} 61 if ( ans==2&amp;amp;&amp;amp;(flag3||flag4)) 62 { 63 ans--; 64 } 65 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 66 if ( ans==2 ) 67 { 68 cout&amp;lt;&amp;lt;a[1]+x&amp;lt;&amp;lt;&amp;#34;&amp;#34;&amp;lt;&amp;lt;a[1]+y&amp;lt;&amp;lt;endl; 69 } 70 if ( ans==1 ) 71 { 72 if ( p==-1 ) 73 { 74 if ( q==1 ) 75 cout&amp;lt;&amp;lt;a[1]+y&amp;lt;&amp;lt;endl; 76 else cout&amp;lt;&amp;lt;a[1]+x&amp;lt;&amp;lt;endl; 77 } 78 else 79 { 80 if ( p+y&amp;lt;=l ) 81 cout&amp;lt;&amp;lt;p+y&amp;lt;&amp;lt;endl; 82 else cout&amp;lt;&amp;lt;p-x&amp;lt;&amp;lt;endl; 83 } 84 } 85 return 0; 86 } 87 88</description></item><item><title>codeforces 525 B. Pasha and String</title><link>https://111qqz.com/2015/04/cf525b/</link><pubDate>Wed, 08 Apr 2015 11:40:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf525b/</guid><description>
http://codeforces.com/problemset/problem/525/B
题意是说一个字符串，进行m次颠倒变换（从a[i]位置到a[l-i+1]位置），问得到的字符串。容易发现，对于越在里边（对称，也就是越靠近中间位置）的字符，调换的次数越多。我们可以把a[i]从小到大排序。然后经过分析发现，把两个相邻的a[i]分为一组，做处理，如果m为奇数，最后还剩下a[m]没有被分组，要单独处理a[m]细节上要注意st数组是从st[0]开始的...好吧的确不方便，适牛也说我了。。数组下标以后还是从0开始吧。。。主要是受高中OI用的pascal的影响。。。那个数组下标随便啊。代码： 1 2 3 /* *********************************************** 4Author :111qqz 5Created Time :2016年02月22日 星期一 23时39分51秒 6File Name :code/cf/problem/525B.cpp 7************************************************ */ 8 9 #include &amp;lt;iostream&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstring&amp;gt;12 #include &amp;lt;cmath&amp;gt;13 #include &amp;lt;cstdio&amp;gt;14 15 using namespace std; 16 17 int m,k,len; 18 const int N=2E5+7; 19 int a[N]; 20 char st[N]; 21 22 int main() 23 { 24 cin&amp;gt;&amp;gt;st; 25 scanf(&amp;#34;%d&amp;#34;,&amp;amp;m); 26 for ( int i = 1 ; i &amp;lt;= m ; i++ ) 27 scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); 28 sort(a+1,a+m+1); 29 k = 1; 30 len = strlen(st); 31 while (k&amp;lt;=m) 32 { 33 for ( int j = a[k] ; j &amp;lt;= a[k+1]-1 ; j++) 34 swap(st[j-1],st[len-j]); 35 k = k + 2; 36 } 37 if ( m %2==1 ) 38 for ( int i = a[m]; i &amp;lt;= len/2 ; i++ ) 39 swap(st[i-1],st[len-i]); 40 cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; 41 return 0; 42 } 43 44 45</description></item><item><title>codeforces 482 A. Diverse Permutation（构造）</title><link>https://111qqz.com/2015/04/cf482/</link><pubDate>Wed, 08 Apr 2015 11:32:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf482/</guid><description>
C - C
**Time Limit:**1000MS **Memory Limit:**262144KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Permutation_p_ is an ordered set of integers _p_1, _p_2, ..., _p__n_, consisting of _n_ distinct positive integers not larger than _n_. We'll denote as_n_ the length of permutation _p_1, _p_2, ..., _p__n_.
Your task is to find such permutation p of length n, that the group of numbers |_p_1 - _p_2|, |_p_2 - p_3|, ..., |_p__n - 1 - _p__n_| has exactly k distinct elements.</description></item><item><title>codeforces 47 C. Exams</title><link>https://111qqz.com/2015/04/cf479c/</link><pubDate>Wed, 08 Apr 2015 11:24:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf479c/</guid><description>
http://codeforces.com/problemset/problem/479/C
1/************************************************ 2Author :111qqz 3Created Time :2016年02月22日 星期一 23时31分10秒 4File Name :code/cf/problem/479C.cpp 5************************************************ */ 6 7#include &amp;lt;iostream&amp;gt;8#include &amp;lt;algorithm&amp;gt;9#include &amp;lt;cstring&amp;gt;10#include &amp;lt;cstdio&amp;gt;11 12#include &amp;lt;cmath&amp;gt;13 14using namespace std; 15int n,ans; 16const int N=1E4+5; 17int a[N],b[N]; 18 19struct Q 20{int a,b; 21}q[N]; 22 23bool cmp(Q x, Q y) 24{ 25 if ( x.a&amp;lt;y.a) return true; 26 if ( x.a==y.a &amp;amp;&amp;amp;x.b&amp;lt;y.b ) return true; 27 return false; 28} 29 30int main() 31{ 32 scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); 33 for ( int i = 1 ; i &amp;lt;= n ; i++ ) 34 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;q[i].</description></item><item><title>HDOJ 4882 Loves Codefires</title><link>https://111qqz.com/2015/03/hdu4882/</link><pubDate>Tue, 31 Mar 2015 10:40:00 +0000</pubDate><guid>https://111qqz.com/2015/03/hdu4882/</guid><description>
ZCC Loves Codefires
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 988 Accepted Submission(s): 500
Problem Description
Though ZCC has many Fans, ZCC himself is a crazy Fan of a coder, called &amp;quot;Memset137&amp;quot;.
It was on Codefires(CF), an online competitive programming site, that ZCC knew Memset137, and immediately became his fan.
But why?
Because Memset137 can solve all problem in rounds, without unsuccessful submissions; his estimation of time to solve certain problem is so accurate, that he can surely get an Accepted the second he has predicted.</description></item><item><title>poj 1065 Wooden Sticks</title><link>https://111qqz.com/2015/03/poj1065/</link><pubDate>Tue, 31 Mar 2015 07:05:00 +0000</pubDate><guid>https://111qqz.com/2015/03/poj1065/</guid><description>
Wooden Sticks Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 19008 Accepted: 8012 Description
There is a pile of n wooden sticks. The length and weight of each stick are known in advance. The sticks are to be processed by a woodworking machine in one by one fashion. It needs some time, called setup time, for the machine to prepare processing a stick. The setup times are associated with cleaning operations and changing tools and shapes in the machine.</description></item><item><title>codeforces 447 B. DZY Loves Strings</title><link>https://111qqz.com/2015/03/cf447b/</link><pubDate>Mon, 30 Mar 2015 09:45:00 +0000</pubDate><guid>https://111qqz.com/2015/03/cf447b/</guid><description>
简单贪心。 因为填的字母没有次数限制，所以最优策略很容易想到，就是在最后面填最大的。 不用实际去填，算出ans就可以。
1 2 3 4 #include &amp;lt;iostream&amp;gt;5 #include &amp;lt;cmath&amp;gt;6 #include &amp;lt;cstring&amp;gt;7 #include &amp;lt;algorithm&amp;gt;8 9 using namespace std; 10 11 int main() 12 { 13 int k,len; 14 char st[2000]; 15 int a[2000]; 16 memset(a,0,sizeof(a)); 17 int w[50]; 18 cin&amp;gt;&amp;gt;st&amp;gt;&amp;gt;k; 19 int m=-1; 20 for (int i=1;i&amp;lt;=26;i++) 21 { 22 23 cin&amp;gt;&amp;gt;w[i]; 24 if (w[i]&amp;gt;m) 25 m=w[i]; 26 } 27 len=strlen(st); 28 for (int i=0;i&amp;lt;len;i++) 29 a[i]=(int)(st[i]-96); 30 long long ans=0; 31 for (int i=0;i&amp;lt;len;i++) 32 { 33 ans=ans+w[a[i]]*(i+1); 34 // cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 35 } 36 for (int i=len;i&amp;lt;len+k;i++) 37 ans=ans+m*(i+1); 38 cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; 39 return 0; 40 } 41</description></item><item><title>hdu 1009 FatMouse' Trade</title><link>https://111qqz.com/2015/03/hdu1009/</link><pubDate>Mon, 30 Mar 2015 08:33:00 +0000</pubDate><guid>https://111qqz.com/2015/03/hdu1009/</guid><description>
简单贪心.... 需要注意的是数据是非负，所以有0的情况要考虑周全，基本都要特殊处理。 多WA了三次，不知道为什么交C++可以过，交G++就不行。
1 2 /* *********************************************** 3Author :111qqz 4Created Time :2016年02月19日 星期五 16时38分28秒 5File Name :code/hdu/1009.cpp 6************************************************ */ 7 8 #include &amp;lt;iostream&amp;gt;9 #include &amp;lt;cstring&amp;gt;10 #include &amp;lt;algorithm&amp;gt;11 #include &amp;lt;cstdio&amp;gt;12 #include &amp;lt;iomanip&amp;gt;13 14 using namespace std; 15 16 int main() 17 { 18 int m,n,f[1500],j[1500]; 19 double scale[1500]; 20 double ans,sum; 21 while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;m,&amp;amp;n)!=EOF&amp;amp;&amp;amp;(m!=-1)) 22 { ans=0; 23 // if (m==0) 24 memset(scale,0,sizeof(scale)); 25 memset(f,0,sizeof(f)); 26 memset(j,0,sizeof(j)); 27 // bool flag=false; 28 for (int i=1;i&amp;lt;=n;i++) 29 { 30 scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;j[i],&amp;amp;f[i]); 31 if (f[i]!</description></item></channel></rss>