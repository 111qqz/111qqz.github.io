<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>位运算 on Clarity</title><link>https://111qqz.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/</link><description>Recent content in 位运算 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Sun, 29 Oct 2017 11:24:42 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces div 1 443 A. Short Program （位运算的理解）</title><link>https://111qqz.com/2017/10/codeforces-div1-443a/</link><pubDate>Sun, 29 Oct 2017 11:24:42 +0000</pubDate><guid>https://111qqz.com/2017/10/codeforces-div1-443a/</guid><description>
题目链接：
题目链接
题意： 一段程序，最多5E5个操作，每个操作的格式为 &amp;lt;opt,x&amp;gt; ，opt表示位或，位异或，位与 三种位运算的一种，x表示范围0..1023的数。现在要求将该程序化简至最多 5个操作，使得对于0..1023的输入，输出与该程序同样的结果。
思路 ： 关键在于想起，位运算还是按照二进制位的运算。我们考虑每位即可。
如果初始是0，现在变成了1，那么实际上我们并不确定，这个操作是xor 1 还是 or 1
因此我们需要两个初始的数，一个所有二进制位上都是0，另一个所有二进制位上都是1.
也就是0和1023
对于某个二进制位
如果初始的 （0，1）变成了 （1，1），那么说明这个位置上的位运算是or
如果初始的 （0，1）变成了（1，0） 那么说明这个位置上的位运算是xor
如果初始的 （0，1）变成了（0，0） 那么说明这个位置上的位运算是and
如果初始的 （0，1）变成了（1，0） 那么说明这个位置上没有进行位运算操作。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main() { int n; cin&amp;gt;&amp;gt;n; char opt[3]; int x; int a = 0; int b = 1023; for ( int i = 1 ; i &amp;lt;= n ; i++) { cin&amp;gt;&amp;gt;opt&amp;gt;&amp;gt;x; if (opt[0]=='|') a |=x,b|=x; if (opt[0]=='^') a^=x,b^=x; if (opt[0]=='&amp;amp;') a&amp;amp;=x,b&amp;amp;=x; } // 01 no // 11 or // 10 xor // 00 and int OR=0,XOR=0,AND=1023; for ( int i = 0 ; i &amp;lt; 10 ; i++) { int A = (a&amp;gt;&amp;gt;i)&amp;amp;1; int B = (b&amp;gt;&amp;gt;i)&amp;amp;1; // cout&amp;lt;&amp;lt;&amp;quot;A:&amp;quot;&amp;lt;&amp;lt;A&amp;lt;&amp;lt;&amp;quot; B:&amp;quot;&amp;lt;&amp;lt;B&amp;lt;&amp;lt;endl; if (A&amp;amp;&amp;amp;B) OR|=(1&amp;lt;&amp;lt;i); if (A&amp;amp;&amp;amp;!</description></item><item><title>hdu 5036 Explosion||2014 北京区域赛网络赛 (概率+bitset优化的状态压缩+floyd传递闭包)</title><link>https://111qqz.com/2016/08/hdu-5036/</link><pubDate>Sun, 21 Aug 2016 11:18:49 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5036/</guid><description>
题目链接
题意：有n扇门，n种钥匙，一一对应。每扇门打开后可能得到k把钥匙（k可能为0）。一扇门还可以用一颗炸弹炸开。现在问要开所有门，使用炸弹的期望个数。
思路：状态压缩。用一个二进制串表示每扇门能打开的门的信息，对应的位上为1表示能打开，为0表示不能打开。
状态是可以传递的。。
如果第i扇门能打开门k，那么能打开第i扇门的第j扇门也可以打开门k。
状态压缩以及传递的过程可以很容易用bitset来维护，这才是bitset的正确打开姿势
相当于用floyd做了一个传递闭包。(floyd的有一层循环隐藏在了bitset中，复杂度没有改变，但是常数小)
最后对于期望的计算方法：统计能打开第i扇门的方案数计为cnt,这cnt的方案中，只有一种是用炸弹炸掉，因此用的炸弹数的期望数为1/cnt
由于期望的独立性，因此打开所有门所有的炸弹数的期望就是每个门的期望累加。
/* *********************************************** Author :111qqz Created Time :2016年08月21日 星期日 18时43分56秒 File Name :code/hdu/5036.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1005; int n; bitset&amp;lt;N&amp;gt;b[N]; //b[i]表示第i扇门可以打开的门 int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>cf 611 B ||codeforces goodbye 2015 B. New Year and Old Property (数学或者数位dp)</title><link>https://111qqz.com/2016/01/cf611b/</link><pubDate>Fri, 01 Jan 2016 13:03:22 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611b/</guid><description>
http://codeforces.com/contest/611/problem/B 题意：问a到b（1E18），二进制表示中只有一个0的数有多少个。 思路：这么大的数。。。不是有循环节就是math problems.  UD:20160318讲道理还有可能是数位dp好不好。。。 我们发现可以很容易得算出1到x的二进制表示中只有一个0 的数有多少个。
problem solved.
20160318update:学了数位dp后又看到这题。。。这题显然是数位dp啊。。。亏我找规律搞了出来2333.
后面附上数位dp方法AC的代码
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 22时49分02秒 File Name :code/cf/goodbye2015/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const int N=1E4+7; LL a,b; LL p[N]; LL c[N]; LL cal( LL x) { return ((x-1LL)*x)/2LL; } LL solve (LL x) { if (x==0LL) return 0; LL res= 0LL; LL cnt = 0LL; LL xx = x; while (xx) { cnt++; p[cnt] = xx%2LL; xx/=2LL; } ms(c,0); res+=cal(cnt-1LL); LL tmp = (1LL&amp;lt;&amp;lt;cnt)-1LL; for ( LL i = 0 ; i &amp;lt;cnt-1 ; i++) { LL happ = 1LL&amp;lt;&amp;lt;i; c[i]=tmp-happ; } sort(c,c+cnt-1); for ( LL i = 0 ; i&amp;lt; cnt -1 ; i++) { if (x&amp;gt;=c[i]) res++; } return res; } int main() { cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; LL ans = solve(b)-solve(a-1LL); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; } 数位dp的方法：</description></item><item><title>codeforces #320 div 2A - Raising Bacteria (位运算）</title><link>https://111qqz.com/2015/09/codeforces320div2a-raisingbacteria/</link><pubDate>Fri, 18 Sep 2015 15:28:00 +0000</pubDate><guid>https://111qqz.com/2015/09/codeforces320div2a-raisingbacteria/</guid><description>
x的二进制表示中1的个数即为答案．
原因是，每天晚上糖果数量翻倍，相当于左移１位,这时候二进制表示中1的数量不变
也就是说，二进制表示中的所有的1，一定都是添加进去的
而且也只有二进制表示中的1是添加进去的
所以二进制表示中1的数量，就是添加的糖果数．
/************************************************************************* &amp;gt; File Name: code/cf/#320/A.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月18日 星期五 23时18分34秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; int main() { #ifndef ONLINE_JUDGE #endif int x; cin&amp;gt;&amp;gt;x; int ans = 0 ; while (x) { if (x%2==1) ans++; x = x / 2; } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; }</description></item></channel></rss>