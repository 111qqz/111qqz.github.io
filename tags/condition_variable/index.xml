<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>condition_variable on 111qqz的小窝</title><link>https://111qqz.com/tags/condition_variable/</link><description>Recent content in condition_variable on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 23 Sep 2018 08:42:33 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/condition_variable/index.xml" rel="self" type="application/rss+xml"/><item><title>[C++11]std::condition_variable notes</title><link>https://111qqz.com/2018/09/condition_variable-notes/</link><pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate><guid>https://111qqz.com/2018/09/condition_variable-notes/</guid><description>
condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_variable，也就是条件变量，是线程间通信的一种方式。
线程之间在很多时候需要通信，比如经典的生产者消费者问题
一个比较naive的方案是，用mutex来保护一个flag,然后另一线程不停得check这个flag的状态是否改变。以及在这个方案上的改进:让另一个线程check之后，可以先睡一段时间。
但是这两种方法都不够好。第一种不好的原因当然是不停得check，肯定会耗费大量的资源。而第二种，由于没办法准确估计要休眠的时间，因此不够实际。
这个时候我们可以考虑使用条件变量。
条件变量是可以用在如下场景: 一个或者多个线程在等某个条件的成立，而这个条件由另外的线程所控制。当该条件成立时，控制该条件的线程会主动通知这些线程，将这些线程唤醒。
如下是一个最简单的例子:
1 std::mutex mut; 2 std::queue&amp;lt;data_chunk&amp;gt; data_queue; // 1 3 std::condition_variable data_cond; 4 5 void data_preparation_thread() 6 { 7 while(more_data_to_prepare()) 8 { 9 data_chunk const data=prepare_data(); 10 std::lock_guard&amp;lt;std::mutex&amp;gt; lk(mut); 11 data_queue.push(data); // 2 12 data_cond.notify_one(); // 3 13 } 14 } 15 16 void data_processing_thread() 17 { 18 while(true) 19 { 20 std::unique_lock&amp;lt;std::mutex&amp;gt; lk(mut); // 4 21 data_cond.wait( 22 lk,[]{return !</description></item></channel></rss>