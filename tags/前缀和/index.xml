<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前缀和 on Clarity</title><link>https://111qqz.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/</link><description>Recent content in 前缀和 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 22 Feb 2017 11:40:23 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/index.xml" rel="self" type="application/rss+xml"/><item><title>112. Path Sum</title><link>https://111qqz.com/2017/02/112-path-sum/</link><pubDate>Wed, 22 Feb 2017 11:40:23 +0000</pubDate><guid>https://111qqz.com/2017/02/112-path-sum/</guid><description>
题目链接
题意：给一棵树。。问是否存在一条从树根到叶子的路径，使得路径上每个点的val之和等于给定的sum。
思路：。。。直接搞就好。。。由于是比较经典的题目所以记录一下。。。注意递归的时候每一部分都要返回值orz..(我是多久没写代码了。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } int SUM; bool dfs(TreeNode* root,int cur) { // cout&amp;lt;&amp;lt;&amp;quot;val:&amp;quot;&amp;lt;&amp;lt;root-&amp;gt;val&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; bool ret=false; if (cur+root-&amp;gt;val==SUM&amp;amp;&amp;amp;leaf(root)) return true; if (root-&amp;gt;left!=NULL) ret = dfs(root-&amp;gt;left,cur+root-&amp;gt;val); if (ret) return true; if (root-&amp;gt;right!</description></item><item><title>BZOJ 1303: [CQOI2009]中位数图（前缀/后缀和乱搞）</title><link>https://111qqz.com/2017/01/bzoj-1303-cqoi2009/</link><pubDate>Mon, 30 Jan 2017 16:09:22 +0000</pubDate><guid>https://111qqz.com/2017/01/bzoj-1303-cqoi2009/</guid><description>
1303: [CQOI2009]中位数图 Time Limit: 1 Sec Memory Limit: 162 MB Submit: 2480 Solved: 1529 [Submit][Status][Discuss]
Description 给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。
Input 第一行为两个正整数n和b ，第二行为1~n 的排列。
Output 输出一个整数，即中位数为b的连续子序列个数。
Sample Input 7 4 5 7 2 4 3 1 6
Sample Output 4
HINT 第三个样例解释：{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6} N&amp;lt;=100000
思路：这道题的思路还是比较经典的...把大于b的数看成1，小于b的数看成-1..于是一段以b为中位数的连续的长度为奇数的数列的和为0.
那么从b往前做一个后缀和，往后做一个前缀和...然后统计每个前缀和/后缀和的值的个数..
然后枚举前缀和/后缀和可能的值（-n..n，由于负数不好处理，整体+n，变成0..2n)
具体见代码
/* *********************************************** Author :111qqz Created Time :2017年01月30日 星期一 20时13分11秒 File Name :code/bzoj/1303.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N]; int sum[N]; int l[N*2],r[N*2]; int n,b; int pos; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 381 div 2 D. Alyona and a tree(二分+前缀和)</title><link>https://111qqz.com/2016/11/cf740d/</link><pubDate>Mon, 28 Nov 2016 07:07:00 +0000</pubDate><guid>https://111qqz.com/2016/11/cf740d/</guid><description>
题目链接
d:题意：一棵树，给出边权和点权，定义点v控制点u，当且仅当u是v的子树中的点，并且dis(u,v)&amp;lt;=a[u]，其中dis(u,v)为点u到点v路径上的边权和，a[u]为点u的点权，现在问对于每个节点v，其能控制的点有多少个。
思路：先写了个rmq+dfs的lca。。。那么任意两个点的距离都可以O(1)得到了。然后不会了233333.
upd:和lca没有什么关系，因为一个点能控制另一个点这两个点一定在一条通向根的链上，因此距离直接减一下就好了。
机智的做法：dfs的时候维护一个栈，对于栈中序列，后面一半是对当前点有贡献的。问题时求对于每个v统计其能控制多少个u，现在我们固定u，考虑能控制他的v。这些v在树上的形态时一条链 ，借助第二类前缀和的思想，对于u标记+1，对于u往上的离根最近的且能统治u的v上面的一个标记-1，然后dfs后序遍历（也就是链的起点时距离根远的那一边），距离处理的时候，只需要在递归之后更新ans就好了。
栈里面维护，到哪个节点，从根下来，边权和最大，找边权和&amp;gt;=当前边权和-a[u]的地方。
启示：由于两个存在统治关系的点在一条链上，边权都为正，边权和具有单调性，单调的东西，容易想到二分处理。
/* *********************************************** Author :111qqz Created Time :2016年11月24日 星期四 09时17分48秒 File Name :code/cf/#381/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int a[N]; LL dis[N]; vector&amp;lt; pair&amp;lt;int,LL&amp;gt; &amp;gt;edge[N]; vector&amp;lt; pair&amp;lt;LL,int&amp;gt; &amp;gt;path; int ans[N]; void dfs( int u,int pre) { ans[u]++; int idx = lower_bound(path.</description></item><item><title>hdu 1559 最大子矩阵 (二维前缀和)</title><link>https://111qqz.com/2016/08/hdu-1559/</link><pubDate>Wed, 03 Aug 2016 13:19:58 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1559/</guid><description>
hdu 1559
题意：给你一个m×n的整数矩阵，在上面找一个x×y的子矩阵，使子矩阵中所有元素的和最大。
思路：二维前缀和就好。。。和单调栈没有半毛钱关系吧。。。
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 21时08分18秒 File Name :code/hdu/1559.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int a[N][N]; int sum[N][N]; int n,m,x,y; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2796 Feel Good (前缀和，单调栈)</title><link>https://111qqz.com/2016/08/poj-2796/</link><pubDate>Wed, 03 Aug 2016 11:30:56 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2796/</guid><description>
poj 2796
题意：给出一个人n（1E5）天的情绪值（0..1E6），一段时间的value的定义是这段时间的情绪之和*这段时间情绪的最小值。
现在求value的最大值，并且输出得到这个最大值的区间。
思路：单调栈。 考虑把每一天作为最小值的时候能向左向由延伸的最远的点的下标，两个方向各做一次单调栈来预处理。和的haunted前缀和搞下。。
然后最后想着了LL,但是读入的时候前缀和的那里忘了LL wa了一发。。。2A
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 19时14分42秒 File Name :code/poj/2796.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; LL sum[N]; int l[N],r[N]; stack&amp;lt;int&amp;gt;stk; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2082 Terrible Sets (前缀和，单调栈)</title><link>https://111qqz.com/2016/08/po2082/</link><pubDate>Wed, 03 Aug 2016 11:07:24 +0000</pubDate><guid>https://111qqz.com/2016/08/po2082/</guid><description>
poj 2082 题目链接
题意：这道题简直就是。。。教给大家怎么把一句话把简单的题让人出得看不懂。。。真的一点意思都没有。给出n个矩形的宽度和高度，这些矩形并排顺次排列在x轴上，问最大面积。
思路：单调栈。 之前的最大矩形面积的宽度都是1.。这次不是1.。做个宽度的前缀和就好。。。1A
/* *********************************************** Author :111qqz Created Time :2016年08月03日 星期三 18时54分40秒 File Name :code/poj/2082.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; pi a[N]; int l[N],r[N]; int sum[N]; int n; stack&amp;lt;int&amp;gt;stk; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1651: [Usaco2006 Feb]Stall Reservations 专用牛棚 (前缀和)</title><link>https://111qqz.com/2016/04/bzoj1651/</link><pubDate>Mon, 11 Apr 2016 12:31:58 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj1651/</guid><description>
1651: [Usaco2006 Feb]Stall Reservations 专用牛棚 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 700 Solved: 393 [Submit][Status][Discuss]
Description Oh those picky N (1 &amp;lt;= N &amp;lt;= 50,000) cows! They are so picky that each one will only be milked over some precise time interval A..B (1 &amp;lt;= A &amp;lt;= B &amp;lt;= 1,000,000), which includes both times A and B. Obviously, FJ must create a reservation system to determine which stall each cow can be assigned for her milking time.</description></item><item><title>BZOJ 1637: [Usaco2007 Mar]Balanced Lineup (前缀和乱搞)</title><link>https://111qqz.com/2016/04/bzoj-1637/</link><pubDate>Fri, 08 Apr 2016 06:59:57 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1637/</guid><description>
1637: [Usaco2007 Mar]Balanced Lineup Time Limit: 5 Sec Memory Limit: 64 MB Submit: 503 Solved: 336 [Submit][Status][Discuss]
Description Farmer John 决定给他的奶牛们照一张合影，他让 N (1 ≤ N ≤ 50,000) 头奶牛站成一条直线，每头牛都有它的坐标(范围: 0..1,000,000,000)和种族(0或1)。 一直以来 Farmer John 总是喜欢做一些非凡的事，当然这次照相也不例外。他只给一部分牛照相，并且这一组牛的阵容必须是“平衡的”。平衡的阵容，指的是在一组牛中，种族0和种族1的牛的数量相等。 请算出最广阔的区间，使这个区间内的牛阵容平衡。区间的大小为区间内最右边的牛的坐标减去最做边的牛的坐标。 输入中，每个种族至少有一头牛，没有两头牛的坐标相同。
Input 行 1: 一个整数: N 行 2..N + 1: 每行两个整数，为种族 ID 和 x 坐标。
Output 行 1: 一个整数，阵容平衡的最大的区间的大小。
Sample Input 7 0 11 1 10 1 25 1 12 1 4 0 13 1 22</description></item><item><title>BZOJ 1635: [Usaco2007 Jan]Tallest Cow 最高的牛 (差分序列（前缀和的逆）)</title><link>https://111qqz.com/2016/04/bzoj-1635/</link><pubDate>Thu, 07 Apr 2016 16:19:00 +0000</pubDate><guid>https://111qqz.com/2016/04/bzoj-1635/</guid><description>
1635: [Usaco2007 Jan]Tallest Cow 最高的牛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 472 Solved: 278 [Submit][Status][Discuss]
Description FJ's N (1 &amp;lt;= N &amp;lt;= 10,000) cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height H (1 &amp;lt;= H &amp;lt;= 1,000,000) of the tallest cow along with the index I of that cow.</description></item><item><title>前缀和问题总结</title><link>https://111qqz.com/2016/02/</link><pubDate>Fri, 19 Feb 2016 07:31:21 +0000</pubDate><guid>https://111qqz.com/2016/02/</guid><description>
There are two types of problems solvable by partial sum. 1.Problems which you are asked to answer some queries about the sum of a part of elements (without modify queries).
Solution of all of this problems are the same. You just need to know how to solve one of them.
Example : You are asked some queries on an array _a_1, _a_2, ...a, n. Each query give you numbers l and r and you should print a__l + a__l + 1 + .</description></item><item><title>hdu 5416 CRB and Tree ( 2015 多校 #10 )</title><link>https://111qqz.com/2016/02/hdu5416/</link><pubDate>Fri, 19 Feb 2016 07:05:18 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5416/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5416 题意：给出一棵树（n&amp;lt;=1E5），定义二元函数函数f(u,v) (u可以等于v)表示节点u到节点v经过的路径的权值的异或和。给出q组查询（q&amp;lt;=10），每组一个s,问有多少对无序点对（u,v）满足f(u,v)=s. 思路：类似codeforces #340 div 2 E XOR and Favorite Number 先dfs,处理出从根节点都任意节点的异或前缀和。然后对于每个询问o(n)扫一遍，统计sum[i]^s出现多少次。 总的时间复杂度为O(Tqn);
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 13时52分32秒 File Name :code/hdu/5416.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector&amp;lt;pi&amp;gt;edge[N]; int n; LL sum[N]; LL cnt[N*10]; int q; void dfs( int x,LL val) { sum[x] = val; for ( int i = 0 ; i&amp;lt; edge[x].</description></item><item><title>hdu 5327 Olympiad （2015 多校 #4 ）</title><link>https://111qqz.com/2016/02/hdu5327/</link><pubDate>Fri, 19 Feb 2016 05:35:45 +0000</pubDate><guid>https://111qqz.com/2016/02/hdu5327/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=5327 题意：问给出的区间[a,b]中有多少个美丽数，美丽数的定义是所有数字都不相同，如123是，100不是，333也不是。 思路：预处理1..100000的美丽数，可以把每个数字拆开放在set里，比较set的size和位数来实现。 然后用前缀和。
/* *********************************************** Author :111qqz Created Time :2016年02月19日 星期五 13时25分36秒 File Name :code/hdu/5327.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a,b; int sum[N]; int p[N]; bool ok ( int x) { set&amp;lt;int&amp;gt;se; se.</description></item><item><title>codeforces #340 div 2 E XOR and Favorite Number</title><link>https://111qqz.com/2016/02/cf617e/</link><pubDate>Mon, 15 Feb 2016 12:32:37 +0000</pubDate><guid>https://111qqz.com/2016/02/cf617e/</guid><description>
http://codeforces.com/contest/617/problem/E
题意：给出n个数，m个查询，每个查询给定l,r，问在区间【l,r】内，有多少对i,j,满足i^(i+1)^(i+2)^...^j的值为给定的常数k.
思路：学了莫队算法以后。。。这题果然是莫队的一眼题。
入手点是，知道异或也像加一样有前缀和性质。如果我们处理一个按照异或规则的前缀和数组sum[i]=sum[i-1]^a[i]，那么i到j的异或和就是sum[i-1]^sum[j] （x^x==0,因此a[1]到a[i-1]的异或和被去掉了）
因此我们要找的就是区间内有多对i,j满足sum[i-1]^sum[j]==k,也就是sum[i-1]==k^sum[j]这和hdu 5213 a=k-b有如此类似的形式，做法也是类似的。
由于对于每个j，找的是i-1,在处理的时候记得将区间左端点-1，
最重要的一点是，莫队的添加和删除操作最好分开写，至少根据d的正负写个if else,因为顺序不一定相同。 最后一个注意的是，可能会爆int ,所以要用long long
/* *********************************************** Author :111qqz Created Time :2016年02月13日 星期六 21时47分47秒 File Name :code/cf/#340/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E6+7; int n,m,k; int siz; LL a[N]; LL sum[N]; int pos[N]; LL cur; LL cnt[N]; LL ans[N]; struct node { int l,r; int id; bool operator &amp;lt;(node b)const { if (pos[l]==pos[b.</description></item><item><title>cf 611 A||codeforces goodbye 2015 C. New Year and Domino</title><link>https://111qqz.com/2016/01/cf611a/</link><pubDate>Fri, 01 Jan 2016 12:57:19 +0000</pubDate><guid>https://111qqz.com/2016/01/cf611a/</guid><description>
http://codeforces.com/contest/611/problem/C 题意：给出一个n*m的地图，.表示可以空，#表示墙。一个东西需要占两个相邻的格子，问给定一个矩形，放一个东西的方案数。 思路：q很大。。应该是先预处理出来直接调用答案。。。计数问题累加性。。应该是前缀和之类。。需要做的就是怎么标记。。我的做法是竖着放和横着放的个数分开来存。从左往右从上往下，每次标记到后一个点。然后二维的前缀和。然后每次询问的时候，去掉最上边和最左边两条边界上对应的多加的点。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N=5E2+7; char maze[N][N]; int n,m; int q; int a[N][N],b[N][N]; int sum[N][N]; int sum2[N][N]; int main() { cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for ( int i = 0 ; i&amp;lt; n ;i++ ) scanf(&amp;quot;%s&amp;quot;,maze[i]); for ( int i = 1 ; i &amp;lt; n ; i++) { for (int j = 0 ; j&amp;lt; m ;j++) { if (maze[i][j]=='.</description></item><item><title>codeforces 18 C. Stripe</title><link>https://111qqz.com/2015/12/cf18c/</link><pubDate>Tue, 29 Dec 2015 08:22:45 +0000</pubDate><guid>https://111qqz.com/2015/12/cf18c/</guid><description>
http://codeforces.com/contest/18/problem/C 题意：将一个序列分成两个非空的部分，保证和相等，问有多少种方法。 思路：做过一个三部分的。。。两部分直接一个前缀和就好了把。。。有一个需要注意的是。。判断负数是否是奇数的时候需要加个绝对值。。。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 16时09分06秒 File Name :code/cf/problem/18C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int total; int sum[N]; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces #336 div 2 B. Hamming Distance Sum</title><link>https://111qqz.com/2015/12/cf608b/</link><pubDate>Wed, 23 Dec 2015 18:52:28 +0000</pubDate><guid>https://111qqz.com/2015/12/cf608b/</guid><description>
http://codeforces.com/contest/608/problem/B 题意：给定两个字符串a,b，问b中的每个连续的长度为a的子串与a的哈密顿距离的和是多少。哈密顿距离是对应位置的字符的差的绝对值的和。由于是01串，也就是字符不同的位置数。 思路：类似前缀和。0和1分别搞。注意开long long
/* *********************************************** Author :111qqz Created Time :2015年12月24日 星期四 00时32分33秒 File Name :code/cf/#336/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int la,lb; char a[N],b[N]; int sum0[N],sum1[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5480|| bestcoder 　　＃５７　div 2　Conturbatio（前缀和｜｜树状数组）</title><link>https://111qqz.com/2015/09/hdu5480/</link><pubDate>Sat, 26 Sep 2015 17:20:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu5480/</guid><description>
比较水．
唯一一点需要注意的是...
可能有重复元素...
因为我的思路是用两棵一维树状数组搞..
每个点标记为1
然后看矩形的两个方向中是否至少有一个方向上和等于长度...
所以这样如果有重复元素的话，不处理会出错..　但实际上又没修改..直接前缀和就好了．．．
树状数组个毛线．．．
不过看到还有人线段树搞得233333
/************************************************************************* &amp;gt; File Name: code/bc/#57/1002.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月26日 星期六 19时31分10秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E5+7; int c[N],d[N]; int n,m,K,Q; bool vx[N],vy[N]; int lowbit(int x) { return x&amp;amp;(-x); } void update ( int x,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) { c[i] = c[i] + delta; } } LL sum ( int x) { LL res = 0 ; for ( int i = x ; i &amp;gt;= 1 ; i = i - lowbit(i)) { res = res + c[i]; } return res; } void update2( int y,int delta) { for ( int i = y ; i &amp;lt;= m ; i = i + lowbit(i)) { d[i] = d[i] + delta; } } LL sum2( int y) { LL res = 0 ; for ( int i = y ; i &amp;gt;= 1 ; i = i - lowbit(i)) { res = res + d[i]; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item></channel></rss>