<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>依赖注入 on Clarity</title><link>https://111qqz.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link><description>Recent content in 依赖注入 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Tue, 09 Oct 2018 07:45:17 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/index.xml" rel="self" type="application/rss+xml"/><item><title>spring 依赖注入</title><link>https://111qqz.com/2018/10/spring-dependency-injection/</link><pubDate>Tue, 09 Oct 2018 07:45:17 +0000</pubDate><guid>https://111qqz.com/2018/10/spring-dependency-injection/</guid><description>
真是个不明觉厉的术语...其实是个特别简单的概念orz
用白话讲，如果一个class A中用到了class B的实例，那么class B的实例就是class A的依赖，如果不是在class A中定义class B的实例，而是通过某个接口，将class B的实例传入classA,就叫依赖注入。
public class Example { // private DatabaseThingie myDatabase; // public Example() { // myDatabase = new DatabaseThingie(); // } public Example(DatabaseThingie useThisDatabaseInstead) { myDatabase = useThisDatabaseInstead; } public void DoStuff() { ... myDatabase.GetData(); ... } } 依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。
简单来说，a依赖b，但a不控制b的创建和销毁，仅使用b，那么b的控制权交给a之外处理，这叫控制反转（IOC），而a要依赖b，必然要使用b的instance，那么
1. 通过a的接口，把b传入； 2. 通过a的构造，把b传入； 3. 通过设置a的属性，把b传入； 这个过程叫依赖注入（DI）。
那么什么是IOC Container？
随着DI的频繁使用，要实现IOC，会有很多重复代码，甚至随着技术的发展，有更多新的实现方法和方案，那么有人就把这些实现IOC的代码打包成组件或框架，来避免人们重复造轮子。
所以实现IOC的组件或者框架，我们可以叫它IOC Container。</description></item></channel></rss>