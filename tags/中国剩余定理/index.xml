<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>中国剩余定理 on 111qqz的小窝</title><link>http://example.org/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</link><description>Recent content in 中国剩余定理 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 15 Oct 2016 09:00:14 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 1573 X问题 (exgcd求解一般线性同余方程组解的个数)</title><link>http://example.org/2016/10/hdu-1573/</link><pubDate>Sat, 15 Oct 2016 09:00:14 +0000</pubDate><guid>http://example.org/2016/10/hdu-1573/</guid><description>题目链接
题意：求在小于等于N的正整数中有多少个X满足：X mod a[0] = b[0], X mod a[1] = b[1], X mod a[2] = b[2], …, X mod a[i] = b[i], … (0 &amp;lt; a[i] &amp;lt;= 10)。
思路：先用扩展欧几里得算法（excrt）解一般同余方程求出一个特解R,然后通解R' = R + k * LCM(a1..am)
注意一些特殊情况，如果无解输出0，如果n小于最小的正整数的R也输出0，
否则答案为(n-R)/M + 1
/* *********************************************** Author :111qqz Created Time :Sat 15 Oct 2016 03:31:09 PM CST File Name :code/hdu/1573.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N =15; LL a[N],r[N]; LL nn; int m; LL exgcd(LL a,LL b,LL &amp;amp;x,LL &amp;amp;y) { if (b==0) { x = 1; y = 0 ; return a; } LL ret = exgcd( b, a%b,y,x); y-=x*(a/b); return ret; } LL ex_crt(LL *m,LL *r,int n) { LL M = m[1] , R = r[1],x,y,gcd; for ( int i = 2 ; i &amp;lt;= n ; i++) { gcd = exgcd(M,m[i],x,y); if ((r[i]-R)%gcd) return 0; LL gx = m[i]/gcd; x = x*(r[i]-R)/gcd; x %=gx; R += x*M; M = M / gcd * m[i]; R%=M; } if (R&amp;lt;=0) R+=M; if (nn&amp;lt;R) return 0; return (nn-R)/M + 1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2891 Strange Way to Express Integers (扩展欧几里得算法解一般线性同余方程组)</title><link>http://example.org/2016/10/poj-2891/</link><pubDate>Fri, 14 Oct 2016 19:16:55 +0000</pubDate><guid>http://example.org/2016/10/poj-2891/</guid><description>题目链接
题意：给出k个方程，形式为 x==r1,求最小的正数x，无解输出-1.
思路：首先很容易让人联想到crt.
然而crt的使用条件是，所有的m(也就是这道题中的a)两两互质，这道题并不满足，因此不能使用crt.
首先，我们看两个式子的情况 X mod m1=r1……………………………………………………………(1) X mod m2=r2……………………………………………………………(2) 则有 X=m1k1+r1………………………………………………………………() X=m2k2+r2 那么 m1k1+r1=m2k2+r2 整理，得 m1k1-m2*k2=r2-r1 令(a,b,x,y,m)=(m1,m2,k1,k2,r2-r1)，原式变成 ax+by=m 熟悉吧？此时，因为GCD(a,b)=1不一定成立，GCD(a,b) | m 也就不一定成立。所以应该先判 若 GCD(a,b) | m 不成立，则方程无解。（理论依据：裴蜀定理） 否则，继续往下。
解出(x,y)，将k1=x反代回（），得到X。 于是X就是这两个方程的一个特解，通解就是 X'=X+kLCM(m1,m2) 这个式子再一变形，得 X' mod LCM(m1,m2)=X 这个方程一出来，说明我们实现了(1)(2)两个方程的合并。 令 M=LCM(m1,m2)，R=r2-r1 （注意这里原博客写错了，应该为R=x*m1+r1） 就可将合并后的方程记为 X mod M = R。
然后，扩展到n个方程。 用合并后的方程再来和其他的方程按这样的方式进行合并，最后就能只剩下一个方程 X mod M=R，其中 M=LCM(m1,m2,&amp;hellip;,mn)。 那么，X便是原模线性方程组的一个特解，通解为 X'=X+k*M。
如果，要得到X的最小正整数解，就还是原来那个方法：
X%=M; if (X&amp;lt;0) X+=M;参考博客
这篇题解是我看了那么多讲得最清楚的一篇了&amp;hellip;.虽然证明的那个地方笔误了。。。好在对照下代码就看出来了（个鬼，我问了好几个人，想到现在。。。最后发现是笔误。好气啊）
这道题实际上给出了解线性同余方程组的一般做法（即，不要求所有的m两两互质）
这种做法的理论依据是扩展欧几里得算法，和中国剩余定理没什么关系&amp;hellip;
不过既然都是解线性同余方程组。。。非要把这种做法叫什么ex_crt&amp;hellip;我也不是很反对&amp;hellip;.
/* *********************************************** Author :111qqz Created Time :Sat 15 Oct 2016 02:42:54 AM CST File Name :code/poj/2891.</description></item><item><title>poj 1006 Biorhythms (中国剩余定理模板题)</title><link>http://example.org/2016/10/poj-1006-biorhythms-/</link><pubDate>Thu, 13 Oct 2016 12:39:27 +0000</pubDate><guid>http://example.org/2016/10/poj-1006-biorhythms-/</guid><description>题目链接：
**题意：**人自出生起就有体力，情感和智力三个生理周期，分别为23，28和33天。一个周期内有一天为峰值，在这一
天，人在对应的方面（体力，情感或智力）表现最好。通常这三个周期的峰值不会是同一天。现在给出三个日
期，分别对应于体力，情感，智力出现峰值的日期。然后再给出一个起始日期，要求从这一天开始，算出最少
再过多少天后三个峰值同时出现。
思路：解一个线性同余方程。crt的模板题。
关于crt的讲解：中国剩余定理学习笔记
几年前就A过了，现在重新写题解复习一下。
/* *********************************************** Author :111qqz Created Time :Thu 13 Oct 2016 08:00:04 PM CST File Name :code/poj/1006.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int p,e,i,d; int a[5],m[5]; void exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y) { if (b==0) { x = 1; y = 0; return; } exgcd(b,a%b,x,y); int tmp = x; x = y; y = tmp - a/b*y; } int crt(int a[],int m[],int n) { int M = 1; int ans = 0 ; for ( int i = 1 ; i &amp;lt;= n; i++) M*=m[i]; for ( int i = 1 ; i &amp;lt;= n ; i++) { int x,y; int Mi = M/m[i]; exgcd(Mi,m[i],x,y); ans = ( ans + Mi * x * a[i])%M; } if (ans&amp;lt;0) ans+=M; return ans; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>中国剩余定理(crt)学习笔记</title><link>http://example.org/2016/10/crt/</link><pubDate>Tue, 11 Oct 2016 13:04:54 +0000</pubDate><guid>http://example.org/2016/10/crt/</guid><description>前置技能点：
维基百科_裴蜀定理（贝祖等式）
有整数解时当且仅当_m_是_d_的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解、都称为裴蜀数，可用扩展欧几里得算法求得。
特别地，方程 有整数解当且仅当整数_a_和_b_互素。（kk:因为1(m=1)只可能是1(d=1)的倍数，也就是说gcd(a,b)=1，即a,b互质）
维基百科_扩展欧几里得算法
![ax + by = \gcd(a, b).](https://wikimedia.org/api/rest_v1/media/math/render/svg/72fe07a990a7ce59a499626f59b1ce588c8f6cda) 通常谈到[最大公约数](https://zh.wikipedia.org/wiki/)时，我们都会提到一个非常基本的事实：**给予二整数a、b，必存在有整数x、y使得ax + by = gcd(a,b)**[[1]](https://zh.wikipedia.org/wiki/#cite_note-1)。 有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。
例子：
求二元一次不定方程的整数解。
* 47 = 30 * 1 + 17 * 30 = 17 * 1 + 13 * 17 = 13 * 1 + 4 * 13 = 4 * 3 + 1 然后把它们改写成“余数等于”的形式
* 17 = 47 * 1 + 30 * (-1) //式1 * 13 = 30 * 1 + 17 * (-1) //式2 * 4 = 17 * 1 + 13 * (-1) //式3 * 1 = 13 * 1 + 4 * (-3) 然后把它们**“倒回去”**</description></item></channel></rss>