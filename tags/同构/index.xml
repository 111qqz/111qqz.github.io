<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>同构 on 111qqz's blog</title><link>https://111qqz.com/tags/%E5%90%8C%E6%9E%84/</link><description>Recent content in 同构 on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 12 Aug 2016 08:37:06 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%90%8C%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>最小表示法学习笔记（同构问题+模板）</title><link>https://111qqz.com/2016/08/</link><pubDate>Fri, 12 Aug 2016 08:37:06 +0000</pubDate><guid>https://111qqz.com/2016/08/</guid><description>
首先放一波资料：叶子豪_最小表示法
周源_《浅谈最小表示法在字符串循环同构问题中的应用》 参考博客 对于字符串循环同构的最小表示法，其问题实质是求S串的一个位置，从这个位置开始循环输出S，得到的S’字典序最小。
一种朴素的方法是设计i,j两个指针。其中i指向最小表示的位置，j作为比较指针。
令i=0,j=1 如果S[i] S[j] i=j, j=i+1 如果S[i] S[j+k] i=j,j=i+1** _ 否则j++ **返回i** 注意到，朴素算法的缺陷在于斜体的情况下i指针的移动太少了。针对这一问题改进就得到了最小表示法的算法。最小表示法的算法思路是维护两个指针i,j。
令i=0,j=1 如果S[i] S[j] i=j, j=i+1 如果S[i] S[j+k] i=i+k ** 否则j++ **返回i****和j****的小者** 注意到上面两个算法唯一的区别是粗体的一行。这一行就把复杂度降到O(n)了。 值得一提的是，与KMP类似，最小表示法处理的是一个字符串S的性质，而不是看论文时给人感觉的处理两个字符串。 应用最小表示法判断两个字符串同构，只要将两个串的最小表示求出来，然后从最小表示开始比较。剩下的工作就不用多说了。
模板：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; const int N = 100000+10; char str[N]; int minimalRepresentation() { int n = strlen(str); int i = 0,j = 1, k = 0; while(i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;n &amp;amp;&amp;amp; k&amp;lt;n) { int t = str[(i+k)%n] - str[(j+k)%n] ; if(t == 0) k++; else { if(t&amp;gt;0) i+=k+1; else j+=k+1; if(i==j) j++; k = 0; } } return i &amp;lt; j ?</description></item></channel></rss>