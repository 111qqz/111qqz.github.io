<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nim游戏 on 111qqz的小窝</title><link>https://111qqz.com/tags/nim%E6%B8%B8%E6%88%8F/</link><description>Recent content in nim游戏 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 20 Jul 2016 12:03:45 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/nim%E6%B8%B8%E6%88%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 1850 Being a Good Boy in Spring Festival (nim游戏问必胜方案数，sg函数)</title><link>https://111qqz.com/2016/07/hdu-1850/</link><pubDate>Wed, 20 Jul 2016 12:03:45 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-1850/</guid><description>
hdu1850题目链接 题意：n堆石子。。每堆可以取任意多个。。。先取完的赢。。问先手能否赢。。能赢的话第一步有几种取法。。 思路：sg函数。。对于方案数，可以用nim游戏的结论。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } 网站链接: /2016/07/hdu-1850/https://111qqz.com/wordpress/wp-content/uploads/2016/07/未命名.png
链接到文件: /content/post/ACM-ICPC/https://111qqz.com/wordpress/wp-content/uploads/2016/07/未命名.png
使用 Page Bundles: true
。设异或和为sum..那么统计满足 a[i]^sum&amp;lt;a[i]的个数就是第一步能走的方案数。
以及。。sg函数。。如果走的步数是任意的。。也就是没有限制。。。那么sg[i] = i...此时也就退化成了一般的nim游戏。。。
/* *********************************************** Author :111qqz Created Time :2016年07月20日 星期三 19时47分48秒 File Name :code/hdu/1850.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; const int M=1E6+7; int n; int sg[M]; int a[N]; void sg_init() { //这个可以记成结论23333 for ( int i = 1 ; i &amp;lt; M ; i ++) sg[i] = i ; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>nim游戏以及证明过程</title><link>https://111qqz.com/2016/07/nim/</link><pubDate>Wed, 20 Jul 2016 08:06:50 +0000</pubDate><guid>https://111qqz.com/2016/07/nim/</guid><description>
参考资料　（后面的证明写错了，差评，不要看，看图就好了）
1. 题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。 题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。 嘿嘿，这个游戏我早就见识过了。小时候用珠算玩这个游戏：第一档拨一个，第二档拨两个，依次直到第五档拨五个。然后两个人就轮流再把棋子拨下来，谁要是最后一个拨谁就赢。有一次暑假看见两个小孩子在玩这个游戏，我就在想有没有一个定论呢。下面就来试着证明一下吧 先解决第一个问题吧。 定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则， 为利己态，用S表示。 [定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。 证明：  若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态，  c = A(1) xor A(2) xor … xor A(n) 0;  把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t)(注：我觉得应该是必然存在奇数个),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。  那么我们把x = A(t) xor c,则得到x  A(1) xor A(2) xor … xor x xor … xor A(n)　（**需要注意的是，这里是没有A(t)这一项的，前面之所以要说明x  = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n)  = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n)  = 0 这就是说从A(t)堆中取出 A(t) - x 根火柴后状态就会从S态变为T态。证毕 Image not found a.</description></item><item><title>hdu 1849Rabbit and Grass(一维nim游戏,sg函数)</title><link>https://111qqz.com/2015/09/hdu1849/</link><pubDate>Tue, 22 Sep 2015 12:47:00 +0000</pubDate><guid>https://111qqz.com/2015/09/hdu1849/</guid><description>
Rabbit and Grass **Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3058 Accepted Submission(s): 2261 **
Problem Description
大学时光是浪漫的，女生是浪漫的，圣诞更是浪漫的，但是Rabbit和Grass这两个大学女生在今年的圣诞节却表现得一点都不浪漫：不去逛商场，不去逛公园，不去和AC男约会，两个人竟然猫在寝食下棋…… 说是下棋，其实只是一个简单的小游戏而已，游戏的规则是这样的： 1、棋盘包含1*n个方格，方格从左到右分别编号为0，1，2，…，n-1； 2、m个棋子放在棋盘的方格上，方格可以为空，也可以放多于一个的棋子； 3、双方轮流走棋； 4、每一步可以选择任意一个棋子向左移动到任意的位置（可以多个棋子位于同一个方格），当然，任何棋子不能超出棋盘边界； 5、如果所有的棋子都位于最左边（即编号为0的位置），则游戏结束，并且规定最后走棋的一方为胜者。
对于本题，你不需要考虑n的大小（我们可以假设在初始状态，棋子总是位于棋盘的适当位置）。下面的示意图即为一个1*15的棋盘，共有6个棋子，其中，编号8的位置有两个棋子。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } 网站链接: /2015/09/hdu1849/https://111qqz.com/wp-content/uploads/2015/11/C101-1004-1.jpg
链接到文件: /content/post/ACM-ICPC/https://111qqz.com/wp-content/uploads/2015/11/C101-1004-1.jpg
使用 Page Bundles: true
大家知道，虽然偶尔不够浪漫，但是Rabbit和Grass都是冰雪聪明的女生，如果每次都是Rabbit先走棋，请输出最后的结果。
Input
输入数据包含多组测试用例，每个测试用例占二行，首先一行包含一个整数m（0&amp;lt;=m&amp;lt;=1000），表示本测试用例的棋子数目，紧跟着的一行包含m个整数Ki(i=1…m; 0&amp;lt;=Ki&amp;lt;=1000)，分别表示m个棋子初始的位置，m=0则结束输入。
Output
如果Rabbit能赢的话，请输出“Rabbit Win!”，否则请输出“Grass Win!”，每个实例的输出占一行。
Sample Input</description></item><item><title>bestcoder #56 div 2 C Clarke and puzzle (nim游戏　树状数组)</title><link>https://111qqz.com/2015/09/bestcoder56div2cclarkeandpuzzlenim/</link><pubDate>Tue, 22 Sep 2015 03:32:00 +0000</pubDate><guid>https://111qqz.com/2015/09/bestcoder56div2cclarkeandpuzzlenim/</guid><description>
比赛的时候没过．还以为是树状数组写残了． 但实际上是有自己不知道的东西． 这种博弈叫　nim游戏 所以这是一个二维的nim游戏． **nim游戏的性质是xor 和为0必败，否则必胜． xor和也有前缀和性质，所以可以用树状数组维护．
/************************************************************************* &amp;gt; File Name: code/bc/#56/r1003.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 11时10分06秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=5E2+5; int c[N][N]; int a[N][N]; int n,m,q; int lowbit ( int x) { return x&amp;amp;(-x); } void update (int x,int y,int delta) { for ( int i = x ; i &amp;lt;= n ; i = i + lowbit(i)) { for ( int j = y ; j &amp;lt;= m ; j = j + lowbit(j)) { c[i][j]^=delta; } } } int sum( int x,int y) { int res = 0; for ( int i = x; i &amp;gt;= 1 ; i = i - lowbit(i)) { for ( int j = y ; j &amp;gt;= 1 ; j = j - lowbit(j)) { res ^= c[i][j]; } } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item></channel></rss>