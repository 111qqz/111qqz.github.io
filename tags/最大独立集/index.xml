<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最大独立集 on 111qqz的小窝</title><link>http://example.org/tags/%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/</link><description>Recent content in 最大独立集 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 28 May 2016 01:34:53 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 1068 Girls and Boys (二分图的最大独立集，匈牙利算法)</title><link>http://example.org/2016/05/hdu1068/</link><pubDate>Sat, 28 May 2016 01:34:53 +0000</pubDate><guid>http://example.org/2016/05/hdu1068/</guid><description>hdu 1068题目链接 题意：有n个同学。。给出同学之间的 爱慕关系。。。选出一个集合使得集合中的人没有爱慕关系。问能选出的最大集合是多少。
思路：没有数据范围，差评！题意说得也不清楚。。由数据知道。。爱慕关系一定是相互的。。。
这道题实际上是二分图的最大独立集问题。
学到的一点是：对于二分图，可能并不能明显得分成两个不相交的集合，而是一个整体。（有左集合到又集合的边，同时有又集合到左集合的边，就是说每条边都是无相边。。？） 这其实等于把两个无向图叠加在了一起（从左指向右的和从又指向左的）
所以hungary得到的最大匹配数应该除以2，才是真正的最大匹配数。
/* *********************************************** Author :111qqz Created Time :2016年05月28日 星期六 08时42分19秒 File Name :code/hdu/1068.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+5; int n; int head[N]; //vector &amp;lt;int&amp;gt;edge[N]; int link[N]; bool vis[N]; int cnt; struct Edge { int v; int nxt; }edge[10005]; void addedge( int u,int v) { edge[cnt].</description></item></channel></rss>