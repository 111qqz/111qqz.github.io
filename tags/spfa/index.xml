<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spfa on Clarity</title><link>https://111qqz.com/tags/spfa/</link><description>Recent content in spfa on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Mon, 18 Jul 2016 12:20:08 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/spfa/index.xml" rel="self" type="application/rss+xml"/><item><title>whust 2016 warm up E ||codeforces 689 B. Mike and Shortcuts (spfa)</title><link>https://111qqz.com/2016/07/cf689b/</link><pubDate>Mon, 18 Jul 2016 12:20:08 +0000</pubDate><guid>https://111qqz.com/2016/07/cf689b/</guid><description>
cf689B题目链接
题意：n点。。点i到点j的代价是|i-j|..给出n条近路。。。a[i]表示点i到a[i]的代价为1（注意近路不一定就近）
思路：一开始建边卡了一下。。。实际上只要连相邻的就好了。。。然后边表只开了2N蠢哭。。。实际上应该3M...因为连相邻的边是双向的。。。再加上近路的单向。。。然后spfa就好了。。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 13时33分18秒 File Name :code/2016whust/F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int a[N]; bool inq[N]; int d[N]; int head[N]; int cnt; struct Edge { int v; int w; int nxt; }edge[8*N]; void addedge( int u,int v,int w) { edge[cnt].</description></item><item><title>BZOJ 1681: [Usaco2005 Mar]Checking an Alibi 不在场的证明 (spfa)</title><link>https://111qqz.com/2016/07/bzoj-1681-usaco2005-marchecking-an-alibi--spfa/</link><pubDate>Wed, 06 Jul 2016 13:18:30 +0000</pubDate><guid>https://111qqz.com/2016/07/bzoj-1681-usaco2005-marchecking-an-alibi--spfa/</guid><description>
1681: [Usaco2005 Mar]Checking an Alibi 不在场的证明 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 250 Solved: 178 [Submit][Status][Discuss]
Description A crime has been comitted: a load of grain has been taken from the barn by one of FJ's cows. FJ is trying to determine which of his C (1 &amp;lt;= C &amp;lt;= 100) cows is the culprit. Fortunately, a passing satellite took an image of his farm M (1 &amp;lt;= M &amp;lt;= 70000) seconds before the crime took place, giving the location of all of the cows.</description></item><item><title>uva 10986 Sending email (spfa)</title><link>https://111qqz.com/2016/05/uva-10986/</link><pubDate>Tue, 24 May 2016 20:14:32 +0000</pubDate><guid>https://111qqz.com/2016/05/uva-10986/</guid><description>
uva10986题目链接 题意：裸的spfa.
思路：模板，1A.
/* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 03时25分27秒 File Name :code/uva/10986.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; int n,m; int S,T; vector &amp;lt; pi &amp;gt; edge[N]; int d[N]; bool inq[N]; bool spfa( int s,int t) { ms(d,0x3f); ms(inq,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 2949 Word Rings (spfa+栈优化)</title><link>https://111qqz.com/2016/05/poj-2949-word-rings/</link><pubDate>Tue, 24 May 2016 19:55:02 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-2949-word-rings/</guid><description>
poj2949 题目链接 题意：我们有 n 个 (n&amp;lt;=100000) 字符串,每个字符串都是由 a~z 的小写英文字 母组成的字符串。如果字符串 A 的结尾两个字符刚好与字符串 B 的开头两字符相 匹配,那么我们称 A 与 B 能相连(注意: A 能与 B 相连不代表 B 能与 A 相连)。 我们希望从给定的字符串中找出一些,使得他们首尾相接形成一个环串(一个串首尾相连也算) 我们想要使这个环串的平均长度最长。
思路：参考了国家集训队论文《spfa算法的优化与应用》
首先我卡在了关于接龙问题的处理方法，只能想到n^2的方法。。显然gg.
而正解是把每个单词看做一条边，把每个单词开头的两个字母和结尾两个字母看做起点和终点，由于都是小写字母，2位26进制数最多表示26*26。
这个建图方式并不是特别显然，不过想一下还是可以理解的。。以及这应该算是处理单词接龙问题的一个技巧。。。
这道题综合了两种常见的问题：字符串的接龙以及平均值的最优化问题。对于前者，我们可以采取把单词看成边，把首尾字母组合看成点的方法。例如对于单词ababc就是点”ab”向点”bc”连一条长度为5的边。这样问题的模型变得更加清晰，规模也得到减小。那么原问题就可以转化成在此图中找一个环，使得环上边权的平均值最大。对于这种问题，我们有很经典的解决方法： 由于Average=(E1+E2+…..+Ek)/K 所以Average*K=E1+E2+……+Ek 即（E1-Average）+（E2-Average）+….+ （Ek-Average）=0 另外注意到上式中的等于号可以改写为小于等于，那么我们可以二分答案Ans，然后判断是否存在一组解满足（E1+E2+…..+Ek）/K&amp;gt;Ans,即判断 （E1- Ans）+（E2- Ans）+….+ （Ek- Ans）&amp;gt;0 于是在二分答案后，我们把边的权值更新，问题就变成了查找图中是否存在一个正环。
然后参考了这篇题解学习了一下栈优化的spfa： spfa栈优化 
以及这篇博客中比较了dfs的spfa和普通栈优化的spfa... 200+ms vs 2000+ms...十倍的优化。。太神了。。。
/* 枚举每一个平均长度mid值。 如果存在一个环，(E1+...+Ek)/k=mid(其中k是边数，E1……Ek是各个边权)， 那么正解比mid大，否则比mid小，这就是二分策略。 那么怎样知道是否存在(E1+...+Ek)/k=mid 呢？ 如下转化：(E1+...+Ek)=mid*k E1-mid + E2–mid + E3-mid + ... + Ek-mid = 0 所以，把所有的边权改为Ei – mid，然后看是否存在正环就可以，存在就是满足条件。 */ /* *********************************************** Author :111qqz Created Time :2016年05月25日 星期三 00时25分51秒 File Name :code/poj/2949.</description></item><item><title>poj 1860 Currency Exchange (spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1860/</link><pubDate>Tue, 24 May 2016 16:16:38 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1860/</guid><description>
poj 1860 题目链接
题意：有n种货币，m个货币交易点，每个货币交易点只能是两种货币之间交换，给出两个方向的汇率和手续费。初始拥有数量v的货币s,问能否经过一些py交易，使得最后手里的货币s比v多。
思路：大概还是用spfa求最长路。。松弛那里需要注意一下算法。。。
1A。。。好爽啊。。。。。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 23时41分46秒 File Name :code/poj/1860.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E2+7; int n,m,s; double v; double d[N]; bool inq[N]; vector &amp;lt;pair&amp;lt;int,pair&amp;lt;double,double&amp;gt; &amp;gt; &amp;gt; edge[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>poj 1932 XYZZY (floyd传递闭包+spfa求最长路)</title><link>https://111qqz.com/2016/05/poj-1932/</link><pubDate>Tue, 24 May 2016 13:00:45 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1932/</guid><description>
poj1932题目链接
题意：初始在点1，有100点能量，然后每个点有一个能量值【-100,100】，经过某个点会加上这个点的能量值，问能否找到一条到点n且的路线，且路径任何点的能量值一直为正。一共不超过100个点。
思路：像样例中是直接联通，一路上的能量值都大于0，这是有解的一种情况。另一种是存在一个正环，可能一次路过后面的能量值不够，但是我们可以走多次啊。
因为要求每一步的能量值都大于0，那么我们可以初始化d[]数组为0，然后用spfa求最长路（只需要把那个三角形等式换个方向即可）
如果可以直接联通，也就是d[n]&amp;gt;0，那么有解。
还有可能是存在一个环（判断环的方法是用一个数组在spfa的时候统计每个点入队的次数，如果一个点的入队次数大于n，那么就存在环，且这个点在环中）
但是我们还要保证起点1和终点n是经过这个环的。
所以先跑一发floyd. 其实n才100也算给了提示吧，不用floyd的话没道理这么小的数据。。？
感觉这道题很棒，把spfa和floyd结合在了一起。
学到了判断环的方法，spfa求最长路的方法，复习了传递闭包。
/* *********************************************** Author :111qqz Created Time :2016年05月24日 星期二 20时03分37秒 File Name :code/poj/1932.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; vector&amp;lt; int &amp;gt; edge[N]; int a[N]; bool conc[N][N]; int in[N]; //统计入队次数，大于n次表明有环。 bool inq[N]; int n; int d[N]; void floyd() //传递闭包 { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (conc[i][k]&amp;amp;&amp;amp;conc[k][j]) conc[i][j] = true; } bool spfa(int s) //spfa求最长路。 { ms(in,0); ms(d,0);//因为小于等于0就死，所以初始是0，这样更新的时候一定是正值才更新。 ms(inq,false); queue&amp;lt;int&amp;gt;q; q.</description></item><item><title>poj 1511 Invitation Cards (链式前向星存图+spfa)</title><link>https://111qqz.com/2016/05/poj-1511/</link><pubDate>Tue, 24 May 2016 11:36:07 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1511/</guid><description>
poj 1511 题目链接 题意：和那道奶牛的舞会类似，要求所有点到点1的距离和加上1点到所有点的距离和。 思路：正反存边建两次图，跑两次spfa. 然而用vector会TLE....所以去学习了新的建图方式。。。也就是链式前向星：链式前向星（边表）学习链接 也叫边表。
是一种几乎没有什么缺点的存图方式。。。？ 比起普通的前向星少了个排序。
哦，还有我发现貌似很多人把这个东西叫邻接表。。但是根据这里：几种建图方式
这个东西还是交边表或者链式前向星比较合适。。。？
/* *********************************************** Author :111qqz Created Time :2016年05月23日 星期一 20时31分19秒 File Name :code/poj/1511.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E7+7; LL d[N]; bool inq[N]; int n,m; struct Edge { int v,w; int nxt; }edge1[N],edge2[N]; //反向存一次 int head1[N],head2[N]; int cnt; void addedge(Edge *edge,int *head,int u,int v,int w) { edge[cnt].</description></item><item><title>BZOJ 1614: [Usaco2007 Jan]Telephone Lines架设电话线 (二分+spfa)</title><link>https://111qqz.com/2016/05/bzoj-1614/</link><pubDate>Sun, 22 May 2016 13:09:49 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj-1614/</guid><description>
1614: [Usaco2007 Jan]Telephone Lines架设电话线 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1325 Solved: 570 [Submit][Status][Discuss]
Description Farmer John打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。 FJ的农场周围分布着N(1 &amp;lt;= N &amp;lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1 &amp;lt;= P &amp;lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。 第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为 L_i (1 &amp;lt;= L_i &amp;lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。 经过谈判，电信公司最终同意免费为FJ连结K(0 &amp;lt;= K &amp;lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过 K对，那么FJ的总支出为0。 请你计算一下，FJ最少需要在电话线上花多少钱。
Input 第1行: 3个用空格隔开的整数：N，P，以及K
第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i
Output 第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成， 输出-1 Sample Input 5 7 1 1 2 5 3 1 4 2 4 8 3 2 3 5 2 9 3 4 7 4 5 6</description></item><item><title>BZOJ 1631: [Usaco2007 Feb]Cow Party (SPFA)</title><link>https://111qqz.com/2016/05/bzoj-1631/</link><pubDate>Sat, 21 May 2016 13:09:57 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj-1631/</guid><description>
1631: [Usaco2007 Feb]Cow Party Time Limit: 5 Sec Memory Limit: 64 MB Submit: 670 Solved: 493 [Submit][Status][Discuss]
Description  农场有N(1≤N≤1000)个牛棚，每个牛棚都有1只奶牛要参加在X牛棚举行的奶牛派对．共有M(1≤M≤100000)条单向路连接着牛棚，第i条踣需要Ti的时间来通过．牛们都很懒，所以不管是前去X牛棚参加派对还是返回住所，她们都采用了用时最少的路线．那么，用时最多的奶牛需要多少时间来回呢？
Input 第1行:三个用空格隔开的整数.
第2行到第M+1行,每行三个用空格隔开的整数:Ai, Bi,以及Ti.表示一条道路的起点,终点和需要花费的时间.
Output 唯一一行:一个整数: 所有参加聚会的奶牛中,需要花费总时间的最大值.
Sample Input 4 8 2 1 2 4 1 3 2 1 4 7 2 1 1 2 3 5 3 1 2 3 4 4 4 2 3
Sample Output 10
HINT 样例说明: 共有4只奶牛参加聚会,有8条路,聚会位于第2个农场. 第4只奶牛可以直接到聚会所在地(花费3时间),然后返程路线经过第1和第3个农场(花费7时间),总共10时间.
思路：想了一下。。因为要知道每个点到x的最短距离。。。以及反过来。。
单向很容易知道。。。以x点为起点做一遍spfa,那么x到每个点的最短距离就知道了。。
那么反过来怎么办呢？
我的做法是反向建边再跑一遍spfa...
1A,开心。
/* *********************************************** Author :111qqz Created Time :2016年04月04日 星期一 19时36分38秒 File Name :code/bzoj/1631.</description></item><item><title>hdu 3790 最短路径问题 (spfa模板题)</title><link>https://111qqz.com/2016/05/hdu3790/</link><pubDate>Sat, 21 May 2016 11:09:54 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3790/</guid><description>
hdu 3790 题目链接
题意：给出n个点m条无向边，每条边有一个距离和一个花费。给出s,t。问从s到t的最短距离以及最短距离时的最小花费。当有多个距离最短的方案时，选取花费最少的。
spfa学习链接
usetc 每周算法讲堂之spfa
先写几道题加深理解。
记得初始化。。。。。。
/* *********************************************** Author :111qqz Created Time :2016年05月21日 星期六 18时42分24秒 File Name :code/hdu/3790.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; int d[N]; int p[N]; bool inq[N]; vector &amp;lt; pair&amp;lt;int,pair&amp;lt;int,int&amp;gt; &amp;gt; &amp;gt; edge[N]; int s,t; void init() { ms(inq,false); ms(d,0x3f); ms(p,0x3f); for ( int i = 0 ; i &amp;lt;=n ; i++) edge[i].</description></item></channel></rss>