<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2-sat on 111qqz的小窝</title><link>http://example.org/tags/2-sat/</link><description>Recent content in 2-sat on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 15 Aug 2015 07:10:00 +0000</lastBuildDate><atom:link href="http://example.org/tags/2-sat/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces 569 E. New Language (2-sat)</title><link>http://example.org/2015/08/codeforces569e/</link><pubDate>Sat, 15 Aug 2015 07:10:00 +0000</pubDate><guid>http://example.org/2015/08/codeforces569e/</guid><description>/************************************************************************* &amp;gt; File Name: code/cf/#315/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月15日 星期六 13时48分36秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=5E2+7; int flag[N],flag2[N]; int f[N][N]; int a[N]; char s[N]; int ans[N]; int len,n,m; char s1[13],s2[13]; int p1,p2,q1,q2,dq1,dq2; void add(int p,int q,int flag[]) { int dq = q * n + p;//找到元辅音状态为q，第p的点的下标 for (int i=1;i&amp;lt;=2*n;++i) { if (f[dq][i]==0) continue; flag[i]=1;//找到所有由dp出发的边指向的点，表示选了dp点一定要选的点。 } } bool check(int flag[]) { for (int i=1;i&amp;lt;=n;++i) if (flag[i]==1&amp;amp;&amp;amp;flag[i+n]==1) return false; //判断是否存在矛盾 //（选了j点后，既要选择某点k的元音，也要选择某点k的辅音）　return true; } bool dfs(int pos,int x) { if (pos&amp;gt;n) return true;//如果能形成一个长度为n的单词，说明这种语言有word bool g[2]; g[0]=g[1]=false; for (int i=x;i&amp;lt;=len;++i)//从当前字母x往后枚举 { for (int j=1;j&amp;lt;=2*n;++j) flag2[j]=flag[j];//为了不影响原始数组，复制一个布尔数组出来。 add(pos,a[i],flag2);//找到所有选了pos点一定要选的点 if (check(flag2)&amp;amp;&amp;amp;(!</description></item></channel></rss>