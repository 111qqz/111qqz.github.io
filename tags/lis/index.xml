<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LIS on 111qqz的小窝</title><link>https://111qqz.com/tags/lis/</link><description>Recent content in LIS on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 26 Jan 2017 08:12:38 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/lis/index.xml" rel="self" type="application/rss+xml"/><item><title>BZOJ 1207: [HNOI2004]打鼹鼠 (LIS)</title><link>https://111qqz.com/2017/01bzoj-1207-hnoi2004-lis/</link><pubDate>Thu, 26 Jan 2017 08:12:38 +0000</pubDate><guid>https://111qqz.com/2017/01bzoj-1207-hnoi2004-lis/</guid><description>
&lt;h2 id="1207-hnoi2004打鼹鼠">1207: [HNOI2004]打鼹鼠&lt;/h2>
&lt;p>Time Limit: 10 Sec  Memory Limit: 162 MB
Submit: 2854  Solved: 1390
[&lt;a href="http://www.lydsy.com/JudgeOnline/submitpage.php?id=1207">Submit&lt;/a>][&lt;a href="http://www.lydsy.com/JudgeOnline/problemstatus.php?id=1207">Status&lt;/a>][&lt;a href="http://www.lydsy.com/JudgeOnline/bbs.php?id=1207">Discuss&lt;/a>]&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿Q编写了一个打鼹鼠的游戏：在一个n&lt;em>n的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果i时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为（i,j）的网格移向(i-1, j),(i+1, j),(i,j-1),(i,j+1)四个网格，机器人不能走出整个n&lt;/em>n的网格。游戏开始时，你可以自由选定机器人的初始位置。现在你知道在一段时间内，鼹鼠出现的时间和地点，希望你编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。&lt;/p></description></item><item><title>BZOJ 1642: [Usaco2007 Nov]Milking Time 挤奶时间 (dp,类似LIS)</title><link>https://111qqz.com/2016/04bzoj1642/</link><pubDate>Sun, 10 Apr 2016 08:31:35 +0000</pubDate><guid>https://111qqz.com/2016/04bzoj1642/</guid><description>
&lt;h2>&lt;/h2>
&lt;p>Time Limit: 5 Sec  Memory Limit: 64 MB
Submit: 667  Solved: 389
[&lt;a href="http://www.lydsy.com/JudgeOnline/submitpage.php?id=1642">Submit&lt;/a>][&lt;a href="http://www.lydsy.com/JudgeOnline/problemstatus.php?id=1642">Status&lt;/a>][&lt;a href="http://www.lydsy.com/JudgeOnline/bbs.php?id=1642">Discuss&lt;/a>]&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>贝茜是一只非常努力工作的奶牛，她总是专注于提高自己的产量。为了产更多的奶，她预计好了接下来的N (1 ≤ N ≤ 1,000,000)个小时，标记为0..N-1。 Farmer John 计划好了 M (1 ≤ M ≤ 1,000) 个可以挤奶的时间段。每个时间段有一个开始时间(0 ≤ 开始时间 ≤ N), 和一个结束时间 (开始时间 &amp;lt; 结束时间 ≤ N), 和一个产量 (1 ≤ 产量 ≤ 1,000,000) 表示可以从贝茜挤奶的数量。Farmer John 从分别从开始时间挤奶，到结束时间为止。每次挤奶必须使用整个时间段。 但即使是贝茜也有她的产量限制。每次挤奶以后，她必须休息 R (1 ≤ R ≤ N) 个小时才能下次挤奶。给定Farmer John 计划的时间段，请你算出在 N 个小时内，最大的挤奶的量。&lt;/p></description></item><item><title>hdu 1950 Bridging signals (LIS)</title><link>https://111qqz.com/2016/04hdu1950/</link><pubDate>Fri, 01 Apr 2016 13:16:54 +0000</pubDate><guid>https://111qqz.com/2016/04hdu1950/</guid><description>
&lt;p>&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=1950">题目链接&lt;/a>
题意：有两跟柱子并排竖直放置，每根柱子有n个结点，从上往下标号1..n， 两根柱子间的结点间要连线，给出计划连接的情况。a[i]表示左边结点i连接右边结点a[i].但是要求连线不能交叉，所以计划可能不能全部执行。现在问最多能连接多少条线。
思路：由于不能交叉，而左边的结点是按照顺序给出的，所以右边连接的结点只能是越来越大。其实就是求a[i]的最长上升子序列。感觉算是LIS的一个比较巧妙的应用？ 由于n还是很大。所以必须nlogn的做法。&lt;/p></description></item><item><title>BZOJ 1609: [Usaco2008 Feb]Eating Together麻烦的聚餐(LIS nlogn解法)</title><link>https://111qqz.com/2016/04bzoj-1609/</link><pubDate>Fri, 01 Apr 2016 12:32:13 +0000</pubDate><guid>https://111qqz.com/2016/04bzoj-1609/</guid><description>
&lt;h2 id="1609-usaco2008-febeating-together麻烦的聚餐">1609: [Usaco2008 Feb]Eating Together麻烦的聚餐&lt;/h2>
&lt;p>Time Limit: 10 Sec  Memory Limit: 64 MB
Submit: 1282  Solved: 766
[&lt;a href="http://www.lydsy.com/JudgeOnline/submitpage.php?id=1609">Submit&lt;/a>][&lt;a href="http://www.lydsy.com/JudgeOnline/problemstatus.php?id=1609">Status&lt;/a>][&lt;a href="http://www.lydsy.com/JudgeOnline/bbs.php?id=1609">Discuss&lt;/a>]&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>为了避免餐厅过分拥挤，FJ要求奶牛们分3批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按FJ的设想所有第3批就餐的奶牛排在队尾，队伍的前端由设定为第1批就餐的奶牛占据，中间的位置就归第2批就餐的奶牛了。由于奶牛们不理解FJ的安排，晚饭前的排队成了一个大麻烦。 第i头奶牛有一张标明她用餐批次D_i(1 &amp;lt;= D_i &amp;lt;= 3)的卡片。虽然所有N(1 &amp;lt;= N &amp;lt;= 30,000)头奶牛排成了很整齐的队伍但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如111222333或者333222111。哦，你也发现了，FJ不反对一条前后颠倒的队列，那样他可以让所有奶牛向后转，然后按正常顺序进入餐厅。 你也晓得，FJ是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在FJ改卡片编号的时候，都不会挪位置。&lt;/p></description></item><item><title>最长上升子序列nlogn解法</title><link>https://111qqz.com/2016/04nlogn/</link><pubDate>Fri, 01 Apr 2016 12:15:41 +0000</pubDate><guid>https://111qqz.com/2016/04nlogn/</guid><description>
&lt;p>首先回顾一下n^2的做法。
状态转移方程为dp[i] =max(1,dp[j]) (1=&amp;lt;j&amp;lt;=i-1&amp;amp;&amp;amp;a[i]&amp;gt;a[j])&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">cin&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">ans&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ans&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们发现，使得dp[i]得到同一个值的dp[j]可能有多个，那么选择哪个呢？
假设 x&amp;lt;y&amp;lt;i，a[x]&amp;lt;a[y],dp[x]==dp[y]，那么我们选择x好还是y好呢？
显然是x好。为什么？因为选择x潜力大。因为可能在x,y之间存在一个z,满足a[x]&amp;lt;a[z]&amp;lt;a[y],如果选择a[y]，就没有办法选择可能使长度更长的a[z]了。通俗得说。。我们要求的是最长上升子序列。。你一开始就弄那么大。。。后面还上哪上升去啊。。。长度小啊。。。&lt;/p></description></item></channel></rss>