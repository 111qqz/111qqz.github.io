<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>矩形周长并 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E7%9F%A9%E5%BD%A2%E5%91%A8%E9%95%BF%E5%B9%B6/</link><description>Recent content in 矩形周长并 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 28 Sep 2017 05:44:47 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E7%9F%A9%E5%BD%A2%E5%91%A8%E9%95%BF%E5%B9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 1828 Picture （线段树+扫描线 求 矩形周长并）</title><link>https://111qqz.com/2017/09/hdu1828/</link><pubDate>Thu, 28 Sep 2017 05:44:47 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu1828/</guid><description>
题目链接
题意: 求矩形周长并。
思路： 线段树+扫描线。
和前面的求面积并比较类似，我们先考虑平行x轴的线段，考虑线段树，维护的一段区间中被矩形覆盖的次数cnt和至少覆盖一次的长度的len.
只不过我们这次求的是每条扫描线的长度对周长的贡献，因此不需要乘高度。
需要注意的是，每条扫描线对周长的贡献，是目前扫描线的长度，与上一次扫描线长度的差的绝对值。（不是与上一次答案的差的绝对值！）
演示x轴求长度和的部分 图片来自 lwt聚聚的博客 Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } 网站链接: /2017/09/hdu1828/http://img.blog.csdn.net/20151005011720453
链接到文件: /content/post/ACM-ICPC/http://img.blog.csdn.net/20151005011720453
使用 Page Bundles: true
以及一个小细节是，求面积的时候，最后一条扫描线对答案是没有贡献的（因为每次是求当前扫描线与下一条扫描线之间的面积）
但是求周长的时候，最后一条扫描线是一定会对答案有贡献的。
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 21时24分20秒 File Name :1828.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; struct Seg { double l,r,h; int d; Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp;rhs)const { return h &amp;lt; rhs.</description></item></channel></rss>