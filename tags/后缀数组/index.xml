<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>后缀数组 on 111qqz的小窝</title><link>http://example.org/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</link><description>Recent content in 后缀数组 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 27 Aug 2016 07:37:23 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/index.xml" rel="self" type="application/rss+xml"/><item><title>seerc 2014 Circle of digits (二分+后缀数组)</title><link>http://example.org/2016/08/seerc-2014-circle-of-digits-/</link><pubDate>Sat, 27 Aug 2016 07:37:23 +0000</pubDate><guid>http://example.org/2016/08/seerc-2014-circle-of-digits-/</guid><description>题目链接
题意：把一个长度为n的只由数字构成的串分成k个不为空的字串，使得最大的串最小（大小是说串所对应的十进制数的大小）
思路：由于长度为x的串肯定大于长度为x-1的串，因此很容易想到，我们要尽可能使得k组串的长度尽可能平均（避免出现某一个串的长度非常大的情况）
我们可以知道，最大值的串的长度一定为 LEN=(n+k-1)/k;
而每一组的长度，只可能是LEN或者LEN-1。
然后build_sa
注意循环串的几个地方记得%n
接下来二分sa数组的下标。
二分check的时候，先枚举断点，断环为链。
由于每部分最长的长度为LEN，所以0..LEN-1中一定存在一个断点。
然后贪心，尽可能取LEN
根据rk值来决定某一段的长度是LEN还是LEN-1（如果rk值比当前的大，那么就只能取LEN-1，否则取LEN）
如果此时k段的长度之和超过了n，说明此时的最大值还可能更小。
于是继续二分区间的前一半。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char s[N]; int sa[N],t[N],t2[N],c[N]; int rk[N],height[N]; int L; int n,k; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[(a+l)%n]==r[(b+l)%n];} void build_sa(int n,int m) { int *x = t; int *y = t2; //ms(cnt,0); ms(c,0); for ( int i = 0 ; i &amp;lt; n ; i++) c[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) c[i]+=c[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--c[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k &amp;lt;&amp;lt;=1) { int p = 0; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; else y[p++] = n+(sa[i]-k)%n; ms(c,0); for ( int i = 0 ; i &amp;lt; n ; i++) c[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) c[i]+=c[i-1]; for ( int i = n-1 ; i &amp;gt;=0 ; i--) sa[--c[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>codeforces 123 D. String　（后缀数组+两次二分得到区间＋rmq）</title><link>http://example.org/2016/08/cf-123/</link><pubDate>Tue, 02 Aug 2016 15:23:55 +0000</pubDate><guid>http://example.org/2016/08/cf-123/</guid><description>题目链接
题意：定义一个函数F．．
(1, 4), (4, 7), (9, 12)
Its continuous sequences are: * * * * * * erfen
． erfen 题目描述得很烂．．看例子把．．大概就是：如果字符串y在字符串x中出现n次，那么F(x,y)=n*(n+1)/2
现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串．
思路：由于刚刚写了一个求一个字符串所有不同子串个数的题目．．．于是就想到了后缀数组．．．
写完之后观察height[i]．如果把height[i]看成底在x轴上的第i个矩形的高的话，n就是一段连续的矩形的长度．
然后．．．暴力会tle 48
题解说单调栈．．．但是单调栈之后还要线段树or并查集？　（by 羊神）
．．．不会啊orz
最后用了二分+rmp过掉的
大概就是两次二分得到一个矩形的区间，和whust2016 #1的那道题有点像．
/* *********************************************** Author :111qqz Created Time :2016年08月01日 星期一 04时57分01秒 File Name :code/cf/problem/123d.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;stack&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; char s[N]; int cmp( int *r , int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i] +=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i ; for ( int k = 1 ; k &amp;lt;= n ; k &amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n-k ; i &amp;lt; n; i++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt;n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i] +=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ;i &amp;lt;n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 2406 Power Strings (后缀数组||kmp)</title><link>http://example.org/2016/08/poj-2406/</link><pubDate>Tue, 02 Aug 2016 13:49:47 +0000</pubDate><guid>http://example.org/2016/08/poj-2406/</guid><description>poj 2406
题意:给定一个字符串 L,已知这个字符串是由某个字符串 S 重复 R 次而得到的, 求 R 的最大值
思路:论文题.
转载论文中的题解:
最关键的在加黑的那句话:看 suffix(1)和 suffix(k+1)的最长公共 前缀是否等于 n-k
why???
转载一段证明:
虽然这道题不适合用后缀数组做,倍增会tle,dc3也是卡时间才能过,但是接触到了一个想法.
要看一个字符串s能否由一个较小的长度为k的字符串t重复若干次得到,除了要整除以外,
gengxin判断suffix(1)和 suffix(k+1)的最长公共****前缀是否等于 n-k即可.
下面是用倍增写的tle了的代码,价值在于那段没有用rmq,而是o(n)更新height数组到height[rk[0]]之间的最小值要怎么写.
/* *********************************************** Author :111qqz Created Time :2016年08月02日 星期二 19时41分08秒 File Name :code/poj/2406.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; char s[N]; int cmp( int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa( int n,int m) { int *x=t; int *y=t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[i]=s[i]]++; for ( int i = 1; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i ; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n- k; i &amp;lt; n ; i++) y[p++] =i; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt;m ; i ++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1; i &amp;lt;n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>spoj SUBST1 - New Distinct Substrings(后缀数组)</title><link>http://example.org/2016/08/spoj-subst1-new-distinct-substrings/</link><pubDate>Tue, 02 Aug 2016 10:50:52 +0000</pubDate><guid>http://example.org/2016/08/spoj-subst1-new-distinct-substrings/</guid><description>题目连接
题意：求所有不同的子串个数。
思路：后缀数组。和上一道题一样，就是数据范围变成了 5E4&amp;hellip;1A
/* *********************************************** Author :111qqz Created Time :2016年08月02日 星期二 18时32分28秒 File Name :code/spoj/subst1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; char s[N]; int sa[N],rk[N],t[N],t2[N],cnt[N],height[N]; int cmp (int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x=t,*y=t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n-k ; i &amp;lt; n ; i++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt;n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ;i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++ ) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>spoj DISUBSTR - Distinct Substrings (统计字串个数，后缀数组)</title><link>http://example.org/2016/08/spoj-disubstr/</link><pubDate>Sun, 31 Jul 2016 19:31:42 +0000</pubDate><guid>http://example.org/2016/08/spoj-disubstr/</guid><description>题目链接
题意：给出一个字符串，问所有不同的字串的个数。
思路：直接求比较困难。我们考虑，假如组成字符串的所有字符都不相同，那么就没有相同的字串，假设字符串的长度为n，那么长度为1的子串有n个，为2的有n-1个。。。为n的有1个，一共就是n*(n+1)/2个。。但是实际上会有重复的。。。
我们再次考虑这张图。
先找一个字符重复的个数，对应height[i]数组就是找height[i]大于等于1个的个数（因为x个height代表了x+1个后缀，保留1个，重复了x个，所以重复的个数恰好和符合条件的height数组对应）
接着找大于等于2的个数，大于等于3的个数&amp;hellip;
最后再把所有答案累加起来，就是总共重复的次数。
然后按照我推出的这个结论，试着写了一发。。。1A蛤蛤蛤。。。
能想到这里大概是因为之前的题目让我得出了，“height数组是个小妖精”的结论,所以入手就先观察了一下height数组。。。
具体的实现呢，就是先统计height[i]中每个值出现的次数，然后做一个后缀和，最后累加。
/* *********************************************** Author :111qqz Created Time :2016年08月01日 星期一 02时43分19秒 File Name :code/spoj/disubstr.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n; char s[N]; int sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x = t,*y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i] += cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i ; for ( int k = 1 ; k &amp;lt;= n; k &amp;lt;&amp;lt;=1 ) { int p = 0 ; for ( int i = n-k ; i &amp;lt; n; i ++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 3261 Milk Patterns (最长公共子串，后缀数组)</title><link>http://example.org/2016/08/poj-3261/</link><pubDate>Sun, 31 Jul 2016 18:18:04 +0000</pubDate><guid>http://example.org/2016/08/poj-3261/</guid><description>poj3261
题意：给一个字符串，要求找出至少出现k次的最长重复子串&amp;hellip;
思路：后缀数组，然后再次用到了根据height数组对后缀进行分组的套路&amp;hellip;二分判定合法性，对于当前的最长长度x,分组使得每组中的height[i]都大于等于x,所不同的是，判定变成了存在一个组，后缀的个数至少为k个（因为这样，就可以对于大于等于k个的后缀，同时取前x长度，得到的就是出现了至少k次且长度为x的前缀）1A,蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年08月01日 星期一 01时30分34秒 File Name :code/poj/3261.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; const int M=2E6+11; const int C = 5; int n,sa[N],rk[N],t[N],t2[N],cnt[M]; int height[N]; int s[N]; int k; int cmp(int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n-k ; i &amp;lt; n; i++) y[p++] = i ; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt;n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt;m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 1743 Musical Theme (不可重叠最长重复子串，后缀数组)</title><link>http://example.org/2016/08/poj-1743-musical-theme-/</link><pubDate>Sun, 31 Jul 2016 16:38:25 +0000</pubDate><guid>http://example.org/2016/08/poj-1743-musical-theme-/</guid><description>poj 1743
题意：n个数字（1..88）表示的音符，问最长的连续两段长度至少为5的变化相同的音符段的长度。。。
思路：求最长重复字串。。。。很容易想到后缀数组。。但是这道题多了一个不可重叠的要求。
这是论文中的题目。这个做法的确想不到，不过很好理解。
如果没有不允许重叠的条件就变成了求所有height[i]中的最大值，而每个height[i]对应的两个后缀的位置是sa[i]和sa[i-1]。
分组使得每组中的height[i]都大于等于k(那height[i]小于k的去哪里了？ 因为height[i]是由两个相邻的后缀得到的，如果某两个后缀的height[i]小于k,只需要将这两个后缀分成两组，这样这个height[i]就不存在了，从而保证了每组中的height[i]都大于等于k)
而我们知道，任意两个后缀的最长公共前缀是他们之间的所有height的最小值。因为对于处于同一组内的两个后缀来说，由于之前保证了每组中的height[i]&amp;gt;=k,也就是保证了任意两个后缀的最长公共前缀大于等于k.
因此用二分判定长度k的时候，这样分组以后，只需要再判断是否相交（也就是如果长度k不满足，可能是因为没有办法分组使得每个height都大于等于k,也可能是存在这样的分组，但是两个后缀相交）。
判断相交其实非常简单，sa[i]表示的是排名第i的后缀的开始位置，那么如果存在sa[j]-sa[i]&amp;gt;=k（其实是sa[i]+k-1&amp;lt;sa[j],sa[i]位置开始的后缀的长度为k的前缀的最后一个字符的所在位置sa[i]+k-1比sa[j]小，就说明不相交，由于是整数，就可以变成sa[i]+k&amp;lt;=sa[j]，也就是sa[j]-sa[i]&amp;gt;-=k）
而某一组内只要有一组i,j，满足sa[j]-sa[i]&amp;gt;=k就是有解，因此我们只需要判断最可能符合条件的一组，也就是找到一组中sa[i]的最大值和最小值，也正因为我们这样，我们在具体实现的过程中也没必要真的模拟分组的过程，只需要一直更新两个极值即可。
以及：lrj的板子是错的！！会re!!!! 已改正。
其他细节见代码注释
/* *********************************************** Author :111qqz Created Time :2016年07月31日 星期日 18时23分53秒 File Name :code/poj/1743.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; const int C=100; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r ,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} int a[N]; void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=a[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n-k ; i &amp;lt; n ; i++) y[p++] = i ; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i] +=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n; i ++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>ural 1517. Freedom of Choice (后缀数组，最长公共子串)</title><link>http://example.org/2016/07/ural1517/</link><pubDate>Sat, 30 Jul 2016 17:18:19 +0000</pubDate><guid>http://example.org/2016/07/ural1517/</guid><description>ural1517 题意：给出两个字符串，求最长的公共字串（要求出具体的字符串是什么）
思路：依然是后缀数组，在更新长度 的时候记录起始位置即可，1A。以及，发现多开了一个完全没有必要的数组w[],这次已删。
20160730update:模板已更正，lrj的模板的rk[i]为0 的时候会出现re的问题&amp;hellip;已特判。
/* *********************************************** Author :111qqz Created Time :2016年07月31日 星期日 00时36分19秒 File Name :code/ural/1517.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char s[N]; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r,int a,int b,int l) {return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x = t,*y= t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n - k ; i &amp;lt; n ; i++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 2774 Long Long Message (最长公共字串，后缀数组模板题)</title><link>http://example.org/2016/07/poj-2774/</link><pubDate>Sat, 30 Jul 2016 16:02:42 +0000</pubDate><guid>http://example.org/2016/07/poj-2774/</guid><description>poj2774
题意：给出两个字符串，问最长的公共连续字串。
思路：后缀数组模板题。
具体可以参考两篇国集论文（09，04） topcoder中的讲解 codechef上的讲解 还有一篇讲 dc3算法的论文：SuffixArrays_dc3 这里不谈具体的后缀数组的学习内容，说说大概的学习过程。
首先要理解**后缀，后缀数组（sa[]），名次数组(rk[])，height数组，lcp **这些概念
先从定义入手，得到sa数组的n2logn的求法&amp;hellip;
由于复杂度爆炸，所以有了两个算法来优化求sa的过程，一个是nlogn的倍增，还有一个是O(n)的dc3。。。
倍增的算法中用到了radix sort
上面这些，都是在说如何求sa,但是如果只有sa一个数组的话，就没有办法很好感受 后缀数组的power.
于是引入了height数组。
有很多问题都是基于height数组的，慢慢感受。
再说这道题：我们可以把两个字符串中间用一个特殊符号连接起来。
那么两个字符串的最长公共字串，就变成了求合并后的字符串的所有后缀的最长公共前缀。（原因是字符串的任何一个字串都可以看成是该字符串的某个后缀的前缀）
那么容易知道，该最长公共前缀的长度一定是某个height值（原因是，height[i]表示的是排名相邻的两个后缀的最长公共前缀的长度，如果不相邻，那么取的是他们排名之间所有height的最小值，只会越来越小。）
还需要注意的是，必须满足得到该height的两个后缀分别出现在原来的两个字符串中&amp;hellip;
要怎么办到呢？ 其实很容易，由于sa[i]数组存放的是排名第i的后缀是后缀几(定义从第x个字符开始的后缀就是后缀x)
设初始第一个字符串的长度为len1,那么如果是第一个字符串的后缀，一定有sa[i]&amp;lt;len1,如果是第二个字符串的后缀，就一定有sa[i]&amp;gt;len1 (sa[i]==len1的是插入的特殊符号开始的后缀)
还有一些细节可以参考代码注释
UD20160730:改正了lrj书中的错误。。对于rk[i]==0的情况进行了特判。。不然会re&amp;hellip;
/* *********************************************** Author :111qqz Created Time :2016年07月30日 星期六 20时58分10秒 File Name :code/poj/2774.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char s[N]; int sa[N],t[N],t2[N],cnt[N],n; int c[N]; int w[N]; int rk[N],height[N]; int cmp( int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l] ;}; void build_sa(int n,int m) //其实我觉得。。。sa怎么得到的不用管。。这部分讲道理不会变。。。反正知道能nlogn得到sa就对了2333 { int *x=t,*y=t2; // 基数排序（不是计数排序！） radix sort.</description></item><item><title>suffix array (转自 codechef)</title><link>http://example.org/2016/07/suffix_array_tutorial/</link><pubDate>Sat, 30 Jul 2016 09:12:57 +0000</pubDate><guid>http://example.org/2016/07/suffix_array_tutorial/</guid><description>原文链接：链接
讲了后缀数组的概念，然后从最暴力的O(nnlogn )的复杂度(O(n)用来比较字符串，O(nlogn)是排序的复杂度)逐步优化，依据各个串之间的关系，大概讲了倍增算法，以及给出了一篇The Skew Algorithm 的论文。
文中实现的倍增算法的复杂度是O（Nlog2N）的。。是因为作者不会基数排序23333。
This text will focus on the construction of Suffix Arrays, it will aim to explain what they are and what they are used for and hopefully some examples will be provided (it will be mainly simple applications so that the concepts don&amp;rsquo;t get too attached to the theoretical explanation).
As usual, this follows my somewhat recent series of tutorials in order to make the reference post with links as complete as possible!</description></item></channel></rss>