<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dp on 111qqz的小窝</title><link>http://example.org/tags/dp/</link><description>Recent content in dp on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 11 Nov 2017 07:11:25 +0000</lastBuildDate><atom:link href="http://example.org/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>SPOJ LCS2 Longest Common Substring 2[后缀自动机+dp]</title><link>http://example.org/2017/11/spoj-lcs2/</link><pubDate>Sat, 11 Nov 2017 07:11:25 +0000</pubDate><guid>http://example.org/2017/11/spoj-lcs2/</guid><description>题意： 求n个串的最长公共子串，n&amp;lt;=10
思路： 不会啊orz
先放一波参考资料&amp;amp;题解好了。
codeforces_Understanding Suffix Automaton in depth
code风景区_spoj_lcs2
code风景区_sam教学
candy SPOJ 1812 LCS2 [后缀自动机 DP]
首先参考下2个串的LCS的做法spoj-lcs
卧槽终于懂了&amp;hellip;
&amp;hellip;代码之后补关键是理解这句话：一个状态能到达说明了Suffix Link指向的状态可以取到最大子串
比如如果状态S（从初始状态到S状态所表示的子串是abcbc） 能够最长向前匹配的长度是x,那么状态s的par的状态Q(从初始状态到Q状态所表示的子串是bc）也至少为x.
所以dp[link[v]] = Max{dp[link[v]],dp[v]}
妈个鸡。。。
没事改什么字符集大小啊。。。
上道题做的是数字。。就手贱把字符集的大小改成了12.。。忘了改回来。。WA到死。。。
/* *********************************************** Author :111qqz Created Time :2017年11月08日 星期三 18时50分18秒 File Name :4436.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; #define MAXALP 30 const int mod = 2012; struct state { int len, link, nxt[MAXALP]; }; const int N =1E5+7; state st[N*2]; int sz, last,rt; char s[N]; int cnt[2*N],rk[2*N];//for radix sort int dp[2*N],maxlen[2*N]; void sa_init() { sz = 0; last = rt = ++sz; st[1].</description></item><item><title>poj 3249 Test for Job (拓扑排序+dp)</title><link>http://example.org/2017/11/poj-3249/</link><pubDate>Tue, 07 Nov 2017 06:13:22 +0000</pubDate><guid>http://example.org/2017/11/poj-3249/</guid><description>http://poj.org/problem?id=3249
题意： 给一个DAG,现要从一条入度为0的点到一个出度为0的点，问最大点权和。
思路： 其实比较容易想到搜&amp;hellip;不过复杂度会炸？
由于到一个点的最大点权和，需要更新完所有到达它的路线之后才能确定。
容易联想到拓扑排序，我们可以在拓扑排序的同时做dp
dp[v] = max(dp[v],dp[u]+a[v])，初始化对于入度为0的点，dp[i] = val[i].
其实拓扑+dp是一种比较一般化的套路&amp;hellip;？
因为拓扑保证了更新顺序
/* *********************************************** Author :111qqz Created Time :2017年11月07日 星期二 13时52分27秒 File Name :3249.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; vector &amp;lt;int&amp;gt;edge[N]; int in[N],out[N]; int n,m; int dp[N]; int val[N]; void init() { for ( int i = 0 ; i &amp;lt; N ; i++) edge[i].</description></item><item><title>codeforces 855 B. Marvolo Gaunt's Ring (前缀最大，dp)</title><link>http://example.org/2017/09/codeforces-855-b/</link><pubDate>Mon, 25 Sep 2017 13:12:25 +0000</pubDate><guid>http://example.org/2017/09/codeforces-855-b/</guid><description>题目链接
题意：给出n,p,q,r,以及n（1E5）个数，所有数的范围都是[-1E9,1E9],现在问p_a[i]+q_a[j]+r*a[k]的最大值，满足1&amp;lt;=i&amp;lt;=j&amp;lt;=k&amp;lt;=n
思路：傻逼dp&amp;hellip;
我。。好菜啊。。。万年dp苦手。
直接转载官方题解了。。。思路的重点是维护了一个最大前缀值。
To calculate the dp:
dp[i][0] = max(dp[i - 1][0], p·a__i)
dp[i][1] = max(dp[i - 1][1], dp[i][0] + q·a__i)
dp[i][2] = max(dp[i - 1][2], dp[i][1] + r·a__i)
The answer will be stored in dp[n][2]/* *********************************************** Author :111qqz Created Time :2017年09月25日 星期一 19时26分34秒 File Name :B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL a[N]; LL p,q,r; int n; LL dp[N][3]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;.</description></item><item><title>leetcode 152. Maximum Product Subarray (最大连续子序列乘积，dp)</title><link>http://example.org/2017/04/leetcode-152-maximum-product-subarray/</link><pubDate>Fri, 14 Apr 2017 11:33:30 +0000</pubDate><guid>http://example.org/2017/04/leetcode-152-maximum-product-subarray/</guid><description>Find the contiguous subarray within an array (containing at least one number) which has the largest product.
For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.
思路：由于有正，有负，还有0.。。所以比最大子串之和要复杂一些。。。
dp[i].max表示到当前位置的最大乘积。
dp[i].min表示到当前位置的最小乘积。
dp[i].max = max{dp[i-1].maxa[i],dp[i-1].mina[i],a[i]};
dp[i].min同理
边界dp[i].max = dp[i].min = a[0]
/* *********************************************** Author :111qqz Created Time :2017年04月14日 星期五 18时57分13秒 File Name :152.cpp ************************************************ */ class Solution { public: //dp //dp[i]表示当前的最大乘积。 //用了滚动数组优化空间/ int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetocde 63. Unique Paths II</title><link>http://example.org/2017/04/63-unique-paths-ii/</link><pubDate>Tue, 11 Apr 2017 10:50:57 +0000</pubDate><guid>http://example.org/2017/04/63-unique-paths-ii/</guid><description>Follow up for &amp;ldquo;Unique Paths&amp;rdquo;:
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.
[ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2.
题意：从左上到右下的方案数，有些点不能走。
思路：简单dp&amp;hellip;1A
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时37分47秒 File Name :63.</description></item><item><title>leetcode 64. Minimum Path Sum (二维dp)</title><link>http://example.org/2017/04/leetcode-64-minimum-path-sum/</link><pubDate>Mon, 10 Apr 2017 02:35:20 +0000</pubDate><guid>http://example.org/2017/04/leetcode-64-minimum-path-sum/</guid><description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
数字三角形。。。。从坐上到右下问最短路径。。每次只能向下或者向右。。。
wa了一次。。。是因为边界值赋值成了0.。。求最短路径显然因为赋值成inf才对orz..果然傻了。。
简单的dp我们简单的A.
顺便吐槽一下。。(100,100)的答案会溢出int&amp;hellip;然而答案就是负的。。。就没人check一下吗，，，
/* *********************************************** Author :111qqz Created Time :2017年04月10日 星期一 10时11分26秒 File Name :64.cpp ************************************************ */ class Solution { public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int n = grid.</description></item><item><title>BZOJ 2748: [HAOI2012]音量调节 (dp)</title><link>http://example.org/2017/04/bzoj-2748-haoi2012-dp/</link><pubDate>Sun, 02 Apr 2017 06:50:50 +0000</pubDate><guid>http://example.org/2017/04/bzoj-2748-haoi2012-dp/</guid><description>2748: [HAOI2012]音量调节 Time Limit: 3 Sec Memory Limit: 128 MB Submit: 1814 Solved: 1148 [Submit][Status][Discuss]
Description 一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都要改变一次音量。在演出开始之前，他已经做好了一个列表，里面写着在每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。 音量用一个整数描述。输入文件中给定整数beginLevel，代表吉他刚开始的音量，以及整数maxLevel，代表吉他的最大音量。音量不能小于0也不能大于maxLevel。输入文件中还给定了n个整数c1,c2,c3…..cn，表示在第i首歌开始之前吉他手想要改变的音量是多少。 吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。
Input 第一行依次为三个整数：n, beginLevel, maxlevel。 第二行依次为n个整数：c1,c2,c3…..cn。
Output 输出演奏最后一首歌的最大音量。如果吉他手无法避免音量低于0或者高于maxLevel，输出-1。
Sample Input 3 5 10 5 3 7
Sample Output 10
HINT 1&amp;lt;=N&amp;lt;=50,1&amp;lt;=Ci&amp;lt;=Maxlevel 1&amp;lt;=maxlevel&amp;lt;=1000
0&amp;lt;=beginlevel&amp;lt;=maxlevel
思路:
一看数据范围&amp;hellip;长着一张dp的脸&amp;hellip;
dp[i][j]表示经过i次调整后能否达到音量j.
初始化dp[0][beginlevel] = true.
按顺序转移就好了.
复杂度O(n*MAXlevel)
/* *********************************************** Author :111qqz Created Time :2017年04月02日 星期日 14时36分58秒 File Name :code/bzoj/2748.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; bool dp[51][1005]; //dp[i][j]表示经过i次操作,能否达到音量j int n,L,R; int a[1005]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1207: [HNOI2004]打鼹鼠 (LIS)</title><link>http://example.org/2017/01/bzoj-1207-hnoi2004-lis/</link><pubDate>Thu, 26 Jan 2017 08:12:38 +0000</pubDate><guid>http://example.org/2017/01/bzoj-1207-hnoi2004-lis/</guid><description>1207: [HNOI2004]打鼹鼠 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 2854 Solved: 1390 [Submit][Status][Discuss]
Description 鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿Q编写了一个打鼹鼠的游戏：在一个nn的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果i时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为（i,j）的网格移向(i-1, j),(i+1, j),(i,j-1),(i,j+1)四个网格，机器人不能走出整个nn的网格。游戏开始时，你可以自由选定机器人的初始位置。现在你知道在一段时间内，鼹鼠出现的时间和地点，希望你编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。
Input 第一行为n（n&amp;lt;=1000）, m（m&amp;lt;=10000），其中m表示在这一段时间内出现的鼹鼠的个数，接下来的m行每行有三个数据time,x,y表示有一只鼹鼠在游戏开始后time个时刻，在第x行第y个网格里出现了一只鼹鼠。Time按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。
Output 仅包含一个正整数，表示被打死鼹鼠的最大数目
Sample Input 2 2 1 1 1 2 2 2
Sample Output 1
HINT Source 思路：很巧妙的题目。类比LIS，如果两只仓鼠的曼哈顿距离小于等于两只仓鼠出现的时间，那么就可以从一只仓鼠转移到另一只仓鼠。利用这个条件，做二维的LIS即可。
/* *********************************************** Author :111qqz Created Time :2017年01月26日 星期四 15时39分26秒 File Name :1207.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n,m; int t[N],x[N],y[N]; int dp[N] ; //dp[i]表示第i只仓鼠出现的时候，最多能打死几只仓鼠。 int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>(dp专题006)hdu 2602 Bone Collector（01背包）</title><link>http://example.org/2016/11/hdu2602/</link><pubDate>Wed, 16 Nov 2016 07:28:33 +0000</pubDate><guid>http://example.org/2016/11/hdu2602/</guid><description>题目链接
题意:容量为V的背包，n个骨头，给出价值和体积，问最多能装多少价值的背包。
思路：01背包裸体。
/* *********************************************** Author :111qqz Created Time :2016年11月16日 星期三 15时14分36秒 File Name :code/hdu/2602.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int dp[N],value[N],cost[N]; int n,V; void solve(int v,int c) { for ( int i = V; i &amp;gt;= c; i --) dp[i] = max(dp[i],dp[i-c]+v); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>[dp专题005]hdu 1864最大报销额（01背包，垃圾题）</title><link>http://example.org/2016/11/hdu1864/</link><pubDate>Wed, 16 Nov 2016 07:04:20 +0000</pubDate><guid>http://example.org/2016/11/hdu1864/</guid><description>hdu1864题目链接
题意：中文题目，不多说了。
思路：正解是01背包，呵呵呵。
出题人是傻逼吗？
不给数据范围？
以及，正解的01背包基于所有的发票额度的只有2位小数。这是让人猜？
本来看到这题这么恶心时不打算写的&amp;hellip;
写了的原因纯粹是为了吐槽傻逼出题人..
简直是我做得最垃圾的题目之一。
/* *********************************************** Author :111qqz Created Time :2016年11月16日 星期三 14时13分28秒 File Name :code/hdu/1864.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E6+7; double P; int n; int dp[N], value[35]; void solve( int value,int cost ) { for ( int i = int(P) ; i &amp;gt;= cost ; i--) dp[i] = max(dp[i],dp[i-cost]+value); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>(dp专题004)hdu 2955Robberies（01背包变形）</title><link>http://example.org/2016/11/hdu2955/</link><pubDate>Tue, 15 Nov 2016 11:19:56 +0000</pubDate><guid>http://example.org/2016/11/hdu2955/</guid><description>题目链接
题意： 给出n个银行 ，以及抢劫每个银行可以得到的价值和被抓的概率，不同银行之间被抓的概率是相互独立的，现在给出安全概率p，只有当概率从小于安全概率时才是安全的，问最多能抢劫多少价值。
思路：一开始很直接就想到把概率算成容量，
于是就成了经典的01背包，然后发现概率是double型。。。想当然得以为最多是2位小数，于是都*100转化成了整数做01背包。
然而正确思路是，把银行价值看成背包容量，而背包价值是概率！
将危险的概率转化成安全概率（1-危险概率=安全概率)
然后做01背包。
然后从大到小扫一遍价值，第一个大于安全概率的就是答案。
注意精度。
/* *********************************************** Author :111qqz Created Time :Tue 15 Nov 2016 06:53:53 PM CST File Name :code/hdu/2955.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; double dp[N]; double p; int n,V; int value[N]; double cost[N]; void solve(double Cost,int Value) { for ( int i = V ; i &amp;gt;= Value ; i--) dp[i] = max(dp[i],dp[i-Value]*Cost); } int dblcmp( double d) { return d&amp;lt;-eps?</description></item><item><title>(dp专题003)hdu 4055 Number String(dp)</title><link>http://example.org/2016/11/hdu-4055/</link><pubDate>Sun, 13 Nov 2016 14:38:06 +0000</pubDate><guid>http://example.org/2016/11/hdu-4055/</guid><description>题目链接
题意：给出n(n&amp;lt;=1E3)个字符，字符可能为'D&amp;rsquo;,&amp;lsquo;I&amp;rsquo;,'?'，第i位对应的字符分别表示，第i位大于第i+1位，第i位小于第i+1位，或者不确定。
现在问满足该字符串的 1..n的排列的方案数。结果9+7
思路：没有太多思路，参考了题解
主要是状态表示没有想到，后面的状态转移方程倒是不难。
思路是，dp[i][j]表示长度为i，最后一位的相对大小为j的方案数。
考虑转移：如果第i-1个位置的字符为‘I’，那么所有比j小的都可以转移到j，也就是dp[i][j] = dp[i-1][1] + dp[i-1][2] + &amp;hellip; + dp[i-1][j-2] + dp[i-1][j-1];
如果第i-1个位置的字符是'D&amp;rsquo;，此时是这道题的重点。
此时的复杂度是n3,可以用前缀和优化掉一个n，复杂度n方。
最后答案就是sum[len+1][len+1]
/*************************************************** Author :111qqz ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; const int mod = 1000000007; char st[N]; int dp[N][N],sum[N][N];//dp[i][j]表示长度为i，最后结尾的字符的相对大小为j的方案数。 int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;D:\code\in.</description></item><item><title>【dp专题002】hdu 4489 The King’s Ups and Downs (dp)</title><link>http://example.org/2016/11/dp002hdu-4489-the-kings-ups-and-downs-dp/</link><pubDate>Sun, 13 Nov 2016 11:33:20 +0000</pubDate><guid>http://example.org/2016/11/dp002hdu-4489-the-kings-ups-and-downs-dp/</guid><description>题目链接
题意：问长度为n的“波浪”型排列（即1..n每个数出现一次）有多少。波浪型的含义是，“高低高”或者“低高低”
思路：我们考虑当前已经知道i-1个数的波浪型的排列的方案数，那么当第i个数到来时，第i个数一定是最大的。
那么将i插入到某个位置，必须满足该位置前面必须以“高低”结尾，该位置后面必须以“低高”结尾才合法。（特别地，允许前面或者后面为空，这点体现在初始化上）
因此我们分别考虑，用dp[i][0]表示有i位且最后结尾为“高低”的方案数，dp[i][1]表示有i位且最后结尾为“低高”的方案数。
此时我们的情况是，已经有i-1个数，我要把第i个数插在某个位置。
这个位置是不确定的，因为我们需要枚举插入的位置（表现为，枚举插入的第i个数前面有j个数，后面剩余i-1-j个数）
那么第i个数前面是选择哪j个数呢？ 组合数为C[i-1][j] (i-1个数选择j个放在前面)
因此长度为i的答案为**sum[i] = sigma{dp[j][0]dp[i-j-1][1]C[i-1][j]} (0=&amp;lt;j&amp;lt;i)
dp[i][0]和dp[i][1]对称，显然相等，都等于sum[i]/2.
我们只需要再预处理一个组合数就好了。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL C[30][30]; LL dp[30][2]; LL sum[25]; void cal() { for ( int i = 1 ; i &amp;lt;= 20 ; i++) { C[i][0] = 1; C[i][i] = 1; } for ( int i = 2; i &amp;lt;= 20 ; i++) for ( int j = 1 ; j &amp;lt; i ; j++) C[i][j] = C[i-1][j] + C[i-1][j-1]; } int main() { cal(); /* for ( int i = 2 ;i &amp;lt;= 10 ; i++) { for ( int j = 0 ; j &amp;lt;= i ; j++) printf(&amp;quot;%d &amp;quot;,C[i][j]); printf(&amp;quot;\n&amp;quot;); } */ ms(sum,0); sum[1] = 1; dp[0][0]=dp[0][1]=dp[1][0]=dp[1][1] = 1; for ( int i = 2 ; i &amp;lt;= 20 ; i++) { for ( int j = 0 ; j &amp;lt; i ; j++) //枚举第i个位置前有几个。 { sum[i] += dp[j][0]*dp[i-1-j][1]*C[i-1][j]; } dp[i][0] = dp[i][1] = sum[i]/2; } // for ( int i = 1; i &amp;lt;= 20 ; i++) printf(&amp;quot;%lld\n&amp;quot;,sum[i]); int T; cin&amp;gt;&amp;gt;T; while (T--) { int cas,n; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;cas,&amp;amp;n); printf(&amp;quot;%d %lld\n&amp;quot;,cas,sum[n]); } return 0; }</description></item><item><title>【dp专题001】bzoj 1009: [HNOI2008]GT考试 (字符串上dp+kmp+矩阵加速线性递推式)</title><link>http://example.org/2016/11/bzoj-1009/</link><pubDate>Sun, 13 Nov 2016 07:21:02 +0000</pubDate><guid>http://example.org/2016/11/bzoj-1009/</guid><description>1009: [HNOI2008]GT考试 Time Limit: 1 Sec Memory Limit: 162 MB Submit: 3127 Solved: 1926 [Submit][Status][Discuss]
Description 　阿申准备报名参加GT考试，准考证号为N位数X1X2&amp;hellip;.Xn(0&amp;lt;=Xi&amp;lt;=9),他不希望准考证号上出现不吉利的数字。 他的不吉利数学A1A2&amp;hellip;Am(0&amp;lt;=Ai&amp;lt;=9)有M位，不出现是指X1X2&amp;hellip;Xn中没有恰好一段等于A1A2&amp;hellip;Am. A1和X1可以为 0
Input 　第一行输入N,M,K.接下来一行输入M位的数。 N&amp;lt;=10^9,M&amp;lt;=20,K&amp;lt;=1000
Output 　阿申想知道不出现不吉利数字的号码有多少种，输出模K取余的结果.
Sample Input 4 3 100 111
Sample Output 81
思路： 这次总算想对了状态表示：dp[i][j] 表示当前处理到第i位，最后j位与不吉利串相同的方案数。 然后此时考虑转移，也就是观察第i+1位。 根据第i+1位字符的不同，转移到的 位置也不相同。 从dp[i][j] 可以转移到dp[i+1][k]，这种转移表现为dp[i+1][k] += dp[i][j] (k取决于第i+1位字符) *我们可以用f[i+1][k]+=f[i][j]trans[j][k]，trans[j][k]表示串s后j位与不吉利串前j位相同， 添加一个字符后后k位与不吉利串前k位相同的方案数。
就是说中间的那一部式子可以化简成矩阵的形式。。因此整个递推式就成了矩阵乘法的形式。 tran数组可以用kmp预处理出来。 重点是注意体会在字符串上dp的思想。
/* *********************************************** Author :111qqz Created Time :2016年11月13日 星期日 13时54分33秒 File Name :code/bzoj/1009.</description></item><item><title>[dp专题000]uva 10328 Coin Toss (java 大数+dp)（Unsolved）</title><link>http://example.org/2016/11/uva10328/</link><pubDate>Sat, 12 Nov 2016 12:39:25 +0000</pubDate><guid>http://example.org/2016/11/uva10328/</guid><description>题目链接
题意：问长度为n，每个位置由且仅有‘H’和'T'组成的序列中，至少有连续k个‘H’出现的方案数。
思路：不会做，参考了题解 不过没有完全搞懂。
根据题解，正面考虑比较麻烦，所以反面考虑。[j]
dp[i][j]表示长度为i，前面最后连续的‘H’的个数不超过j个的方案数。
考虑转移方程为：
总的情况为：dp[i][j] = dp[i-1][j] * 2;
但是其中有多考虑的情况，就是第i位是'H&amp;rsquo;，且i位之前的最后j个位置都是'H&amp;rsquo;（即从i-j位到第i-1位都是‘H’，此时第i-j-1位必然是'T&amp;rsquo;）
如果i &amp;gt; j + 1，dp[ i ] [ j ] = dp [ i - 1 ] [ j ] * 2 - x（不满足条件的部分）
然后我们来考虑这个x怎么求，既然是不满足条件，那么肯定是第i的位置放了H，前面的都是H，从而这些连续的H大于j。那么就考虑dp[ i - 1 - j - 1 ]（中间这 j - 1 个（kk:疑似作者笔误。应该位j个）全为H，加上第i个H，就不满足条件了），所以：
dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * 2 - dp [ i - j - 2 ] [ j ]（kk:仍然不是很懂这个式子&amp;hellip;）</description></item><item><title>codeforces 605 A. Sorting Railway Cars (dp)</title><link>http://example.org/2016/10/cf605a/</link><pubDate>Tue, 04 Oct 2016 12:59:16 +0000</pubDate><guid>http://example.org/2016/10/cf605a/</guid><description>题目链接
题意：给出一个n个数的排列，每次可以把一个数放到最前面或者最后面的位置，问至少要进行多少次操作才能使得数列升序。
思路：考虑不被移动的那些数，当把所有一定的数去掉以后，这些剩下的数一定是一段数值连续，位置递增的数。如果想要移动的数最少，俺么这串递增的数就尽可能长。
dp[a[i]] = dp[a[i]-1] + 1
那么ans = n - max{dp[i]}
另外：对于要移动的数，我们可以按照一定顺序（放在前面的数按照递减顺序，放在最长序列后面的数按照递增顺序）移动，可以保证每个数只需要移动一次。
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 20时10分00秒 File Name :code/cf/problem/605A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5904 LCIS (dp)</title><link>http://example.org/2016/09/hdu-5904-lcis-dp/</link><pubDate>Sun, 25 Sep 2016 20:13:38 +0000</pubDate><guid>http://example.org/2016/09/hdu-5904-lcis-dp/</guid><description>题目链接
题意： 给定两个序列，求它们的最长公共递增子序列的长度, 并且这个子序列的值是连续的 思路：以值为连续做入手点。
很显然个鬼咯dp[a[i]]表示以a[i]结尾的最大长度。 dp[a[i]] = dp[a[i-1]] + 1 对于b序列一样。
答案为 MAX(min(dp[i],dp2[i])) ( 1=&amp;lt;i &amp;lt;= 1E6)
/* *********************************************** Author :111qqz Created Time :Mon 26 Sep 2016 04:02:24 AM CST File Name :code/hdu/5904.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int dp[N],dp2[N]; int n,m; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>斜率优化学习笔记</title><link>http://example.org/2016/09/</link><pubDate>Sat, 24 Sep 2016 15:38:00 +0000</pubDate><guid>http://example.org/2016/09/</guid><description>浅谈数形结合思想在信息学竞赛中的应用
参考博客
这个东西英文好像叫做：convex hull trick
Convex_hull_trick_wiki codeforces convex hull trick
简单说说我的理解：斜率优化是一种数形结合的思想。。。
对于一个dp的若干状态。。。有些状态是不会对答案有贡献的。。。这些我们就可以不考虑。。。
简单地说。。。如果把状态的下标和状态对应成二维平面的点。。。
凸起来的点一定不会影响答案。。。
具体证明参考论文。。。。。
也就是维护一个&amp;quot;下凸折线&amp;rdquo;
具体维护的办法是用单调队列来维护。。。
感觉还是挺简单的。。。。</description></item><item><title>hdu 5763 || 2016 multi #4 1001 Another Meaning (kmp+dp)</title><link>http://example.org/2016/08/hdu-5763/</link><pubDate>Thu, 11 Aug 2016 15:41:57 +0000</pubDate><guid>http://example.org/2016/08/hdu-5763/</guid><description>hdu 5763 题目链接
题意：给定两个字符串A和B，每个出现在A中的B(可以overlap)都有两种含义，问A串一共可能有多少种含义。
思路：kmp+dp.
考虑dp[i]为前i个字符（也就是从开始长度为i，注意不是字符串的下标为i）的含义数。
我们考虑第i个字符对其他位置字符的贡献。
首先第i位的含义数可以无条件得转移到i+1位。也就是dp[i+1]+=dp[i];
此外，如果第i位是一个B串开始的位置，那么第i位对i+len2位就有贡献。也就是dp[i+len2]+=dp[i];
初始化dp[0]=1，其他为0.
剩下我们要做的就是处理出A串中的哪些位置是B串开始的位置。
kmp处理下就好，用一个布尔数组标记。
/* *********************************************** Author :111qqz Created Time :2016年08月11日 星期四 11时07分24秒 File Name :code/hdu/5763.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int MOD = 1E9+7; const int N=1E5+7; int nxt[N]; char a[N],b[N]; bool v[N]; int dp[N]; void getnxt(char *s) { int i = 0; int j = -1; nxt[0] = -1; int n = strlen(s); while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } void kmp( char *a,char *b) { int n = strlen(a); int m = strlen(b); getnxt(b); int i = 0 ; int j = 0 ; while (i&amp;lt;n) { if (j==-1||a[i]==b[j]) i++,j++; else j = nxt[j]; if (j==m) { v[i-m] = true;//长度为i的位置的下标是i-1,开始的位置是（i-1）+m+1,也就是i-m // cout&amp;lt;&amp;lt;&amp;quot;i:&amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; i-m:&amp;quot;&amp;lt;&amp;lt;i-m&amp;lt;&amp;lt;endl; } } } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 429 B. Working out (dp)</title><link>http://example.org/2016/07/cf429b/</link><pubDate>Wed, 27 Jul 2016 19:05:42 +0000</pubDate><guid>http://example.org/2016/07/cf429b/</guid><description>cf429 b 题目链接 题意：
n*m个格子，每个格子有一个人value a[i][j]&amp;gt;0，连个人，一个从左上角到右下角，每次只能向下或者向右移动，一个从左下到右上，每次只能向上或者向右移动，现在要求两个人恰好相遇一次，相遇点的a不算数，问在满足这样的条件下使得两个人的a最大。。。（很坑的一点是。。这里相遇并不考虑时间。。就是说，不在同一时间都到达过某一格子，也认为相遇。所以我认为，题目含义更准确的说法是，路径只有一个交点）
思路：很巧妙。先预处理4个二维数组，分别表示点(i,j）到四个角落的最大值。（这个处理很容易，类似数字三角形）
然后枚举相遇的点，对于确定的相遇的点(x,y)，我们可以认为是四个角落各连一条线到点(i,j)
由于只能相遇一次，所以连接方式只有两种情况。
/* *********************************************** Author :111qqz Created Time :2016年07月28日 星期四 02时13分58秒 File Name :code/cf/429B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; LL a[N][N]; LL dp[5][N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2018 母牛的故事 (基础dp，记忆化搜索)</title><link>http://example.org/2016/07/hdu-2018/</link><pubDate>Wed, 27 Jul 2016 05:57:39 +0000</pubDate><guid>http://example.org/2016/07/hdu-2018/</guid><description>hdu2018题目链接
题意:第1年有1头奶牛，每年生一头奶牛，新生的奶牛从生下来的第四年（包括生下来那年）也开始每年一头奶牛。 问第n年有多少头奶牛。 思路：最容易想到的。。递推一下。。。dp[i] = dp[i-1] + dp[i-3] (注意初始化不是一个dp[1]=1,而是dp[1..4]=1..4)
递推代码：
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 13时19分17秒 File Name :code/hdu/2018.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first a#define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=60; int n; LL dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2084 数塔 (基础dp)</title><link>http://example.org/2016/07/hdu-2084/</link><pubDate>Wed, 27 Jul 2016 05:12:10 +0000</pubDate><guid>http://example.org/2016/07/hdu-2084/</guid><description>hdu2084题目链接
题意：dp入门题。。。数字三角形。。
思路：
昨天看mit公开课。。。讲到dp的精髓是sub-problem+ reuse&amp;hellip;
为什么自底向上呢。。。
初始化dp[n][i] = a[n][i]其实是在处理只有最后一行的子问题。。。
需要特别强调的是。。处于某个子问题的时候。。。其他部分就好像不存在一样。。。
每一个点只能向下或者向右下两条路可走。。。
那么对于这一点的最大值。。。一定是取后来可走的两点的最大值加上自身。。。
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 12时56分28秒 File Name :code/hdu/2084.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N][N]; int dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 4283 You Are the One (区间dp)</title><link>http://example.org/2016/07/hdu-4283/</link><pubDate>Tue, 26 Jul 2016 07:38:44 +0000</pubDate><guid>http://example.org/2016/07/hdu-4283/</guid><description>hdu 4283题目链接
题意：有N个人按顺序排成一排上台表演，每个都有一个num[]值，若在他是第k个上场的人，则会有num[]*(k-1)的unhappiness。台下有一个黑屋（stack），对每一个人，可以选择让他先进屋子或者直接上台。现在让你找到一个最优方案使得所有人的unhappiness之和最小。
思路：
我想对了的： 无。状态设计就错了。。。转移方程也就不可能对。。。
错的一塌糊涂。。。嗯。。基础题。。完全不会2333
参考题解：参考博客1 参考博客2
/* *********************************************** Author :111qqz Created Time :2016年07月26日 星期二 15时03分41秒 File Name :code/hdu/4283.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; int sum[N]; int dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3661 Running (区间dp)</title><link>http://example.org/2016/07/poj-3661-running-dp/</link><pubDate>Mon, 25 Jul 2016 16:51:22 +0000</pubDate><guid>http://example.org/2016/07/poj-3661-running-dp/</guid><description>poj 3661题目链接
题意：锻炼，一共n分钟，每分钟可以选择跑步或者休息，第i分钟跑步可以跑d[i]米，并增加一点疲劳度，如果选择休息，那么每分钟减少1点疲劳值。一旦开始休息，必须休息到疲劳值为0才能再次开始跑步。疲劳值不能超过m.第n分钟的时候疲劳值必须为0，否则之后会感觉身体被掏空。问n分钟最远多多远。
思路：
我能想到的： * dp[i][j]表示第i分钟疲劳度为j的时候能跑的最远距离 * 初始化dp为0. * 最后的答案为dp[n][0] * 如果第i分钟跑步，转移方程为dp[i][j] = max(dp[i][j],dp[i-1][j-1]+d[i]); 我想错了的： * 休息的时候的转移方程应该是第i天刚好**休息好**时：dp[i][0]=max(dp[i-j][j],dp[i][0]) 而不是**开始休息**时 * 由于是第i天休息好时的状态，那么开始休息的时间是固定的（第i-j天），只进行一个转移，而不会影响中间的那些天 我想的不够好的： * 考虑到了可能最后几天为了疲劳度为0干脆就不跑，我的做法是取了所有的dp[i][0]的最大值。但是更好的做法似乎是dp[i][0] = dp[i-1][0]转移一下。 参考博客：参考博客
参考题解：
a)、先看dp[i][0]的情况，表示第i分钟时，疲劳值为0，考虑这个值由哪些情况得到，1、dp[i][0] = dp[i-1][0]，这个没有任何问题。2、dp[i][0] = dp[i-j][j]。表示i-j分钟时的疲劳值为j，然后一直休息j分钟把疲劳值降成0。
b)、现在考虑dp[i][j]的情况，它可以由dp[i-1][j-1] + Di得到，表示第i分钟选择走Di。因为要保证没有后效性，所以只有这一种情况可以转移。/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 23时42分26秒 File Name :code/poj/3661.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; const int M=505; int n; int m; int d[N]; int dp[N][M]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1651 Multiplication Puzzle (区间dp)</title><link>http://example.org/2016/07/poj-1651/</link><pubDate>Mon, 25 Jul 2016 15:09:40 +0000</pubDate><guid>http://example.org/2016/07/poj-1651/</guid><description>poj 1651题目链接
题意：n个数，删掉a[i]的得分是a[i]*a[i-1]*a[i+1]，两个端点的不允许删。问删完n-2个数得到的最小分数是多少。
思路：能想到设计状态dp[i][j]表示区间[i,j]的最小分数。然后就没思路了。 T T
参考了几篇题解，思路大概是，枚举最后剩下的那个数。
**DP(l, r) = DP(l, k) + DP(k, r) + a[l]*a[k]*a[r];**以及。。。初始化又想错了。。。
要注意。。初始化可能没办法一次完成。。。这道题的初始化就是分情况的。。。
对于区间长度不够的。。初始化为0.。
区间长度为3的。。初始化为a[i]*a[i+1]*a[i+2]。。
其他的初始化为正无穷。。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 22时44分55秒 File Name :code/poj/1651.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; int dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3280 Cheapest Palindrome (区间dp)</title><link>http://example.org/2016/07/poj-3280/</link><pubDate>Mon, 25 Jul 2016 13:26:14 +0000</pubDate><guid>http://example.org/2016/07/poj-3280/</guid><description>poj 3280 题目链接
题意：一个字符串，给出添加一个字符或者删掉该字符的花费，问最小的话费使得字符串变成回文串。
思路：dp[i][j]表示区间[i,j]的字符串变成回文的最小花费。。。
这个可以想到。。dp[i][j] = dp[i+1][j-1] (a[i]==a[j])这个也可以想到。。。
增加和删除是等价的，所以取小的那个代价就行。。这个我也想到了。。
然后转移的地方没有特别明白。。。
和之前的找到一个划分的点k不同的是。。。
如果不等于。。
那么
, dp[i][j] = min(dp[i][j],dp[i+1][j]+cost[a[i]]); dp[i][j] = min(dp[i][j],dp[i][j-1]+cost[a[j]]); 这个方程可以理解。。。但是感觉自己想不出来 QAQ
以及。。我初始化写错了。。。
以为是求 最小值就初始化成了0x3f&amp;hellip;
但是这样是错的。。。
具体见代码注释。。。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 19时42分19秒 File Name :code/poj/3280.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; char s[N]; int dp[N][N]; int n,len; int cost[N]; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>light oj 1422 - Halloween Costumes (区间dp)</title><link>http://example.org/2016/07/light-oj-1422-halloween-costumes-dp/</link><pubDate>Mon, 25 Jul 2016 11:24:27 +0000</pubDate><guid>http://example.org/2016/07/light-oj-1422-halloween-costumes-dp/</guid><description>light oj 1422 题目链接
题意：
按顺序去参加舞会。每个舞会对衣服都有要求。可以连续穿好多件衣服。需要时候就脱下来，但是一旦脱下来，这件衣服就报废了。问最少需要几件衣服。
思路：没有思路。我连这题是dp都看不出来。。知道是dp也一点思路都没。。虽然这道题是道区间dp的入门题。。。但是不怕被鄙视。。我一点也没思路。。
参考了10多篇题解。。。终于懂了一点。。
参考博客1 参考博客2 参考博客3 参考博客4
这句话让我恍然大悟。。。难道。。都是套路？
dp[i][j]表示的是[i,j]之间最少需要的衣服数量。
初始化dp[i][i] = 1，表示每天都换一件新衣服，显然不优。
a[i]==a[j]时，dp[i][j] = dp[i][j-1] ，表示第j天不用新换衣服，
然后枚举划分区间的点k,分成[i,k]和[k+1,j]两部分，取所有情况中最好的（这大概就是区间dp的套路？）
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 18时49分07秒 File Name :code/loj/1422.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int dp[N][N]; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2955 Brackets（区间dp....括号匹配。。。人生第一道区间dp）</title><link>http://example.org/2016/07/poj2955/</link><pubDate>Mon, 25 Jul 2016 07:46:23 +0000</pubDate><guid>http://example.org/2016/07/poj2955/</guid><description>poj2955题目链接
题意：给出若干括号，问最大匹配数是多少。
思路：没有思路。我知道这是dp。。。然后其他就什么都不知道了。。。转移方程？ 完全没思路。。知道了转移方程。。。。嗯，还是不会。。。边界怎么写？状态怎么推？循环顺序? 循环次序？我一点思路都没有。。。。。
人生中第一道区间dp(这话我都说了不知道多少次了。。。每次都学不会。。。。sad)
我的dp水平和其他部分的水平还真是不匹配。。。
看了题解。。。自己写（抄）了一遍。。还是觉得好玄学。。。
细节见代码。
/* *********************************************** Author :111qqz Created Time :2016年07月25日 星期一 15时12分28秒 File Name :code/poj/2955.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; char st[N]; int dp[N][N]; bool check(char a,char b) { //cout&amp;lt;&amp;lt;&amp;quot;a:&amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;quot; b:&amp;quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; if((a=='['&amp;amp;&amp;amp;b==']')||(a=='('&amp;amp;&amp;amp;b==')')) return true; return false; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1649: [Usaco2006 Dec]Cow Roller Coaster (dp，类似01背包)</title><link>http://example.org/2016/04/bzoj-1649/</link><pubDate>Mon, 11 Apr 2016 09:19:52 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1649/</guid><description>Time Limit: 5 Sec Memory Limit: 64 MB Submit: 504 Solved: 265 [Submit][Status][Discuss]
Description The cows are building a roller coaster! They want your help to design as fun a roller coaster as possible, while keeping to the budget. The roller coaster will be built on a long linear stretch of land of length L (1 &amp;lt;= L &amp;lt;= 1,000). The roller coaster comprises a collection of some of the N (1 &amp;lt;= N &amp;lt;= 10,000) different interchangable components.</description></item><item><title>BZOJ 1644: [Usaco2007 Oct]Obstacle Course 障碍训练课 (BFS,DP)</title><link>http://example.org/2016/04/bzoj-1644-usaco2007-octobstacle-course-bfsdp/</link><pubDate>Sun, 10 Apr 2016 12:41:46 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1644-usaco2007-octobstacle-course-bfsdp/</guid><description>1644: [Usaco2007 Oct]Obstacle Course 障碍训练课 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 451 Solved: 226 [Submit][Status][Discuss]
Description 考虑一个 N x N (1 &amp;lt;= N &amp;lt;= 100)的有1个个方格组成的正方形牧场。有些方格是奶牛们不能踏上的，它们被标记为了'x&amp;rsquo;。例如下图：
. . B x . . x x A . . . . x . . x . . . . . x . .
贝茜发现自己恰好在点A处，她想去B处的盐块舔盐。缓慢而且笨拙的动物，比如奶牛，十分讨厌转弯。尽管如此，当然在必要的时候她们还是会转弯的。对于一个给定的牧场，请你计算从A到B最少的转弯次数。开始的时候，贝茜可以使面对任意一个方向。贝茜知道她一定可以到达。
Input 第 1行: 一个整数 N 行
2..N + 1: 行 i+1 有 N 个字符 ('.', &amp;lsquo;x&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;)，表示每个点的状态。</description></item><item><title>BZOJ 1632: [Usaco2007 Feb]Lilypad Pond (BFS,dp)</title><link>http://example.org/2016/04/bzoj-1632/</link><pubDate>Wed, 06 Apr 2016 15:37:13 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1632/</guid><description>1632: [Usaco2007 Feb]Lilypad Pond Time Limit: 5 Sec Memory Limit: 64 MB Submit: 496 Solved: 153 [Submit][Status][Discuss]
Description Farmer John 建造了一个美丽的池塘，用于让他的牛们审美和锻炼。这个长方形的池子被分割成了 M 行和 N 列( 1 ≤ M ≤ 30 ; 1 ≤ N ≤ 30 ) 正方形格子的 。某些格子上有惊人的坚固的莲花，还有一些岩石，其余的只是美丽，纯净，湛蓝的水。 贝茜正在练习芭蕾舞，她从一个莲花跳跃到另一个莲花，当前位于一个莲花。她希望在莲花上一个一个的跳，目标是另一个给定莲花。她能跳既不入水，也不到一个岩石上。 令门外汉惊讶的是，贝茜的每次的跳跃像中国象棋的马一样：横向移动1，纵向移动2，或纵向移动1，横向移动2。贝茜有时可能会有多达8个选择的跳跃。 Farmer John 在观察贝茜的芭蕾舞联系，他意识到有时候贝茜有可能跳不到她想去的目的地，因为路上有些地方没有莲花。于是他想要添加几个莲花使贝茜能够完成任务。一贯节俭的Farmer John想添加最少数量的莲花。当然，莲花不能放在石头上。 请帮助Farmer John确定必须要添加的莲花的最少数量。在添加的莲花最少基础上，算出贝茜从起始点跳到目标点需要的最少的步数。最后，还要算出满足添加的莲花的最少数量时，跳跃最少步数的跳跃路径的条数。
Input 第 1 行: 两个整数 M , N
第 2..M + 1 行:第 i + 1 行，第 i + 1 行 有 N 个整数，表示该位置的状态: 0 为水; 1 为莲花; 2 为岩石; 3 为贝茜开始的位置; 4 为贝茜要去的目标位置.</description></item><item><title>BZOJ 1618: [Usaco2008 Nov]Buying Hay 购买干草 (完全背包)</title><link>http://example.org/2016/04/bzoj-1618-usaco2008-novbuying-hay-/</link><pubDate>Sun, 03 Apr 2016 11:53:05 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1618-usaco2008-novbuying-hay-/</guid><description>1618: [Usaco2008 Nov]Buying Hay 购买干草 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 906 Solved: 456 [Submit][Status][Discuss]
Description  约翰的干草库存已经告罄，他打算为奶牛们采购日(1≤日≤50000)磅干草．
 他知道N(1≤N≤100)个干草公司，现在用1到N给它们编号．第i个公司卖的干草包重量为Pi(1≤Pi≤5000)磅，需要的开销为Ci(l≤Ci≤5000)美元．每个干草公司的货源都十分充足，可以卖出无限多的干草包． 帮助约翰找到最小的开销来满足需要，即采购到至少H磅干草．
Input  第1行输入N和日，之后N行每行输入一个Pi和Ci．
Output  最小的开销．
Sample Input 2 15 3 2 5 3
Sample Output 9
FJ can buy three packages from the second supplier for a total cost of 9.
思路：完全背包。。。注意是买至少V,可以超过。我的做法是算了两倍，然后取最小值（V..2V)
/* *********************************************** Author :111qqz Created Time :2016年04月03日 星期日 19时40分29秒 File Name :code/bzoj/1618.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int p[N],c[N]; int n; int V; int dp[1000005]; void solve (int val,int cost) { for ( int i = value ; i &amp;lt;= V ; i++) dp[i] = min(dp[i],dp[i-value]+cost); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1617: [Usaco2008 Mar]River Crossing渡河问题 (DP)</title><link>http://example.org/2016/04/bzoj1617/</link><pubDate>Sun, 03 Apr 2016 11:34:42 +0000</pubDate><guid>http://example.org/2016/04/bzoj1617/</guid><description>1617: [Usaco2008 Mar]River Crossing渡河问题 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 837 Solved: 606 [Submit][Status][Discuss]
Description Farmer John以及他的N(1 &amp;lt;= N &amp;lt;= 2,500)头奶牛打算过一条河，但他们所有的渡河工具，仅仅是一个木筏。 由于奶牛不会划船，在整个渡河过程中，FJ必须始终在木筏上。在这个基础上，木筏上的奶牛数目每增加1，FJ把木筏划到对岸就得花更多的时间。 当FJ一个人坐在木筏上，他把木筏划到对岸需要M(1 &amp;lt;= M &amp;lt;= 1000)分钟。当木筏搭载的奶牛数目从i-1增加到i时，FJ得多花M_i(1 &amp;lt;= M_i &amp;lt;= 1000)分钟才能把木筏划过河（也就是说，船上有1头奶牛时，FJ得花M+M_1分钟渡河；船上有2头奶牛时，时间就变成M+M_1+M_2分钟。后面的依此类推）。那么，FJ最少要花多少时间，才能把所有奶牛带到对岸呢？当然，这个时间得包括FJ一个人把木筏从对岸划回来接下一批的奶牛的时间。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..N+1行: 第i+1为1个整数：M_i
Output 第1行: 输出1个整数，为FJ把所有奶牛都载过河所需的最少时间 Sample Input 5 10 3 4 6 100 1
输入说明:
FJ带了5头奶牛出门。如果是单独把木筏划过河，FJ需要花10分钟，带上 1头奶牛的话，是13分钟，2头奶牛是17分钟，3头是23分钟，4头是123分钟，将 5头一次性载过去，花费的时间是124分钟。
Sample Output 50
HINT 输出说明: Farmer John第一次带3头奶牛过河（23分钟），然后一个人划回来</description></item><item><title>BZOJ 1616: [Usaco2008 Mar]Cow Travelling游荡的奶牛(DP)</title><link>http://example.org/2016/04/bzoj1616/</link><pubDate>Sun, 03 Apr 2016 07:52:18 +0000</pubDate><guid>http://example.org/2016/04/bzoj1616/</guid><description>1616: [Usaco2008 Mar]Cow Travelling游荡的奶牛 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1012 Solved: 553 [Submit][Status][Discuss]
Description 奶牛们在被划分成N行M列(2 &amp;lt;= N &amp;lt;= 100; 2 &amp;lt;= M &amp;lt;= 100)的草地上游走，试图找到整块草地中最美味的牧草。Farmer John在某个时刻看见贝茜在位置 (R1, C1)，恰好T (0 &amp;lt; T &amp;lt;= 15)秒后，FJ又在位置(R2, C2)与贝茜撞了正着。 FJ并不知道在这T秒内贝茜是否曾经到过(R2, C2)，他能确定的只是，现在贝茜在那里。 设S为奶牛在T秒内从(R1, C1)走到(R2, C2)所能选择的路径总数，FJ希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动1单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。 现在你拿到了一张整块草地的地形图，其中&amp;rsquo;.&amp;lsquo;表示平坦的草地，'*&amp;lsquo;表示挡路的树。你的任务是计算出，一头在T秒内从(R1, C1)移动到(R2, C2)的奶牛可能经过的路径有哪些。
Input 第1行: 3个用空格隔开的整数：N，M，T
第2..N+1行: 第i+1行为M个连续的字符，描述了草地第i行各点的情况，保证 字符是&amp;rsquo;.&amp;lsquo;和&amp;rsquo;*&amp;lsquo;中的一个 * 第N+2行: 4个用空格隔开的整数：R1，C1，R2，以及C2
Output 第1行: 输出S，含义如题中所述 Sample Input 4 5 6 &amp;hellip;.</description></item><item><title>BZOJ 1613: [Usaco2007 Jan]Running贝茜的晨练计划 (dp)</title><link>http://example.org/2016/04/bzoj1613/</link><pubDate>Sat, 02 Apr 2016 09:41:36 +0000</pubDate><guid>http://example.org/2016/04/bzoj1613/</guid><description>1613: [Usaco2007 Jan]Running贝茜的晨练计划 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1468 Solved: 706 [Submit][Status][Discuss]
Description 奶牛们打算通过锻炼来培养自己的运动细胞，作为其中的一员，贝茜选择的运动方式是每天进行N(1 &amp;lt;= N &amp;lt;= 10,000)分钟的晨跑。在每分钟的开始，贝茜会选择下一分钟是用来跑步还是休息。 贝茜的体力限制了她跑步的距离。更具体地，如果贝茜选择在第i分钟内跑步，她可以在这一分钟内跑D_i(1 &amp;lt;= D_i &amp;lt;= 1,000)米，并且她的疲劳度会增加 1。不过，无论何时贝茜的疲劳度都不能超过M(1 &amp;lt;= M &amp;lt;= 500)。如果贝茜选择休息，那么她的疲劳度就会每分钟减少1，但她必须休息到疲劳度恢复到0为止。在疲劳度为0时休息的话，疲劳度不会再变动。晨跑开始时，贝茜的疲劳度为0。 还有，在N分钟的锻炼结束时，贝茜的疲劳度也必须恢复到0，否则她将没有足够的精力来对付这一整天中剩下的事情。 请你计算一下，贝茜最多能跑多少米。
Input 第1行: 2个用空格隔开的整数：N 和 M
第2..N+1行: 第i+1为1个整数：D_i
Output 第1行: 输出1个整数，表示在满足所有限制条件的情况下，贝茜能跑的最大 距离 Sample Input 5 2 5 3 4 2 10
Sample Output 9
输出说明:
贝茜在第1分钟内选择跑步（跑了5米），在第2分钟内休息，在第3分钟内跑 步（跑了4米），剩余的时间都用来休息。因为在晨跑结束时贝茜的疲劳度必须 为0，所以她不能在第5分钟内选择跑步。
题意：一个人第i分钟可以选择跑步或者休息，如果跑步可以跑d[i]米，疲劳度+1，如果休息疲劳度-1，但是一旦开始休息必须休息到疲劳度为0，疲劳度为0以后再休息疲劳度仍然为0，初始疲劳度为0，问n分钟最多跑多远。</description></item><item><title>最长上升子序列nlogn解法</title><link>http://example.org/2016/04/nlogn/</link><pubDate>Fri, 01 Apr 2016 12:15:41 +0000</pubDate><guid>http://example.org/2016/04/nlogn/</guid><description>首先回顾一下n^2的做法。 状态转移方程为dp[i] =max(1,dp[j]) (1=&amp;lt;j&amp;lt;=i-1&amp;amp;&amp;amp;a[i]&amp;gt;a[j])
for ( int i = 1 ; i &amp;lt;= n ; i++) cin&amp;gt;&amp;gt;a[i]; for ( int i = 1 ; i &amp;lt;= n ; i++) { dp[i] = 1; for ( int j = 1 ; j &amp;lt; i ; j++) { if (a[i]&amp;gt;a[j]) dp[i] = max(dp[i],dp[j]+1); } ans = max(ans,dp[i]); } 然后我们发现，使得dp[i]得到同一个值的dp[j]可能有多个，那么选择哪个呢？ 假设 x&amp;lt;y&amp;lt;i，a[x]&amp;lt;a[y],dp[x]==dp[y]，那么我们选择x好还是y好呢？ 显然是x好。为什么？因为选择x潜力大。因为可能在x,y之间存在一个z,满足a[x]&amp;lt;a[z]&amp;lt;a[y],如果选择a[y]，就没有办法选择可能使长度更长的a[z]了。通俗得说。。我们要求的是最长上升子序列。。你一开始就弄那么大。。。后面还上哪上升去啊。。。长度小啊。。。
因此我们得出一个结论，对于dp[t]==k的所有t,要选择a[t]最小的，这样有更大可能得到更长的序列。
我们用g[k]表示所有dp[t]==k的t中，最小的a[t]的值。g[k] = min{A[t]} (dp[t] = k)
我们可以发现关于g的两个性质。
（1） g[k]肯定是单调不增的。因为求最小值嘛，肯</description></item><item><title>codeforces #338 div2 B || 615B Longtail Hedgehog</title><link>http://example.org/2016/03/cf615b/</link><pubDate>Tue, 22 Mar 2016 10:28:04 +0000</pubDate><guid>http://example.org/2016/03/cf615b/</guid><description>题目链接 题意：给出n个点，m条边，定义一条路径的价值为【路径长度*(路径终点的度)】，求最大价值。 思路：一月份的时候写过一个回溯。。。TLE22了。。。其实也能猜到是dp..但是无奈不会写。然而其实真的不难== 我们枚举路径的终点，dp[i]表示以点i为终点能得到的最长路径长度。
转移方程：dp[i] = max(dp[i],dp[edge[i][j]]+1);
含义是与i点相连的j点是否要将i点加在以j点为路径末尾的路径的终点，使i点成为新的路径终点。
具体看代码
/* *********************************************** Author :111qqz Created Time :2016年01月08日 星期五 21时55分26秒 File Name :code/cf/#338/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; vector&amp;lt;int&amp;gt;edge[N]; LL ans; LL cur; LL dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>ural 1057. Amount of Degrees (b进制数位dp)</title><link>http://example.org/2016/03/ural1057/</link><pubDate>Fri, 18 Mar 2016 07:06:05 +0000</pubDate><guid>http://example.org/2016/03/ural1057/</guid><description>题目链接 题意：设条件A为一个数恰好是k个互不相同的b的整数次幂的和，问某一个区间内满足条件A的数的个数是有多少个。
Example. Let _X_=15, _Y_=20, _K_=2, _B_=2. By this example 3 numbers are the sum of exactly two integer degrees of number 2:
17 = 24+20, 18 = 24+21, 20 = 24+22.
思路：数位dp..需要理解清楚恰好有k个b的互不相同的整数次幂的和这句话。
如果恰好是b的整数幂。。可以转化成b进制。。
互不相同。。说明。。所有位置上的数字要么是0，要么是1.
于是题目可以转化成求某区间内，满足一个数的b进制中恰好有k个1，其余都是0的数的个数有多少个。
然后就是数位dp的套路了。。。
注意dp数组的大小。。。应该按照位数最多的2进制考虑。。。一开始是按照10进制考虑结果只开了dp[15][15]&amp;hellip;.简直蠢哭。
/* *********************************************** Author :111qqz Created Time :2016年03月18日 星期五 12时13分55秒 File Name :code/ural//1057.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int l,r; int k,base; int digit[700]; int dp[700][700]; int dfs( int pos , int cnt, bool limit) { if (pos==0) return cnt==0; if (cnt&amp;lt;0) return 0; if (!</description></item><item><title>hdu 4734 F(x) (数位dp)</title><link>http://example.org/2016/03/hdu4734/</link><pubDate>Fri, 18 Mar 2016 01:32:06 +0000</pubDate><guid>http://example.org/2016/03/hdu4734/</guid><description>题目链接s 题意：将一个10进制数x按照2进制展开后得到的值设为f(x)&amp;hellip;现在给出a,b（10^9）问【0，b】中满足f[x]&amp;lt;=f[a]的数的个数。 思路：先算出f[a]&amp;hellip;然后我们发现f(x)最大也就10*2^10=10240.。。数组可以存下。。搞之。和上一道题类似。。我们不关心两个f函数的值具体是多少。。。只关心他们的相对大小情况。。所以还是可以合并成一个变量。。。然而我用两个变量为什么错了。。不懂==
错误代码（用两个变量分别记录）
/* *********************************************** Author :111qqz Created Time :2016年03月17日 星期四 21时30分57秒 File Name :code/hdu/4734.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int a,b; int digit[15],digita[15]; int fa; int dp[10][110000];//dp[i][j]表示长度为i,f[x]为j的方案数.</description></item><item><title>bc #75 C || hdu 5642 King's Order （数位dp）</title><link>http://example.org/2016/03/hdu5642/</link><pubDate>Thu, 17 Mar 2016 12:35:47 +0000</pubDate><guid>http://example.org/2016/03/hdu5642/</guid><description>hdu5642题目链接 题意：问长度为n的仅由26个小写字母组成的合法字符串有多少个。如果某个字符连续出现四次或以上，则这个字符串为非法。否则为合法。
思路：当时以为是组合数学的题。。。推了半天公式还是还是gg&amp;hellip; 现在学了数位dp..果然是数位dp里很简单的一种。。。 dp[i][j][k]表示长度为i,最后一个字符对应的数字为j,最后一个字符出现了k次的方案数。
需要注意的是，这种连续几个位置相等或者不相等什么的。。。没有必要维护具体那些位置上的字符是什么。。。所以这种只统计最后一个字符，以及最后一个字符出现的次数的方法具有普遍意义。。注意理解。。。</description></item><item><title>hdu 3709 Balanced Number (数位dp)</title><link>http://example.org/2016/03/hdu-3709-balanced-number-dp/</link><pubDate>Thu, 17 Mar 2016 11:46:31 +0000</pubDate><guid>http://example.org/2016/03/hdu-3709-balanced-number-dp/</guid><description>题目链接 题意：找到某区间中平衡数的个数。所谓平衡数是指，存在某个位置，值得两边的力矩相等。举个例子。。比如14326，如果把4作为中间。。那么左边=11=1 右边=31+22+62=19。。。 思路：枚举中间的pivot。。。注意如果是个位数也是平衡数（就是认为两边的力矩都是0了。。。），所以每一个位置都可能是平衡位置。。枚举的时候从1到len&amp;hellip; 一开始我是分别记录两边的值。。非常浪费空间。。。然而发现其实没必要。。我们只关心左边是否相等。。而不关心左右的值到底是多少。。所以可以把两边的值带符号合并成一个值（pivot左边为+，pivot右边为负）。。。如果最后为0。。说明左右相等。。。
以及。。这个值(设为sum)是递减的。。。所以任何时刻如果sum&amp;lt;0。。那么狗带。。算一个剪枝。。而且避免了下标为负。。。
以及，关于前导0的问题。。。有些题目不允许前导0.。。。但是并不是所有不允许前导0的都需要特别处理。。。像这道。。前导0不会导致更新答案。。。所以不用管。。。 但是要注意。。。由于0，00,000,0000都是合法的balanced数。。。然而其实他们是一个数。。多加了len-1次。。记得减去。
/* *********************************************** Author :111qqz Created Time :2016年03月17日 星期四 17时08分59秒 File Name :code/hdu/3709.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL l,r; int T; int digit[30]; LL dp[20][2000][20]; //窝要判断左边和右边是否相等，并不需要分别统计两边，只要把数值带上符号，统计左右两边的和即可。 //如果相等，那么和为0.</description></item><item><title>poj3252 Round Numbers (不允许前导0的二进制数位dp)</title><link>http://example.org/2016/03/poj3252/</link><pubDate>Thu, 17 Mar 2016 08:51:14 +0000</pubDate><guid>http://example.org/2016/03/poj3252/</guid><description>题目链接 题意：问某区间中，round number 的个数是多少。所谓round number,当且仅当一个数的二进制表示中，‘0’的个数大于等于‘1’的个数。 思路：简单数位dp..和windy数那道题类似，都是不允许前导0.。。所以在dfs中要加一维判断前面是否有非0的数。。。
/* *********************************************** Author :111qqz Created Time :2016年03月17日 星期四 16时17分07秒 File Name :code/poj/3252.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int l,r; int digit[35]; int dp[35][35][35]; //dp[i][j][k]表示长度为i，有j个0，k个1的方案数。 int dfs( int pos,int cnt0,int cnt1,bool limit,bool prehasnonzero) //不允许前导0，所以要加prehasnonzero这个参数 //来确定是否位数减少了.</description></item><item><title>hdu 4507 吉哥系列故事——恨7不成妻 (返回平方和的数位dp)</title><link>http://example.org/2016/03/hdu4507/</link><pubDate>Thu, 17 Mar 2016 07:55:35 +0000</pubDate><guid>http://example.org/2016/03/hdu4507/</guid><description>题目链接 题意：如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 1、整数中某一位是7； 2、整数的每一位加起来的和是7的整数倍； 3、这个整数是7的整数倍；
现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。
思路;如果是求count的话毫无难度。。。和之前的题目没什么区别。。不多说了。
但是是求平方数。。。一开始我的做法是在dfs中加一个LL 的参数表示当前的和，然后每次到dfs的出口，之前统计count的时候返回的是1，表示找到了满足条件的一个数，那这回就返回平方和。。但是这样做是错的。。。具体为什么错没有想得很明白。。。大概会少算？
然后参考了如下博客： hdu4507解题报告1 hdu4507解题报告2
适牛的博客之数位dp
正解是，之前的dp只统计了一个cnt,这回要同时统计cnt,sum,sqsum(平方和)..
我们先讨论如何求得满足条件的数的和。
我们设某次进入dfs的数是x,当前长度为pos（长度是越来越短的，因为是从高位到低位，对于没有处理到的低位，是按0算的，比如一个五位数xxxxx，第一次dfs以后也许得到4xxxx,x表示没有填的数的位置，实际上这个数就是40000），当前位置要防止的数字是i,考虑其位置，i对这个数的大小（不是和，就是最后要得到的一个数）的贡献是i*10^(pos-1),设为f. 那么当前的数就是f+x. 我们要求的就是所有f+x的和。现在我们考虑当新添加pos位的数字i对于和的贡献。
当新添加i时，相当与把之前的数整体左移了一位，相当于×10（因为之前[1,x]中的每个满足条件的数都乘了10，所以和也乘了10），然后对于新添加的i，它的贡献是i*cnt[x]，含义是对于之前[1,x]所有满足条件的每个数，都进行了pos位置填i的操作，所有对于所有满足条件的和一共添加了cnt[x]个i.
**如果写成用递推的式子就是 **
*sum[10*x+i] = 10 * sum[x] + cnt[x]i;//感谢@clq学长
如果用dfs的话式子就是
sum[new_state] = Σ{ sum[old_state] + (number to add at the postion) * (its base) * count[old_state] }。
接下来我们考虑维护平方和，方法类似。
(f+x)^2=ff+xx+2fx.
ff直接可以算，xx..其实就是上一层dfs得到的(f'+x&amp;rsquo;)^2嘛&amp;hellip;也就是sum2[x] (sum2表示平方和)
2fx也可以算,x就是上一个状态的和。
同样，我们考虑现在已经有了x,处理到pos位置，填到该位置的数字是i的时候对平方和的影响。
xx部分在上一个状态处理过了，即为sum2[x], 2f*x 也可以通过sum[x]得到&amp;hellip;
**注意ff,同样，对于之前的[1,x]中每个满足的数，都相当于第pos位添加了i,每个数对平方和的贡献都是ii,所以要*cnt[x]&amp;hellip; **
以及要不断取模，为了方便写了两个函数来搞，代码看起来清楚一些。。。
哦，还有一个小坑。。取模相减以后可能为负数。。。。记得加MOD&amp;hellip;
** **
/* *********************************************** Author :111qqz Created Time :2016年03月16日 星期三 10时44分58秒 File Name :code/hdu/4507.</description></item><item><title>hdu 3652 B-number (带整除的数位dp )</title><link>http://example.org/2016/03/hdu3652/</link><pubDate>Wed, 16 Mar 2016 02:23:08 +0000</pubDate><guid>http://example.org/2016/03/hdu3652/</guid><description>题目链接 题意：给出n,问[1,n]中，满足包含“13”且这个数（不是各位的和）能被13整除的数的个数。 思路：依然是数位dp..不过有一个小tip。。
由于包含13的情况非常难考虑（包含一个“13”，两个“13”&amp;hellip;..)
所以要从反面考虑，即不包含13的情况。
但是由于还有另一个条件。
做法是把能被13整除的数考虑成全集U,然后在U中做分划，一部分是含13的，另一部分是不含13的。
这样我们要求两个答案，一个是能被13整除的，另一个是能被13整除并且不含13的，相减即为题目所求。
/* *********************************************** Author :111qqz Created Time :2016年03月16日 星期三 09时27分49秒 File Name :code/hdu/3652.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; LL dp[20][15]; LL dp2[20][2][15]; int digit[20]; LL dfs (int pos,int sum,bool limit) { if (pos==0) return sum==0; if (!</description></item><item><title>hdu 4722 good numbers (带整除的数位dp)</title><link>http://example.org/2016/03/hdu4722/</link><pubDate>Wed, 16 Mar 2016 01:17:27 +0000</pubDate><guid>http://example.org/2016/03/hdu4722/</guid><description>题目链接 题意：求一个区间内所有位数字之和能被10整除的数的个数。 思路：数位dp，dfs要一个参数记录从最高位到现在的pos位置的数字之和的结果。 dp[i][j] 表示长度为i，和为j的方案数。 记得开long long ，然而我开了那么多long long 忘了dp 的long long 结果wa到死。。果然大早上不清醒吗==
/* *********************************************** Author :111qqz Created Time :2016年03月16日 星期三 08时10分19秒 File Name :code/hdu/4722.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL l,r; int digit[30]; LL dp[30][15]; //dp 数组忘记开long long ,wa到死。。。。。。。。。日了哈士奇。 LL dfs ( int pos,int sum,bool limit) { if (pos==0) { if (sum==0) return 1; else return 0; } if (!</description></item><item><title>bzoj 1026 windy数(数位dp入门题)</title><link>http://example.org/2016/03/bzoj1026/</link><pubDate>Tue, 15 Mar 2016 13:05:13 +0000</pubDate><guid>http://example.org/2016/03/bzoj1026/</guid><description>题目链接 题意：不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 思路：数位dp 这道题的特点是前面不允许前导0，也就是说，如果第i位前面全是0的话，这个数就变成了i位数，i就变成了最高位，而最高位没有前面的数（**如果这里不考虑不允许前导0这个因素而把前面的一个数认为成是0就错了） **最高位的数可以直接取。 还有记忆化调用以及存储的时候也要注意&amp;hellip;只有当位数相同的时候转移才有意义。 具体的方法是dfs中多了一个prehasnonzero的bool变量，就是字面意思，判断当前位置前面的位置是够存在一个非0的值。
/* *********************************************** Author :111qqz Created Time :2016年03月15日 星期二 19时49分57秒 File Name :code/bzoj/1026.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int l,r; int dp[30][10]; int digit[30]; int dfs ( int pos,int pre,bool limit,bool prehasnonzero) // prehasnonzero表示当前位前面的位是否有非0的位。 {zhi if (pos==0) return 1; if (prehasnonzero&amp;amp;&amp;amp;!</description></item><item><title>hdu 3555 Bomb （数位dp入门题）</title><link>http://example.org/2016/03/hdu3555/</link><pubDate>Tue, 15 Mar 2016 11:48:19 +0000</pubDate><guid>http://example.org/2016/03/hdu3555/</guid><description>题目链接 题意:问从1到n的所有数中，有多少个数含有数字串“49” 思路：和上一道不要62很像，但是由于是要统计有49的，但是有49的情况实在太多了，正难则反，用减法定理反过来考虑，先统计出不含49的数的个数，这样就和不要62一样了，然后再用总数减。
/* *********************************************** Author :111qqz Created Time :2016年03月15日 星期二 19时32分24秒 File Name :code/hdu/3555.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; LL digit[30]; LL dp[30][2]; LL dfs ( int pos,bool preis4,bool limit) { if (pos==0) return 1; if (!</description></item><item><title>hdu 2089 不要62 （数位dp模板题，附带详细解释）</title><link>http://example.org/2016/03/hdu-2089/</link><pubDate>Tue, 15 Mar 2016 11:27:43 +0000</pubDate><guid>http://example.org/2016/03/hdu-2089/</guid><description>题目链接 题意：问区间[n,m]中，不含数字4，也不含数字串“62”的所有数的个数。
思路：可以转化成求区间[0,x]
第一次接触数位dp,参考了这几篇博客。
不要62（数位dp）解题报告
解题报告2
解题报告3
比较重要的前提：
¨对于一个小于n的数，肯定是从高位到低位出现某一位&amp;lt;n的那一位。
¨如 n = 58 n为十进制数。
¨ x = 49 此时x的十位&amp;lt;n
¨ x = 51 此时x的个位&amp;lt;n
¨有了上述性质，我们就可以从高到低枚举第一次&amp;lt;n对应位是哪一位。
这样之前的位确定了，之后的位就不受n的限制即从00&amp;hellip;0~99&amp;hellip;9，可以先预处理
以及写成递归形式代码会简洁很多，所以就写了递归形式。
更详细的解释参加代码注释。
/* *********************************************** Author :111qqz Created Time :2016年03月15日 星期二 18时04分46秒 File Name :code/hdu/2089.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int dp[30][2]; int digit[30]; int dfs (int pos,bool preis6,bool limit) //pos表示从低到高的第几位，是从高位往低位递归的（也就是从左到又） // preis6 表示上一个数字是否为6， // limit表示该位置是否有限制。 { // cout&amp;lt;&amp;lt;pos&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;preis6&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;limit&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;endl; if (pos==0) return 1; //到该位置表明找到了一个解.</description></item><item><title>codeforces #341 div 2 E. Wet Shark and Blocks (数位dp+矩阵加速)</title><link>http://example.org/2016/02/cf621e/</link><pubDate>Mon, 08 Feb 2016 09:04:41 +0000</pubDate><guid>http://example.org/2016/02/cf621e/</guid><description>http://codeforces.com/problemset/problem/621/E 题意：有b组数，每组数均有n个且相同。你必须在每组选一个数，组成一个新数sum，使得sum % x == k，问方案数 % (1e9+7)。
思路：数位dp.首先考虑b不是很大的一般情况。dp[i][j]表示处理到前i个块的时候结果为j的方案数。那么转移方程就是：**dp[i][(j_10+t)%x] = dp[i-1][j]_cnt[t] ** cnt[i]表示数字i出现的个数。
但是由于b很大（1E9）,所以需要用矩阵加速。
/* *********************************************** Author :111qqz Created Time :2016年02月08日 星期一 16时24分34秒 File Name :code/cf/#341/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const LL MOD=1E9+7; int n,b,k,X; struct Matrix { LL a[110][110]; }; void add(LL &amp;amp;x,LL y) { x += y; x %= MOD; } Matrix multi(Matrix x,Matrix y ) //矩阵乘法。 { Matrix z; ms(z.</description></item><item><title>codeforces 148 D. Bag of mice</title><link>http://example.org/2016/02/cf148d/</link><pubDate>Wed, 03 Feb 2016 19:34:38 +0000</pubDate><guid>http://example.org/2016/02/cf148d/</guid><description>http://codeforces.com/problemset/problem/148/D 题意：盒子里有w只白老鼠，b只黑老鼠，公主和魔王轮流取（公主先），先取到白老鼠的人获胜。魔王每次取完以后，盒子中的老鼠会因为吓尿了跑掉一只，跑掉的老鼠不算任何人取的。问公主获胜的概率。
思路：概率dp.. dp[i][j]表示有i只白老鼠，j只黑老鼠的时候公主获胜的概率。 转移方程 1. 公主抽到白老鼠（之后龙不必再抽） 胜率为i/(i+j)*1 2. 公主抽到黑老鼠，龙抽到黑老鼠，跳出一只黑老鼠，胜率为j/(i+j) * (j-1)/(i+j-1) * (j-2)/(i+j-2) * f[i][j-3] (j&amp;gt;=3) 3. 公主抽到黑老鼠，龙抽到黑老鼠，跳出一只白老鼠，胜率为j/(i+j) * (j-1)/(i+j-1) * (i/(i+j-2) * f[i-1][j-2] (j&amp;gt;=2) 4. 龙抽到白老鼠，胜率为0 /* *********************************************** Author :111qqz Created Time :2016年02月04日 星期四 02时44分23秒 File Name :code/cf/problem/148D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int w,b; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 518 D. Ilya and Escalator</title><link>http://example.org/2016/02/cf518/</link><pubDate>Tue, 02 Feb 2016 08:20:47 +0000</pubDate><guid>http://example.org/2016/02/cf518/</guid><description>http://codeforces.com/problemset/problem/518/D
题意：有n个人排队上一个电梯。。。在某一秒内，队首的人有p的概率上电梯，1-p的概率不动。每个人只有在队首的位置才可以上电梯（也就是每一秒内，最多只有一个人可以上电梯）。电梯无线长（也就是上了电梯就不会离开了），问在第t秒的时候，电梯上的人的个数的数学期望是多少。 思路：一开始推公式的我还是图样。这题是dp.其实也不难想。dp[i][j]表示第i秒时电梯上有j个人的概率。 当j==n的时候，也就是所以人都上了电梯以后。dp[i+1][j]+=dp[i][j],对于其他时刻 dp[i+1][j+1]+=dp[i][j]p,dp[i+1][j]+=dp[i][j](1-p). 初始化dp[0][0]=1,即0时刻电梯上有0个人的概率为1. /* *********************************************** Author :111qqz Created Time :2016年02月02日 星期二 15时57分06秒 File Name :code/cf/518D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n,t; double p; double dp[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>cf 611 B ||codeforces goodbye 2015 B. New Year and Old Property (数学或者数位dp)</title><link>http://example.org/2016/01/cf611b/</link><pubDate>Fri, 01 Jan 2016 13:03:22 +0000</pubDate><guid>http://example.org/2016/01/cf611b/</guid><description>http://codeforces.com/contest/611/problem/B 题意：问a到b（1E18），二进制表示中只有一个0的数有多少个。 思路：这么大的数。。。不是有循环节就是math problems. UD:20160318讲道理还有可能是数位dp好不好。。。 我们发现可以很容易得算出1到x的二进制表示中只有一个0 的数有多少个。
problem solved.
20160318update:学了数位dp后又看到这题。。。这题显然是数位dp啊。。。亏我找规律搞了出来2333.
后面附上数位dp方法AC的代码
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 22时49分02秒 File Name :code/cf/goodbye2015/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const int N=1E4+7; LL a,b; LL p[N]; LL c[N]; LL cal( LL x) { return ((x-1LL)*x)/2LL; } LL solve (LL x) { if (x==0LL) return 0; LL res= 0LL; LL cnt = 0LL; LL xx = x; while (xx) { cnt++; p[cnt] = xx%2LL; xx/=2LL; } ms(c,0); res+=cal(cnt-1LL); LL tmp = (1LL&amp;lt;&amp;lt;cnt)-1LL; for ( LL i = 0 ; i &amp;lt;cnt-1 ; i++) { LL happ = 1LL&amp;lt;&amp;lt;i; c[i]=tmp-happ; } sort(c,c+cnt-1); for ( LL i = 0 ; i&amp;lt; cnt -1 ; i++) { if (x&amp;gt;=c[i]) res++; } return res; } int main() { cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; LL ans = solve(b)-solve(a-1LL); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; } 数位dp的方法：</description></item><item><title>codeforces 30 C. Shooting Gallery</title><link>http://example.org/2015/12/codeforces-30-c-shooting-gallery/</link><pubDate>Tue, 29 Dec 2015 10:54:59 +0000</pubDate><guid>http://example.org/2015/12/codeforces-30-c-shooting-gallery/</guid><description>http://codeforces.com/contest/30/problem/C 题意：给出n个target在一个二维平面上。给出每个target的坐标，出现的时间，以及击中的概率。target出现之后就会瞬间消失，枪移动的单位速度为1，射击不需要时间。问能击中的target的最大期望是多少。
思路：路径dp。。。按照时间升序排列。 dp[i]表示到第i个target出现的时候的期望。
/* *********************************************** Author :111qqz Created Time :2015年12月29日 星期二 18时14分45秒 File Name :code/cf/problem/30C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n; double dp[N]; int dblcmp(double d) { return d&amp;lt;-eps?</description></item><item><title>codeforces #327 A. Flipping Game</title><link>http://example.org/2015/12/cf327a/</link><pubDate>Fri, 25 Dec 2015 13:53:06 +0000</pubDate><guid>http://example.org/2015/12/cf327a/</guid><description>http://codeforces.com/contest/327/problem/A 题意：给定一段序列，只由0,1组成。要求选一段非空区间，做翻转操作（0变1,1变0），问变完之后1最多能有多少。 思路：最后的1个个数=初始的1的个数+变换区间的0的个数-变换区间的1的个数。初始的是常数。那么我们只要找到某一个区间内，0的个数-1的个数有最大值即可。如果a[i]==0的时候令b[i]=1，否则b[i]=0,那就是经典了最大连续区间和的问题了。dp的思想o(n)可以解决。
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 21时35分22秒 File Name :code/cf/problem/327A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n ; int a[N],b[N]; int ans; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 456 C. Boredom</title><link>http://example.org/2015/12/codeforces-456-c-boredom/</link><pubDate>Fri, 25 Dec 2015 10:53:05 +0000</pubDate><guid>http://example.org/2015/12/codeforces-456-c-boredom/</guid><description>http://codeforces.com/contest/456/problem/C 题意：给出n(1E5)个数（1E5），每次可以选一个数a[k]并删掉a[k],a[k]-1,a[k]+1得到a[k]分，问最多能得到的分数。 思路：裸dp.f[i]表示选到数i的时候能达到的最大分数。开一个计数数组cnt[x]表示数字x出现的次数。那么显然有f[0]=0,f[1]=cnt[1],f[i(i&amp;gt;=2)] = max(f[i-1]，f[i-2]+f[i]*cnt[i]);答案为f[max(a[i])]，注意要开long long
/* *********************************************** Author :111qqz Created Time :2015年12月25日 星期五 18时17分05秒 File Name :code/cf/problem/455A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n ; int a[N]; LL cnt[N]; LL dp[N]; bool cmp( int a,int b) { return a&amp;gt;b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>bestcoder #56 div 2 B Clarke and problem(dp)</title><link>http://example.org/2015/09/bestcoder56div2bclarkeandproblemdp/</link><pubDate>Tue, 22 Sep 2015 03:02:00 +0000</pubDate><guid>http://example.org/2015/09/bestcoder56div2bclarkeandproblemdp/</guid><description>果然dp還是弱項啊啊啊啊．． 不過比最開始的完全無從下手強了不少應該．．．
至少dp狀態表示相對了．．．．轉移方程沒想出來嗚嗚嗚
官方題解：设d(i, j)d(i,j)表示前ii个数，模pp为jj的方案数，则容易得到d(0, 0)=1, d(i, j)=d(i-1, j)+sum_{j=0}^{p-1} d(i-1, (j-a[i]) mod p)d(0,0)=1,d(i,j)=d(i−1,j)+∑​j=0​p−1​​d(i−1,(j−a[i]) mod p)，很多人没1a是因为没注意|a_i| le 10^9∣a​i​​∣≤10​9​​
/************************************************************************* &amp;gt; File Name: code/bc/#56/1002.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月22日 星期二 10时47分20秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N = 1E3+5; const int MOD = 1E9+7; LL a[N],dp[N][N]; int n,p; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description></item><item><title>codeforces #319 B - Modulo Sum (抽屉原理，dp)</title><link>http://example.org/2015/09/codeforces319b-modulosumdp/</link><pubDate>Wed, 16 Sep 2015 03:24:00 +0000</pubDate><guid>http://example.org/2015/09/codeforces319b-modulosumdp/</guid><description>背包还是理解的不够透彻．．
因为每次都是用那个一维形式的．
这道题的做法类似01背包.
此外还可以有一个优化&amp;hellip;
当n&amp;gt;m的时候．．．根绝抽屉原理．．一定为yes..
复杂度可以从o(nm)优到　o(m^2)
/************************************************************************* &amp;gt; File Name: code/cf/#319/B.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年09月15日 星期二 19时54分44秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define ms(a,x) memset(a,x,sizeof(a)) #define lr dying111qqz using namespace std; #define For(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m; int a[N]; int dp[N]; void OneZeroPack(int cost,int value) { for ( int v = m ; v--; v &amp;gt;=cost) { dp[v] = max(dp[v],dp[v-cost]+value); } } int main() { #ifndef ONLINE_JUDGE #endif cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; if (n&amp;gt;=m) { puts(&amp;quot;YES&amp;quot;); return 0; } int k = 0; for ( int i = 0 ; i &amp;lt; n ; i++) { int x; scanf(&amp;quot;%d&amp;quot;,&amp;amp;x); if (x&amp;gt;m) continue; //大于背包容量的肯定直接舍去 k++; a[k] = x; } // for ( int i = 1 ; i &amp;lt;= k ; i++) cout&amp;lt;&amp;lt;&amp;quot;a[i]:&amp;quot;&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;endl; for ( int i = 0 ; i &amp;lt;= m ; i++) dp[i] = -inf; dp[0] = 0 ; for ( int i = 1 ; i &amp;lt;= k ; i++) { OneZeroPack(a[i],a[i]); } for ( int i = 0 ; i &amp;lt;= m ; i++) cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;dp[i]&amp;lt;&amp;lt;endl; if (dp[m]==-inf) { puts(&amp;quot;NO&amp;quot;); } else { puts(&amp;quot;YES&amp;quot;); } #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; }</description></item><item><title>HUST team contest #E A Mountain Road||poj 3846 (dp)</title><link>http://example.org/2015/08/poj3846/</link><pubDate>Thu, 20 Aug 2015 19:57:00 +0000</pubDate><guid>http://example.org/2015/08/poj3846/</guid><description>比赛的时候以为是贪心&amp;hellip;
想了好久.
不过最后没敢写,因为没办法证明正确性,只是直觉==
最后剩下的时间给队友改另一道题了..
果然明智&amp;hellip;
蠢的人的直觉真心不靠谱..
这题是dp
我们可以把车按照方向的不同分为A车和B车
dp[i][j][0..1]表示已经经过了a方向的i辆车,经过了b方向的j辆车,并且最后一辆车是a/b方向的情况的离开道路的时间.
似乎问题不大.
然后就一直wa&amp;hellip;
wa到怀疑人生好么!!!
最后发现
问题出在!
dp数组初始化赋值成正无穷的时候,溢出啦!
然后我搜了下,发现0x7fffffff果然不是什么好东西!
以后正无穷用0x3f3f3f3f
这东西&amp;gt;1E9,相加不超过int
而且最重要的是,如果定义 inf = 0x3f3f3f3f
0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))
不要使用0x7fffffff!
不要使用0x7fffffff!
不要使用0x7fffffff!
/************************************************************************* &amp;gt; File Name: code/2015summer/0821/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月21日 星期五 01时28分23秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=2E2+7; int dp[N][N][2]; int cntA,cntB; struct Q{ int beg,t; char dir; }q[N],a[N],b[N]; void init(){ int n; int beg,time; char dir; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); cntA = 0 ; cntB = 0 ; for ( int i = 0 ; i &amp;lt; n ;i++){ cin&amp;gt;&amp;gt;q[i].</description></item><item><title>codeforces 560 E. Gerald and Giant Chess (dp+lucas定理,求大组合数 mod p,p为质数)</title><link>http://example.org/2015/08/codeforces560e-geraldandgiantchessdplucasmodpp/</link><pubDate>Tue, 18 Aug 2015 11:36:00 +0000</pubDate><guid>http://example.org/2015/08/codeforces560e-geraldandgiantchessdplucasmodpp/</guid><description>dp方程想错了.果然还是欠练啊.
如果我们不考虑坏点,那么从 (0,0)到(x,y)的方案数是c(x+y,x)或者c(x+y,y)
因为有坏点的存在,我们可以逆向思维,先求出总数,然后减去那些由于坏点的影响不能走的方案数.
由于存在黑点i(x,y)，从左上到该黑点的方案数sum[i] = C(x+y,x)，其中如果在黑点i的左上还有黑点j(u,v)，那么应该减去sum[j]*C(x-u+y-v)(y-u)
然后可以把坏点按照x为第一关键字,y为第二关键字排序.
从左上出发,往右下扫黑点.
还有一个考点是大组合数的求法
因为太大,递推也不行.
可以用欧拉公式求逆元的方法求解.
或者是lucas定理.
记得拿到骑士(1,1)到(n,m)的题和这道题很像.
也是从坐上到右下,中间有些坏点,不过骑士的走法并不是向下或者想有1步,而是向右p步,向下q步,或者向又q步,向下p步.
而且那道题的n和m是 10^9的数量级&amp;hellip;
那道题的话就只能用lucas定理了貌似
这道题算是那道题的弱化版本,在此orz zhangk,果然厉害
所以我还是决定写lucas定理的解法
lucas定理适用于 求C(n,m)%p,p为素数 且n,m很大的情况.
引用一段题解:
题意，给一个n * m 的网格，其只有一些点是坏的不能走，要求从0，0点起到n,m的总方案数。 设dp[i] 表示到达第i个坏点且不经过其他坏点的总方案数。增加一个点(n-1,m-1),则dp[k]即为答案。 壮态转移方程 dp[i] = C[x[i]+y[i],x[i]) - sum(dp[j] * C(x[i] - x[j] + y[i] - y[j],x[i] - x[j]),j表示，所有在i之前的坏点，由于这里的dp[i]都是不经过别的坏点，不会有重复的路径，所以减去以前的坏点到达i的路径就是答案。 先排序，就可以得到每个点的先后顺序，这样在更新状态的时候，可以从小到大枚举。总的复杂度为 o(k * k); 现在剩下的问题 就是要求c(n,m),由于n,m很大，一般求组合数的方法是n * m，这样复杂度太高，即使用递推o(n)的复杂度，也是太高的。这里引入了 定理Lucas，这个就是专门求大组合数的一种方法。 Lucas(n,m,p)=c(n%p,m%p)*Lucas(n/p,m/p,p) 设 aa = n % p,bb = m % p;这里可以看出来把n,m很大的数转化了相对比较小的aa,bb, 这个公式把n - n/p m - m/p,这样可以递归解决。求c(aa,bb)就可以直接用组合公式aa!</description></item><item><title>codeforces 567 F. Mausoleum (dp)</title><link>http://example.org/2015/08/codeforces567f/</link><pubDate>Sun, 16 Aug 2015 07:09:00 +0000</pubDate><guid>http://example.org/2015/08/codeforces567f/</guid><description>很容易看出来是dp
我们左右一起，一对一对放．
对于每一对，有三种方法，分别是两左，一左一右，两右．
初始区间长度为２n，每次放完后缩小区间长度 ，最后一定是放２个n，这个时候区间长度缩小为２，表明一种满足题意的情况．
状态转移的时候需要分别判断三个状态是否满足题目中给出的k组限制条件．
细节见注释．
/************************************************************************* &amp;gt; File Name: code/cf/#314/F.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月16日 星期日 14时37分15秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N = 1E2+7; int n, k, a[N], b[N]; LL dp[N][N]; string sign[N]; int L, R, F, S; enum { OLD, CUR, NEW }; int get_type(int i) { if (i &amp;lt; L || i &amp;gt; R) return OLD; if (i == F || i == S) return CUR; return NEW; } bool compare(int a, int b, string s) { if (s == &amp;quot;=&amp;quot;) return a == b; if (s == &amp;quot;&amp;gt;&amp;quot;) return a &amp;gt; b; if (s == &amp;quot;&amp;lt;&amp;quot;) return a &amp;lt; b; if (s == &amp;quot;&amp;gt;=&amp;quot;) return a &amp;gt;= b; if (s == &amp;quot;&amp;lt;=&amp;quot;) return a &amp;lt;= b; } bool check(int l, int r, int f, int s) { L = l, R = r; F = f, S = s; for (int i = 0; i &amp;lt; k; i++) { int lf = get_type(a[i]); // 判断对于当前要添加的位置，是否有题目中给出限制的位置，如果是，判断是否满足限制． //如果有一个限制条件不满足就不成立，所有限制条件都满足才成立． int rg = get_type(b[i]); if (lf !</description></item><item><title>codeforces 570 E. Pig and Palindromes (dp)</title><link>http://example.org/2015/08/codeforces570e-pigandpalindromesdp/</link><pubDate>Fri, 14 Aug 2015 20:33:00 +0000</pubDate><guid>http://example.org/2015/08/codeforces570e-pigandpalindromesdp/</guid><description>比赛的时候想到了是dp搞&amp;hellip;
不过dp废&amp;hellip;..
可能更多的是心理上&amp;hellip;
这道题并不怎么难想,但是以觉得是dp,就给了自己一种暗示&amp;hellip;这题我搞不出来&amp;hellip;
实际上,我把cA掉的时候应该还有一个小时十分钟左右的样子&amp;hellip;
d题没啥思路,所以我有大概一个小时的时间可以搞e&amp;hellip;未必就搞不出来.
还有因为答案很大要取模,感觉一般取模的题,要么是数学,要么是像dp这种有递推式子的.
这道题的思路是:
因为要形成回文串,我们可以从两边往中间走,保证每一步都相同.
dp[i][x1][x2] 表示路径长度为i,左上角出发到达x坐标为x1,又下角出发到达x坐标为x2,且两条路径上对应的字母都相同的方案数.
然后判断当前格子的字母是否一样,如果一样,则考虑转移.
由于从左上角出发可以往下往右,从右下角出发可以往上往左,排列组合,所以当前状态和之前的四种状态有关.
由因为这步的状态只和上以步的四种状态有关,所以路径长度那以维要滚动掉不然会MLE
dp方程为 dp[cur][x1][x2]=(dp[cur^1][x1][x2],dp[cur^1][x1-1][x2],dp[cur^1][x1][x2+1],dp[cur^1][x1-1][x2+1])%MOD;
然后注意由于(m+n) 的奇偶性,答案会有所不同.
根据奇偶性判断从两端出发是到两个相邻的格子还是到同一个格子.
初始化的话如果(1,1)和{n,m}点的字母一样那么 dp[0][1][n] 为1,否则为0.
其他点显然都为0
/************************************************************************* &amp;gt; File Name: code/cf/#316/EE.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月15日 星期六 04时10分13秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int MOD=1E9+7; const int N=5E2+7; int n,m; char st[N][N]; int dp[2][N][N]; int main() { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m); for ( int i = 1 ; i &amp;lt;= n ; i++) { scanf(&amp;quot;%s&amp;quot;,&amp;amp;st[i][1]); } // dp[0][1][n]= st[1][1]==st[n][m]; if (st[1][1]==st[n][m]) { dp[0][1][n]=1; } else { dp[0][1][n]=0; } int cur = 0; int mx = (m+n-2)/2; for ( int step = 1 ; step &amp;lt;= mx ; step++) { cur = cur ^ 1; for (int i = 1 ; i&amp;lt;= n ; i++) { for ( int j = 1 ; j &amp;lt;= n ; j++ ) { dp[cur][i][j] =0 ; } } for ( int x1 = 1 ; x1 &amp;lt;= n&amp;amp;&amp;amp;x1-1&amp;lt;=step ;x1++) { for ( int x2 = n ; x2&amp;gt;=1 &amp;amp;&amp;amp;n-x2&amp;lt;=step ;x2--) { int y1 = 1+step-(x1-1); int y2 = m-step+(n-x2); //由x1,x2 可以计算出y1,y2 if (st[x1][y1]==st[x2][y2]) { dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1][x2])%MOD; dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1][x2+1])%MOD; dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1-1][x2])%MOD; dp[cur][x1][x2] = (dp[cur][x1][x2] + dp[cur^1][x1-1][x2+1])%MOD; }//只有当前pic 相同的时候才转移 } } } int ans = 0; for ( int i = 1 ; i&amp;lt;= n ; i++ ) { ans = (ans + dp[cur][i][i]) % MOD; } if ((m+n)%2) { for ( int i = 1 ; i&amp;lt;= n-1 ; i++) { ans = (ans + dp[cur][i][i+1])%MOD; } } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>hdu 1160 FatMouse's Speed (最长上升子序列)</title><link>http://example.org/2015/04/hdu1160/</link><pubDate>Mon, 06 Apr 2015 16:36:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1160/</guid><description>FatMouse's Speed Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 10172 Accepted Submission(s): 4521
Special Judge
Problem Description
FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing.</description></item><item><title>hdu 1260 tickets</title><link>http://example.org/2015/04/hdu1260/</link><pubDate>Mon, 06 Apr 2015 16:23:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1260/</guid><description>Tickets **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 1408 Accepted Submission(s): 687
**
Problem Description
Jesus, what a great movie! Thousands of people are rushing to the cinema. However, this is really a tuff time for Joe who sells the film tickets. He is wandering when could he go back home as early as possible.
A good approach, reducing the total time of tickets selling, is let adjacent people buy tickets together.</description></item><item><title>hdu 1176 免费馅饼(二维dp)</title><link>http://example.org/2015/04/hdu1176/</link><pubDate>Sun, 05 Apr 2015 18:05:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1176/</guid><description>免费馅饼 **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 29065 Accepted Submission(s): 9921
**
Problem Description
都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：
为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）
Input
输入数据有多组。每组数据的第一行为以正整数n(0
Output
每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。
提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。
Sample Input
6
5 1
4 1
6 1
7 2
7 2
8 3
0
Sample Output
4
Author
lwg
二维dp
状态转移方程也很容易想到
dp[i][j]表示在时间i，位置J的时候能得到的馅饼的个数。
dp[i][j]是由dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]得到。
注意边界和初始化。
因为一开始是在位置5
所以 dp[1][4]=a[1][4];
　dp[1][5]=a[1][5];
　dp[1][6]=a[1][6];
但是取出最大的dp[i][j]的时候出了问题导致我一直WA，而且还没有想的很明白。。
AC代码：
/* *********************************************** Author :111qqz Created Time :2016年02月22日 星期一 23时18分21秒 File Name :code/hdu/1176.</description></item><item><title>hdu 1114 - Piggy-Bank (完全背包)</title><link>http://example.org/2015/04/hdu1114/</link><pubDate>Sun, 05 Apr 2015 15:14:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1114/</guid><description>F - Piggy-Bank
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig.</description></item><item><title>hdu 1087 - Super Jumping! Jumping! Jumping! (最长上升子序列)</title><link>http://example.org/2015/04/hdu1087/</link><pubDate>Sun, 05 Apr 2015 14:12:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1087/</guid><description>E - Super Jumping! Jumping! Jumping!
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Nowadays, a kind of chess game called &amp;ldquo;Super Jumping! Jumping! Jumping!&amp;rdquo; is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now.
The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or &amp;ldquo;start&amp;rdquo; or &amp;ldquo;end&amp;rdquo;.</description></item><item><title>hdu1069 Monkey and Banana (最长下降子序列)</title><link>http://example.org/2015/04/hdu1069/</link><pubDate>Sun, 05 Apr 2015 05:04:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1069/</guid><description>C - Monkey and Banana
**Time Limit:**1000MS **Memory Limit:**32768KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food.</description></item><item><title>hdu 1171 Big Event in HDU （母函数，01背包）</title><link>http://example.org/2015/04/hdu1171/</link><pubDate>Sat, 04 Apr 2015 14:56:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1171/</guid><description>**Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 26534 Accepted Submission(s): 9332 **
Problem Description
Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don't know that Computer College had ever been split into Computer College and Software College in 2002. The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too.</description></item><item><title>hdu 1203 I NEED A OFFER! （01背包）</title><link>http://example.org/2015/04/hdu1203/</link><pubDate>Sat, 04 Apr 2015 12:12:00 +0000</pubDate><guid>http://example.org/2015/04/hdu1203/</guid><description>I NEED A OFFER! **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 18287 Accepted Submission(s): 7320 **
Problem Description
Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。
Input
输入有若干组数据，每组数据的第一行有两个正整数n,m(0&amp;lt;=n&amp;lt;=10000,0&amp;lt;=m&amp;lt;=10000) 后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。 输入的最后有两个0。
Output
每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。
Sample Input
10 3 4 0.1 4 0.2 5 0.3 0 0
Sample Output
44.0%
Hint
You should use printf(&amp;quot;%%&amp;quot;) to print a &amp;lsquo;%'.
01背包
最开始WA在初始化，dp数组全都赋值为1，忘赋了dp[0]，导致如果恰好是花光所有钱得到答案的时候答案错误。
然后还一直WA。
后来发现是当N=0的时候，我直接取了所有A[I]=0对应的B[I]中最大的值。。。这显然是错的，少年你是脑抽吗。。。。。
然后修改了下，终于A掉了。。。。。
/* *********************************************** Author :111qqz Created Time :2016年02月22日 星期一 22时50分40秒 File Name :code/hdu/1203.</description></item><item><title>hdu 2546 饭卡 （01背包）</title><link>http://example.org/2015/04/hdu2546/</link><pubDate>Sat, 04 Apr 2015 08:53:00 +0000</pubDate><guid>http://example.org/2015/04/hdu2546/</guid><description>饭卡 **Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 14225 Accepted Submission(s): 4945
**
Problem Description
电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。
某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。
Input
多组数据。对于每组数据：
第一行为正整数n，表示菜的数量。n&amp;lt;=1000。
第二行包括n个正整数，表示每种菜的价格。价格不超过50。
第三行包括一个正整数m，表示卡上的余额。m&amp;lt;=1000。
n=0表示数据结束。
Output
对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。
Sample Input
1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0
Sample Output
-45 32
Source
UESTC 6th Programming Contest Online
在入门dp。
显然是01背包。 cost和value都是价钱。
但是有限制条件。
很容易想到，为了使得余额最少，我们要把最贵的留在最后买。
读入的时候把最贵的菜价拿出来
然后剩下的n-1个菜，做一个容量为m-5的01背包。
注意如果m&amp;lt;5,直接输出即可。
/* *********************************************** Author :111qqz Created Time :2016年02月22日 星期一 22时44分27秒 File Name :code/hdu/2546.</description></item><item><title>hdu 5119 - Happy Matt Friends（dp解法）</title><link>http://example.org/2015/02/hdu5119/</link><pubDate>Tue, 17 Feb 2015 09:04:00 +0000</pubDate><guid>http://example.org/2015/02/hdu5119/</guid><description>Description
Matt has N friends. They are playing a game together.
Each of Matt’s friends has a magic number. In the game, Matt selects some (could be zero) of his friends. If the xor (exclusive-or) sum of the selected friends’magic numbers is no less than M , Matt wins.
Matt wants to know the number of ways to win.
Input
The first line contains only one integer T , which indicates the number of test cases.</description></item></channel></rss>