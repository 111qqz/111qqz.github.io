<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>记忆化搜索 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link><description>Recent content in 记忆化搜索 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 27 Jul 2016 05:57:39 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 2018 母牛的故事 (基础dp，记忆化搜索)</title><link>https://111qqz.com/2016/07/hdu-2018/</link><pubDate>Wed, 27 Jul 2016 05:57:39 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-2018/</guid><description>
hdu2018题目链接
题意:第1年有1头奶牛，每年生一头奶牛，新生的奶牛从生下来的第四年（包括生下来那年）也开始每年一头奶牛。 问第n年有多少头奶牛。 思路：最容易想到的。。递推一下。。。dp[i] = dp[i-1] + dp[i-3] (注意初始化不是一个dp[1]=1,而是dp[1..4]=1..4)
递推代码：
/* *********************************************** Author :111qqz Created Time :2016年07月27日 星期三 13时19分17秒 File Name :code/hdu/2018.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first a#define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=60; int n; LL dp[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces edu1 D. Igor In the Museum</title><link>https://111qqz.com/2015/12/codeforces-edu1-d-igor-in-the-museum/</link><pubDate>Fri, 04 Dec 2015 08:29:50 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-edu1-d-igor-in-the-museum/</guid><description>
http://codeforces.com/contest/598/problem/D
题意：给第一个地图。 ‘.’是能走的，‘’是不能走的。**每个‘.’和''之间有一幅画，**给出k个起点，问对于每组起点，最多能观察到多少副画。
思路：dfs.要注意即使只有一个‘*’，从不同方向访问仍然算不同的画。这样就不用标记画是否访问过了。一开始直接暴力dfs..TLE 10
然后发现，如果是在同一个联通快内，能看到的画的最大值是确定的。。如果之前有同一个联通快内的其他点dfs过得到过答案，那么下次就不用再dfs了。。。记得把之前的记过保存下来。。
我具体的写法是把某一次dfs进过的点的恒纵坐标都存起来。。。然后dfs结束后把更新这些沿途中经过的点的答案。。结果还是TLE 10
果然是记忆化写残了。。也不是写残了。。看了几个别人的代码。。。记忆化存的时候是按照某一次来存答案。。而我是按照某个点的坐标。。来存答案。果然还是要提高姿势水平啊。。。SAD
/* *********************************************** Author :111qqz Created Time :2015年12月04日 星期五 15时08分22秒 File Name :code/cf/edu1/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+3; int n,m,k; char maze[N][N]; bool pic[N][N]; int v[N][N]; int ans[N*N]; int res; int cnt = 0 ; bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;n&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;m&amp;amp;&amp;amp;v[x][y]==-1) return true; return false; } int dfs ( int x,int y,int kk) { if (!</description></item></channel></rss>