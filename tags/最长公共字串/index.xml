<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最长公共字串 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E4%B8%B2/</link><description>Recent content in 最长公共字串 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 31 Jul 2016 18:18:04 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 3261 Milk Patterns (最长公共子串，后缀数组)</title><link>https://111qqz.com/2016/08/poj-3261/</link><pubDate>Sun, 31 Jul 2016 18:18:04 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3261/</guid><description>
poj3261
题意：给一个字符串，要求找出至少出现k次的最长重复子串...
思路：后缀数组，然后再次用到了根据height数组对后缀进行分组的套路...二分判定合法性，对于当前的最长长度x,分组使得每组中的height[i]都大于等于x,所不同的是，判定变成了存在一个组，后缀的个数至少为k个（因为这样，就可以对于大于等于k个的后缀，同时取前x长度，得到的就是出现了至少k次且长度为x的前缀）1A,蛤蛤蛤
/* *********************************************** Author :111qqz Created Time :2016年08月01日 星期一 01时30分34秒 File Name :code/poj/3261.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; const int M=2E6+11; const int C = 5; int n,sa[N],rk[N],t[N],t2[N],cnt[M]; int height[N]; int s[N]; int k; int cmp(int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0; for ( int i = n-k ; i &amp;lt; n; i++) y[p++] = i ; for ( int i = 0 ; i &amp;lt; n; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt;n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt;m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 1743 Musical Theme (不可重叠最长重复子串，后缀数组)</title><link>https://111qqz.com/2016/08/poj-1743-musical-theme-/</link><pubDate>Sun, 31 Jul 2016 16:38:25 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-1743-musical-theme-/</guid><description>
poj 1743
题意：n个数字（1..88）表示的音符，问最长的连续两段长度至少为5的变化相同的音符段的长度。。。
思路：求最长重复字串。。。。很容易想到后缀数组。。但是这道题多了一个不可重叠的要求。
先二分答案,把题目变成判定性问题:判断是否 存在两个长度为 k 的子串是相同的,且不重叠。解决这个问题的关键还是利用 height 数组。把排序后的后缀分成若干组,其中每组的后缀之间的 height 值都 不小于 k。例如,字符串为“aabaaaab”,当 k=2 时,后缀分成了 4 组,如图 5 所示。
容易看出,有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然 后对于每组后缀,只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于 k。如果有一组满足,则说明存在,否则不存在。整个做法的时间复杂度为 O(nlogn)。**本题中利用 height 值对后缀进行分组的方法很常用,**请读者认真体 会。 这是论文中的题目。这个做法的确想不到，不过很好理解。
如果没有不允许重叠的条件就变成了求所有height[i]中的最大值，而每个height[i]对应的两个后缀的位置是sa[i]和sa[i-1]。
分组使得每组中的height[i]都大于等于k(那height[i]小于k的去哪里了？ 因为height[i]是由两个相邻的后缀得到的，如果某两个后缀的height[i]小于k,只需要将这两个后缀分成两组，这样这个height[i]就不存在了，从而保证了每组中的height[i]都大于等于k)
而我们知道，任意两个后缀的最长公共前缀是他们之间的所有height的最小值。因为对于处于同一组内的两个后缀来说，由于之前保证了每组中的height[i]&amp;gt;=k,也就是保证了任意两个后缀的最长公共前缀大于等于k.
因此用二分判定长度k的时候，这样分组以后，只需要再判断是否相交（也就是如果长度k不满足，可能是因为没有办法分组使得每个height都大于等于k,也可能是存在这样的分组，但是两个后缀相交）。
判断相交其实非常简单，sa[i]表示的是排名第i的后缀的开始位置，那么如果存在sa[j]-sa[i]&amp;gt;=k（其实是sa[i]+k-1&amp;lt;sa[j],sa[i]位置开始的后缀的长度为k的前缀的最后一个字符的所在位置sa[i]+k-1比sa[j]小，就说明不相交，由于是整数，就可以变成sa[i]+k&amp;lt;=sa[j]，也就是sa[j]-sa[i]&amp;gt;-=k）
而某一组内只要有一组i,j，满足sa[j]-sa[i]&amp;gt;=k就是有解，因此我们只需要判断最可能符合条件的一组，也就是找到一组中sa[i]的最大值和最小值，也正因为我们这样，我们在具体实现的过程中也没必要真的模拟分组的过程，只需要一直更新两个极值即可。
以及：lrj的板子是错的！！会re!!!! 已改正。
其他细节见代码注释
/* *********************************************** Author :111qqz Created Time :2016年07月31日 星期日 18时23分53秒 File Name :code/poj/1743.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; const int C=100; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r ,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} int a[N]; void getSa( int n,int m) { int *x = t; int *y = t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=a[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n-k ; i &amp;lt; n ; i++) y[p++] = i ; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i] +=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n; i ++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>ural 1517. Freedom of Choice (后缀数组，最长公共子串)</title><link>https://111qqz.com/2016/07/ural1517/</link><pubDate>Sat, 30 Jul 2016 17:18:19 +0000</pubDate><guid>https://111qqz.com/2016/07/ural1517/</guid><description>
ural1517 题意：给出两个字符串，求最长的公共字串（要求出具体的字符串是什么）
思路：依然是后缀数组，在更新长度 的时候记录起始位置即可，1A。以及，发现多开了一个完全没有必要的数组w[],这次已删。
20160730update:模板已更正，lrj的模板的rk[i]为0 的时候会出现re的问题...已特判。
/* *********************************************** Author :111qqz Created Time :2016年07月31日 星期日 00时36分19秒 File Name :code/ural/1517.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char s[N]; int n,sa[N],rk[N],t[N],t2[N],cnt[N]; int height[N]; int cmp(int *r,int a,int b,int l) {return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l];} void getSa(int n,int m) { int *x = t,*y= t2; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n ; i++) cnt[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k&amp;lt;&amp;lt;=1) { int p = 0 ; for ( int i = n - k ; i &amp;lt; n ; i++) y[p++] = i; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; ms(cnt,0); for ( int i = 0 ; i &amp;lt; n; i++) cnt[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) cnt[i]+=cnt[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--cnt[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>poj 2774 Long Long Message (最长公共字串，后缀数组模板题)</title><link>https://111qqz.com/2016/07/poj-2774/</link><pubDate>Sat, 30 Jul 2016 16:02:42 +0000</pubDate><guid>https://111qqz.com/2016/07/poj-2774/</guid><description>
poj2774
题意：给出两个字符串，问最长的公共连续字串。
思路：后缀数组模板题。
具体可以参考两篇国集论文（09，04） topcoder中的讲解 codechef上的讲解 还有一篇讲 dc3算法的论文：SuffixArrays_dc3 这里不谈具体的后缀数组的学习内容，说说大概的学习过程。
首先要理解**后缀，后缀数组（sa[]），名次数组(rk[])，height数组，lcp **这些概念
先从定义入手，得到sa数组的n2logn的求法...
由于复杂度爆炸，所以有了两个算法来优化求sa的过程，一个是nlogn的倍增，还有一个是O(n)的dc3。。。
倍增的算法中用到了radix sort
上面这些，都是在说如何求sa,但是如果只有sa一个数组的话，就没有办法很好感受 后缀数组的power.
于是引入了height数组。
**定义 height[i]=suffix(sa[i-1])和 suffix(sa[i])的最长公** **共前缀,也就是排名相邻的两个后缀的最长公共前缀。那么对于 j 和 k,不妨设** **rank[j]有很多问题都是基于height数组的，慢慢感受。
再说这道题：我们可以把两个字符串中间用一个特殊符号连接起来。
那么两个字符串的最长公共字串，就变成了求合并后的字符串的所有后缀的最长公共前缀。（原因是字符串的任何一个字串都可以看成是该字符串的某个后缀的前缀）
那么容易知道，该最长公共前缀的长度一定是某个height值（原因是，height[i]表示的是排名相邻的两个后缀的最长公共前缀的长度，如果不相邻，那么取的是他们排名之间所有height的最小值，只会越来越小。）
还需要注意的是，必须满足得到该height的两个后缀分别出现在原来的两个字符串中...
要怎么办到呢？ 其实很容易，由于sa[i]数组存放的是排名第i的后缀是后缀几(定义从第x个字符开始的后缀就是后缀x)
设初始第一个字符串的长度为len1,那么如果是第一个字符串的后缀，一定有sa[i]&amp;lt;len1,如果是第二个字符串的后缀，就一定有sa[i]&amp;gt;len1 (sa[i]==len1的是插入的特殊符号开始的后缀)
还有一些细节可以参考代码注释
UD20160730:改正了lrj书中的错误。。对于rk[i]==0的情况进行了特判。。不然会re...
/* *********************************************** Author :111qqz Created Time :2016年07月30日 星期六 20时58分10秒 File Name :code/poj/2774.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char s[N]; int sa[N],t[N],t2[N],cnt[N],n; int c[N]; int w[N]; int rk[N],height[N]; int cmp( int *r,int a,int b,int l){ return r[a]==r[b]&amp;amp;&amp;amp;r[a+l]==r[b+l] ;}; void build_sa(int n,int m) //其实我觉得。。。sa怎么得到的不用管。。这部分讲道理不会变。。。反正知道能nlogn得到sa就对了2333 { int *x=t,*y=t2; // 基数排序（不是计数排序！） radix sort.</description></item></channel></rss>