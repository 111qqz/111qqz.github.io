<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>梯度下降 on 111qqz的小窝</title><link>http://example.org/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</link><description>Recent content in 梯度下降 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 10 Jul 2017 01:49:04 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/index.xml" rel="self" type="application/rss+xml"/><item><title>几种梯度下降(GD)法的比较（转载）</title><link>http://example.org/2017/07/Gradient-descent-methods/</link><pubDate>Mon, 10 Jul 2017 01:49:04 +0000</pubDate><guid>http://example.org/2017/07/Gradient-descent-methods/</guid><description>参考资料
机器学习中梯度下降（Gradient Descent， GD）算法只需要计算损失函数的一阶导数，计算代价小，非常适合训练数据非常大的应用。
梯度下降法的物理意义很好理解，就是沿着当前点的梯度方向进行线搜索，找到下一个迭代点。但是，为什么有会派生出 batch、mini-batch、online这些GD算法呢？
原来，batch、mini-batch、SGD、online的区别在于训练数据的选择上：
1. batch GD
每次迭代的梯度方向计算由所有训练样本共同投票决定，
batch GD的损失函数是：
J(θ)=12m∑i=1m(hθ(x(i))−y(i))2J(θ)=12m∑i=1m(hθ(x(i))−y(i))2
训练算法为：
repeate{θ:=θ−α1m∑i=1m(hθ(x(i))−y(i))x(i)j}repeate{θ:=θ−α1m∑i=1m(hθ(x(i))−y(i))xj(i)}
什么意思呢，batch GD算法是计算损失函数在整个训练集上的梯度方向，沿着该方向搜寻下一个迭代点。”batch“的含义是训练集中所有样本参与每一轮迭代。
2. mini-batch GD
batch GD每一轮迭代需要所有样本参与，对于大规模的机器学习应用，经常有billion级别的训练集，计算复杂度非常高。因此，有学者就提出，反正训练集只是数据分布的一个采样集合，我们能不能在每次迭代只利用部分训练集样本呢？这就是mini-batch算法。
假设训练集有m个样本，每个mini-batch（训练集的一个子集）有b个样本，那么，整个训练集可以分成m/b个mini-batch。我们用ωω表示一个mini-batch, 用ΩjΩj表示第j轮迭代中所有mini-batch集合，有：
Ω={ωk:k=1,2&amp;hellip;m/b}Ω={ωk:k=1,2&amp;hellip;m/b}
那么， mini-batch GD算法流程如下：
repeate{repeate{foreachωkinΩ:θ:=θ−α1b∑i=1b(hθ(x(i))−y(i))x(i)}for(k=1,2&amp;hellip;m/b)}repeate{repeate{foreachωkinΩ:θ:=θ−α1b∑i=1b(hθ(x(i))−y(i))x(i)}for(k=1,2&amp;hellip;m/b)}
3. Stochastic GD （SGD）
随机梯度下降算法（SGD）是mini-batch GD的一个特殊应用。SGD等价于b=1的mini-batch GD。即，每个mini-batch中只有一个训练样本。
4. Online GD
随着互联网行业的蓬勃发展，数据变得越来越“廉价”。很多应用有实时的，不间断的训练数据产生。在线学习（Online Learning）算法就是充分利用实时数据的一个训练算法。
Online GD于mini-batch GD/SGD的区别在于，所有训练数据只用一次，然后丢弃。这样做的好处是可以最终模型的变化趋势。比如搜索广告的点击率(CTR)预估模型，网民的点击行为会随着时间改变。用batch算法（每天更新一次）一方面耗时较长（需要对所有历史数据重新训练）；另一方面，无法及时反馈用户的点击行为迁移。而Online Leaning的算法可以实时的最终网民的点击行为迁移。</description></item></channel></rss>