<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on 111qqz的小窝</title><link>http://example.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 01 Sep 2018 09:27:40 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>[设计模式] 观察者( Observer )模式学习笔记</title><link>http://example.org/2018/09/observer-pattern-notes/</link><pubDate>Sat, 01 Sep 2018 09:27:40 +0000</pubDate><guid>http://example.org/2018/09/observer-pattern-notes/</guid><description>最近在学习node.js，里面讲到node.js的事件机制使用了观察者模式，因此来学习一下。
观察者模式的目的是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
因此观察者模式又叫发布-订阅模式。
下面放一个简化之后的例子:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Secretary; // 看股票的同事类（观察对象，观察者） class StockObserver { public: StockObserver(string strName, Secretary* strSub) { name = strName; sub = strSub; } void Update(); private: string name; Secretary* sub;我所理解的设计模式（C++实现）——观察者模式（Observer Pattern） }; // 秘书类（主题对象，通知者） class Secretary { public: string action; void Add(StockObserver ob) { observers.push_back(ob); } void Remove(int addIndex) { if(addIndex &amp;gt;=0 &amp;amp;&amp;amp; addIndex &amp;lt; observers.size()) observers.erase(observers.begin() + addIndex); } void Notify() { vector&amp;lt;StockObserver&amp;gt;::iterator it; for (it=observers.</description></item><item><title>[设计模式] 组合模式（composite） 学习笔记</title><link>http://example.org/2018/08/Composite-Pattern-notes/</link><pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate><guid>http://example.org/2018/08/Composite-Pattern-notes/</guid><description>目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个tree 。如果某个节点是叶子节点了，那么对应的tree都为NULL. 只不过这里用了更加面向对象的实现。
具体看代码：
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月28日 星期二 14时21分51秒 File Name :composite.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Component { // 为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为 protected: string name; public: Component(string n) { name = n; } virtual ~Component() {} virtual void Add(Component* c) = 0; virtual void Remove(Component* c) = 0; virtual void Display(int depth) = 0; }; class Leaf : public Component { // 在组合中表示叶节点对象，叶节点没有子节点 public: Leaf(string name) : Component(name) {} void Add(Component* c){} // 叶节点没有Add功能，但这样做能使接口具备一致性，这就是透明方式，如果不加入Add和Remove方法，那就是安全方式。 void Remove(Component* c){} // 同上 void Display(int depth) { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; endl; } }; class Composite : public Component { // 定义有枝节点行为，用来存储子部件 private: list&amp;lt;Component* &amp;gt; children; public: Composite(string name) : Component(name) {} void Add(Component* c) { children.</description></item></channel></rss>