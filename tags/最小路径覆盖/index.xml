<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最小路径覆盖 on 111qqz的小窝</title><link>http://example.org/tags/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/</link><description>Recent content in 最小路径覆盖 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 26 May 2016 13:02:47 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 1422 Air Raid (DAG的最小路径覆盖，匈牙利算法)</title><link>http://example.org/2016/05/poj-1422/</link><pubDate>Thu, 26 May 2016 13:02:47 +0000</pubDate><guid>http://example.org/2016/05/poj-1422/</guid><description>poj 1422题目链接
题意+思路：DAG的最小路径覆盖。。。匈牙利算法。。。poj 2594的低配版。。
/* *********************************************** Author :111qqz Created Time :2016年05月26日 星期四 20时24分15秒 File Name :code/poj/r2594.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m; bool conc[N][N]; bool vis[N]; int link[N]; void floyd() { for ( int k = 1 ; k &amp;lt;= n ; k++) for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) if (conc[i][k]&amp;amp;&amp;amp;conc[k][j]) conc[i][j] = true; } bool dfs( int u) { for ( int i = 1 ; i &amp;lt;= n ; i++) { if (conc[u][i]) { if (vis[i]) continue; vis[i] = true; if (link[i]==-1||dfs(link[i])) { link[i] = u; return true; } } } return false; } int hungary() { int res = 0 ; ms(link,-1); for ( int i = 1 ; i &amp;lt;= n ; i++) { ms(vis,false); if (dfs(i)) res++; } return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2594 Treasure Exploration (DAG图最小路径覆盖变形，匈牙利算法+floyd求传递闭包)</title><link>http://example.org/2016/05/poj-2594/</link><pubDate>Thu, 26 May 2016 12:43:12 +0000</pubDate><guid>http://example.org/2016/05/poj-2594/</guid><description>poj 2594 题目链接
题意：一个DAG图，每个点有宝藏&amp;hellip;可以降落任意个机器人到任意点&amp;hellip;然后机器人可以沿着路径走，路过某个点的时候，可以取走该点的宝藏。问要取走所有宝藏，最少需要多少个机器人。
思路：乍一看。。很像DAG图的最小路径覆盖。。但是最小路径覆盖是要求每个点只能经过一次的。。而这道题路过某个点的时候，可以不取走宝藏。。以及题面里明确说了“you should notice that the roads of two different robots may contain some same point. ”
那是否还可以用最小路径覆盖做呢。。答案是可以的。。。
区别就在于一个点如果被一条路径使用过一次，还可不可以使用第二次。。。
如果我们按照传统的DAG图的最小路径覆盖考虑。。。如果一个点会被路径经过两次。。。那么我们不妨增加一个点。。。 进一步考虑。。。我们要的是尽可能覆盖所有点。。。如果这条路径前后的点不会因为这个点而中断，那么这个增设点是否存在，其实是无所谓的，只要改点前后的点连通性不受影响即可。 说到连通性，不禁想到floyd求传递闭包。
然后对于DAG图的最小路径覆盖问题。。。就可以用hungary算法求解。。。
ans = n - 最大匹配数。
这应该算作hungary的一个应用。</description></item></channel></rss>