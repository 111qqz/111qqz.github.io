<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dijkstra on 111qqz's blog</title><link>https://111qqz.com/tags/dijkstra/</link><description>Recent content in dijkstra on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 14 Jul 2016 17:25:24 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/dijkstra/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3873 Invade the Mars (有限制条件的最短路。。)</title><link>https://111qqz.com/2016/07/hdu-3873/</link><pubDate>Thu, 14 Jul 2016 17:25:24 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-3873/</guid><description>
hdu3873题目链接
题意：n个点的图。。。每个点可能被若干其他点保护。。。被保护的意思是。。。如果想访问某个点。。那么必须先访问保护该点的所有点。。。问从点1到点n的最小代价。。
思路：。。一开始写了spfa。。。然后一脸懵逼。。。因为我第一次访问某个点的时候无法保证距离是最短的。。。所以还是上dij吧。。。
然后dij写得比较少。。。不是很熟练。。参考了这篇题解参考题解
思路倒是不难想，我在写spfa的时候也是这样想法，然后试图记录路径递归来搞。。。。。然而并不可以2333
也是第一次遇到带限制条件的最短路。。。还是多积累吧。。。
哦对了。。。权值比较大。。。要记得开long long
/* *********************************************** Author :111qqz Created Time :2016年07月15日 星期五 00时32分14秒 File Name :code/hdu/3873.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; long long ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E3+7; const int M=7E4+7; int n,m; int cnt; int head[N]; int in[N]; //in[i]表示点i被几个点保护。。。 vector &amp;lt;int&amp;gt;prec[N]; LL d[N]; bool vis[N]; LL maxt[N]; struct Edge { int v; LL w; int nxt; }edge[M]; void init() { ms(head,-1); ms(in,0); cnt = 0 ; for ( int i = 1 ; i &amp;lt;= n ; i++) prec[i].</description></item><item><title>codeforces 567 E President and Roads (优先队列＋迪杰斯特拉＋tarjan)</title><link>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</link><pubDate>Sun, 16 Aug 2015 19:26:00 +0000</pubDate><guid>https://111qqz.com/2015/08/codeforces567epresidentandroadstarjan/</guid><description>
题意是说，给定一个有向图，对于每一条边，问是否是s到t的最短路上一定会经过的边．
如果是就输出yes
如果不是，问能否通过减少这条边的权值（减少的权值就是修理费用），使得这条边成为新的最短路上的边．
对于一条边是否一定是最短路上的边，我们可以从s做一遍最短路，然后反响建边，从t再做一遍最短路．
得到两个d1,d2数组
如果一条边d1[u] + d2[v] + w(u, v) = 最短路，那这条边在最短路上的边．但是未必不能缺少．
我们还要判断这条边是否是不能缺少的．
不能缺少的意思是说，如果没有这条边，就不能构成最短路．
那么这条边一定是桥．
我们可以用tarjan算法求桥．
据说是水题，不过图论还没怎么刷，所以对我来说还是很有难度的．
只是基本懂了
下面的代码是我仿照其他人的代码写出来的....求不鄙视　＞＜
/************************************************************************* &amp;gt; File Name: code/cf/#314/E.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月17日 星期一 03时09分39秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef pair&amp;lt;LL,LL&amp;gt; P; const int maxn = 200005; const LL mod1 = 1e9 + 7; const LL mod2 = 99999991; const LL inf = 1e15; struct Nod{ LL b,val,next,idx; void init(LL b,LL val,LL next,LL idx){ this-&amp;gt;b=b;this-&amp;gt;val=val;this-&amp;gt;next=next;this-&amp;gt;idx=idx; } }buf[2][maxn]; LL len[2],E[2][maxn]; LL n,m,s,t; LL dis[2][maxn],cnt[2][2][maxn],ans1[maxn],ans2[maxn]; priority_queue&amp;lt;P,vector&amp;lt;P&amp;gt;,greater&amp;lt;P&amp;gt; &amp;gt; q; void init() { memset(E,-1,sizeof(E)); memset(cnt,0,sizeof(cnt)); len[0] = len[1] = 0; } void add_edge(LL a,LL b,LL val,LL idx) { buf[0][len[0]].</description></item></channel></rss>