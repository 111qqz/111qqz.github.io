<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前端 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%89%8D%E7%AB%AF/</link><description>Recent content in 前端 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 18 Sep 2018 13:31:06 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>react 中setState的更新策略</title><link>https://111qqz.com/2018/09/react-setstate-Update-strategy/</link><pubDate>Tue, 18 Sep 2018 13:31:06 +0000</pubDate><guid>https://111qqz.com/2018/09/react-setstate-Update-strategy/</guid><description>
&lt;p>起因是想更新一个array类型的state,结果setState更新之后用console.log() debug 结果，发现结果特别玄学。。。&lt;/p>
&lt;p>查了下发现this.setState是个异步操作。。。&lt;/p></description></item><item><title>前端To do list</title><link>https://111qqz.com/2018/09/front-end-to-do-list/</link><pubDate>Thu, 06 Sep 2018 09:56:57 +0000</pubDate><guid>https://111qqz.com/2018/09/front-end-to-do-list/</guid><description>
&lt;p>20181014update: 可以不写了，开心&lt;/p>
&lt;p>迫于生计，要从零开始学习前端。&lt;/p>
&lt;p>由于之前的to do list 年代久远+ 前端的技术栈可之前几乎没有关系，因此新开一篇记录。&lt;/p>
&lt;pre>&lt;code> * css盒子模型
* 布局,flex
* 前端debug的方法
* &amp;lt;del&amp;gt;javascript,&amp;lt;/del&amp;gt;有空可以使用js刷leetcode练习语法
* &amp;lt;del&amp;gt;typescript&amp;lt;/del&amp;gt;
* jsx，以及jsx的typescript版tsx
* 学习axios https://alligator.io/react/axios-react/
* 学习dva: https://github.com/sorrycc/blog/issues/62
* 学习umijs https://umijs.org/zh/guide/with-dva.html#
&lt;/code>&lt;/pre></description></item><item><title>typescript学习笔记</title><link>https://111qqz.com/2018/09/typescript-notes/</link><pubDate>Wed, 05 Sep 2018 08:02:42 +0000</pubDate><guid>https://111qqz.com/2018/09/typescript-notes/</guid><description>
&lt;p>先放参考资料:&lt;/p>
&lt;p>&lt;a href="https://ts.xcatliu.com/">TypeScript 入门教程&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.typescriptlang.org/docs/handbook/react-&amp;amp;-webpack.html">React &amp;amp; Webpack&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/sw-yx/react-typescript-cheatsheet/blob/master/README.md">react-typescript-cheatsheet &lt;/a>(强推一波，讲了很多react+ts的实践）&lt;/p>
&lt;p>typescript是javascript的语法扩展。。。好处是提供了类型。。可以在编译（结果为js文件)的时候提供静态的类型检查。。。&lt;/p></description></item><item><title>Redux 学习笔记</title><link>https://111qqz.com/2018/08/redux-notes/</link><pubDate>Thu, 30 Aug 2018 12:05:35 +0000</pubDate><guid>https://111qqz.com/2018/08/redux-notes/</guid><description>
&lt;p>Redux是Flux架构的一种实现。&lt;/p>
&lt;p>至于Flux架构是什么，可以参考&lt;a href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程&lt;/a>&lt;/p>
&lt;p>粗略得讲，和MVC架构是同一类东西，最大的区别是单向数据流，禁止了Model和VIEW层之间数据的流动。
&lt;img class="image_figure image_external" loading="lazy" src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png" alt="" />
&lt;/p></description></item><item><title>JavaScript 学习笔记</title><link>https://111qqz.com/2018/08/javascript-notes/</link><pubDate>Thu, 30 Aug 2018 03:42:19 +0000</pubDate><guid>https://111qqz.com/2018/08/javascript-notes/</guid><description>
&lt;p>&lt;del>暂时没空从头开始搞&amp;hellip;用到哪里先记录一下好了orz&lt;/del>&lt;/p>
&lt;p>我觉得不行，还是要先大致了解一下。&lt;/p>
&lt;p>参考资料:&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">A re-introduction to JavaScript (JS tutorial)&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链&lt;/a>&lt;/p>
&lt;pre>&lt;code>// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：
// {a: 1, b: 2}
// o 的 [[Prototype]] 有属性 b 和 c：
// {b: 3, c: 4}
// 最后, o.[[Prototype]].[[Prototype]] 是 null.
// 这就是原型链的末尾，即 null，
// 根据定义，null 没有[[Prototype]].
// 综上，整个原型链如下:
// {a:1, b:2} ---&amp;gt; {b:3, c:4} ---&amp;gt; null
console.log(o.a); // 1
// a是o的自身属性吗？是的，该属性的值为1
console.log(o.b); // 2
// b是o的自身属性吗？是的，该属性的值为2
// 原型上也有一个'b'属性,但是它不会被访问到.这种情况称为&amp;quot;属性遮蔽 (property shadowing)&amp;quot;
console.log(o.c); // 4
// c是o的自身属性吗？不是，那看看原型上有没有
// c是o.[[Prototype]]的属性吗？是的，该属性的值为4
console.log(o.d); // undefined
// d是o的自身属性吗？不是,那看看原型上有没有
// d是o.[[Prototype]]的属性吗？不是，那看看它的原型上有没有
// o.[[Prototype]].[[Prototype]] 为 null，停止搜索
// 没有d属性，返回undefined
hasOwnProperty方法,用来检查对象是否有自己定义的属性，而不是从原型链上继承的属性。
该方法不需要遍历原型链。
function Graph() {
this.vertices = [];
this.edges = [];
}
Graph.prototype = {
addVertex: function(v){
this.vertices.push(v);
}
};
console.log(g.hasOwnProperty('vertices'));
// true
console.log(g.hasOwnProperty('nope'));
// false
console.log(g.hasOwnProperty('addVertex'));
// false
console.log(g.__proto__.hasOwnProperty('addVertex'));
// true
var g = new Graph();
// g是生成的对象,他的自身属性有'vertices'和'edges'.
// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) =&amp;gt; accumulator + currentValue;
// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));
// expected output: 10
// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));
// expected output: 15
const object1 = {
a: 1,
b: 2,
c: 3,
a: 4
};
const object2 = Object.assign({a: 14, d: 5,h:12}, object1);
console.log(object2.a, object2.d,object2.h);
// expected output: 1 5 12
// Properties in the target object will be overwritten by properties in the sources if they have the same key.
//Later sources' properties will similarly overwrite earlier ones.
function multiply(multiplier, ...theArgs) {
return theArgs.map(function (element) {
return multiplier * element;
});
}
var arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
function parentFunc() {
var a = 1;
function nestedFunc() {
var b = 4; // parentFunc can't use this
return a + b;
}
return nestedFunc(); // 5
}
(参数1, 参数2, …, 参数N) =&amp;gt; { 函数声明 }
(参数1, 参数2, …, 参数N) =&amp;gt; 表达式（单一）
//相当于：(参数1, 参数2, …, 参数N) =&amp;gt;{ return 表达式; }
// 当只有一个参数时，圆括号是可选的：
(单一参数) =&amp;gt; {函数声明}
单一参数 =&amp;gt; {函数声明}
// 没有参数的函数应该写成一对圆括号。
() =&amp;gt; {函数声明}
var materials = [
'Hydrogen',
'Helium',
'Lithium',
'Beryllium'
];
materials.map(function(material) {
return material.length;
}); // [8, 6, 7, 9]
materials.map((material) =&amp;gt; {
return material.length;
}); // [8, 6, 7, 9]
materials.map(material =&amp;gt; material.length); // [8, 6, 7, 9]
class ChildClass extends ParentClass { ... }
&lt;/code>&lt;/pre></description></item><item><title>react学习笔记</title><link>https://111qqz.com/2018/08/react-notes/</link><pubDate>Tue, 28 Aug 2018 10:16:16 +0000</pubDate><guid>https://111qqz.com/2018/08/react-notes/</guid><description>
&lt;p>首先介绍一个fb家的快速开发react的工具 &lt;a href="https://github.com/facebook/create-react-app">create-react-app&lt;/a>&lt;/p>
&lt;p>这个东西依赖node6.0或者更高版本。&lt;/p>
&lt;p>关于在ubuntu 14.04上安装node ，可以参考&lt;a href="https://www.hostingadvice.com/how-to/install-nodejs-ubuntu-14-04/#node-version-manager">这个链接&lt;/a>&lt;/p>
&lt;p>发现执行nvm install 6.0会没有任何相应&amp;hellip;但是实际上已经安装好了。&lt;/p></description></item></channel></rss>