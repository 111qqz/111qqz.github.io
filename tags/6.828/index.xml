<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>6.828 on 111qqz的小窝</title><link>https://111qqz.com/tags/6.828/</link><description>Recent content in 6.828 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 03 Mar 2019 12:45:25 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/6.828/index.xml" rel="self" type="application/rss+xml"/><item><title>【施工中】MIT 6.828 lab 3: User Environments</title><link>https://111qqz.com/2019/03/mit-6-828-lab-3-user-environments/</link><pubDate>Sun, 03 Mar 2019 12:45:25 +0000</pubDate><guid>https://111qqz.com/2019/03/mit-6-828-lab-3-user-environments/</guid><description>
JOS的environments基本可以理解成&amp;quot;process&amp;quot;进程的同义词，但是由于&amp;quot;process&amp;quot;是一个unix术语，因此使用environment这个词．
Part A: User Environments and Exception Handling 查看　kern/env.c文件，看到三个全局变量:
1 struct Env *envs = NULL; // All environments 2 struct Env *curenv = NULL; // The current env 3 static struct Env *env_free_list; // Free environment list envs会在JOS启动后会指向一个Env structures的数组，表示JOS中的全部environments. 理论上，JOS kernel最多能支持NENV个同时运行的environments.　但是实际上不会远不会达到这个数量．
env_free_list是一个链表结构，用来存放当前没有在运行的Env structure.. 和page_free_list　类似．
curenv表示的是当前正在运行的environment,当JOS刚刚启动，第一个environment运行之前，curenv的值为NULL.
接下来我们来阅读一下inc/env.h文件
1 2 /* See COPYRIGHT for copyright information. */ 3 4 #ifndef JOS_INC_ENV_H 5 #define JOS_INC_ENV_H 6 7 #include &amp;lt;inc/types.h&amp;gt;8 #include &amp;lt;inc/trap.</description></item><item><title>【施工完毕】MIT 6.828 lab 2: Memory Management</title><link>https://111qqz.com/2019/02/mit-6-828-lab-2/</link><pubDate>Thu, 14 Feb 2019 14:01:46 +0000</pubDate><guid>https://111qqz.com/2019/02/mit-6-828-lab-2/</guid><description>
2019年2月24:完成了除了&amp;quot;Challenge&amp;quot;以外的全部练习和问题. 总共花费15个小时. 2019年2月26:完成&amp;quot;Challenge 2&amp;quot;(应该是最简单的一个orz，只花了不到一个小时) Part 1: Physical Page Management 操作系统必须时刻追踪哪些物理内存在使用，哪些物理内存没有在使用。
一个问题是，
Ex 1. In the file kern/pmap.c, you must implement code for the following functions (probably in the order given). boot_alloc() mem_init() (only up to the call to check_page_free_list(1)) page_init() page_alloc() page_free()
check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.</description></item><item><title>【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping</title><link>https://111qqz.com/2019/01/mit-6-828-lab-1/</link><pubDate>Thu, 24 Jan 2019 12:27:58 +0000</pubDate><guid>https://111qqz.com/2019/01/mit-6-828-lab-1/</guid><description>
花费了30+小时，终于搞定了orz Part 1: PC Bootstrap The PC's Physical Address Space 8086/8088时代 +------------------+ &amp;lt;- 0x00100000 (1MB) | BIOS ROM | +------------------+ &amp;lt;- 0x000F0000 (960KB) | 16-bit devices, | | expansion ROMs | +------------------+ &amp;lt;- 0x000C0000 (768KB) | VGA Display | +------------------+ &amp;lt;- 0x000A0000 (640KB) | | | Low Memory | | | +------------------+ &amp;lt;- 0x00000000 由于8086/8088只有20跟地址线，因此物理内存空间就是2^20=1MB.地址空间从0x00000到0xFFFFF.其中从0x00000开始的640k空间被称为&amp;quot;low memory&amp;quot;，是PC真正能使用的RAM。从 0xA0000 到 0xFFFFF　的384k的non-volatile memory被硬件保留，用作video display buffers和BIOS等。
80286/80386时代及以后 为了保持向后兼容，因此0-1MB的空间还是和原来保持一致。因此地址空间似乎存在一个“洞”（为什么我觉得其实是两个“洞”。。。不是空着的才叫“洞”吗），PC能使用的RAM被这个“洞”（也就是0xA0000 到 0xFFFFF)分成了0x00000000到0x000BFFFF的640k和 0x00100000到0xFFFFFFFF两部分。
+------------------+ &amp;lt;- 0xFFFFFFFF (4GB) | 32-bit | | memory mapped | | devices | | | /\/\/\/\/\/\/\/\/\/\ /\/\/\/\/\/\/\/\/\/\ | | | Unused | | | +------------------+ &amp;lt;- depends on amount of RAM | | | | | Extended Memory | | | | | +------------------+ &amp;lt;- 0x00100000 (1MB) | BIOS ROM | +------------------+ &amp;lt;- 0x000F0000 (960KB) | 16-bit devices, | | expansion ROMs | +------------------+ &amp;lt;- 0x000C0000 (768KB) | VGA Display | +------------------+ &amp;lt;- 0x000A0000 (640KB) | | | Low Memory | | | +------------------+ &amp;lt;- 0x00000000 此外，在地址空间的最上面一部分，通常被BIOS保留用于 32-bit PCI devices的memory mapped.</description></item><item><title>【施工中】MIT 6.828 Operating System Engineering 学习笔记</title><link>https://111qqz.com/2019/01/mit-6-828-overview/</link><pubDate>Tue, 15 Jan 2019 16:39:18 +0000</pubDate><guid>https://111qqz.com/2019/01/mit-6-828-overview/</guid><description>
课程主页
这课稍微有点硬核...感觉基础稍微有些不扎实就做不下去orz.
网上似乎是有博客写了6.828的学习笔记，不过我更希望自己能够独立完成，二手的知识，谁知道是对的错的呢...况且课程本身给的参考资料应该还是足够多的。
环境的话，手头没有ubuntu系统，恰好半年前剁了阿里云的轻应用服务器，就在上面做吧。
为了这门课，我读了/计划读以下书籍（随时更新）。大概也是为了检查一遍自己的知识体系。
* [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/) 已读完，大概需要120小时 * [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf) 6.828给的汇编参考书籍 每个lab用到的网页形式的参考资料，会在每个lab的博客中分别给出。
最后，放一段《游褒禅山记》中的文字，与君共勉！
夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？</description></item></channel></rss>