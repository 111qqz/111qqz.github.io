<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hash map on 111qqz的小窝</title><link>http://example.org/tags/hash-map/</link><description>Recent content in hash map on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 21 Aug 2021 17:43:02 +0800</lastBuildDate><atom:link href="http://example.org/tags/hash-map/index.xml" rel="self" type="application/rss+xml"/><item><title>ska::flat_hash_map 源码分析</title><link>http://example.org/2021/08/ska_flat_hash_map_notes/</link><pubDate>Sat, 21 Aug 2021 17:43:02 +0800</pubDate><guid>http://example.org/2021/08/ska_flat_hash_map_notes/</guid><description>背景 最近在调研各种hashmap.. 发现ska::flat hash map性能优秀。。于是来看看代码。。 发现最大的特点是,ska::flat_hash_map使用了带probe count上限的robin hood hashing
相关概念 Distance_from_desired 对于采用了open addressing的hash实现，当插入发生冲突时，会以一定方式(如线性探测、平方探测等)来探测下一个可以插入的slot. 因而实际插入的slot位置与理想的slot位置通常不相同，这段距离定义为distance_from_desired 在没有冲突的理想情况下，所有distance_from_desired的值应该都为0 distance_from_desired的一种更常见的说法叫做probe sequence lengths(PSL)
robin hood hashing robin hood hashing的核心思想是&amp;quot;劫富济贫&amp;quot; distance_from_desired小的slot被认为更&amp;quot;富有&amp;quot;，distance_from_desired大的slot被认为更&amp;quot;贫穷&amp;quot; 具体来说，当去插入一个新的元素时，如果当前位置的元素的distance_from_desired要比待插入元素的distance_from_desired要小，那么就将待插入元素放入当前位置，将当前位置的元素取出，寻找一个新的位置。
这样做使得所有元素的distance_from_desired的分布更为平均，variance更小。 这样的分布对cache更友好（几乎全部元素distance_from_desired都小于一个cache line的长度，因此在find的时候只需要fetch一次cache line），从而拥有更好的性能。
一般的robin hashing 在find时，一般用一个全局的最大distance_from_desired作为没有找到该元素终止条件。 一种常见的改进是,不维护全局最大distance_from_desired,而是在看到当前位置元素的distance_from_desired比要插入的元素的distance_from_desired小时终止。
iterator find(const FindKey&amp;amp; key) { size_t index = hash_policy.index_for_hash(hash_object(key), num_slots_minus_one); EntryPointer it = entries + ptrdiff_t(index); for (int8_t distance = 0; it-&amp;gt;distance_from_desired &amp;gt;= distance; ++distance, ++it) { if (compares_equal(key, it-&amp;gt;value)) return {it}; } return end(); } 带上限的robin hashing 一般的robin hashing在insert时，会不断进行寻找(包括了可能的swap过程)，直到找到一个空的slot为止。该过程在hash table较满时可能接近线性的时间复杂度。 ska::flat_hash_map对这一点的改进是，限制了insert时尝试的上限次数，作者给出的经验值为log(N),其中N为slots的个数。 这样保证每个slot的最大distance_from_desired不会超过log(N)</description></item></channel></rss>