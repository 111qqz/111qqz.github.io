<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>回文串 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/</link><description>Recent content in 回文串 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 05 Oct 2016 12:05:16 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>codeforces 240 F. TorCoder (线段树)</title><link>https://111qqz.com/2016/10/cf240f/</link><pubDate>Wed, 05 Oct 2016 12:05:16 +0000</pubDate><guid>https://111qqz.com/2016/10/cf240f/</guid><description>
题目链接
题意：给一个仅由小写字母组成的字符串，然后m个操作，每个操作一个区间，要求把区间中排列成字典序最小的回文串，如果不能形成回文串，就忽略该操作。
思路：和上一道线段树优化计数排序的题目很像，几乎是一样的。
同样的，26棵线段树，每种字母对应一棵。
每次统计询问区间中每种字母的个数。
然后先判断是否能形成回文（奇数长度只有一个个数为奇数的，偶数长度不能出现个数为奇数的）
能的话重置区间，然后前后分别覆盖。
注意如果是奇数长度的话，记得先覆盖中间点。
需要注意这道题的输入输出方式不是标准的。。。而是要加文件。。。不然会MLE 1
然而Tle 19....Tle了好久。。。
最后换了种线段树的写法就过了。。。
然而后面这种写法就一定好么。。。。好像也不是。。。
总之是个挺玄学的东西。。。。不管了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月05日 星期三 04时00分51秒 File Name :code/cf/problem/240F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #include &amp;lt;bits/stdc++.h&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+1; int tree[26][N*4]; int lazy[26][N*4]; int n,m; char st[N]; int cnt[26]; int L,R; inline bool scan_d(int &amp;amp;num) { char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!</description></item><item><title>uva 401 Palindromes</title><link>https://111qqz.com/2016/01/uva-401-palindromes/</link><pubDate>Wed, 20 Jan 2016 15:53:21 +0000</pubDate><guid>https://111qqz.com/2016/01/uva-401-palindromes/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=96&amp;amp;page=show_problem&amp;amp;problem=342 题意：问一个字符串是不是回文串，是不是镜像串。镜像串的意思是。。从镜子里看还一样。。给定了一些存在镜像的字母和数字。。 思路：回文串的判断用c++的string要更容易一些。。直接reverse一下。。判断是否相等就行。。。然后需要注意的是。。如果某个字符补存在镜像那么一定不是镜像串
如果某个字符不存在镜像那么一定不是镜像串！
如果某个字符不存在镜像那么一定不是镜像串！
蠢哭惹好么。。。。
* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 16时00分57秒 File Name :code/uva/401.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; string a,b; char tmp[1000005]; map&amp;lt;char,char&amp;gt;mp; void init() { mp.</description></item></channel></rss>