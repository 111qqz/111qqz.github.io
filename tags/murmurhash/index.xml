<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>murmurhash on 111qqz的小窝</title><link>http://example.org/tags/murmurhash/</link><description>Recent content in murmurhash on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Mar 2017 12:20:37 +0000</lastBuildDate><atom:link href="http://example.org/tags/murmurhash/index.xml" rel="self" type="application/rss+xml"/><item><title>murmurhash源码分析</title><link>http://example.org/2017/03/reading-murmurhash-code/</link><pubDate>Wed, 22 Mar 2017 12:20:37 +0000</pubDate><guid>http://example.org/2017/03/reading-murmurhash-code/</guid><description>分析levelDB源码的时候遇到的&amp;hellip;发现是一个广泛应用的hash算法，而且是纯c写的，于是找来了源码看。
最初的实现是C++的，但是被移植到了其他的流行语言上，包括 Python,[11]C,[12]C#,[9][13]Perl,[14]Ruby,[15]PHP,[16]Haskell,[17]、Scala[18]、Java[19][20]和JavaScript[21][22]等。
这个算法已经被若干开源计划所采纳，最重要的有libstdc++ (4.6版)、Perl[23]、nginx (不早于1.0.1版)[24]、Rubinius[25]、 libmemcached (Memcached的C语言客户端驱动)[26]、maatkit[27]、Hadoop[1]、Kyoto Cabinet[28]以及RaptorDB[29]。虽然说破天就是一个hash函数。。似乎没什么好分析的？
不过由于是第一次分析有现实意义的代码，所以简单一点也不是罪过吧orz
以及这次分析代码的重点不在hash算法本身&amp;hellip;而是算法之外的其他东西&amp;hellip;
大概感受下有现实意义的工程代码的布局之类orz
hash函数本身没有分析&amp;hellip;这个没什么好分析的吧&amp;hellip;应该是类似一种构造，看懂每一步很容易，但是你还是想不出来啊？而且一堆&amp;quot;magic number&amp;rdquo;
代码很短，也就200行,分析见注释。
/** * `main.c' - murmurhash * * copyright (c) 2014 joseph werle &amp;lt;joseph.werle@gmail.com&amp;gt; */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;inttypes.h&amp;gt; #include &amp;quot;murmurhash.h&amp;quot; static void usage () { fprintf(stderr, &amp;quot;usage: murmur [-hV] [options]\n&amp;quot;); } static void //函数类型和函数名不一行写是什么风格orz... help () { fprintf(stderr, &amp;quot;\noptions:\n&amp;quot;); fprintf(stderr, &amp;quot;\n --seed=[seed] hash seed (optional)&amp;quot;); fprintf(stderr, &amp;quot;\n&amp;quot;); } static char * read_stdin () { size_t bsize = 1024; size_t size = 1; char buf[bsize]; char *res = (char *) malloc(sizeof(char) * bsize); char *tmp = NULL; // memory issue if (NULL == res) { return NULL; } //申请内存失败了.</description></item></channel></rss>