<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最小覆盖子矩形 on Clarity</title><link>https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E7%9F%A9%E5%BD%A2/</link><description>Recent content in 最小覆盖子矩形 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Wed, 10 Aug 2016 16:54:11 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E7%9F%A9%E5%BD%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 2185 Milking Grid (最小覆盖子矩形，kmp)</title><link>https://111qqz.com/2016/08/poj-2185/</link><pubDate>Wed, 10 Aug 2016 16:54:11 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2185/</guid><description>
poj 2185 题目链接
题意：给出一个字符矩形，问一个面积最小的矩形，覆盖掉整个矩形。大概就是二维的最小覆盖子串。
思路：对于每一行做最小覆盖子串，然后求lcm，每一列也是如此。最后记得判断不能超过原有的n,m。
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 23时46分47秒 File Name :code/poj/2185.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char s[N][80]; int n,m; int nxt[N]; void getrownxt(int row,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[row][i]==s[row][j]) nxt[++i]=++j; else j = nxt[j]; } void getcolnxt(int col,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i][col]==s[j][col]) nxt[++i]=++j; else j = nxt[j]; } int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } int lcm(int a,int b) { return a/gcd(a,b)*b; //蒟蒻的自我修养 } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item></channel></rss>