<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pytorch on 111qqz的小窝</title><link>https://111qqz.com/tags/pytorch/</link><description>Recent content in Pytorch on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 17 Dec 2023 18:22:24 +0800</lastBuildDate><atom:link href="https://111qqz.com/tags/pytorch/index.xml" rel="self" type="application/rss+xml"/><item><title>[施工中] cupy与torch的导入顺序不同对计算结果的影响</title><link>https://111qqz.com/2023/12/cupy-torch-import-order-impact/</link><pubDate>Sun, 17 Dec 2023 18:22:24 +0800</pubDate><guid>https://111qqz.com/2023/12/cupy-torch-import-order-impact/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>公司内部的基于torch的toolbox发现某个版本之后,结果发生了偏移. 通过一系列排查,发现当导入cupy和torch的顺序不同时，计算结果会有所差异。
也就是说,如下两段代码会导致模型训练等环节的计算得到不同的结果.&lt;/p></description></item><item><title>pytorch 函数笔记</title><link>https://111qqz.com/2018/02/pytorch-function-notes/</link><pubDate>Fri, 23 Feb 2018 02:55:25 +0000</pubDate><guid>https://111qqz.com/2018/02/pytorch-function-notes/</guid><description>
&lt;p>记录一些常用的&amp;hellip;总去查文档也是有点麻烦&lt;/p>
&lt;pre>&lt;code> *
&lt;/code>&lt;/pre>
&lt;h3 id="tensorview-的作用是reshape-比如a--torchrange1-16-得到一个tensor-that-has-16-elements-from-1-to-16-在aaview44就得到了一个44的tensor-需要注意reshape之后元素的个数不能改变1644-参数-1的作用是我懒得算这一维度应该是多少由于元素个数不能改变所以希望自动被计算需要注意的是只有一个维度可以写-1不过view和reshape有些区别reshape-always-copies-memory-view-never-copies-memory">tensor.view 的作用是reshape 比如 a = torch.range(1, 16) 得到一个tensor  that has 16 elements from 1 to 16. 在a=a.view(4,4)就得到了一个4&lt;em>4的tensor。 需要注意reshape之后元素的个数不能改变(16==4&lt;/em>4)  参数-1的作用是，我懒得算这一维度应该是多少,（由于元素个数不能改变）所以希望自动被计算。**需要注意的是，只有一个维度可以写-1。 **不过view和reshape有些区别：&lt;em>reshape always copies memory. view never copies memory&lt;/em>&lt;/h3>
&lt;pre>&lt;code> *
&lt;/code>&lt;/pre>
&lt;h3 id="torchsqueeze将输入张量形状中的1去除并返回-如果输入是形如a1b1c1d那么输出形状就为abcd当给定dim时那么挤压操作只在给定维度上例如输入形状为a1bsqueezeinput-0将会保持张量不变只有用squeezeinput-1形状会变成ab注意-返回张量与输入张量共享内存所以改变其中一个的内容会改变另一个">torch.squeeze  将输入张量形状中的&lt;code>1&lt;/code> 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)，那么输出形状就为： (A×B×C×D)当给定&lt;code>dim&lt;/code>时，那么挤压操作只在给定维度上。例如，输入形状为: (A×1×B), &lt;code>squeeze(input, 0)&lt;/code> 将会保持张量不变，只有用 &lt;code>squeeze(input, 1)&lt;/code>，形状会变成 (A×B)。注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。&lt;/h3>
&lt;pre>&lt;code> *
&lt;/code>&lt;/pre>
&lt;h3 id="torchunsqueeze返回一个新的张量对输入的制定位置插入维度-1-注意-返回张量与输入张量共享内存所以改变其中一个的内容会改变另一个如果dim为负则将会被转化diminputdim1">torch.unsqueeze  返回一个新的张量，对输入的制定位置插入维度 1 注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。如果&lt;code>dim&lt;/code>为负，则将会被转化dim+input.dim()+1&lt;/h3>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; x = torch.Tensor([1, 2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; torch.unsqueeze(x, 0)
1 2 3 4
[torch.FloatTensor of size 1x4]
&amp;gt;&amp;gt;&amp;gt; torch.unsqueeze(x, 1)
1
2
3
4
[torch.FloatTensor of size 4x1]
*
&lt;/code>&lt;/pre>
&lt;h3 id="tensorexpandsize-扩展tensor可以保持维度数目不变每一维度的size增加比如ab变到cd其中cadb-1参数表示某一个维度的size不发生改变--有可以扩展tensor到更多的维度新增加的维度会默认放在最前面并且不能以-1作为参数">tensor.expand(&lt;em>size)   扩展tensor.可以保持维度数目不变，每一维度的size增加(比如A&lt;/em>B变到C*D,其中C&amp;gt;=A,D&amp;gt;=B).-1参数表示某一个维度的size不发生改变  . 有可以扩展tensor到更多的维度，新增加的维度会默认放在最前面，并且不能以-1作为参数。&lt;/h3>
&lt;pre>&lt;code> *
&lt;/code>&lt;/pre>
&lt;h3 id="tensorcontiguous-将一个tensor变成连续的一些ops如expandexpand_">&lt;strong>tensor.contiguous  将一个tensor变成连续的。（一些ops如expand/expand_as会让tensor 不连续）&lt;/strong>&lt;/h3></description></item></channel></rss>