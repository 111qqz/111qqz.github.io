<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最小覆盖子串 on Clarity</title><link>https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</link><description>Recent content in 最小覆盖子串 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Thu, 11 Aug 2016 16:53:06 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3746 Cyclic Nacklace (最小覆盖子串，kmp)</title><link>https://111qqz.com/2016/08/hdu-3746/</link><pubDate>Thu, 11 Aug 2016 16:53:06 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-3746/</guid><description>
hdu 3746题目链接 题意：给定一个字符串，是一个环（首尾相连），问至少再添加多少个珠子才能使得整个串是循环的。。。
思路：一下子想到了最小覆盖子串的模型。。。我求出最小覆盖子串的长度（n-nxt[n]）。然后特判下最小覆盖子串的长度等于字符串长度的情况。。。试着叫了一发。。。竟然就A了2333.。。大概是所谓的题感吧（逃
/* *********************************************** Author :111qqz Created Time :2016年08月12日 星期五 00时41分19秒 File Name :code/hdu/3746.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N]; int n; int nxt[N]; void getnxt( char *s) { int n = strlen(s); int i = 0; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i]==s[j]) nxt[++i]=++j; else j = nxt[j]; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2185 Milking Grid (最小覆盖子矩形，kmp)</title><link>https://111qqz.com/2016/08/poj-2185/</link><pubDate>Wed, 10 Aug 2016 16:54:11 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2185/</guid><description>
poj 2185 题目链接
题意：给出一个字符矩形，问一个面积最小的矩形，覆盖掉整个矩形。大概就是二维的最小覆盖子串。
思路：对于每一行做最小覆盖子串，然后求lcm，每一列也是如此。最后记得判断不能超过原有的n,m。
/* *********************************************** Author :111qqz Created Time :2016年08月10日 星期三 23时46分47秒 File Name :code/poj/2185.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; char s[N][80]; int n,m; int nxt[N]; void getrownxt(int row,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[row][i]==s[row][j]) nxt[++i]=++j; else j = nxt[j]; } void getcolnxt(int col,int n) { int i = 0 ; int j = -1; nxt[0] = -1; while (i&amp;lt;n) if (j==-1||s[i][col]==s[j][col]) nxt[++i]=++j; else j = nxt[j]; } int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } int lcm(int a,int b) { return a/gcd(a,b)*b; //蒟蒻的自我修养 } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>KMP与最小覆盖子串</title><link>https://111qqz.com/2016/08/kmp/</link><pubDate>Wed, 10 Aug 2016 16:28:58 +0000</pubDate><guid>https://111qqz.com/2016/08/kmp/</guid><description>
参考资料（本文大部分是参考这篇博客，附带一些证明步骤的解释） 首先明确一些概念： 最小覆盖子串：对于某个字符串s，它的最小覆盖子串指的是长度最小的子串p，p满足通过自身的多次连接得到q，最后能够使s成为q的子串。 比如： 对于s=&amp;quot;abcab&amp;quot;，它的最小覆盖子串p=&amp;quot;abc&amp;quot;，因为p通过在它后面再接上一个p（即重叠0个字符），可以得到q=&amp;quot;abcabc&amp;quot;，此时s是q的子串。 对于s=&amp;quot;ababab&amp;quot;，它的最小覆盖子串为p=&amp;quot;ab&amp;quot;。
pre[i]（或next[i]）的实质是串str[1..i]的最长且小于i的“相等前、后缀”分别为str[1..pre[i]]（前缀）与str[(i-pre[i]+1)..i]（后缀），通俗讲就是：使str[1..i]前k个字母与后k个字母相等的最大k值。
结论先行：最小覆盖子串（串尾多一小段时，用前缀覆盖）长度为n-next[n]（n-pre[n]），其中n为串长，串的最后一位为为s[n-1].
证明分两部分：
１－长为n-next[n]的前缀必为覆盖子串。
当next[n]&amp;lt;n-next[n]时，如图a，长为next[n]的前缀A与长为next[n]的后缀B相等，故长为n-next[n]的前缀C必覆盖后缀B；
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://hi.csdn.net/attachment/201110/12/0_1318409624ugQu.gif
Disk path: /static/http://hi.csdn.net/attachment/201110/12/0_1318409624ugQu.gif
Using Page Bundles: false
当next[n]&amp;gt;n-next[n]时，如图b，将原串X向后移n-next[n]个单位得到Y串，根据next的定义，知长为next[n]的后缀串A与长为前缀串B相等，X串中的长为n-next[n]的前缀C与Y串中的前缀D相等，而X串中的串E又与Y串中的D相等……可见X串中的长为n-next[n]的前缀C可覆盖全串（其实是一个不断的等价交换的过程，用同样的方法可以证明每两个相邻的相等，所以可以覆盖全串）
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: http://hi.csdn.net/attachment/201110/12/0_13184096821133.gif
Disk path: /static/http://hi.</description></item></channel></rss>