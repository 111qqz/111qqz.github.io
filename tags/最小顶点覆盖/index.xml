<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最小顶点覆盖 on Clarity</title><link>https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96/</link><description>Recent content in 最小顶点覆盖 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Mon, 30 May 2016 13:56:28 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9C%80%E5%B0%8F%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96/index.xml" rel="self" type="application/rss+xml"/><item><title>poj 3041 Asteroids (二分图的最小顶点覆盖，匈牙利算法)</title><link>https://111qqz.com/2016/05/poj-3041/</link><pubDate>Mon, 30 May 2016 13:56:28 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-3041/</guid><description>
poj 3041题目链接 题意：一个nn的网格中，有k个大小为11的小行星，现在可以用激光枪每次消灭一行的小行星或者消灭一列的小行星。问最少需要使用多少次激光枪消灭所有的小行星。
思路：一个建图技巧是：对于网格图，我们可以把某个格子的横纵坐标看成点，而格子所代表的内容看成边来建图。
如果我们按照这样的方式建图，那么这道题的行或者列就成了点，而小行星就成了边。我们要做得是选最少的点，使得这些点覆盖所有的边。
根据Knoig定理，二分图的最小顶点覆盖数等于二分图的最大匹配数。
匈牙利一遍即可。1A
/* *********************************************** Author :111qqz Created Time :2016年05月30日 星期一 21时42分55秒 File Name :code/poj/3041.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; const int M=1E4+7; int n,k; int cnt; struct Edge { int v; int nxt; }edge[M]; int head[N]; bool vis[N]; int link[N]; void addedge( int u,int v) { edge[cnt].</description></item><item><title>poj 1325 Machine Schedule(二分图的最小顶点覆盖，匈牙利算法)</title><link>https://111qqz.com/2016/05/poj-1325-machine-schedule/</link><pubDate>Thu, 26 May 2016 15:40:56 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1325-machine-schedule/</guid><description>
poj 1325 题目链接 题意：有两台机器A和B,分别有n和m种工作模式。 现在有k个job,三元组（i,x,y),job i可以用A机器的x模式完成或者用B机器的y模式完成。初始两个机器都在模式0.机器更换模式的时候需要重启，问最少的重启次数。
思路：这道题的难点在于建图。。。每个job恰好对应了两种模式。。那么如果把模式看成点。。边就对应了这个job。。这样就是一个二分图。。。至于方向。。。怎么指都可以。。。统一就行。。
完全没有图的影子的题依然可以用图论解决。。。而且算是加深了对图这种模型的理解把。
然后这道题就变成了二分图的最小顶点覆盖。
**二分图中，选取最少的点数，使这些点和所有的边都有关联（把所有的边的覆盖），叫做最小点覆盖。** 根据Knoig定理：二分图的最小顶点覆盖数等于二分图的最大匹配数。
一个证明：二分图最小顶点覆盖的证明
剩下的就是裸的hungary..
然而WA了好几次。。。
一个小细节没处理好。。。
由于初始是模式0.。。
所以模式0肯定要特殊考虑。。。因为初始状态是没有重启的。。。
但是我错误得以为只有当存在（i,0,0）这样的边时才忽略不算。。。
但是其实只要有一个端点是0就好了啊。。。不管哪端是0，我就用这个0来完成工作。。。依然不增加重启次数。。。
这不是什么坑点。。。脑袋秀逗了。。。
/* *********************************************** Author :111qqz Created Time :2016年05月26日 星期四 21时41分11秒 File Name :code/poj/1325.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int n,m,k; int cnt; struct Edge { int v; int nxt; }edge[N]; int head[N]; int link[N]; bool vis[N]; void addedge( int u,int v) { edge[cnt] .</description></item></channel></rss>