<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>构造 on 111qqz的小窝</title><link>https://111qqz.com/tags/%E6%9E%84%E9%80%A0/</link><description>Recent content in 构造 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Tue, 10 Oct 2017 10:19:55 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/%E6%9E%84%E9%80%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 5950 Recursive sequence (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/10/hdu-5950/</link><pubDate>Tue, 10 Oct 2017 10:19:55 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-5950/</guid><description>
题目链接
题意： 给f[1],f[2],n,f[i] = 2*f[i-2] + f[i-1] + i^4,求f[n]的值。
思路： 很容易想到矩阵，但是i^4不是线性的差评，我们可以拆一下
i^4=(i-1+1)^4,然后二项式展开即可
i^4=(i-1)^4 + 4*(i-1)^3 + 6(i-1)^2 + 4(i-1) + 1
所以为了维护i^4这一项，需要(i-1)^4,(i-1)^3,(i-1)^2,(i-1),1,
再加上f[i-1]和f[i-2]两项，一共7项。
然后构造矩阵为
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } 网站链接: /2017/10/hdu-5950/https://111qqz.com/wordpress/wp-content/uploads/2017/10/webwxgetmsgimg.jpg
链接到文件: /content/post/ACM-ICPC/https://111qqz.com/wordpress/wp-content/uploads/2017/10/webwxgetmsgimg.jpg
使用 Page Bundles: true
16沈阳 onsite的题，当时好像写了一个小时，现在看来，果然是个人尽皆知的傻逼题orz
/* *********************************************** Author :111qqz Created Time :2017年10月10日 星期二 17时38分11秒 File Name :5950.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=7; const LL MOD =2147493647LL; LL a,b,n; struct Mat { LL mat[N][N]; void clear() { ms(mat,0); } void print() { for ( int i = 0 ; i &amp;lt; N; i++) for ( int j = 0 ; j &amp;lt; N ; j++) printf(&amp;quot;%lld%c&amp;quot;,mat[i][j],j==N-1?</description></item><item><title>UVA - 10518 How Many Calls? (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/10/uva-10518/</link><pubDate>Sun, 01 Oct 2017 11:10:16 +0000</pubDate><guid>https://111qqz.com/2017/10/uva-10518/</guid><description>
题目链接
题意： 求f[n] = f[n-1] + f[n-2] + 1，在b(10000)进制下的最后一位数字的十进制表示。
思路： 构造矩阵即可，M矩阵是一个3_3的矩阵，M1矩阵是一个3_1的矩阵。。很easy，就不说了。
写题解的目的是，对于这种要求b进制下，最后一位或者最后两位的数字的十进制表示的问题，其实就是在说，取模的数是base或者base^2
1A美滋滋
/* *********************************************** Author :111qqz Created Time :2017年10月01日 星期日 18时39分17秒 File Name :10518.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 5; LL n,base; struct Mat { LL mat[N][N]; void clear() { ms(mat,0); } }M,M1; Mat operator * ( Mat a,Mat b) { Mat c; c.</description></item><item><title>hdu 4686 Arc of Dream (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/10/hdu-4686/</link><pubDate>Sun, 01 Oct 2017 06:33:48 +0000</pubDate><guid>https://111qqz.com/2017/10/hdu-4686/</guid><description>
hdu4686题目链接
题意： An Arc of Dream is a curve defined by following function:
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } 网站链接: /2017/10/hdu-4686/https://odzkskevi.qnssl.com/5bb0e0e69de61a673fbd079520fe97e2?v=1506621126
链接到文件: /content/post/ACM-ICPC/https://odzkskevi.qnssl.com/5bb0e0e69de61a673fbd079520fe97e2?v=1506621126
使用 Page Bundles: true
where a 0 = A0 a i = a i-1_AX+AY b 0 = B0 b i = b i-1_BX+BY What is the value of AoD(N) modulo 1,000,000,007?</description></item><item><title>hdu 4990 Reading comprehension (构造矩阵，快速幂)</title><link>https://111qqz.com/2017/09/hdu-4990/</link><pubDate>Sat, 30 Sep 2017 11:38:05 +0000</pubDate><guid>https://111qqz.com/2017/09/hdu-4990/</guid><description>
题目链接
题意： 给出了一段程序，程序实际算的是f[n] = (f[n-1] + n%2)%m的值，其中f[1]=1,给出n,m(1E9)，问f[n]
思路： 显然是矩阵快速幂，终点在于构造矩阵。
通过经验可得（这次真的是经验了。。。其实也挺容易的，要点大概在于先把需要的项列在一起，然后增加0或者多个，为了转移需要的辅助项。
根据当前列和下一列，手动构造转移矩阵）
转移矩阵M为
[2, 1,0]
[0,-1,1]
[0,0 ,1]
4A..都是一个原因。。矩阵乘法那里。。。就算你%了m..也是两个1E9在相乘。。。然后就炸了23333,改成LL即可。
/* *********************************************** Author :111qqz Created Time :2017年09月30日 星期六 19时08分59秒 File Name :4990.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f;le int n; LL mod; struct Mat { LL mat[8][8]; void clear() { ms(mat,0); } }M,M1; Mat operator * (Mat a,Mat b) { Mat c; c.</description></item><item><title>今日头条笔试题_或与加(打表,构造)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-03/</link><pubDate>Thu, 30 Mar 2017 03:04:06 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-03/</guid><description>
给定 x, k ，求满足 x + y = x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。
比如当 x=5，k=1时返回 2，因为5+1=6 不等于 5|1=5，而 5+2=7 等于 5 | 2 = 7。
输入描述: 每组测试用例仅包含一组数据，每组数据为两个正整数 x , k。 满足 0 &amp;lt; x , k ≤ 2,000,000,000。
输出描述: 输出一个数y。
输入例子: 5 1 输出例子: 达标2 一看就是数学题...? 打表观察...
1 0000001 2 0000010 3 0000011 4 0000100 5 0000101 6 0000110 7 0000111 8 0001000 9 0001001 10 0001010 11 0001011 12 0001100 13 0001101 14 0001110 15 0001111 16 0010000 17 0010001 18 0010010 19 0010011 20 0010100 21 0010101 22 0010110 23 0010111 24 0011000 25 0011001 26 0011010 27 0011011 28 0011100 29 0011101 30 0011110 31 0011111 32 0100000 33 0100001 34 0100010 35 0100011 36 0100100 37 0100101 38 0100110 39 0100111 40 0101000 41 0101001 42 0101010 43 0101011 44 0101100 45 0101101 46 0101110 47 0101111 48 0110000 49 0110001 50 0110010 51 0110011 52 0110100 53 0110101 54 0110110 55 0110111 56 0111000 57 0111001 58 0111010 59 0111011 60 0111100 61 0111101 62 0111110 63 0111111 64 1000000 65 1000001 66 1000010 67 1000011 68 1000100 69 1000101 70 1000110 71 1000111 72 1001000 73 1001001 74 1001010 75 1001011 76 1001100 77 1001101 78 1001110 79 1001111 80 1010000 81 1010001 82 1010010 83 1010011 84 1010100 85 1010101 86 1010110 87 1010111 88 1011000 89 1011001 90 1011010 91 1011011 92 1011100 93 1011101 94 1011110 95 1011111 96 1100000 97 1100001 98 1100010 99 1100011 100 1100100 发现如果x的二进制表示中,如果某位为1,那么对应的y的位置上一定为0.</description></item><item><title>codeforces #381 div 2 C. Alyona and mex (构造)</title><link>https://111qqz.com/2016/11/cf740c/</link><pubDate>Mon, 28 Nov 2016 07:03:51 +0000</pubDate><guid>https://111qqz.com/2016/11/cf740c/</guid><description>
题目链接
题意：
m个区间，要求构造一个长度为n的数组，满足m个区间中，每个区间的mex值中的最小值最大。
s思路：很容易想到的是...这个最大的mex 不可能超过每一组区间长度，假设最小的区间长度为mn
那么是否一定可以构造出mex为mn的数组呢？
是的。
只需要按照
0,1,2...mn-1,0,1....的方式构造即可。
/* *********************************************** Author :111qqz Created Time :2016年11月24日 星期四 09时00分04秒 File Name :code/cf/#381/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; struct node { int l,r; int len; bool operator &amp;lt; ( node b)const { if (r==b.</description></item><item><title>codeforces 496 C Removing Columns (构造)</title><link>https://111qqz.com/2016/10/cf496c/</link><pubDate>Tue, 04 Oct 2016 11:37:22 +0000</pubDate><guid>https://111qqz.com/2016/10/cf496c/</guid><description>
题目链接
题意：给一个n*m的由小写字母组成的table.要求从上往下每一行字典序不严格递增。问最少删除几列才能满足。
思路：一开始想的是用一个left数组维护每次删除后某一列左边是哪一列，目的是为了下次的判断。
再想了下，发现没必要。我们只需要知道，两行之间的关系是否确定就好了。over[i][j]为真表示第i行和第j行的胜负已分，对于胜负已分的行，大小无所谓。
对于胜负未分的行，如果table[i][j]&amp;gt;table[i+1][j]，就必须要删掉这一列了。。。。
需要注意的是，某一列最多删一次，记得打上标记。
以及ove标记的时候，要在最后确定这一列没有被删以后再标记。。。用一个set存下可能的胜负已分的行的下标即可。
1A
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 19时10分39秒 File Name :code/cf/problem/496C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; char table[N][N]; int n,m; bool mark[N]; bool over[N][N]; int left[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 509 B. Painting Pebbles （构造）</title><link>https://111qqz.com/2016/10/cf509b/</link><pubDate>Mon, 03 Oct 2016 19:09:23 +0000</pubDate><guid>https://111qqz.com/2016/10/cf509b/</guid><description>
题目链接
题意：n堆石子，每堆a[i]个，k种颜色。给每个石子涂色，要求对于每种颜色，任意两堆中该颜色石子的个数最多差一个。问是否有解，有解输出一组方案。
思路：我们发现有解与否只和最大值最小值有关。
设mn为最小值,mx为最大值。
当mx&amp;gt;mn+k时无解，否则有解。
如果有解。。。输出方案就好了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 02时40分20秒 File Name :code/cf/problem/509B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,k; int a[105]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 468 A. 24 Game (构造)</title><link>https://111qqz.com/2016/10/cf468a/</link><pubDate>Sun, 02 Oct 2016 17:14:48 +0000</pubDate><guid>https://111qqz.com/2016/10/cf468a/</guid><description>
题目链接
题意：给出n，有1..n n个数，可以选择两个数进行加，减，乘，三种操作，操做完得到一个数放回。 n-1次操作后只剩下一个数。现在要求剩下的数为24.问方法。
思路：我们发现。。。两个数相减可以为1.。那么只要找到4个数的方案和5个数的方案就好了。。。
4个数：123*4
5个数：4*5+3+2-1
然而窝一开始以为必须前面减后面。。。
所以是按照4K,4K+1,4K+2,4K+3分的类。。。每4个数得到两个-1，再相乘。。。。麻烦了一点。。代码写了一半的时候意识到了按2K,2K+1分类就行。
/* *********************************************** Author :111qqz Created Time :2016年10月03日 星期一 00时50分18秒 File Name :code/cf/problem/468A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;code/in.</description></item><item><title>codeforces 679A A. Bear and Prime 100 (交互题，构造)</title><link>https://111qqz.com/2016/10/cf679a/</link><pubDate>Sun, 02 Oct 2016 12:58:24 +0000</pubDate><guid>https://111qqz.com/2016/10/cf679a/</guid><description>
题目链接
题意：存在一个[2..100]之间的数，每次可以询问一个数是否是该数的因子，返回yes或者no,最多询问20次。每次要输出询问的数，以及最后要输出这个数是否是质数。
思路：第一次做交互题。。。发现完全不能按照以前的思路。。。
更像是相反的。。。把output看做某种输入。。。input里是某种结果。。。我要根据input里的东西来确定一些东西。
就是先有output，再有input。。。output是选手的输入（最后一个除外），input是返回结果(不是你写的代码的返回结果）
对于这道题。。我们要尽可能少得猜一个数的因子，以确定该数是否为质数。
一个数不是质数的话，就有至少两个大于1的因子。。。
很容易想到。。。判素因子。。。
由于至少有2个非1的因子才不是素数。。。最小为2，因此另一个因子不会大于50.。。
此外。。。有可能有两个相同质因数组成的因子。。。。
因此还要判一下22,35,55,77
/* *********************************************** Author :111qqz Created Time :Sun 02 Oct 2016 08:22:44 PM CST File Name :code/cf/problem/679A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int prime[19]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49}; string st; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 623 A. Graph and String (构造)</title><link>https://111qqz.com/2016/09/cf623a/</link><pubDate>Fri, 02 Sep 2016 08:48:37 +0000</pubDate><guid>https://111qqz.com/2016/09/cf623a/</guid><description>
题目链接：题目链接
题意：给出一个无向图，该图是通过仅包含‘a’ 'b' 'c'三个字母，以规则“i,j之间有边，当且仅当s[i]和s[j]相同，或者s[i]和s[j]在字母表中相邻”（也就是只有'a'和'c'是没有边相连的）得到的，现在问能否还原这个字符串，如果能，输出任意一个解。
思路：其实就是简单构造。。。
构造的一个技巧是。。把能确定的地方先确定了。。。。
我们发现'b'比较特殊。。因为b和任意点都相连。。。
于是可以统计一下度。。。然后确定字符串中的b
然后对于某个没有确定的位置，我放置一个a,并且把所有和这个位置相连的都放成a
字符串中剩下的没有确定的位置就一定是c了。
这个时候我再判断是否满足题中图的条件。
/* *********************************************** Author :111qqz Created Time :2016年09月02日 星期五 15时56分14秒 File Name :code/cf/problem/623A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=505; int n,m; bool conc[N][N]; int degree[N]; char ans[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #368 div 2 C. Pythagorean Triples (构造，数学)</title><link>https://111qqz.com/2016/08/cf707c/</link><pubDate>Sun, 21 Aug 2016 10:45:59 +0000</pubDate><guid>https://111qqz.com/2016/08/cf707c/</guid><description>
题目链接
题意：给出一个数，问包含这个数三个数组成的勾股数，输出另外两个数。
思路：
所谓勾股数,就是当组成一个直角三角形的三边长都为正整数时,我们就称这一组数为勾股数. 那么,组成一组勾股数的三个正整数之间,是否具有一定的规律可寻呢?下面我们一起来观察几组勾股数： 规律一：在勾股数（3,4,5）、（5,12,13）、（7,24,25）（9,40,41）中,我们发现 由（3,4,5）有：32=9=4+5 由（5,12,13）有：52=25=12+13 由（7,24,25）有：72=49=24+25 由（9,40,41）有：92=81=40+41. 即在一组勾股数中,当最小边为奇数时,它的平方刚好等于另外两个连续的正整数之和.因此,我们把它推广到一般,从而可得出以下公式： ∵（2n+1)²=4n²+4n+1=（2n²+2n）+（2n²+2n+1） ∴（2n+1)**²**+（2n²+2n)²=（2n²+2n+1)²（n为正整数） 证明（略） **勾股数公式一：（2n+1,2n²+2n,2n²+2n+1）（n为正整数）** 规律二：在勾股数（6,8,10）、（8,15,17）、（10,24,26）中,我们发现 由（6,8,10）有：62=36+2×（8+10） 由（8,15,17）有：82=64=2×（15+17） 由（10,24,26）有：102=100=2×（24+26） 即在一组勾股数中,当最小边为偶数时,它的平方刚好等于两个连续整数之和的二倍,推广到一般,从而可得出另一公式： ∵（2n）2=4n2=2[（n2-1）+（n2+1）] ∴（2n）2+（n2-1）2=（n2+1）2（n≥2且n为正整数） 证明（略） **勾股数公式二：（2n,n²-1,n²+1）（n≥2且n为正整数）** 利用以上两个公式,我们可以快速写出各组勾股数. 结论是： n&amp;lt;=2无解。
n为奇数用公式1构造。
n为偶数用公式2构造。
** **
 /* *********************************************** Author :111qqz Created Time :2016年08月20日 星期六 21时02分26秒 File Name :code/cf/#368/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL n; int main() { #ifndef ONLINE_JUDGE //freopen(&amp;quot;code/in.</description></item><item><title>codeforces 652 B. z-sort (简单构造)</title><link>https://111qqz.com/2016/03/cf652b/</link><pubDate>Thu, 31 Mar 2016 06:11:36 +0000</pubDate><guid>https://111qqz.com/2016/03/cf652b/</guid><description>
题目链接 题意：给出n个元素的序列，问能否得到一个新的序列，使得奇数位置非递减排列，偶数位数非递增排列。 思路：感觉一定可以啊。。。排序以后直接构造。。。
/* *********************************************** Author :111qqz Created Time :2016年03月31日 星期四 14时05分11秒 File Name :code/cf/problem/652B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; int a[N]; int ans[N]; int n ; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #342 div 2 D. Finals in arithmetic</title><link>https://111qqz.com/2016/02/cf625d/</link><pubDate>Mon, 08 Feb 2016 12:28:22 +0000</pubDate><guid>https://111qqz.com/2016/02/cf625d/</guid><description>
http://codeforces.com/contest/625/problem/D 题意：问能否找到一个s,满足s+s的反转=k 思路：如果是回文数。。。那么显然满足。除以2就可以得到答案。 如果不是回文数。。那么考虑进位的情况。 要么从后一位进1，要么从前一位退10回来。 需要特殊考虑1开头的。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 18时28分39秒 File Name :code/cf/#342/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;sstream&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; bool vis[N]; void pre() { ms(vis,false); for ( int i = 10 ; i &amp;lt;12000 ; i++) { int vala = i ; stringstream ss; ss&amp;lt;&amp;lt;vala; string tmp = ss.</description></item><item><title>codeforces #342 div 2 C. K-special Tables</title><link>https://111qqz.com/2016/02/cf625c/</link><pubDate>Sun, 07 Feb 2016 11:32:04 +0000</pubDate><guid>https://111qqz.com/2016/02/cf625c/</guid><description>
http://codeforces.com/contest/625/problem/C 题意：构造一个矩阵。。满足三个条件。。。 思路：简单构造。。。看代码把。。。。
/* *********************************************** Author :111qqz Created Time :2016年02月07日 星期日 17时49分15秒 File Name :code/cf/#342/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; int n; int k; int ans[N][N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 10785 The Mad Numerologist</title><link>https://111qqz.com/2016/01/uva10785/</link><pubDate>Wed, 27 Jan 2016 14:13:44 +0000</pubDate><guid>https://111qqz.com/2016/01/uva10785/</guid><description>
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=1726 题意：给出26个大写字母的权值，要求构造一个长度为n（n不超过210）的字符串。并且满足奇数位置只能放元音字母，偶数位置只能放辅音字母，且每个元音字母最多放21次，每个辅音字母最多放5次，要求构造的字符串的权值之和最小，在权值最小的前提下字典序最小。
思路：贪心。一开始错误得以为不是完整得不能交换（也就是不完整的字母只能放在最后，这是错误的）。但实际上只要每个字母的数量不变，那么就不影响权值。所以做法是，奇数位置偶数位置分别搞，先把构成字符串的字母按次存入，然后排序一下，输出即可。
/* *********************************************** Author :111qqz Created Time :2016年01月26日 星期二 15时10分28秒 File Name :code/uva/10785.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char a[30],b[30]; char oddans[210],evenans[210]; int n; void pre() { a[1]='A'; a[2]='U'; a[3]='E'; a[4]='O'; a[5]='I'; b[1]='J'; b[2]='S'; b[3]='B'; b[4]='K'; b[5]='T'; b[6]='C'; b[7]='L'; b[8]='D'; b[9]='M'; b[10]='V'; b[11]='N'; b[12]='W'; b[13]='F'; b[14]='X'; b[15]='G'; b[16]='P'; b[17]='Y'; b[18]='H'; b[19]='Q'; b[20]='Z'; b[21]='R'; } void solve () { int odd = (n+1)/2; int even = n/2; int vowa = odd/21; int vowr = odd; int cona = even/5; int conr = even%5; int cnt = 0 ; for ( int i = 1 ; i &amp;lt;= vowa ; i++) { for ( int j =1 ; j &amp;lt;=21 ; j++) { cnt++; oddans[cnt] = a[i]; } } for ( int i = 1 ; i &amp;lt;=vowr ; i++) { cnt++; oddans[cnt]=a[vowa+1]; } cnt = 0 ; for ( int i = 1 ; i &amp;lt;= cona ; i++) { for ( int j = 1 ; j &amp;lt;= 5 ; j++) { cnt++; evenans[cnt]=b[i]; } } for ( int i = 1 ; i &amp;lt;=conr ; i++) { cnt++; evenans[cnt]=b[cona+1]; } sort(oddans+1,oddans+odd+1); sort(evenans+1,evenans+even+1); for ( int i = 1 ;i &amp;lt;= n ; i++) { if (i%2==1) { printf(&amp;quot;%c&amp;quot;,oddans[i/2+1]); } else { printf(&amp;quot;%c&amp;quot;,evenans[i/2]); } } puts(&amp;quot;&amp;quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 22 C. System Administrator</title><link>https://111qqz.com/2015/12/cf22c/</link><pubDate>Wed, 30 Dec 2015 13:47:31 +0000</pubDate><guid>https://111qqz.com/2015/12/cf22c/</guid><description>
http://codeforces.com/contest/22/problem/C 题意：要求用n个点m条边构造一个不允许有重边的图，满足当去掉点v的时候，剩下的n-1个不联通。如果有答案输出任意，没答案输出-1. 思路：首先如果n个点要联通。。至少有n-1条边，此时为一棵树。但是是不是边越多越好呢？显然是不可以的。满足去掉一个点使得n-1个点不联通的情况为，存在一个点u只和v相连，不和任意任何其他点相连，那么当去掉v点，u点就变成不可到达了。边数最多的情况就是，除了v点以外的n-1个点，每个点的度都是n-2(去掉自身以及u点还有n-2个点)，，那么除去u点以外的n-1个点的度数就是（n-1）(n-2)，边数则为(n-1)(n-2)/2，再加一条连接u的边，所以图的最大边数为(n-1)*(n-2)/2+1，最小为n-1.
如果有解，那么接下来的问题是构造。
我是按照如下方式构造的：
先构造一条链，将u点放在第一个，v点放在第二个。不妨当v=1时令u=2,否则u=1;
m-=n-1,如果m还有剩余，那么从第二个点开始，一直到第n-2个点，每个点与至少隔1个点的其他点相连，直到边数没有剩余。
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 20时36分06秒 File Name :code/cf/problem/22C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m,v; int a[N]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 600 C. Make Palindrome</title><link>https://111qqz.com/2015/12/cf600c/</link><pubDate>Tue, 08 Dec 2015 09:44:29 +0000</pubDate><guid>https://111qqz.com/2015/12/cf600c/</guid><description>
http://codeforces.com/problemset/problem/600/C 题意：给定一个字符串。要求用最少的变换得到一个回文串。且在变换次数相同时要字典序最小的。输出变换后的字符串。 思路：对不能构成会文串有影响的是出现奇数次的字母。所以我们先统计每个字母出现的次数。然后按照出现奇数次的字母的个数分奇偶分别搞。偶数的话直接把后面一半变成前面一半。奇数的话，也是这样。输出的时候按照字母从a扫到z，如果有就输出一半。然后再倒着扫一遍。 输出另一半。这样可以保证是字典序最小。需要注意的是奇数的时候的输出情况。不要忘记中间那个字母。
/* *********************************************** Author :111qqz Created Time :2015年12月08日 星期二 16时39分56秒 File Name :code/cf/problem/600C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; char st[N]; int len; int cnt[30]; int odd[30]; int k; int mappd[30]; char ans[N]; void solve() { // cout&amp;lt;&amp;lt;&amp;quot;k:&amp;quot;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl; if (k==0) { for ( int i = 0 ; i &amp;lt; 26 ; i++) { for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } for ( int i = 25 ; i &amp;gt;= 0 ; i--) for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); return ; } if (k%2==0) { for ( int i = 1 ; i &amp;lt;= k/2 ; i++) { cnt[odd[i]]++; cnt[odd[i+k/2]]--; } int num = 0; for ( int i = 0 ; i &amp;lt; 26 ; i++) { for ( int j = 0 ; j &amp;lt; cnt[i]/2; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } for ( int i = 25 ; i &amp;gt;=0 ; i--) { for ( int j = 0 ; j &amp;lt; cnt[i]/2 ; j++) printf(&amp;quot;%c&amp;quot;,char(i+'a')); } printf(&amp;quot;\n&amp;quot;); } if (k%2==1) { // cout&amp;lt;&amp;lt;&amp;quot;what the fuck?</description></item><item><title>codeforces 377 A maze</title><link>https://111qqz.com/2015/12/cf377a/</link><pubDate>Sat, 05 Dec 2015 06:34:40 +0000</pubDate><guid>https://111qqz.com/2015/12/cf377a/</guid><description>
http://codeforces.com/contest/377/problem/A 题意：给定一个n*m的maze. ‘.’代表空，‘#’代表墙。要求构造一种方案，使得将k个空格填成墙壁后不影响当前的连通性（即没有被填充的空格之间可以相互到达） 思路：一开始想从上往下从左往右构造。错误的认为四个角一定是可以变成墙的。
但其实只要是可能在某条路径上的点，就都不一定可以变成墙。。而四个角显然可以被某条路径经过。
正确的解法很巧妙。以任意一个空格开始跑一遍dfs，设空格一共有sum个，那么就dfs到(sum-k)个。可以做好标记。通过dfs得到的这（sum-k）之间一定是联通的。那么只要填充剩下的就可以了。
/* *********************************************** Author :111qqz Created Time :2015年12月05日 星期六 14时06分54秒 File Name :code/cf/problem/377A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E2+7; char maze[N][N]; bool vis[N][N]; int n,m,k; int sx,sy; int sum; int num; bool flag = false; bool ok ( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;=n-1&amp;amp;&amp;amp;y&amp;lt;=m-1&amp;amp;&amp;amp;maze[x][y]=='.</description></item><item><title>poj 1305 (毕达哥拉斯三元组，构造勾股数)</title><link>https://111qqz.com/2015/08/poj1305/</link><pubDate>Sat, 22 Aug 2015 06:18:00 +0000</pubDate><guid>https://111qqz.com/2015/08/poj1305/</guid><description>
题意是说，能构造多少本元勾股数和勾股数，要求构造的数&amp;lt;=n
所谓本元勾股数，就是三个勾股数没有公因数，两两互质。
由本元勾股数扩大k倍，就可以得到其他勾股数。
而构造本元勾股数的方法如下：
***a=st,b=(s^2-t^2)/2,c=(s^2+t^2)/2
其中s&amp;gt;t&amp;gt;=1是任意没有公因数的奇数！
引用一段构造正确性的证明：
本原勾股数组（PPT)是一个三元组（a，b，c),其中a，b，c无公因数，且满足a² +b² =c²。
很明显存在无穷多个勾股数组（abc同乘以n），下面研究abc没有公因数的情况，先写出一些本原勾股数组：
case:(3,4,5) (5,12,13) (8,15,17) (7,24,25) (20,21,29)(9,40,41)(12,35,37)(11,60,61)(28,45,53) (33,56,65) (16,63,65)
观察可以看出a，b奇偶性不同且c总是奇数。（用一点技巧可以证明这是正确的）
3² = 5² - 4² = (5-4)(5+4) = 1 × 9
15² = 17²-8² = (17-8)(17+8) = 9 ×25
35² = 37² - 12² = (37-12)(37+12) = 25 ×49
......
很神奇的是似乎c-b与c+b总是平方数，并且c-b与c+b木有公因数。证明一下下：假设有公因数，设d是c-b与c+b的公因数，则d也整除(c+b)+(c-b)=2c, (c+b)-(c-b) = 2b,所以d整除2c，2b，但是b，c木有公因数，又假设了（a，b，c)是本原勾股数组，从而d等于1或2，又因为d整除（c-b)(c+b)=a².</description></item><item><title>codeforces 534 A. Exam</title><link>https://111qqz.com/2015/04/cf534a/</link><pubDate>Mon, 13 Apr 2015 02:55:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf534a/</guid><description>
A. Exam
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
An exam for n students will take place in a long and narrow room, so the students will sit in a line in some order. The teacher suspects that students with adjacent numbers (i and i + 1) always studied side by side and became friends and if they take an exam sitting next to each other, they will help each other for sure.</description></item><item><title>codeforces 482 A. Diverse Permutation（构造）</title><link>https://111qqz.com/2015/04/cf482/</link><pubDate>Wed, 08 Apr 2015 11:32:00 +0000</pubDate><guid>https://111qqz.com/2015/04/cf482/</guid><description>
C - C
**Time Limit:**1000MS **Memory Limit:**262144KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
Permutation_p_ is an ordered set of integers _p_1, p_2, ..., p__n, consisting of n distinct positive integers not larger than n. We'll denote as_n the length of permutation _p_1, _p_2, ..., p__n.
Your task is to find such permutation p of length n, that the group of numbers |_p_1 - _p_2|, |_p_2 - _p_3|, ..., |p__n - 1 - p__n| has exactly k distinct elements.</description></item></channel></rss>