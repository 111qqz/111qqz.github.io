<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>trie on 111qqz's blog</title><link>https://111qqz.com/tags/trie/</link><description>Recent content in trie on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 11 Nov 2017 18:04:34 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/trie/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 6059 | 2017 Multi-University Training Contest - Team 3 Kanade's trio (trie)</title><link>https://111qqz.com/2017/11/hdu-6059/</link><pubDate>Sat, 11 Nov 2017 18:04:34 +0000</pubDate><guid>https://111qqz.com/2017/11/hdu-6059/</guid><description>
http://acm.hdu.edu.cn/showproblem.php?pid=6059
题意： 含 N 个数字的 A 数组，求有多少个三元组 (i,j,k) 满足 i&amp;lt;j&amp;lt;k 且a[i]^a[j] &amp;lt; a[j]^a[k]
思路: 考虑a[i]和a[k]二进制不同位中的最高位，此时满足题意的a[j]是该位与a[i]相同，其他位任意的所有a[j]的个数。
我们可以从1..n，依次插入a[k]到trie中,插入时，顺便用num[i][j]统计二进制第i位为j的数的个数。
当要插入a[k]时，a[1]..a[k-1]已经插入到了trie中。
trie上统计当某个节点，该位为0的数的个数和该为为1的数的个数。
需要注意这样统计出的数并不能保证i&amp;lt;j (但是可以保证i&amp;lt;k。。。)
因为我们的trie需要额外维护一部分ext.具体解释见代码注释。
/* *********************************************** Author :111qqz Created Time :2017年11月12日 星期日 01时30分29秒 File Name :6059.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int a[N]; int num[35][2];//cnt[i][j] 表示二进制表示中第i位为j的数的个数 struct Trie { struct Node { Node *nxt[2]; LL cnt[2];//需要统计前缀为某个串，该位置为0和该位置为1的个数。 LL ext[2]; Node() { for ( int i = 0 ; i &amp;lt; 2; i++) nxt[i] = NULL; cnt[0]=cnt[1]=0 ; ext[0]=ext[1]=0; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(int x) { Node *u = root; for ( int i = 29 ; i &amp;gt;= 0 ; i--) { int y = (x&amp;gt;&amp;gt;i)&amp;amp;1; num[i][y]++; //统计二进制第i位为y的数的个数 u-&amp;gt;cnt[y]++; //统计trie树上当前节点数的个数 u-&amp;gt;ext[y]+=num[i][y]; //把此时插入的数看做a[i]，那么u-&amp;gt;ext[y]就是满足j&amp;lt;=i 的j的数目 //因为之后要用到，所以要提前维护 if (u-&amp;gt;nxt[y]==NULL) u-&amp;gt;nxt[y] = new Node(); u = u-&amp;gt;nxt[y]; } } LL Cal( int x) { Node *u = root; LL res = 0 ; for ( int i = 29 ; i &amp;gt;= 0 ; i--) { int y = (x&amp;gt;&amp;gt;i)&amp;amp;1; res += num[i][y^1]*u-&amp;gt;cnt[y^1]-u-&amp;gt;ext[y^1]; //对于此时插入的a[k]的二进制第i位（从低往高）的数y,只有当a[i]和a[j]的第i位为1-y时，才会贡献答案。 // num[i][y^1]为第i位为1-y的a[j]的个数（a[j]的其他位，包括比i高的位和比i低的位都不受限制 // u-&amp;gt;cnt[y^1]表示trie树上，从rt到p节点所表示的二进制位上，a[i]与a[k]一直相同，p的下一个节点a[i]与a[k]的二进制位不同 的 a[i]的个数 u = u-&amp;gt;nxt[y]; if (u==NULL) break; } return res; } }trie; void solve() { trie.</description></item><item><title>poj 2001 Shortest Prefixes (trie树)</title><link>https://111qqz.com/2016/08/poj-2001/</link><pubDate>Mon, 15 Aug 2016 19:22:36 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-2001/</guid><description>
poj 2001 题目链接
题意：给出n个字符串的表，问每个字符串的简化表示。简化表示的要求是，以该字符串的最短的而且不能产生歧义的前缀来表示。
思路：字典树，多一个cnt属性，每次insert的时候，路过的每个节点的cnt++
find的时候从root往下扫。。遇到的cnt为1的节点结尾的字符串。。就是该单词的唯一表示。。。
按照这个思路写了一发。。。1A好开心哈哈哈
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 02时55分22秒 File Name :code/poj/2001.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E3+7; char s[N][25]; int n; struct Trie { struct Node { Node *nxt[26]; int cnt; Node() { for ( int i = 0 ; i &amp;lt; 26; i++) nxt[i] = NULL; cnt = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; u-&amp;gt;cnt++; } } string Find(char *s) { Node *u = root; string res=&amp;quot;&amp;quot;; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; res = res + s[i]; u = u-&amp;gt;nxt[v]; if (u-&amp;gt;cnt==1) return res; //cnt为1表示应该就唯一了吧。。。 } } }trie; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 3630 Phone List (带删除操作的静态trie树模板题)</title><link>https://111qqz.com/2016/08/poj-3630/</link><pubDate>Mon, 15 Aug 2016 18:52:16 +0000</pubDate><guid>https://111qqz.com/2016/08/poj-3630/</guid><description>
poj 3630 题目链接
题意：给出n个字符串，问是否满足所有的字符串都不以其他的字符串为前缀。
思路：字典树，先建树，然后每次查找的之前先删掉自己，找完以后再加回来。
以及这题动态建艹不过。。。学习了一下静态建树的写法。。。第一次写静态的写法。。。可以当做模板用。。。
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 00时46分23秒 File Name :code/poj/3630.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; char s[N][12]; int tot; struct Trie { int nxt[10]; int cnt; void init() { ms(nxt,0); cnt = 0; } }trie[N]; int add() { memset(&amp;amp;trie[tot],0,sizeof(Trie)); return tot++; } void Insert(char *s) { int rt = 0 ; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (!</description></item><item><title>hdu 1247 Hat’s Words (trie树)</title><link>https://111qqz.com/2016/08/hdu-1247/</link><pubDate>Mon, 15 Aug 2016 16:36:29 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1247/</guid><description>
hdu 1247 题目链接
题意：给出n个字符串的单词表，输出所有的字符串a，满足字符串a是由n中另外两个字符串拼接成的。
思路：字典树。。其实我一开始想出了正解。。。。就是分割一个单词然后分别在trie上查找。。。但是由于题目坑爹得没给单词的长度这个数据范围。。并不是很敢写2333。。。看了下题解发现就是这么做。。。然后写了下1A。。。
不给数据范围玩个鸟啊。。。
/* *********************************************** Author :111qqz Created Time :2016年08月16日 星期二 00时08分01秒 File Name :code/hdu/1247.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 5E4+7; char s[N][200]; int n ; struct Trie { struct Node { Node *nxt[26]; bool ok; //标记单词的结尾 Node() { for ( int i = 0 ; i &amp;lt; 26 ; i++) nxt[i] = NULL; ok = false; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; } u-&amp;gt;ok = true; } bool Find(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) return 0; u=u-&amp;gt;nxt[v]; } return u-&amp;gt;ok; } }trie; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 5536 || 2015 长春区域赛 J Chip Factory (带删除操作的trie树)</title><link>https://111qqz.com/2016/08/hdu-5536/</link><pubDate>Mon, 15 Aug 2016 15:54:40 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-5536/</guid><description>
hdu 5536 题目链接
题意：给出n个数，然后问最大的(a[i]+a[j])^a[k] (i,j,k互不相同)
思路：异或和最大很容易想到字典树。。但是如何保证i,j,k互不相同这里没有想明白。。。。。我的想法是加一个标记代表之前的id，但是我加的标记是只有在叶子节点上才有的。。。也就是会出现走到了最后一步才发现这个节点是不能走的情况。。。
正确的做法是，加一个cnt标记。
每次插入的时候，这个数从根节点到叶子节点每个节点的cnt都+1
删除的时候做就是每个节点的cnt都-1.
这样子每次Find的时候只走cnt&amp;gt;0的点。。
这种做法的正确性基与：
两个不同的数。。一定有至少一位的二进制数不同。。。保证了当只出现过一次的数x被删掉以后，其他的数y的存在不会导致经过x的路径
** 两个相同的数，每一位二进制数位都是相同搞的。 **保证了id不同的相同的数。。即使一个被删掉。。另外的也可以继续访问。。。因为cnt仍然是大于0的。。。
/* *********************************************** Author :111qqz Created Time :2016年08月15日 星期一 22时54分03秒 File Name :code/hdu/5536.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int LEN=32; const int N=1005; int n; char str[35]; int a[N]; struct Trie { struct Node { Node *nxt[2]; int val; int cnt; Node() { for (int i = 0 ; i &amp;lt; 2 ; i++) nxt[i] = NULL; cnt = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s,int num) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u=u-&amp;gt;nxt[v]; u-&amp;gt;cnt++; } u-&amp;gt;val = num; } void Delete(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (u-&amp;gt;nxt[v]!</description></item><item><title>hdu 4828 Xor Sum (trie 树模板题，经典应用)</title><link>https://111qqz.com/2016/08/hdu-4828-xor-sum-trie-/</link><pubDate>Mon, 15 Aug 2016 13:09:28 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-4828-xor-sum-trie-/</guid><description>
hdu 4825 题目链接
题意：给定n个数，然后给出m个询问，每组询问一个数x，问n中的数y使得x和y的异或和最大。
思路：字典树。。把每个数转化成二进制，注意补全前导0，使得所有数都有相同的位数。
如果想要异或和最大，那么每一位尽可能都是1.
所以做法是，先构建字典树，然后每次find的时候，尽可能按照和当前寻找的数的位相反的位的方向走（如果有的话）
比如当前位是1，那我就往0的方向走。
需要注意的是，多组数据，每次要重新初始化一遍。
做法是 在struct 中重新 root = new Node() 一下。。这样就重新调用了Node中初始化用的构造函数。
/* *********************************************** Author :111qqz Created Time :2016年08月15日 星期一 20时03分05秒 File Name :code/hdu/4825.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int LEN = 32; int n,m; char str[35]; struct Trie { struct Node { Node *nxt[2]; int val; Node() { for ( int i = 0 ; i &amp;lt; 2 ; i++) nxt[i]=NULL; val = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s,int num) { Node *u =root; int len = strlen(s); // cout&amp;lt;&amp;lt;&amp;quot; len :&amp;quot;&amp;lt;&amp;lt;len&amp;lt;&amp;lt;endl; for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'0'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v] = new Node(); u = u-&amp;gt;nxt[v]; } u-&amp;gt;val = num; } int Find(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int x = s[i]-'0'; int y = !</description></item><item><title>hdu 1251 统计难题 (trie树模板题)</title><link>https://111qqz.com/2016/08/hdu-1251/</link><pubDate>Sun, 14 Aug 2016 16:06:02 +0000</pubDate><guid>https://111qqz.com/2016/08/hdu-1251/</guid><description>
hdu 1251 题目链接
题意：先给一个单词表，然后给出若干查询，每个查询一个单词，问单词表中以这个单词为前缀的单词的个数。
思路：trie树裸题。第一次写trie树。。感觉要注意的是trie树是一个比较耗费空间的数据结构。。？ 以及动态开辟内存记得free...？
/* *********************************************** Author :111qqz Created Time :2016年08月14日 星期日 19时58分41秒 File Name :code/hdu/1251.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; char s[20]; struct Trie { struct Node { Node *nxt[26]; int cnt; Node() { for ( int i = 0 ; i &amp;lt; 26; i++) nxt[i]=NULL; cnt = 0 ; } }; Node *root; void init() { root = new Node(); } Trie() { root = new Node(); } void Insert(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) u-&amp;gt;nxt[v]=new Node(); u = u-&amp;gt;nxt[v]; u-&amp;gt;cnt++; } } int Find(char *s) { Node *u = root; int len = strlen(s); for ( int i = 0 ; i &amp;lt; len ; i++) { int v = s[i]-'a'; if (u-&amp;gt;nxt[v]==NULL) return 0; u = u-&amp;gt;nxt[v]; } return u-&amp;gt;cnt; } }trie; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item></channel></rss>