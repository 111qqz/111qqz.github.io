<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>线段树 on 111qqz的小窝</title><link>http://example.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/</link><description>Recent content in 线段树 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 01 Nov 2017 02:19:00 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><item><title>BZOJ 1230: [Usaco2008 Nov]lites 开关灯 (线段树区间修改，区间查询)</title><link>http://example.org/2017/11/bzoj-1230/</link><pubDate>Wed, 01 Nov 2017 02:19:00 +0000</pubDate><guid>http://example.org/2017/11/bzoj-1230/</guid><description>1230: [Usaco2008 Nov]lites 开关灯 Time Limit: 10 Sec Memory Limit: 162 MB Submit: 1676 Solved: 874 [Submit][Status][Discuss]
Description Farmer John尝试通过和奶牛们玩益智玩具来保持他的奶牛们思维敏捷. 其中一个大型玩具是牛栏中的灯. N (2 &amp;lt;= N &amp;lt;= 100,000) 头奶牛中的每一头被连续的编号为1..N, 站在一个彩色的灯下面.刚到傍晚的时候, 所有的灯都是关闭的. 奶牛们通过N个按钮来控制灯的开关; 按第i个按钮可以改变第i个灯的状态.奶牛们执行M (1 &amp;lt;= M &amp;lt;= 100,000)条指令, 每个指令都是两个整数中的一个(0 &amp;lt;= 指令号 &amp;lt;= 1). 第1种指令(用0表示)包含两个数字S_i和E_i (1 &amp;lt;= S_i &amp;lt;= E_i &amp;lt;= N), 它们表示起始开关和终止开关. 奶牛们只需要把从S_i到E_i之间的按钮都按一次, 就可以完成这个指令. 第2种指令(用1表示)同样包含两个数字S_i和E_i (1 &amp;lt;= S_i &amp;lt;= E_i &amp;lt;= N), 不过这种指令是询问从S_i到E_i之间的灯有多少是亮着的. 帮助FJ确保他的奶牛们可以得到正确的答案.
Input 第 1 行: 用空格隔开的两个整数N和M</description></item><item><title>hdu 3642 Get The Treasury (线段树+扫描线，求长方体体积交)</title><link>http://example.org/2017/09/hdu-3642/</link><pubDate>Fri, 29 Sep 2017 10:34:09 +0000</pubDate><guid>http://example.org/2017/09/hdu-3642/</guid><description>hdu3642题目链接
题意：给出若干个（1000）长方体，求至少交三次的空间的体积。
尺寸为[x1,x2],[y1,y2],[z1,z2],其中x，y的坐标的绝对值不超过1E6,Z的坐标的绝对值不超过1E9.
思路：
线段树+扫描线。
由于Z的坐标范围比较小，我们的做法是 利用“微分”的思想，将每个长方体，想成若干的高度为1的矩形（矩形片）
因此就转化成了求矩形至少交三次的面积
其中和矩形交，也就是矩形至少交2次的面积比较类似，只不过线段树多维护一个至少三次覆盖的长度的域。
void PushUp(int l,int r,int rt) { //cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;&amp;quot; id:&amp;quot;&amp;lt;&amp;lt;id&amp;lt;&amp;lt;endl; if (tree[rt].cnt&amp;gt;=3) { tree[rt].one = tree[rt].two = tree[rt].three = X[r+1]-X[l]; } else if (tree[rt].cnt==2) { tree[rt].one = tree[rt].two = X[r+1]-X[l]; if (l==r) tree[rt].three = 0 ; else tree[rt].three = tree[rt&amp;lt;&amp;lt;1].one + tree[rt&amp;lt;&amp;lt;1|1].one; }else if (tree[rt].cnt==1) { tree[rt].one = X[r+1] - X[l]; if (l==r) tree[rt].two = tree[rt].three = 0; else { tree[rt].two = tree[rt&amp;lt;&amp;lt;1].</description></item><item><title>hdu 1828 Picture （线段树+扫描线 求 矩形周长并）</title><link>http://example.org/2017/09/hdu1828/</link><pubDate>Thu, 28 Sep 2017 05:44:47 +0000</pubDate><guid>http://example.org/2017/09/hdu1828/</guid><description>题目链接
题意: 求矩形周长并。
思路： 线段树+扫描线。
和前面的求面积并比较类似，我们先考虑平行x轴的线段，考虑线段树，维护的一段区间中被矩形覆盖的次数cnt和至少覆盖一次的长度的len.
只不过我们这次求的是每条扫描线的长度对周长的贡献，因此不需要乘高度。
需要注意的是，每条扫描线对周长的贡献，是目前扫描线的长度，与上一次扫描线长度的差的绝对值。（不是与上一次答案的差的绝对值！）
演示x轴求长度和的部分 图片来自 lwt聚聚的博客 以及一个小细节是，求面积的时候，最后一条扫描线对答案是没有贡献的（因为每次是求当前扫描线与下一条扫描线之间的面积）
但是求周长的时候，最后一条扫描线是一定会对答案有贡献的。
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 21时24分20秒 File Name :1828.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; int n; struct Seg { double l,r,h; int d; Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp;rhs)const { return h &amp;lt; rhs.</description></item><item><title>hdu 1255 覆盖的面积 (扫描线+线段树 求矩形面积交)</title><link>http://example.org/2017/09/hdu1255/</link><pubDate>Wed, 27 Sep 2017 13:20:23 +0000</pubDate><guid>http://example.org/2017/09/hdu1255/</guid><description>题目链接
题意： 求n（1000）个矩形的面积交，也就是至少有2个矩形覆盖的区域的面积。
思路： 和矩形面积并_hdu1542解题报告  类似
面积并问题中，线段树len维护的是至少覆盖一次的区域的长度
在面积交的问题中，我们需要多维护一个&amp;quot;至少覆盖两次的区域的长度&amp;quot;的域（设为double two;）
同时也要维护至少覆盖一次的区域的长度（设为double one;），是因为至少覆盖两次的区域的长度可以由至少覆盖一次的区域长度得到（好像是废话）
PushUp的时候要格外注意当前节点被完整覆盖一次的情况。
此时tree[rt].two 可以由两个子区间的one的情况想加得到
（因为rt节点被完整覆盖了至少一次，那么如果rt儿子区间中被覆盖了至少一次，对于rt区间中被rt&amp;laquo;1和rt&amp;laquo;1|1覆盖至少一次的区间在对于rt区间就已经覆盖了至少2次）
以及要注意题意说得不够清楚。最后保留2位小数是四舍五入。
读入的实际上是左下角和右上角的点。。。。
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 19时10分37秒 File Name :1255.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E3+7; int n; struct Seg { double l,r,h; int d; Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp; rhs)const { return h&amp;lt;rhs.</description></item><item><title>hdu 1542 Atlantis (线段树+扫描线求矩形面积并，模板题)</title><link>http://example.org/2017/09/hdu-1542/</link><pubDate>Wed, 27 Sep 2017 10:59:46 +0000</pubDate><guid>http://example.org/2017/09/hdu-1542/</guid><description>hdu1542题目链接
题意： 求n(100)个矩形的面积并。
思路： 扫描线+线段树
题目是2000年中欧区域赛的题目，虽然年代久远，但是有好几个点还是很值得学习的。
首先是离散化的适用范围: 之前比较常用的是将比较大的整数值离散化，常常是因为数值太大无法作为下标。 那么其实，浮点数有的时候也需要进行离散化，比如作为数组的下标，比如用来枚举。 做法上是和将较大的整数值离散化没有区别，因为遇到的题目不多，所以特意记录一下。 第二点是扫描线的思想：
其实扫描线的思想很早就接触过，noip2011的时候，tyvj上有一道类似的题目，不过是一唯的，当时印象深刻的是@Ocean 兄的那个比喻：
一段公路上右很多区间要收不同的费用，区间的开始给一个标记，表示该段区间对答案有贡献，区间的结束拿走该标记，表示该段区间对答案的贡献结束。
这就是扫描线的思想。
第三个是处理线段覆盖问题的一般做法：
通常线段树的节点处理的都是点，处理线段的时候就会比较麻烦。
这也是处理线段覆盖问题的通用方法。对于上面引用中提到的例子中“更新[1,4]，就相当于更新标号为[1,3]的线段”，是因为标号为1的节点代表区间[1,2]，标号为2的节点代表区间[2,3],标号为3的节点代表期间[3,4]
接下来具体讨论这道题目的做法：
将矩形按平行x轴方形构建扫描线（只是思想，不用实际构造），
每个矩形2条平行x轴的边分类{上边，下边}2类，如果我们从下往上“扫描”线，那么[下边]就表示了对答案贡献的开始，[下边]就表示了对答案贡献的结束。
* 扫描线扫描的过程（建议配合代码模拟） 初始状态
扫到最下边的线, 点1→3更新为1
扫到第二根线, 此时S=lcnt!=0∗h两根线之间, 得到绿色的面积, 加到答案中去, 随后更新计数
同上, 将黄色的面积加到答案中去
同上, 将灰色的面积加到答案中去
同上, 将紫色的面积加到答案中去
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 16时37分39秒 File Name :1542.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n; double X[N]; //存储所有x坐标，用来离散化。 //扫描线 struct Seg { double l,r,h; //表示扫面线的起点，终点，所在的高度(y坐标） int d;//1或者-1，表示扫描线对面积是正向影响还是负向影响 Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp;rhs)const { return h&amp;lt;rhs.</description></item><item><title>zoj 3606 Lazy Salesgirl (线段树，单点更新，区间合并)</title><link>http://example.org/2017/09/zoj-3606/</link><pubDate>Tue, 26 Sep 2017 12:52:37 +0000</pubDate><guid>http://example.org/2017/09/zoj-3606/</guid><description>zoj3606题目链接
题意：有个小女孩卖火柴,有n个人会来买，分别在时间t[i]，以价格p[i]，买的火柴个数为1+(k-1)%3,其中k为这是小女孩第几次卖火柴。 如果有大于w的时间没人来买火柴，小女孩就会睡着。小女孩睡着后如果有人来买火柴，那小女孩就会醒过来，但是不会卖给这个人火柴。现在问使营业额最大的基础上最小的时间间隔w。
思路： 显然，w应该是某2个顾客的来访时间只差（而不是什么任意值）.
因此我们可以通过枚举相邻访问时间的顾客的访问之间之差。
我们可以从小到大枚举w，这样就可以保证得到的最大营业额的对应w最小。
构造一颗线段树，维护4个域，cnt表示区间中，确实购买了火柴的顾客的人数，sum[i] (i属于0..2) 表示一个区间中最左边的顾客购买了i+1根火柴后，该区间的最大利润。
所以其实这道题类似hdu4288解题报告 
维护sum[i]的时候，右一点绕，需要注意对于tree[rt].sum[i]，我们只是说该区间的最左边的人买了(i+1)根火柴，该区间的其他人买了几根火柴无所谓，我们只想知道该区间的利润。
wa了一次。。因为虽然我们分析出w一定是某2个连续的时间的差值，一定是整数值，但是为了迷惑人。。题目还是要以6位小数输出。
/* *********************************************** Author :111qqz Created Time :2017年09月26日 星期二 18时32分43秒 File Name :3606.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int total; struct node { int p,t; int id; bool operator &amp;lt; (const node &amp;amp;b) const { return t&amp;lt;b.</description></item><item><title>hdu 4288 Coder (离散化， 线段树，单点更新，区间合并)</title><link>http://example.org/2017/09/hdu-4288/</link><pubDate>Tue, 26 Sep 2017 06:56:57 +0000</pubDate><guid>http://example.org/2017/09/hdu-4288/</guid><description>题目链接
题意：n（1E5）个操作，分为三种，add x表示将x加到集合中（保证集合中之前没有x)，del x表示从集合中删掉x(保证集合中一定右x),sum表示求集合中所有元素按从小到大排列后，所有的下标中满足i%5=3的a[i]的和。1=&amp;lt;x&amp;lt;=1E9
思路：很容易想到的是，由于插入和删除元素造成的位置改变是剧烈的，因此要分别维护i%5==k,k属于0..4的元素的和。
这道题的核心点在于，由于只有1E5个操作，我们可以将元素离散化，这样做的目的是，将每个数和位置一一对应，每个位置用1或者0，表示该位置对应的元素是否在集合中。
考虑线段树，维护6个域，1个是区间中，在集合中的元素个数，剩下5个域，分别表示以该区间的端点为位置1，位置x%i=k的元素的和（k属于0..4)。因此每个叶子节点都是位置1.
考虑PushUp, 区间元素和之间累加，难点在于其他5个域的维护。
假设当前区间为rt,那么对于sum[0..4] (sum代表的就是上面说的要维护的5个域），显然区间rt&amp;laquo;1的答案可以直接贡献给rt.
对于rt&amp;laquo;1|1的答案，考虑rt&amp;laquo;1|1中位置为%5==x的元素和，rt&amp;laquo;1中的元素个数为len个，那么rt&amp;laquo;1|1中sum[x]对 rt中的sum[(x+len)%5]有贡献。
反推出对rt 中 sum[i]有贡献的是rt&amp;laquo;1|1中的sum[(i-len+5)%5)]
/* *********************************************** Author :111qqz Created Time :2017年09月26日 星期二 12时42分10秒 File Name :4288.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; struct Node { int cnt; //区间中，在集合中存在的元素的个数。 LL sum[5]; //sum[i]表示该区间中，以区间起点为下标1开始计算时，位置为x%5==i时的元素的和。 }tree[N&amp;lt;&amp;lt;2]; struct Opt { int opt; LL val; }qu[N]; LL H[N],A[N]; int cnt; int Hash( int x) { return lower_bound(H,H+cnt,x)-H; } void PushUp( int rt) { tree[rt].</description></item><item><title>BZOJ 1012: [JSOI2008]最大数maxnumber (线段树,,单点更新)</title><link>http://example.org/2017/04/bzoj-1012/</link><pubDate>Sat, 01 Apr 2017 09:20:48 +0000</pubDate><guid>http://example.org/2017/04/bzoj-1012/</guid><description>1012: [JSOI2008]最大数maxnumber Time Limit: 3 Sec Memory Limit: 162 MB Submit: 9717 Solved: 4244 [Submit][Status][Discuss]
Description 　现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L 个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加 上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取 模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个 数。
Input 　第一行两个整数，M和D，其中M表示操作的个数(M &amp;lt;= 200,000)，D如上文中所述，满足D在longint内。接下来 M行，查询操作或者插入操作。
Output 　对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。
Sample Input 5 100 A 96 Q 1 A 97 Q 1 Q 2
Sample Output 96 93 96
思路:线段树即可&amp;hellip;.
只是为了回忆一下..发现线段树还是没有忘记的23333
/* *********************************************** Author :111qqz Created Time :2017年04月01日 星期六 16时37分55秒 File Name :code/bzoj/1012.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int N=2E5+7; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int m,D; int tree[N&amp;lt;&amp;lt;2]; //树最大为M个节点.</description></item><item><title>codeforces #381 div2 E. Alyona and towers (线段树 区间合并)</title><link>http://example.org/2016/11/cf740e/</link><pubDate>Mon, 28 Nov 2016 07:16:52 +0000</pubDate><guid>http://example.org/2016/11/cf740e/</guid><description>e:题意：那个数，定义hill为一段连续的区间，满足该区间为严格单峰。现在有若干操作，每个操作是对某段区间的数同时增加一个数，问每次操作后，所有的hill中，宽度最大的（区间长度最大）的是多少。
思路：同时增加一个数很线段树。。。但是要维护什么呢。。。？
_但是合并的时候要怎么办呢。。。__考虑两个方向的合并。。。__所以还要维护一个区间中，包含右端点的向左单调减延伸的长度，以及左端点的值。__同理，要维护一个区间中，包含左端点的向右单调增延伸的长度，以及右端点的值。__那么每次pushup的时候，就是两个区间hill的最大值，以及两个方向合并的最大值中取最大。。。__。。。上面是我口胡的。。。_upd:
口胡的还是有点靠谱的（并没有2333，还是漏了情况）
具体题解见代码注释
以及，为了过这道题先过了在岛老师空间题解中提到的两道题目：
hdu 3308 题目链接
hdu 5367题目链接
/* *********************************************** Author :111qqz Created Time :2016年11月27日 星期日 22时16分44秒 File Name :code/cf/#381/E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int a[N]; int n,m; struct Tree { LL lm,rm;//左右端点值。 int ans,len,upL,upR,downL,downR,maxL,maxR; /* 分别为 * ans:区间最优解 * len:区间长度 * upL,downL,maxL：包含左端点的递增，递减，山型的长度 * upR,downR,maxR: 包含右端点的递增，递减，山型的长度 */ Tree() { ans = len = upL = upR = downL = downR = maxL = maxR = lm = rm = 0; } Tree( int x) { ans = len = upL = upR = downL = downR = maxL = maxR = 1; lm = rm = x; } }; Tree operator + ( Tree x,Tree y) //x为左子树所表示的区间，y为右子树所表示的区间 { Tree res; if (x.</description></item><item><title>hdu 5367 digger(动态线段树，区间合并)</title><link>http://example.org/2016/11/hdu-5367-digger/</link><pubDate>Sun, 27 Nov 2016 08:59:09 +0000</pubDate><guid>http://example.org/2016/11/hdu-5367-digger/</guid><description>题目链接
题意：
地主小花有n座山，这些山在地主家门前排成一条直线。这些山一开始均有相同的高度。 每一天，小花都会要求ZJiaQ开挖机把几座山挖掉一定高度，或者给一些山堆上一些高度。并且要求报告ZJiaQ报告现在有多少座山属于“高山脉” 当一排山的高度相等，并且比这排山左边和右边的山要高时，这排山被称为高山脉。 当然，最左边和最右边的山不可能是“高山脉”的一部分 思路：线段树，要维护的域蛮多的。
下面高山脉简称&amp;quot;HM&amp;rdquo;
sum:区间中HM的总长度。
lsum,rsum,区间中包含左端点，右端点的高度相同的山的长度。
lh,rh：区间中包含左端点，包含右端点的的高度相同的山的高度。
llh,rrh:从左端点向右，从有段点向左的，第一个高度不相同的山的高度。
由于这道题n有1E9，没办法像以前的办法build 线段树，因此我们采用动态线段树的技巧。
官方题解：
关于动态线段树：
平时我们做的线段树，假设区间为[1,n]，那我们通常都是直接以 1 号点表示区间【1，n】，以 i2 号点表示 i 节点代表区间的左半区间，以 i2+1 号点表示 i 节点多代表区间的右半区间，一半空间长度都定义为4*n。
 在本题中，n比较大，直接将所有线段树中的所有节点定义出来不现实，那我们注意到，这道题实际上是对区间进行的一系列操作，那么就可能存在一个区间【l，r】，在所有处理过程中，该区间都可以被当做一个整体来看待。 如果是这样的话，我们定义出与该区间的子区间相对应的节点就没有意义了。
 动态生成线段树就是：假设对某一节点 p (代表区间【l，r】)进行处理时，并不是对整个区间[l，r]进行处理，而是对其某个子区间进行处理，那这个时候，该区间就不能一直被当做一个整体来看待，所以生成两个初始子节点lp、rp（节点之均为初始值），表示该区间的左半部分与右半部分，然后父节点 p 在对两个新生成的子节点进行更新。
/* *********************************************** Author :111qqz Created Time :2016年11月27日 星期日 14时45分27秒 File Name :code/hdu/5367.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int INF = 0x3f3f3f3f; const int N=5E4+7; int cur,root; int n,q,nnn; struct Tree { int sum;//高山脉的长度和 int child[2];//左右孩子的编号 int rsum,lsum;//从左端点，右端点其高度相同的连续的山有多少个。 int lh,rh;//左边连续，右边连续的山的高度。 int llh,rrh;//从左边往右第一个不连续，从右边往左第一个不连续的山的高度。 int lazy; void init(int l,int r) { sum = child[0] = child[1] = lh = rh = llh = rrh = lazy = 0; lsum = rsum = r-l+1; //初始所有高度相同，所以高度相同的连续的山的个数等于区间长度。 } }; struct SegmentTree{ Tree tree[N*60]; void check(int &amp;amp;rt,int l,int r) { //cout&amp;lt;&amp;lt;&amp;quot;rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; if (rt) return; rt=++cur; tree[rt].</description></item><item><title>hdu 3308 LCIS (线段树单点更新，区间合并)</title><link>http://example.org/2016/11/hdu-3308/</link><pubDate>Sat, 26 Nov 2016 11:21:26 +0000</pubDate><guid>http://example.org/2016/11/hdu-3308/</guid><description>题目链接
题意：长度为n的序列，单点更新，或者询问某一个区间中最长连续严格递增序列的长度是多少。（此处的连续为位置连续，并非数值连续，也就是3,5,7,9，这样的就是满足题意的长度为4的序列）
思路：线段树区间合并。维护三个域。
mx:区间中最长连续严格递增序列的长度
lm:包含区间左端点的最长连续严格递增序列的长度。
rm:包含区间右端点的最长连续严格递增序列的长度。
PushUp的时候，一个区间的答案显然可以从左右两个子区间的最大值得到。
还有一种可能是左右区间各取一部分，此时必须满足左区间的右端点值严格小于右区间的左端点值。
需要注意的是，如果某区间的最长连续严格递增子序列的长度等于区间长度，那么该区间可以向相应方向延伸。
查询的时候也是如此，要记得查询的时候，某一段区间对答案贡献不会超过区间长度。。
hdu有点坑。。。函数名不能命名为update&amp;hellip;update2也不行2333
/* *********************************************** Author :111qqz Created Time :2016年11月26日 星期六 18时12分49秒 File Name :code/hdu/3308.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; int a[N]; struct Tree { int mx,lm,rm; }tree[N&amp;lt;&amp;lt;2]; void PushUp(int rt,int l,int r) { tree[rt].</description></item><item><title>hdu 4747 Mex （线段树lazy标记）</title><link>http://example.org/2016/11/hdu-4747-mex-lazy/</link><pubDate>Sun, 13 Nov 2016 10:10:47 +0000</pubDate><guid>http://example.org/2016/11/hdu-4747-mex-lazy/</guid><description>题目连接
题意：给出n(n&amp;lt;=200000)个数，问所有区间[l,r]中mex的和。 （一个区间mex的定义为，这个区间中没有出现的最小的非负数）
思路：我们观察到mex(1,i)随着i增大，是不减的。(单调是线段树查询区间的时候非常好用的东西,这也是次题的突破口)
mex(1,i)可以O(n)维护出
现在我们考虑左端点向右移动对答案的影响。
当i移动到i+1时，此时序列中少了a[i]，设r为最小的x，满足a[x]=a[i]，那么当右断点在区间[r+1,n]，mex值是没有改变的。
当右端点属于[i+1,r-1]时，mex大于a[i]的会变成a[i]。
由于我们知道从1到某区间的mex值是单调的，那么mex大于a[i]的点必然是连续的一段。
我们可以知道最左边的q，满足mex(1,q)大于a[i]，然后将区间[q,r-1]成段更新为a[i]
因此整理思路，我们需要做两件事。
一个是每次区间求和，一个是找到最左边的q满足mex(1,q)大于a[i].
线段树维护三个域，max域，表示该区间中mex(1,i)的最大值；
sum域，表示该区间中mex(1,i)的和
lazy域，表示延迟标记。
可以预处理出nxt数组，表示位置i上的数下次出现最近是在nxt[i]
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; const int N=2E5+7; #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 typedef long long LL; int n; int a[N]; bool vis[N]; int Mex[N]; pair &amp;lt; int , int &amp;gt; b[N]; int nxt[N]; struct Tree { LL lazy; LL sum; LL mx; }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 240 F. TorCoder (线段树)</title><link>http://example.org/2016/10/cf240f/</link><pubDate>Wed, 05 Oct 2016 12:05:16 +0000</pubDate><guid>http://example.org/2016/10/cf240f/</guid><description>题目链接
题意：给一个仅由小写字母组成的字符串，然后m个操作，每个操作一个区间，要求把区间中排列成字典序最小的回文串，如果不能形成回文串，就忽略该操作。
思路：和上一道线段树优化计数排序的题目很像，几乎是一样的。
同样的，26棵线段树，每种字母对应一棵。
每次统计询问区间中每种字母的个数。
然后先判断是否能形成回文（奇数长度只有一个个数为奇数的，偶数长度不能出现个数为奇数的）
能的话重置区间，然后前后分别覆盖。
注意如果是奇数长度的话，记得先覆盖中间点。
需要注意这道题的输入输出方式不是标准的。。。而是要加文件。。。不然会MLE 1
然而Tle 19&amp;hellip;.Tle了好久。。。
最后换了种线段树的写法就过了。。。
然而后面这种写法就一定好么。。。。好像也不是。。。
总之是个挺玄学的东西。。。。不管了。。。
/* *********************************************** Author :111qqz Created Time :2016年10月05日 星期三 04时00分51秒 File Name :code/cf/problem/240F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #include &amp;lt;bits/stdc++.h&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+1; int tree[26][N*4]; int lazy[26][N*4]; int n,m; char st[N]; int cnt[26]; int L,R; inline bool scan_d(int &amp;amp;num) { char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!</description></item><item><title>codeforces 558 E. A Simple Task (线段树优化计数排序)</title><link>http://example.org/2016/10/cf558e/</link><pubDate>Tue, 04 Oct 2016 18:41:12 +0000</pubDate><guid>http://example.org/2016/10/cf558e/</guid><description>题目链接
题意：给出一个字符串，仅由小写字母组成。现在给出q个操作，每个操作l,r,k三个参数，k=1表示把区间[l,r]变为升序排列，k=0表示把区间[l,r]变为降序排列。
思路：首先，最重要的一点是，由于只有26个字母，联想到计数排序。
对于字符集数目比较小情况，一定要想到计数排序。
对于字符集数目比较小情况，一定要想到计数排序。
对于字符集数目比较小情况，一定要想到计数排序。
那么我们回顾计数排序，不妨考虑升序排列的情况，是怎么做的呢？
做法是统计该区间中每种字符的个数，然后按照字符的大小，从小到大在区间上从左到右得放置每种字符。
大概是这样子：
for(int j=x;j&amp;lt;=y;j++) cnt[s[j] - 'a']++; ind = 0; for(int j=x;j&amp;lt;=y;j++) { while(cnt[ind] == 0) ind++; s[j] = ind + 'a'; cnt[ind]--; } 然而这个复杂度每次是o(n)的。。。
我们需要用线段树来优化计数排序的过程。。。
思考计数排序其实分为两个过程：
一是统计某区间中每个字符的个数。
二是将字符按照字符的大小顺序重新放回区间。
我们可以建26棵线段树，一种字母对应一棵。
对于过程一，我们可以直接query.
对于过程2，由于相同的字母总是相邻在一起的，因此可以用线段树成段更新来优化，也就是lazy标记。
tree[id][rt]表示第id棵线段树对应的区间中字母id+'a&amp;rsquo;-1的个数。
lazy[id][rt]三种值，-1表示没有标记，0表示重置标记，1表示被某种字母覆盖的标记。（重置的意思是，该区间被排序了，但是还不确定该区间上字母是哪些）
输出的时候，对于某个位置，只要query到26个字母中值不为0的那个输出就好了。
总的复杂度：O(26qlgn)
代码注释中还有部分细节和理解
/* *********************************************** Author :111qqz Created Time :2016年10月04日 星期二 23时59分11秒 File Name :code/cf/problem/558E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;bitset&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int tree[27][N&amp;lt;&amp;lt;2];//26棵线段树，表示26个字母在对应区间中的个数。 int lazy[27][N&amp;lt;&amp;lt;2];//lazy存储的是某段区间是否被某个字母覆盖.</description></item><item><title>codeforces 145 E. Lucky Queries (线段树lazy标记)</title><link>http://example.org/2016/09/cf145e/</link><pubDate>Tue, 27 Sep 2016 11:15:53 +0000</pubDate><guid>http://example.org/2016/09/cf145e/</guid><description>题目链接
题意：给出一串只由数字'4'和'7'组成的串。两种操作，一种是询问整个串中最长非下降子序列的长度，另一种给出区间[l,r]，将区间中的没个数反转，反转的定义为，4变成7,7变成4.
思路：线段树lazy标记。
线段树的域记录5个信息，c4,c7,c47,c74，flip,a分别表示4的个数,7的个数，非下降子序列的个数，非上升的子序列的个数，以及该区间是否被翻转。
纠结了很久PushUp操作。。。。
c4和c7倒是没什么疑问。。。。
一开始觉得c47是由三部分的最大值更新得到的。。。
left.c4+right.c47,left.c4+right.c7,left.c47+right.c7&amp;hellip;
但是样例过不了。。。
纠结了半天发现。。。
比如4774,4444是左右两个区间的时候。。。。
c47最大是5.。。但是left.c4 + right.c7=6，比正确答案大。
原因是。。一个区间中4的位置可能是分散的。。。这样只有某段连续出现的4对答案的贡献是正确的。。。
所以只有区间长度为1的时候c4+c7的更新方式才是合法的。。。
我们不妨在初始化的时候。。。。在线段树的叶子节点直接设置c47为1（当然相应地c74也要为1）
另外一个收获是。。。线段树对于区间的操作（对于点的操作也是同样）
不一定是某种常见的定义过的操作（求和啊，最大值最小值啊之类的）
也可能是某种自定义的操作。。。
比如这道题中的flip操作。。。
就是对区间的一个自定义的操作。。。
/* *********************************************** Author :111qqz Created Time :Tue 27 Sep 2016 09:14:22 AM CST File Name :code/cf/problem/145E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N = 1E6+7; int n,m; char st[N]; struct node { int c7,c4,c47,c74; bool flip; void out() { printf(&amp;quot;c4:%d c7: %d c47 :%d c74 : %d\n&amp;quot;,c4,c7,c47,c74); } }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 52 C. Circular RMQ (线段树区间更新，区间询问)</title><link>http://example.org/2016/09/cf52c/</link><pubDate>Sun, 25 Sep 2016 22:43:40 +0000</pubDate><guid>http://example.org/2016/09/cf52c/</guid><description>题目链接
题意：一个循环数列，两种操作，一种是把某段区间中加上v，另一种是询问某区间的最小值。对于每个询问，输出答案。
思路：区间更新+区间询问的模板题&amp;hellip;.
注意体会pushdown以及update的时候。。。
要同时更新tree数组和lazy数组。。。
读入的时候可以用sscanf判断操作类型。。。
/* *********************************************** Author :111qqz Created Time :Mon 26 Sep 2016 05:30:21 AM CST File Name :code/cf/problem/52C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; LL a[N]; LL tree[N&amp;lt;&amp;lt;2]; LL lazy[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt] = min(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void PushDown( int rt) { if (lazy[rt]) { lazy[rt&amp;lt;&amp;lt;1] += lazy[rt]; lazy[rt&amp;lt;&amp;lt;1|1] +=lazy[rt]; tree[rt&amp;lt;&amp;lt;1] +=lazy[rt]; tree[rt&amp;lt;&amp;lt;1|1] +=lazy[rt]; lazy[rt] = 0; } } void build( int l,int r,int rt) { if (rt) if (l==r) { tree[rt] = a[l] ; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } void update(int L,int R,LL sc,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) { lazy[rt] +=sc; tree[rt] +=sc; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,sc,lson); if (R&amp;gt;=m+1) update(L,R,sc,rson); PushUp(rt); } LL query( int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; LL ret = 1LL&amp;lt;&amp;lt;60; if (L&amp;lt;=m) ret = min(ret,query(L,R,lson)); if (R&amp;gt;=m+1) ret = min(ret,query(L,R,rson)); return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 455 E. Function (斜率优化，线段树套凸包)</title><link>http://example.org/2016/09/cf455e/</link><pubDate>Sun, 25 Sep 2016 16:10:49 +0000</pubDate><guid>http://example.org/2016/09/cf455e/</guid><description>题目链接 题意：已知 f(1, j) = a[j] f[i][j] = min (f[i-1][j],f[i-1][j-1]) 然后给出 n n≤1E5​​ 个数（a[i] a​i​​≤1E4​​)，给出 m组查询（m&amp;lt;=1E5），每组两个数 x,y 问 f(x,y) 是多少。
参考题解：茶姐的回答（下标好像搞错了，领会意思即可
官方题解
以及前置技能点是：斜率优化+线段树
思路：考虑一排数a[1]到a[n]，原问题可以转化成从a[y]走x-1步，每一步原地不动或者向左移动一个格子后的总的代价。
Function is calculated as follows: , k__i — how many times we visited the i th element of the array a.
这个式子感觉不是很明确。。。。
窝来解释一下。。。l=y-x+1是可能走到的最左边的点。。。。
终点在【L,Y】区间内都是合法的。。。。
然后考虑代价最小的情况。。。
一定是在最小的格子上尽可能多得停留，在其他格子上只停留一次。。。
对于终点为l的情况，走到y要花费y-l步,一共要走x-1步，那么多出来x-1-(y-l)步，这些步停留在最小的点上是最优的，最小的点上之前停留了一次，现在再多停留x-1-(y-l)次，也就是停留了x-(y-l)次。
那么，另一个结论是，区间[l,y]中，当a[l]为最小的时候才是最优的。。。
为什么呢？
假设a[k] (k&amp;gt;l)是最小，那么以a[k]为终点的情况一定比以a[l]为终点的情况优秀（因为多走了【l,k-1】之间的点。。。走这些点比停留在a[k]的代价大）
因此对于l是终点的情况，一定在a[l]是最小值的时候是最优的。
此时代价为：
sum[y] - sum[l] + a[l]·(x - (y - l))
我们变形得到：
sum[y] - sum[l] + a[l]·(x - (y - l)) = sum[y] - sum[l] + a[l]·(x - y + l) = sum[y] - sum[l] + a[l]·l + a[l]·(x - y) = sum[y] + (a[l]·(x - y) + a[l]·l - sum[l])</description></item><item><title>codeforces 380 C. Sereja and Brackets (线段树区间合并)</title><link>http://example.org/2016/09/cf380c/</link><pubDate>Fri, 23 Sep 2016 10:38:51 +0000</pubDate><guid>http://example.org/2016/09/cf380c/</guid><description>题目链接 题意：给出一个由‘(’和‘）’组成的字符串。。。然后给出若干查询。。。每个查询一个区间，问区间中能匹配的括号数。。。
思路：考虑某一个区间中的括号匹配。。。其实是一个不断寻找&amp;rsquo;()&amp;lsquo;然后删去的过程。。。
因此对于某个区间的括号匹配数。。。等于左边区间和右边区间和合法匹配数之和，再加上左区间和右区间新的能匹配到一起的括号数。
（说“因此”是因为。。。只要左边有没匹配的左括号。。。右边有没匹配的右括号。。。因为他们中间有的都是匹配好的括号，会被删除。。。所以两边的括号总能匹配在一起）
具体做法是：
线段树的节点中有三个域，分别表示，合法的括号匹配数，没有被匹配的左括号数，和没有被匹配的右括号数。
query的时候要合并左右两个区间。。。不过可能某一区间中为空。。。这里合理得初始化为node(0,0,0)，就不用分情况讨论了。。。
一个和node(0,0,0)合并对原来的答案没有影响。。。。
以及，凡是需要在query的时候合并区间的问题。。。（不是那种简单的sum,min/max合并）
返回一个node会方便很多。。。。。
/* *********************************************** Author :111qqz Created Time :Fri 23 Sep 2016 05:32:22 PM CST File Name :code/cf/problem//380C.cpp ************************************************ */ #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; struct node { int left,right,sum; node (){} node ( int x,int y,int z): left(x),right(y),sum(z){}; }tree[N&amp;lt;&amp;lt;2]; char st[N]; int n; void PushUp( int rt) { int add = min(tree[rt&amp;lt;&amp;lt;1].</description></item><item><title>poj 2886 Who Gets the Most Candies? （线段树模拟加强版约瑟夫问题+反素数)</title><link>http://example.org/2016/09/poj-2886/</link><pubDate>Wed, 21 Sep 2016 17:03:08 +0000</pubDate><guid>http://example.org/2016/09/poj-2886/</guid><description>poj 2886 题目链接
题意：n个人围成一圈，每个人身上由一个数，可正可负。从第k个人开始出圈，如果第k个人身上的数是X,X&amp;gt;0，就左边第x个没有出圈的人出圈，否则右边第-X个人出圈。 第k个人出圈得到的糖果数目为f(k)，f(x)表示x的因子个数。现在问谁能拿到最多的糖果，并且拿到了多少糖果。
思路：看起来好像很麻烦。。其实可以分解成两个问题。
第一个子问题就是约瑟夫问题的加强版。。。每次间隔不是定数，而取决与上一次出队的人。。。
终点是数据有5E5.。。模拟的话会炸掉。。。所以用线段树来模拟这个过程。。。
类似于那道插队的问题。。。线段树的域存的是某区间中空位置的数量。。初始为1.。。
然后每次update的时候优先查看左子树。。。
第二个子问题就是。。。到底第几个出去的人那道的糖果最多。。。。
其实也就是求1..n中。。。因子数最大的那个。。。
利用反素数表。。。每次upper_bound一下即可。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 09:19:11 PM CST File Name :code/poj/2886.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E5+7; int tree[N&amp;lt;&amp;lt;2]; int n,k; char nam[N][11]; int val[N]; int s[40] = {1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,500001}; int b[40] = {1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200}; void PushUp( int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void build( int l,int r,int rt) { if (l==r) { tree[rt] = 1; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } int update( int p,int l,int r,int rt) { if (l==r) { tree[rt]--; return l; } int m = (l+r)&amp;gt;&amp;gt;1; int ret; if (p&amp;lt;=tree[rt&amp;lt;&amp;lt;1]) ret = update(p,lson); else ret = update(p-tree[rt&amp;lt;&amp;lt;1],rson); PushUp(rt); return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #609 F. Frogs and mosquitoes (线段树+二分)</title><link>http://example.org/2016/09/codeforces-609-f-frogs-and-mosquitoes-/</link><pubDate>Tue, 20 Sep 2016 17:48:18 +0000</pubDate><guid>http://example.org/2016/09/codeforces-609-f-frogs-and-mosquitoes-/</guid><description>题目链接
题意：n只青蛙，第i只位于x[i],舌头长度为t[i]。m只蚊子，第i只蚊子所在位置为p[i],蚊子的大小为b[i]。
蚊子按照出现顺序输入。
一只青蛙能吃到蚊子当且仅当蚊子和青蛙在同一个位置，或者蚊子在青蛙右边并且与青蛙的距离小于等于该青蛙舌头的长度。
当多只青蛙可以吃到同一只蚊子的时候，最左边的那只青蛙来吃。
当一只青蛙吃掉一只蚊子以后，青蛙的舌头增加蚊子的大小。
当一只青蛙吃掉一只蚊子后，因为舌头边长而又能吃到其他蚊子的时候，这只青蛙会继续吃，只到当前没有蚊子可以被任何一只青蛙吃到，在这个过程之后才会飞来下一只蚊子。
思路：问题的关键在于，对于某只蚊子，我们如何找到能吃到该蚊子的青蛙中最左边的那只。
可以抽象成寻找区间[1,r]中，最左边的那个&amp;gt;=x的元素。
联想到一个类似的问题：对于区间[1,n]，找到最左边的&amp;gt;=x的元素。做法是线段树维护最大值，只需要每次先query左子树，就可以保证找到额是最左边的。
但是如果是区间[1,r]呢。。。
我们发现。。。区间[1..k] (k&amp;lt;=r)的最大值是随着k的增大而不减的。。。。（最大值。。。肯定不减呀）
也就是说是单调的。。。因此我们可以考虑二分。。。这很重要。。。
寻找区间[1，r]中第一个大于等于x的元素，利用单调性来二分做是一个很经典的做法，复杂度(lgn)^2,注意体会。
因此具体做法是：
建树，存的是区间中x[i]+t[i]的最大值。
对于每一只飞来的蚊子，寻找能吃到它的最左边的青蛙的编号（具体做法是，先找到最后一个位置小于等于蚊子位置的青蛙的下标，作为青蛙的下标的上界，然后二分，每次query区间最大值，不断缩小区间。）
当蚊子被吃的时候记录答案，更新青蛙的各种信息（线段树要update)
并且由于青蛙的舌头变长了，可能吃到之前没有青蛙能吃到的蚊子，因此要把之前的没有能被青蛙吃到的蚊子存进一个multiset(因为蚊子可能落在同一个位置） 然后让当前的青蛙尽可能吃这些没有被吃到的蚊子，同时更新青蛙的各种信息，并在multiset中删除这只蚊子/
没被吃的时候就扔进multiset里。
需要注意multiset erase的时候要erase一个迭代器。。。不然会把所有相同的都删掉。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 12:30:16 AM CST File Name :code/cf/problem/609F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; LL ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; struct node { LL x,t; LL sum; int id; bool operator &amp;lt; (node b)const { return x&amp;lt;b.</description></item><item><title>codeforces 540 E. Infinite Inversions (分类思想+线段树求逆序对)</title><link>http://example.org/2016/09/cf540e/</link><pubDate>Tue, 20 Sep 2016 12:07:02 +0000</pubDate><guid>http://example.org/2016/09/cf540e/</guid><description>题目链接
题意：一个无穷数列，从1开始，初始第i个位置上为i，给出n个swap，每次交换两个位置的数。问交换n次以后得到的数列中，逆序对的数。
思路：
官方题解：
2
2 6
4 8
The global sequence will look as follows: [1 6 3 8 5 2 7 4 9 &amp;hellip;], and here is the array of swapped elements: [6 8 2 4].
Let's understand with which numbers the number 8 forms the inversions. The only elements that could do that are the elements between the initial position of the number 8 (where the number 4 is now) and its current position: [5 2 7].</description></item><item><title>codeforces 515 E. Drazil and Park ( 线段树区间合并)</title><link>http://example.org/2016/09/cf515e/</link><pubDate>Mon, 19 Sep 2016 10:54:47 +0000</pubDate><guid>http://example.org/2016/09/cf515e/</guid><description>题目链接
题意：圆上，询问任意一段弧中，任意两点的距离+两点的权值和的最大值。
思路：
1.环先拆成串，复制1..n到后面，变成1..2n。
化简公式：
2 * h[u] + 2 * h[v] + dist(u, v) = 2 * h[v] + d[1] + d[2] + &amp;hellip; + d[v-1] + 2 * h[u] - (d[1] + d[2] + &amp;hellip; + d[u-1]).
设A[v] = 2 * h[v] + d[1] + d[2] + &amp;hellip; + d[v-1], B[u] = 2 * h[u] - (d[1] + d[2] + &amp;hellip; + d[u-1]).
Another important thing is that L__u + R__v always bigger than L__v + R__u when u &amp;lt; v.</description></item><item><title>codeforces #351 D. Jeff and Removing Periods (线段树/树状数组判断位置成等差数列)</title><link>http://example.org/2016/09/cf351d/</link><pubDate>Sun, 18 Sep 2016 13:53:39 +0000</pubDate><guid>http://example.org/2016/09/cf351d/</guid><description>题目链接 题意：有n个数，每次可以删除掉数值相同并且所在位置成等差数列（只删2个数或者只删1个数应该也是可以的），删掉这些数以后可以将剩下的数重新以任意顺序排列，称为一次操作。现在给出m个询问，每个询问一个区间[l,r]，问删光区间[l,r]中的数最少需要的操作次数。
思路/题解：由于第一次操作之后可以重排，那么把相同的数放在一起得到一个位置的公差为1的等差数列，之后的答案显然是元素个数。所以需要判断初始的时候，是否能一次删光某个数值的数，也就是需要判断初始时刻是否有某个数出现的所有位置组成一个等差数列。
(去icpc-camp的论坛问了一波。。。链接在这里)
之前刚刚学了判断一个区间中不同的数有多少个的姿势。。。
所以问题就在于如何判断这个等差数列。。。
参考叉姐的思路，我的思路如下：
上面是判断一种数的情况。。。我要找到一种数满足题意即可。。
具体做法：
顺便说一句：叉姐人真的好nice啊。。本来昨天大概找了大半天题解。。看了代码也没看懂。。。
然后晚上去icpc-camp的论坛上问了一波。。。
然后茶姐的回复窝仍然看不懂。。。。。
感觉窝问的应该不是什么困难的问题（虽然我想了好久都想不出）。。。
所以纠结了好久要不要再问一下叉姐。。。。
最后还是问了。。。结果叉姐非常热心而又详细地回答了我。。。。
真是让我这种蒟蒻感动不已啊。。。。orz
怪不得人人爱叉姐。
/* *********************************************** Author :111qqz Created Time :Sun 18 Sep 2016 08:30:02 PM CST File Name :code/cf/problem/351D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int a[N],pre[N],lst[N]; int n,m; int tree[N&amp;lt;&amp;lt;2]; int t[N]; int ans[N]; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (r==b.</description></item><item><title>spoj DQUERY - D-query (询问区间中不同数的个数，线段树(离线) or 莫队算法（离线） or 主席树（在线）)</title><link>http://example.org/2016/09/spoj-dquery/</link><pubDate>Sat, 17 Sep 2016 12:01:43 +0000</pubDate><guid>http://example.org/2016/09/spoj-dquery/</guid><description>题目链接 题意：给出n个数，然后m个询问，每个询问一个区间[l,r],问该区间中不同的数有多少个。
思路：离线处理+线段树的做法不多说了：
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 11:34:32 PM CST File Name :code/spoj/dquery.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E4+7; const int M=2E5+7; int n,Q; int a[N]; int tree[N&amp;lt;&amp;lt;2]; map&amp;lt;int,int&amp;gt;mp; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (r==b.</description></item><item><title>codeforces 338 E. Optimize! (线段树维护最小前缀和）</title><link>http://example.org/2016/09/codeforces-338-e-optimize/</link><pubDate>Fri, 16 Sep 2016 10:13:51 +0000</pubDate><guid>http://example.org/2016/09/codeforces-338-e-optimize/</guid><description>题目链接
题意：题意是由伪代码给出的。。手算模拟了一下(noip初赛即视感），题意大概是说，给出两个数组a和b，a数组长度为n,b数组长度为len,然后从a中截取连续的len个元素，称为数组s，如果存在一种方法使得s中元素和b中的元素一一对应且每组和都大于等于h,则称这个s是合法的。现在问a中有多少个合法的s。 具体来说，对于样例 5 2 10 5 3 1 8 5 5 7
s={8,5}和s={5,7}是有解的。 因为对于前者8+3&amp;gt;=10并且5+5&amp;gt;=10,对于后者5+5&amp;gt;=10,7+3&amp;gt;=10,因此答案为2 思路：
最重要的一部是，我们先将b排序，然后维护一个函数f[i],在排序后的b中找到一个最小的j，满足a[i]+b[j]&amp;gt;=h,然后让f[i]=j?
f[i]直接二分就可以得到。。
因为f[i]的值是使得a[i]满足条件的最小的b值。
然后我们观察发现。
f[i]大于等于len的元素个数最多有1个，不然无解。
f[i]大于等于len-1的元素个数最多有2个，不然无解。
f[i]大于等于i的元素个数最多由len+1-i个，不然无解。
设g[i]=len+1-i-sum[i],sum[i]=y[i]+y[i+1]+&amp;hellip;+y[len]。
如果某个s中，对于所有的i，都有g[i]&amp;gt;=0，那么这个s就是合法的。
实际上我们没有必要去查询每个g[i]，只要g[i]中最小的大于等于0，那么这个s就是合法的。
现在的问题就变成了动态维护一段长度为len的最小后缀和。
我的思路是整体覆盖，
当a数组的区间从[l,r]到[l+1,r+1]的时候，增加了a[r+1],假设f[r+1]=p,那么用线段树更新区间[1,p]，都增加1. 减少了a[l],假设f[l]=q,那么同样用线段树维护，使得区间[1,q]都减少1.
讲道理应该也可以做吧。。。
不过被羊神@sheep教育说其实单点更新就可以。。。
于是去学了下动态维护区间最大子段和的线段树做法： bzoj 1756解题报告hit oj 2687 解题报告
然后单点更新维护最大后缀和就很容易了。
类似的做法，我们也维护一个最小前缀和。初始化的时候把1..len赋值成-1.
然后每次移动区间，从【l,r】移动到[l+1,r+1]的时候，将f[r+1]添加1，将f[l]减少1.
这样如果某个s中的任意前缀和都是等于0的，那么这个s就是合法的。
因此我们只需要维护最小前缀和。
代码是维护的最小前缀和
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 05:13:38 PM CST File Name :code/cf/problem/338E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=150005; int n,len,h; int a[N],b[N],f[N]; struct Tree { int mn;//最小前缀和 int sum;//区间和 }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>BZOJ 1756: Vijos1083 小白逛公园　 （线段树维护单点修改区间查询最大子段和）</title><link>http://example.org/2016/09/bzoj-1756/</link><pubDate>Thu, 15 Sep 2016 21:51:33 +0000</pubDate><guid>http://example.org/2016/09/bzoj-1756/</guid><description>1756: Vijos1083 小白逛公园 Time Limit: 10 Sec Memory Limit: 64 MB Submit: 1078 Solved: 353 [Submit][Status][Discuss]
Description 小新经常陪小白去公园玩，也就是所谓的遛狗啦…在小新家附近有一条“公园路”，路的一边从南到北依次排着n个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。 一开始，小白就根据公园的风景给每个公园打了分-.-。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第a个和第b个公园之间（包括a、b两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。 那么，就请你来帮小白选择公园吧。
Input 第一行，两个整数N和M，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。 接下来N行，每行一个整数，依次给出小白 开始时对公园的打分。 接下来M行，每行三个整数。第一个整数K，1或2。K=1表示，小新要带小白出去玩，接下来的两个整数a和b给出了选择公园的范围（1≤a,b≤N）；K=2表示，小白改变了对某个公园的打分，接下来的两个整数p和s，表示小白对第p个公园的打分变成了s（1≤p≤N）。 其中，1≤N≤500 000，1≤M≤100 000，所有打分都是绝对值不超过1000的整数。
Output 小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。
Sample Input 5 3 1 2 -3 4 5 1 2 3 2 2 -1 1 2 3
Sample Output 2 -1
题意：中文题面，不多说。
思路：关于维护最大子段和的问题，做法同
hitoj2687题解
但是和上面这道题不同的是，每次询问的是某个区间的最大字段和，而不是整个区间的最大子段和。
我们的做法是，将查询的区间拆成若干个区间，然后按照pushup中的方法合并。
一个技巧是query的时候返回一个结构体，这样会比较好写。
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 03:15:50 AM CST File Name :code/bzoj/1756.</description></item><item><title>hit oj 2687 Candy (线段树动态维护最大连续子段)</title><link>http://example.org/2016/09/hit-oj-2687-candy/</link><pubDate>Thu, 15 Sep 2016 21:04:48 +0000</pubDate><guid>http://example.org/2016/09/hit-oj-2687-candy/</guid><description>题目链接
题意：给出n个数,m个修改，每次修改后询问整个区间的最大连续子段。
思路：考虑一段区间，分成左右两个子区间，这段区间的最大子段有三种情况：只在左区间中，只在右区间中，既在左区间中又在右区间中。前两种很好维护，对于后一种，我们新增加线段树的两个域，mxl,mxr，分别表示一个区间中包含左端点在的最大字段和（也就是最大前缀和），和一个区间中包含右端点在的最大子段和（也就是最大后缀和），然后对于最大子段既在左区间又在右区间的情况，只需要合并【左区间的最大后缀和 】和【右区间的最大前缀和】就好。
关于一个区间最大前缀和的维护，取该区间的左区间的最大前缀和和【该区间的左区间和】+【该区间的右区间的最大前缀和】的最大值。
最大后缀和同理。
这是一种很经典的做法，注意体会。
1A
/* *********************************************** Author :111qqz Created Time :Fri 16 Sep 2016 04:01:49 AM CST File Name :code/hitoj/2687.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,m; struct { int mx; int mxr; int mxl; int sum; }tree[N&amp;lt;&amp;lt;2]; void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 501 D Misha and Permutations Summation (康托展开+康托逆展开+factorial_number_system+线段树×2)</title><link>http://example.org/2016/09/codeforces-501-d-misha-and-permutations-summation-factorial_number_systemx2/</link><pubDate>Wed, 14 Sep 2016 07:05:21 +0000</pubDate><guid>http://example.org/2016/09/codeforces-501-d-misha-and-permutations-summation-factorial_number_systemx2/</guid><description>题目链接
题意：给出两个排列，定义ord(p)为排列p的顺序（字典顺从小到大），定义perm(x)为顺序为x的排列，现在要求1 ≤ n ≤ 200 000
思路：首先去学了一下康托展开和逆展开。。。其实就是对于这种排列之类的问题。。。的一个比较省空间的hash函数。。。？
康托展开资料
然后由于n非常大。。康托展开中要查找当前位置后面有多少个比当前位置小的。。。
然而这复杂是n2。。。肯定gg。。。
因此里面那层我们用一课线段树维护。。。复杂度nlgn
在康托逆展开的过程中。。。我们要查询之前没有出现过的第k个元素。。。。
因为n很大这里也需要线段树来维护。。。
所以再建一棵线段树。。。某位置表示初始时刻是否为空，初始都为1，表示都没有出现。思想类似于poj 2828 poj 2828解题报告
然后还是由于n很大。。。在康托展开中的阶乘部分。。。完全存不下。。。
直接用高精度应该也能做？
不过比较推荐的做法是： The Factorial Number System wiki_Factorial number system
是一种和阶乘相关的进制表示法。
大概就是不同位置上的权值，不像一般的k进制数，是k^0,k^1,k^2&amp;hellip;.
而是0!,1!,2!。。。
这种表示合法的正确性基于：
1*1! + 2*2! + 3*3! + ... + k*k! = (k+1)! - 1 具体参见上面两个链接。
因为我们可以把所有康托展开都用 Factorial number system来表示。
/* *********************************************** Author :111qqz Created Time :Tue 13 Sep 2016 04:33:55 PM CST File Name :code/cf/problem/501D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n ; int tree[N&amp;lt;&amp;lt;2]; int fac[N]; int A[N],B[N]; int ans[N]; void PushUp(int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson); else update(p,rson); PushUp(rt); } int query(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0 ; if (L&amp;lt;=m) { int res = query(L,R,lson); ret +=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson); ret +=res; } return ret; } void Contor(int A[])//https://en.</description></item><item><title>light oj 1080 Binary Simulation (线段树lazy标记，区间更新，单点查询)</title><link>http://example.org/2016/09/light-oj-1080-binary-simulation-lazy/</link><pubDate>Tue, 13 Sep 2016 17:41:49 +0000</pubDate><guid>http://example.org/2016/09/light-oj-1080-binary-simulation-lazy/</guid><description>题目链接
题意：给出一个长度为n的数列，每个位置是0或者1，给出q个操作，操作有两种类型，分别是将一段区间中反转，和询问当前某位置是0还是1
思路：lazy标记。lazy[i]记录以i节点为根节点的子树对应的区间中被翻转的次数，初始为0.然后查询的时候，根据被翻转次数的奇偶性确定答案。
wa了好多发。。。比较致命的是。。PushDown函数忘记改了。。。还按照染色的方法直接赋值的。。。然而这里是统计次数。。。所以是累加。。。。
/* *********************************************** Author :111qqz Created Time :Wed 14 Sep 2016 12:59:07 AM CST File Name :code/loj/1080.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int lazy[N&amp;lt;&amp;lt;2];//记录翻转次数 int n; string st; int a[N]; void PushDown( int rt) { if (lazy[rt]) { lazy[rt&amp;lt;&amp;lt;1] +=lazy[rt]; lazy[rt&amp;lt;&amp;lt;1|1]+=lazy[rt]; lazy[rt] = 0; } } void build(int l,int r,int rt) { if (l==r) { lazy[rt] = 0; return; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); } void update(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) { lazy[rt]++; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,lson); if (R&amp;gt;=m+1) update(L,R,rson); } int query( int p,int l,int r,int rt) { if (l==r) return lazy[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; //int res; if (p&amp;lt;=m) query(p,lson); else query(p,rson); // return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 356 A. Knight Tournament (线段树lazy标记，倒序处理)</title><link>http://example.org/2016/09/cf356a/</link><pubDate>Tue, 06 Sep 2016 19:19:11 +0000</pubDate><guid>http://example.org/2016/09/cf356a/</guid><description>思路：由于先前被打败的骑士直接就退场了。。。所以如果不做判断。。那么之后胜利的骑士会干扰之前的结果。。。
可以在pushdown的时候加判断。。。
不过我觉得比较好的做法是。。。倒序处理。。。。
倒序处理。。。后处理的直接覆盖先处理的结果。。。因为后处理的在之前。。优先级更高。。。被覆盖掉的骑士其实应该是退场的。。。
倒序处理就避免了判断的问题。。。完美。。。
/* *********************************************** Author :111qqz Created Time :Wed 07 Sep 2016 02:13:55 AM CST File Name :code/cf/problem/356A.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=3E5+7; int n,m; struct node { int l,r,x; }q[N]; int lazy[N&amp;lt;&amp;lt;2]; void PushDown( int rt) { if (lazy[rt]) lazy[rt&amp;lt;&amp;lt;1]=lazy[rt&amp;lt;&amp;lt;1|1]=lazy[rt]; lazy[rt] = 0; } void update(int L,int R,int sc,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) { lazy[rt] = sc; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,sc,lson); if (R&amp;gt;=m+1) update(L,R,sc,rson); } int query(int p,int l,int r,int rt) { if (l==r) return lazy[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) query(p,lson); else query(p,rson); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 292 E. Copying Data (染色问题，线段树lazy标记模板题)</title><link>http://example.org/2016/09/cf292e/</link><pubDate>Tue, 06 Sep 2016 13:57:54 +0000</pubDate><guid>http://example.org/2016/09/cf292e/</guid><description>x题目链接
题意：给出两个数组，每个数组n个数，分别为a和b,给出m个操作，操作有两种类型，第一种是给出x,y,k,表示从a数组的x坐标开始复制k个数到b数组的y到y+k-1。
第二种操作是给出x，询问当前b[x]是多少。
对于每个第二种操作，输出结果。
思路：第一次写lazy标记的线段树。
今天突然就顿悟了。。。其实lazy标记的思想大概就是。。
对于某段区间的更新，如果没有查询到这段区间中任何一个数的时候。。。那么这个更新其实是无所谓的。。。
（让我想到了那个脑洞，就是整个世界都是一段程序，为了让你不察觉异常并且耗费尽量少的资源，所有场景只有在有人观测的时候才会被加载，不观测就用很少的资源随便处理一下233）
所以lazy标记，也叫延迟标记，就是只有当查询到某个节点的时候，才去把之前的修改更新，不然不更新（就好像有人观测的时候，上帝才把某个场景的代码写出来）
这道题除了延迟标记这个点外，还用到了染色问题的经典做法。
所谓染色问题，这里说的是一种区间覆盖问题，每次用一个颜色覆盖某段区间，最后询问某一点是什么颜色（大概是这样&amp;hellip;?
回到这道题，具体做法是，记录每次覆盖操作的位移差，然后用线段树维护某个点最后被覆盖的时间（也可以形象得说被染成了什么颜色，染的颜色种类和时间对应）
这样，每次询问b[x]的时候，我们可以查询x位置最后是被染成了什么颜色，然后根据之前记录的位移差信息，就可以得到相应的答案。
这是一种经典做法，这类问题具有一定普遍性，注意体会。
以及，之前对lazy标记有一个错误得认识，以为lazy是基于线段树本身数组的一个辅助数组。。。但是做完这道题后感觉。。。
之前写的单点更新的线段树数组tree和现在的lazy标记的数组应该是同等地位。。。。PushDown和PushUp大概也是同等地位。。。就是说。。。可以只出现PushDown和lazy数组不出现PushUp和tree.
还有一些写法上的注意，见代码注释。
/* *********************************************** Author :111qqz Created Time :Tue 06 Sep 2016 08:41:03 PM CST File Name :code/cf/problem/292E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int lazy[N&amp;lt;&amp;lt;2];//lazy[i]记录的信息是以i节点为根节点的子树所表示的区间被覆盖的时间。 int n,m; int q[N]; //记录覆盖信息，q[i]表示第i个覆盖的位移差。 int a[N],b[N]; void PushDown( int rt) { if (lazy[rt]) lazy[rt&amp;lt;&amp;lt;1]=lazy[rt&amp;lt;&amp;lt;1|1]=lazy[rt]; lazy[rt] = 0; } void update(int L,int R,int sc,int l,int r,int rt) { if (L&amp;lt;=l &amp;amp;&amp;amp; r&amp;lt;=R) { lazy[rt] = sc; return; } PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (L&amp;lt;=m) update(L,R,sc,lson); if (R&amp;gt;=m+1) update(L,R,sc,rson); //如果是区间查询或者修改，那么就需要分别两个if来判断。 } int query(int p,int l,int r,int rt) { if (l==r) return lazy[rt]; PushDown(rt); int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) query(p,lson); //如果是单点查询或者修改，那么不在这个就一定在另一个，所以可以用else.</description></item><item><title>codeforces 474 F. Ant colony (线段树求gcd+统计区间中某数出现的次数的经典做法)</title><link>http://example.org/2016/09/cf474f/</link><pubDate>Mon, 05 Sep 2016 13:42:23 +0000</pubDate><guid>http://example.org/2016/09/cf474f/</guid><description>题目链接
题意：给出n个数，m个查询，每组查询一个区间[l,r]，问[l,r]中会被吃掉多少个（区间[l,r]中的数只有当其是其他所有数的因数时才不会被吃掉,顺便问一句。。a divide b 是 a除b,也就是b除以a,b/a的意思嘛23333）
思路：我们知道，不会被吃掉的数其实就是区间[l,r]中所有数的gcd,求gcd可以很容易用线段树办到。。。关键是还要统计该区间中等于gcd的数有多少个。
并不会做。
大概有两种做法。。。？
一种是基哥@clq11111说的，将询问离线，然后从小到大排序插入，询问区间中等于x转化成询问区间中小于等于x的，和询问区间中小于等于x-1的，做差即为所求。
第二种办法是题解的讨论区部分的：
想了一下感觉很有道理。。。
这种做法是说：建一个val和该val对应下标的pair，然后排序（pair默认按照val第一关键字，pair第二关键字升序排）
排序之后，val相同的都在一起了，我们只需要找一段最大的区间，使得这段区间中的第二关键字在[l,r]范围内，然后这段区间的长度就是[l,r]区间中该数出现的次数.
找这段最大的区间，两次二分就好。说起来二分得到区间这个做法之前写过两次。。。之前都是手写的。。。这次用了STL。
具体写法参见代码
1A开心哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 08:37:57 PM CST File Name :code/cf/problem/474F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int tree[N&amp;lt;&amp;lt;2]; int gcd( int a,int b) { if (a%b==0) return b; return gcd(b,a%b); } void PushUp( int rt) { tree[rt] = gcd(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void build(int l,int r,int rt) { if (l==r) { tree[rt] = a[l].</description></item><item><title>codeforces 61 E. Enemy is weak (离散化+线段树求逆序三元组)</title><link>http://example.org/2016/09/cf61e/</link><pubDate>Mon, 05 Sep 2016 08:35:49 +0000</pubDate><guid>http://example.org/2016/09/cf61e/</guid><description>题目链接 题意：给出n个数，求满足 i&amp;lt;j&amp;lt;k且a[i]&amp;gt;a[j]&amp;gt;a[k]的三元组有多少个。
思路：对于这种要求三个数满足条件的题目，老司机的经验是考虑中间那个数，这道题也不例外。
我们枚举j，通过求两次逆序对求出对于每个a[j]，满足a[i]&amp;gt;a[j]的i的个数，以及满足a[j]&amp;gt;a[k]的个数。
两个个数的乘积就是j作为中间数满足的三元组的个数，这样把所有的j累加就是答案。
其他的就是，要离散化，以及最后答案可能会爆long long?
1A，好爽啊哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 03:40:20 PM CST File Name :code/cf/problem/61E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int a[N]; int A[N]; int H[N]; int n; int m; int tree1[N&amp;lt;&amp;lt;2],tree2[N&amp;lt;&amp;lt;2]; pair&amp;lt;LL,LL&amp;gt;ans[N]; void PushUp(int rt,int *tree) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt,int *tree) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson,tree); else update(p,rson,tree); PushUp(rt,tree); } int query(int L,int R,int l,int r,int rt,int *tree) { // cout&amp;lt;&amp;lt;&amp;quot;L:&amp;quot;&amp;lt;&amp;lt;L&amp;lt;&amp;lt;&amp;quot; R:&amp;quot;&amp;lt;&amp;lt;R&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; if (L&amp;gt;R) return 0; if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0 ; if (L&amp;lt;=m) { int res = query(L,R,lson,tree); ret+=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson,tree); ret +=res; } return ret; } int Hash( int x) { return lower_bound(H,H+m,x)-H; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 459 D. Pashmak and Parmida's problem (离散化+线段树求逆序对数)</title><link>http://example.org/2016/09/cf459d/</link><pubDate>Mon, 05 Sep 2016 07:23:18 +0000</pubDate><guid>http://example.org/2016/09/cf459d/</guid><description>题目链接 题意：定义_f_(_l_, _r_, _x_)为区间[l,r]中x出现的次数。现在要求calculate the number of pairs of indicies _i_, _j_ (1 ≤ _i_ &amp;lt; _j_ ≤ _n_) such that_f_(1, _i_, _a__i_) &amp;gt; _f_(_j_, _n_, _a__j_).
思路：可以通过o(n)预处理出f(1,i,a[i])和f[j,n,a[j]]，其实预处理的过程就是离散化的过程呢。。。
分别得到
1 1 2 3 2 3 4
4 3 3 2 2 1 1
所以答案其实就是第一组数在第二组数中找逆序数的过程。。。
我们不妨倒序处理。
需要注意的是，线段树维护的区间是0..mx，我整体增加了1.
线段树求逆序对和树状数组求逆序对是同样的思想。。。注意体会。。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 02:06:05 PM CST File Name :code/cf/problem/459D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; map&amp;lt;int,int&amp;gt;mp; int n ; int a[N],b[N]; int tmp[N]; int tree[N&amp;lt;&amp;lt;2];//tree[i]表示的是以i节点为根节点的子树所代表的区间中数的个数。 void PushUp( int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson); else update(p,rson); PushUp(rt); } int query(int L,int R,int l,int r,int rt) { if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0; if (L&amp;lt;=m) { int res = query(L,R,lson); ret +=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson); ret +=res; } return ret; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 339 D. Xenia and Bit Operations(线段树)</title><link>http://example.org/2016/09/cf339d/</link><pubDate>Sun, 04 Sep 2016 17:48:11 +0000</pubDate><guid>http://example.org/2016/09/cf339d/</guid><description>题目链接
题意：给出n和m,初始给出1&amp;laquo;n个数，先相邻的两个数进行或操作（a[1]^a[2],a[3]^a[4]&amp;hellip;），得到的新数列再相邻的两个数进行异或操作。
最后得到一个数，即为答案。现在给出m个操作，每个操作两个数p,b，表示令a[p]=b,每次变化后输出最终的结果。
思路：线段树。这道题让我学到了，线段树的数组tree[i]存储的信息可能不唯一，可以不同层存储的是不同的信息。
比如这道题中，距离叶子节点距离为奇数的点存储的是或操作的结果，距离叶子节点距离为偶数的点存储的是异或操作的结果。
还需要注意的是，build和update操作都是从顶向下，最后一个操作是异或还是或取决于n的奇偶性，记得判断。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 12:56:34 AM CST File Name :code/cf/problem/339D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1&amp;lt;&amp;lt;18; int tree[N&amp;lt;&amp;lt;2]; int n,m; void PushUp(int rt,int state) { if (state==-1) tree[rt] = tree[rt&amp;lt;&amp;lt;1]|tree[rt&amp;lt;&amp;lt;1|1]; else tree[rt] = tree[rt&amp;lt;&amp;lt;1]^tree[rt&amp;lt;&amp;lt;1|1]; } void build(int l,int r,int rt,int state) { if (l==r) { scanf(&amp;quot;%d&amp;quot;,&amp;amp;tree[rt]); return ; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson,-state); build(rson,-state); PushUp(rt,state); } void update( int p,int sc,int l,int r,int rt,int state) { if (l==r) { tree[rt] = sc; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,sc,lson,-state); else update(p,sc,rson,-state); PushUp(rt,state); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 19 D. Points (离散化+树套树（线段树+set）)</title><link>http://example.org/2016/09/cf19d/</link><pubDate>Sun, 04 Sep 2016 13:47:07 +0000</pubDate><guid>http://example.org/2016/09/cf19d/</guid><description>题目链接
题意：
1.add x,y 将点(x,y)加进坐标系。
2.remove x,y 将点(x,y)移除.
3.find x,y 找到点(x,y)右上角的点(xp&amp;gt;x,yp&amp;gt;y)。如果有多个输出x最小的。还是有多个输出y最小的。
x,y均为非负数。以上操作均合法。思路：没有思路。。。不会啊。。。以为要二维线段树什么的。。。。总之是不会做。。。
大概从中午开始看题解。。。8个小时。。。。终于完全搞懂了orz
很巧妙得把二维问题转化成了一维问题。。。
我来说一下大概做法，具体的细节见代码注释：
在x轴方向维护一课线段树，线段树的数组tree[i]存储的信息是以i节点为根节点的子树所对应的区间能达到的最大的y值。线段树的叶子节点上是一个set，set[i]是横坐标为i时的纵坐标集合，也就是所谓的树套树。
由于x很大，但是n比较小，所以我们这里采用了stl+去重的办法离散化离散化的三种办法
对于添加和删除点的操作，我们更新完对应的set把相应的x（离散化后的）在线段树中更新就好（因为线段树的update操作是和set有关的）
对于find操作，我们首先从线段树中找到（下标大于x且最小且集合中存在大于y的元素的集合）的下标
这样我们确定了x，再upper_bound一下找到对应的集合中最小的y.
初始化由于没有插入y,所以tree可以初始化为-1，不用建树。。。（反正建了也都是-1）
/* *********************************************** Author :111qqz Created Time :Sun 04 Sep 2016 07:19:05 PM CST File Name :code/cf/problem/19D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; int tree[N&amp;lt;&amp;lt;2]; //记录线段树的信息，tree[i]表示的是以i节点为根节点的子树所代表的区间中的点的最大的y值。 set&amp;lt;int&amp;gt;se[N];//集合se[i]是横坐标为x的点的纵坐标的集合。 struct node //线段树套平衡树，在x轴的方向上建一棵线段树，线段树的每个叶子节点是一个set。 { int x,y; char cmd[15]; void input() { scanf(&amp;quot;%s%d%d&amp;quot;,cmd,&amp;amp;x,&amp;amp;y); } }q[N]; int H[N]; void PushUp(int rt) { tree[rt] = max(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void update( int p,int l,int r,int rt) { if (l==r) { if (se[l].</description></item><item><title>poj 2828 Buy Tickets (线段树单点更新，逆序插入)</title><link>http://example.org/2016/09/poj-2828/</link><pubDate>Sat, 03 Sep 2016 13:26:54 +0000</pubDate><guid>http://example.org/2016/09/poj-2828/</guid><description>poj 2828 题目链接
题意：n个人，每个人有一个rp值（用来区分不同的人），还有一个pos[i]，表示当第i个人来排队的时候插入到第pos[i]个人的后面（也就是排在位置pos[i]+1)
现在问最后的序列，从1到n输出n个人的rp值
思路：第二道线段树，并不会做，看了题解。
比较关键的一点是：按照顺序的话，当后来的一个人插入到前面，那么之前很多人排好的位置将发生改变，这个代价是巨大的。
由于越后来的人越容易确定位置，因此正确的做法是倒序处理。
对于第i个人，我们把他放在从前往后数的第i个空的位置即可。
接下来需要做的就是线段树处理，线段树存储的信息是某一个区间中空位置的个数。
感觉是一道很好的题目，对于新手来说并不是很容易，不过理解了这道题目以后，感觉进一步理解线段树，有点开心。
/************************************************************************* &amp;gt; File Name: code/poj/2828.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年10月29日 星期四 09时00分08秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;cctype&amp;gt; #define yn hez111qqz #define j1 cute111qqz #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) using namespace std; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; typedef long long LL; typedef double DB; const int inf = 0x3f3f3f3f; const int N=2E5+7; int pos[N],val[N]; int n; int tree[N&amp;lt;&amp;lt;2]; //tree[i]存储的是以i为根节点的子树对应的区间中空位置的数量。 int ans[N]; void PushUp(int rt) { tree[rt] = tree[rt&amp;lt;&amp;lt;1]+tree[rt&amp;lt;&amp;lt;1|1]; //一段区间空位置的数量等于两端子区间中空位置的数量的和。 } void build(int l,int r,int rt) { if (l==r) { tree[rt] = 1; //初始的空位置的数量为区间长度r-l+1 return ; } int m = (l+r)&amp;gt;&amp;gt;1; build(lson); build(rson); PushUp(rt); } void update (int p,int val,int l,int r,int rt) { if (l==r) //终于找到了该点的归属。。。 { ans[l] = val; tree[rt]--; return ; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=tree[rt&amp;lt;&amp;lt;1]) update(p,val,lson); //如果左子树所代表的区间中空位置的数目够的话就放左边 else update(p-tree[rt&amp;lt;&amp;lt;1],val,rson);//否则放右边，一共需要p个空位置，左边提供了tree[rt&amp;lt;&amp;lt;1]个，还需要右边提供p-tree[rt&amp;lt;&amp;lt;1]个。 PushUp(rt); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1754 I Hate It (线段树模板题，炒鸡详细注释版)</title><link>http://example.org/2016/08/hdu-1754/</link><pubDate>Thu, 18 Aug 2016 11:47:41 +0000</pubDate><guid>http://example.org/2016/08/hdu-1754/</guid><description>hdu 1754 题目链接 题意：单点更新，区间查询最大值。 思路：线段树。 一开始借鉴了clj的pointer写法。。wjmzbmr's code 直接MLE。。。看来也许只能在cf上用。。。 下面是MLE的代码：
/* *********************************************** Author :111qqz Created Time :2016年08月18日 星期四 18时40分24秒 File Name :code/hdu/1754.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;deque&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int a[N],n,m; int _max( int x,int y) { if (x==-1||y==-1) return x==-1?</description></item><item><title>线段树学习笔记</title><link>http://example.org/2016/08/</link><pubDate>Thu, 18 Aug 2016 09:19:31 +0000</pubDate><guid>http://example.org/2016/08/</guid><description>嘛，终于下定决心搞定线段树了。
之前几次都是被lazy标记卡住，这次大概不会了吧2333
放一些学习资料，最后比较zkw线段树和普通线段树的区别。
codeforces上非递归线段树讲解 （其实就是zkw吧）
线段树进阶（各种花式技巧）
找到了一篇非常赞的tutorial（含lazy标记） 链接</description></item><item><title>hdoj 2795 Billboard</title><link>http://example.org/2015/12/hdoj2795/</link><pubDate>Thu, 17 Dec 2015 09:03:02 +0000</pubDate><guid>http://example.org/2015/12/hdoj2795/</guid><description>http://acm.hdu.edu.cn/showproblem.php?pid=2795 题意：一个尺寸为wh的方格。要按顺序放放n个尺寸为1wi的纸条。问每一个纸条回被放在哪里。如果有多个，放在最上面（编号小） 思路：把没横行能放的最大长度看做一个序列建树。由于h比n大很多。。多出来的没用。。直接取较小值就行。
/* *********************************************** Author :111qqz Created Time :2015年12月17日 星期四 15时04分52秒 File Name :code/hdu/2785.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int h,w,n; struct SegTree //将每个横格能放置的最大长度看做一个序列，建树。 { int mx; }tree[4*N]; void build ( int l,int r,int rt) { // cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; tree[rt].</description></item><item><title>hdu 3333 Turing Tree (求区间中不相同数的和，离线+线段树/树状数组)</title><link>http://example.org/2015/08/hdu3333/</link><pubDate>Fri, 07 Aug 2015 18:42:00 +0000</pubDate><guid>http://example.org/2015/08/hdu3333/</guid><description>题目链接
喵呜，离散树状数组。
这道题由于相同的值加和的时候只算一次，所以比较伤脑筋==
怎么办呢？
我们发现对于一个值，由于相同的只算一次，所以在任意时间内，这个值只需要出现一次。
如果我们从作往右将原数组更新到树状数组，如果某个值之前出现过，那么我在更新当前的时候，还需要删掉之前那个。
这样就可以保证当前的序列中一个值只出现了一次，而且位置更新成最后出现的位置。
如果只出现一次的话那就又是我们喜闻乐见的那个熟悉的树状数组了呢 喵呜！
但是这样删掉前面出现的元素真心大丈夫？ 万一之后又查询了之前你删掉的点岂不是整个人都萌萌哒了？
所以我们可以按照查询区间的又断点排序，保证前面删掉的点以后不会再被查询。
也就是按照顺序，从左往右，边查询，边更新原数组到树状数组。
由于查询区间是无序的，按照右端点排序之后打乱了原来的查询顺序，所以要离线操作。
由于查询区间是无序的，按照右端点排序之后打乱了原来的查询顺序，所以要离线操作。
由于查询区间是无序的，按照右端点排序之后打乱了原来的查询顺序，所以要离线操作。
** **重要的事情说三遍。
所谓离线操作，就是查询的时候不直接输出答案，而是将答案存起来，然后最后一起输出。
 我们需要开一个数组pre [x] 记录x这个数的上一个位置，初始为-1
由 x的范围太大，数组存不下，所以要离散化。
离散化是为了记录一个数上次出现的位置！
注意要开LL 。
/************************************************************************* &amp;gt; File Name: code/hdu/3333.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月07日 星期五 17时04分07秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=3E4+3; LL c[N]; LL n,m,qur; LL ref[N]; LL pre[N]; LL ori[N]; struct Q { LL val,id; }q[N]; struct S { LL x,y; LL id,ans; }s[100005]; bool cmp( Q a,Q b) { if (a.</description></item><item><title>poj 2481 Cows(树状数组||线段树)</title><link>http://example.org/2015/08/poj2481/</link><pubDate>Mon, 03 Aug 2015 19:32:00 +0000</pubDate><guid>http://example.org/2015/08/poj2481/</guid><description>poj 2481 题目链接
题意：给定n个区间，问对于每个区间，有多少个区间真包含该区间（真包含的意思是说，两个区间不能完全重合）
思路：
需要注意的是star那道题读入的时候已经排好了序，而这道题没有排序
由于答案是按照下表输出，排序的时候下标会被打乱，所以要存一下下表到结构体里。
另一个区别是，star那道题星星不会重复，就是说一个位置不会有多颗星星。
而这道题却可能，而且题目中说，如果区间的长度差为0（就是后面的那个不等式），那么不计数。
因为区间下标可能为0，但是树状数组的下表必须从1开始，所以下表要+1，但是由于下表可能有所重复，所以 不能用++,而是用+1
不然会增加多次（我就是这么w a了两次。。。）树状数组ac代码：
/************************************************************************* &amp;gt; File Name: code/poj/2481.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月04日 星期二 02时06分05秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=1E5+7; int n; int a[N],t[N]; struct Q { int s,e,id; }q[N]; bool cmp (Q a,Q b) { if (a.</description></item><item><title>poj 2352 Stars （树状数组||线段树）</title><link>http://example.org/2015/08/poj2352/</link><pubDate>Mon, 03 Aug 2015 17:29:00 +0000</pubDate><guid>http://example.org/2015/08/poj2352/</guid><description>poj 2352题目链接
题意：给出n个星星的位置，一个星星的level定义为其左下角（不严格）星星的数量。
要求统计0到n-1 level的星星各有多少个。
下面是一年前写的树状数组的题解：
更新于2015年08月04日01:47:18：
好像有点明白了&amp;hellip;..详情看注释树状数组ac代码：
/************************************************************************* &amp;gt; File Name: code/poj/2352.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月04日 星期二 00时33分52秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=4E4+7; int a[N]; int t[N]; int x,y; int n; int lowbit (int x) { return x&amp;amp;(-x); } void update(int x,int c) { int i; for ( int i = x ; i &amp;lt;= 32001 ; i = i + lowbit(i)) { t[i] = t[i] + c; } } int sum( int x) { int i; int res = 0; for ( int i = x ; i &amp;gt;= 1 ; i = i-lowbit(i)) { res = res + t[i]; } // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;quot; res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; return res; } int main() { scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for ( int i = 0 ; i &amp;lt; n ; i ++ ) { scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y); a[sum(++x)]++; // ++x是因为坐标是从0 开始，而树状数组的下标一定是从1开始，不然会TLE // sum(++x)是求 ++x 的level // // update(x,1); //向上更新，对于每一个比x大的位置，由于x的存在，那些位置的点的level都会增加1 //比如对于星3，因为星1的读入，我向上更新了星2,星3,星4,星5，这时候他们的level都是1 //之后读入星2，更新了星3和星5，星3的level是2，星5的level也是2，之后由于星4，星5的level又加1，为5.</description></item></channel></rss>