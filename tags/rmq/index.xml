<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rmq on 111qqz的小窝</title><link>https://111qqz.com/tags/rmq/</link><description>Recent content in rmq on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 30 Jul 2017 17:45:18 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/rmq/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 3078 Network (LCA)</title><link>https://111qqz.com/2017/07/hdu-3078/</link><pubDate>Sun, 30 Jul 2017 17:45:18 +0000</pubDate><guid>https://111qqz.com/2017/07/hdu-3078/</guid><description>
题目链接
题意： 一棵树，给出点权，问一条树链上第k大的点权，点权可以动态修改。
思路： 暴力即可orz(数据是真的水啊。
求路径上的点的时候需要用到LCA
/* *********************************************** Author :111qqz Created Time :2017年07月31日 星期一 01时12分54秒 File Name :3078.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=8E4+7; int n,q; int val[N]; vector &amp;lt; pi &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int fa[N]; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; fa[u] = pre; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>codeforces #425 D. Misha, Grisha and Underground (dfs+rmq在线求LCA,讨论了一年)</title><link>https://111qqz.com/2017/07/codeforces-div2-425d/</link><pubDate>Sun, 30 Jul 2017 12:05:30 +0000</pubDate><guid>https://111qqz.com/2017/07/codeforces-div2-425d/</guid><description>
题目链接
题意： 给出一棵树，以及三个点（可能重合），问两两组成的3条路径中，哪2条路径重合部分最长。
思路： LCA还是一下就能想到的，rmq+dfs在线求。
然后我开始分情况讨论，讨论了一年也没讨论完，哭哭
结论是：求出三个lca，并取深度最大的那个，就是我们要的三岔路口K，然后分别求出K到a，b，c三点的路径长度，取最大值+1就是答案。
所以我的问题在于，没有试图往一般性的方向考虑，以为讨论一下就可以了...
这大概就是所谓的猜结论？
感性的理解的话，LCA越深，意味着另一个点到LCA的距离越远，也就是相交的路径越长
但是我的话，估计还是很难在短短不到一个小时内得出这样一般性的结论orz...
这大概就是数学方面的天赋差距把...T T
/* *********************************************** Author :111qqz Created Time :2017年07月30日 星期日 15时12分34秒 File Name :D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n,q; vector &amp;lt; pi &amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>codeforces 123 D. String　（后缀数组+两次二分得到区间＋rmq）</title><link>https://111qqz.com/2016/08/cf-123/</link><pubDate>Tue, 02 Aug 2016 15:23:55 +0000</pubDate><guid>https://111qqz.com/2016/08/cf-123/</guid><description>
题目链接
题意：定义一个函数F．．
For exampe: _F_(_babbabbababbab_, _babb_) = 6. The list of pairs is as follows: (1, 4), (4, 7), (9, 12)
Its continuous sequences are:
* (1, 4) * (4, 7) * (9, 12) * (1, 4), (4, 7) * (4, 7), (9, 12) * (1, 4), (4, 7), (9, 12) erfen
． erfen 题目描述得很烂．．看例子把．．大概就是：如果字符串y在字符串x中出现n次，那么F(x,y)=n*(n+1)/2
现在给一个字符串，求所有的F(s,x)的和，x为字符串的所有不相同的子串．
思路：由于刚刚写了一个求一个字符串所有不同子串个数的题目．．．于是就想到了后缀数组．．．
写完之后观察height[i]．如果把height[i]看成底在x轴上的第i个矩形的高的话，n就是一段连续的矩形的长度．</description></item><item><title>hdu 4123 Bob’s Race (树的直径+尺取+rmq)(珍爱生命，远离log)</title><link>https://111qqz.com/2016/07/hdu-4123/</link><pubDate>Sun, 17 Jul 2016 16:21:03 +0000</pubDate><guid>https://111qqz.com/2016/07/hdu-4123/</guid><description>
hdu 4123 题目链接
题意：一棵树，定义d[i]为点i到树上某点的最大距离。。。给出若干查询，每个查询一个x,问最多能有多少点满足这些点中，最大的d与最小的d的差小于等于x.要求这些点的编号必须是连续的。
思路：可以三遍bfs处理出所有点的d...
由于不能排序。。。所以就是尺取+rmq....
然而神Tm TLE.....
这复杂度还TLe...
结果最后发现是。。。log运算的常数太大被卡。。。
所以做法是先预处理一下。。。嗯。。。。
珍爱生命，远离log! 珍爱生命，远离log! 珍爱生命，远离log! /* *********************************************** Author :111qqz Created Time :2016年07月17日 星期日 19时37分55秒 File Name :code/hdu/4123.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair #define log2 0.</description></item><item><title>zoj 3195 Design the city （lca,dfs+rmq）</title><link>https://111qqz.com/2016/05/zoj-3195/</link><pubDate>Sat, 21 May 2016 08:31:20 +0000</pubDate><guid>https://111qqz.com/2016/05/zoj-3195/</guid><description>
zoj 3195题目链接 题意：求树上三点的最短距离。。。 思路：两两求，和除以2. 因为忘记初始化p=0..WA了将近两个小时。。。？ 妈的智障。
/* *********************************************** Author :111qqz Created Time :2016年05月21日 星期六 14时44分39秒 File Name :code/zoj/3195.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; int n,m; vector &amp;lt; pi &amp;gt; edge[N]; int q; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>hdu 2874 Connections between cities (添加虚点，并查集+LCA(rmq+dfs))</title><link>https://111qqz.com/2016/05/hdu-2874/</link><pubDate>Sat, 21 May 2016 04:58:22 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu-2874/</guid><description>
hdu2874题目链接
题意：给一个森林，问两点的最短距离，或者输出两点不联通。
思路：最最重要的一点是:添加虚点！
最最重要的一点是:添加虚点！
最最重要的一点是:添加虚点！
所谓虚点，就是之前假设某个不存在的点，有点类似做辅助线。
通过添加虚点，我们可以把这个森林转化成一棵树。
这样求两点的距离就可以转化成一棵树上的两点的距离。
用dis[u]+dis[v]-2*dis[LCA(u,v)]来求。 dis[i]表示节点i到新的树根节点的距离。
不联通的话就是LCA 为0的情况（0是添加的虚点，作为新的树的根）
具体添加虚点的方法是：森林中每棵树的根连边到虚点上。权值大小随意，因为最后会抵消（？） 为了知道每棵树的根，需要用到并查集(其实根是随便定义的，但是森林中每棵树只能一个点和虚点相连不然就出现环了，所以需要用到并查集）
以及了解了（？）并查集的非递归的路径压缩写法。。。？
缺点是速度更慢，优点是不会爆栈。。。
还有需要学习一下按rank合并和按size合并的进阶并查集。。。？
以及：RE了好多次是因为。。。添加了虚点0，所以各种下标都应该是从0开始，初始化清空的时候忘了（从0开始）清vector...导致多组数据一直往edge[0]里面添加边。。。然后就炸了（手动微笑）
/* *********************************************** Author :111qqz Created Time :2016年05月20日 星期五 19时31分44秒 File Name :code/hdu/2874.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E4+7; int n,m,q; vector &amp;lt; pi &amp;gt; edge[N]; int dis[N]; int E[2*N],depth[2*N],R[2*N]; int p; int dp[2*N][20]; int f[N]; /*int root2 ( int a) { int x = a,ret; while (x!</description></item><item><title>poj 1986 Distance Queries (lca,在线做法dfs+rmq)</title><link>https://111qqz.com/2016/05/poj-1986/</link><pubDate>Fri, 20 May 2016 11:25:49 +0000</pubDate><guid>https://111qqz.com/2016/05/poj-1986/</guid><description>
题目链接 题意：求树上两点的最短距离？ 思路： dis[i]表示点i到根节点的距离，那么任意两点u,v的最短距离d = dis[u]+dis[v]-2*dis[LCA(u,v)]. 只需要求出rmq+dfs的在线方法求出lca(u,v)即可。
/* *********************************************** Author :111qqz Created Time :2016年05月20日 星期五 15时36分47秒 File Name :code/poj/1986.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=4E4+7; int n,m; vector &amp;lt; pi &amp;gt; edge[N]; int q; int in[N]; int E[2*N],R[2*N],dis[N],depth[2*N]; int p; int dp[2*N][20]; void dfs( int u,int dep,int d,int pre) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;&amp;quot; d:&amp;quot;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;endl; p++; E[p] = u; depth[p] = dep; R[u] = p ; dis[u] = d; int siz = edge[u].</description></item><item><title>hdu 3530 Subsequence (尺取+rmq)</title><link>https://111qqz.com/2016/05/hdu3530/</link><pubDate>Thu, 19 May 2016 09:44:36 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu3530/</guid><description>
hdu 3530题目链接
题意：给出n个数，m,k，问最大的j-i+1,使得【i,j】间的最大值与最小值的差属于[m,k] 思路：rmq+尺取。 2A.
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 16时52分03秒 File Name :code/hdu/3530.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; int a[N]; int dp[N][20],dp2[N][20]; int m,k; void rmq_init() { for ( int i = 1 ; i &amp;lt;= n ; i ++) dp[i][0] = dp2[i][0] = a[i]; for ( int j = 1 ; (1&amp;lt;&amp;lt;j) &amp;lt;= n ; j++) for ( int i = 1 ; i + (1&amp;lt;&amp;lt;j) -1 &amp;lt;= n ; i++) { dp[i][j] = max(dp[i][j-1],dp[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); dp2[i][j]=min(dp2[i][j-1],dp2[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } } int rmq( int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; int mx = max(dp[l][k],dp[r-(1&amp;lt;&amp;lt;k)+1][k]); int mn = min(dp2[l][k],dp2[r-(1&amp;lt;&amp;lt;k)+1][k]); return mx-mn; } int ruler() { int head = 1; int tail = 1; int res = -1 ; while (tail&amp;lt;=n) { int cur = rmq(head,tail); while (head&amp;lt;tail&amp;amp;&amp;amp;rmq(head,tail)&amp;gt;k) head++; while (tail&amp;lt;n&amp;amp;&amp;amp;rmq(head,tail)&amp;lt;m) tail++; //if (tail&amp;gt;n) break; cur = rmq(head,tail); if (cur&amp;gt;=m&amp;amp;&amp;amp;cur&amp;lt;=k) { res = max(res,tail-head); } // cout&amp;lt;&amp;lt;&amp;quot;head:&amp;quot;&amp;lt;&amp;lt;head&amp;lt;&amp;lt;&amp;quot; tail:&amp;quot;&amp;lt;&amp;lt;tail&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;&amp;quot; res:&amp;quot;&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; tail++; } return res+1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 1470 Closest Common Ancestors (lca,rmq+dfs,读入技巧)</title><link>https://111qqz.com/2016/05/poj1470/</link><pubDate>Thu, 19 May 2016 08:42:05 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1470/</guid><description>
poj1470题目链接
题意：求两点的lca. 思路：dfs+rmq. 读入技巧。 读入比较坑爹。。。 学会了一种新的读入技巧。
scanf(&amp;quot;%2s&amp;quot;,st);
表示读一个长度为2的字符串。。。读的时候会忽略各种空白字符。
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 15时44分12秒 File Name :code/poj/1470.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=905; int n; vector &amp;lt;int&amp;gt; edge[N]; int in[N]; int E[2*N],R[2*N]; int depth[2*N]; int p; int dp[2*N][12]; int cnt[N]; void dfs( int u,int dep) { p++; E[p] = u ; depth[p] = dep; R[u] = p; int siz = edge[u].</description></item><item><title>poj 1330 Nearest Common Ancestors (lca,用dfs+rmq在线求解)</title><link>https://111qqz.com/2016/05/poj1330/</link><pubDate>Thu, 19 May 2016 07:39:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj1330/</guid><description>
poj1330题目链接
题意：给出一棵树，求两点的lca. 思路：将lca转化成rmq在线求解。
代码部分参考了：参考代码
感觉实现得很巧妙。。。 把树存成了有向图，dfs遇到的时候一定是第一次遇到，此时更新R. 然后第二次遇到某个点就是在回溯的时候了。
算法学习链接
/* *********************************************** Author :111qqz Created Time :2016年05月19日 星期四 15时05分31秒 File Name :code/poj/1330.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E4+7; vector &amp;lt;int&amp;gt;edge[N]; int n; int in[N]; int cur; int E[2*N]; int R[N]; int depth[2*N]; int dp[2*N][16]; void dfs ( int u,int dep) { // cout&amp;lt;&amp;lt;&amp;quot;u:&amp;quot;&amp;lt;&amp;lt;u&amp;lt;&amp;lt;&amp;quot; dep:&amp;quot;&amp;lt;&amp;lt;dep&amp;lt;&amp;lt;endl; cur++; E[cur] = u; depth[cur] = dep; R[u] = cur; //有向图存的话，在这里访问的一定是第一次经过。 int siz = edge[u].</description></item><item><title>hdu 4122 Alice's mooncake shop(rmq)</title><link>https://111qqz.com/2016/05/hdu4122/</link><pubDate>Wed, 18 May 2016 13:03:34 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu4122/</guid><description>
hdu2142题目链接 题意：有n个订单和可以在m小时内制作月饼 接下来是n个订单的信息:需要在mon月,d日,year年,h小时交付订单r个月饼 接下来一行t,s表示制作的月饼可以保质t天，每保质一天需要花费s的价值 接下来m行表示从第0小时开始在该时间制作月饼的花费的价值 求完成所有订单消耗的最小价值
思路：一开始毫无头绪。。因为读错题了。。。之后发现做月饼只能在整点做，即使是提前，也只能提前整数个小时做。 然后发现冰箱的容量是没有限制的，所以每个订单单独考虑即可。
那么对于每一个订单，我们要找到订单当天以及之前T天，这T+1天中做月饼花费最少的那天做月饼。
但是如果对于每个订单，如果每次都更新相应的价值，找一次最小值，复杂度会炸。
这里我卡了一下。。。然后发现，可以只初始化一次。虽然在不同时间做月饼的花费会因为订单时间的不同而不同，但是每相邻的两个小时之间做月饼花费的差是固定的，也就是花费的相对大小是固定的。
因此对于每个订单，我在相应的区间内找到花费最小的时间的下标，然后恢复成实际的花费（因为花费是一个等差数列，很好恢复）
由于之后给的花费是开始后的第i小时。。。那么订单不妨也转化成小时的形式。。。
注意判断闰年。。
2A,开心。
/* *********************************************** Author :111qqz Created Time :2016年05月18日 星期三 19时37分03秒 File Name :code/hdu/4122.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M[15]={-1,31,28,31,30,31,30,31,31,30,31,30,31}; //平年每月天数，1 indexed.</description></item><item><title>poj 3368 Frequent values （暴力+rmq，分类讨论）</title><link>https://111qqz.com/2016/05/poj3368/</link><pubDate>Wed, 18 May 2016 07:47:48 +0000</pubDate><guid>https://111qqz.com/2016/05/poj3368/</guid><description>
poj 3368 题目链接
题意：给出n个非减的数a[i],求区间[l,r]中出现次数最多的数的出现的次数。
思路：由于数列非减，那么相等的数一定相邻。很容易系哪个到构造另一个数组f[i]，表示从当前位置向左边延伸最多延伸几个相等的数。
f[i] = f[i-1] + 1 (iff a[i]==a[i-1])
然后查询的时候。
如果直接用ST算法查询rmq的话。。。
可能产生错误结果，原因是f[i]是从左边1到i这段连续区间里当前数出现的次数。
但是查询区间不一定是从1开始，所以查询区间内的第一段连续相等的数可能不完整。。。想了半天。。最后看了题解，发现是这部分暴力来搞。但是如果所有数列中所有数都相等，这样的复杂度就达到了o(1E10)?。。。2s应该过不了吧。。。但是所有题解都是这么写的。。。不是很懂。。。所谓的面向数据编程？
不过还是有启示的：分类讨论的思想。一道题未必用一种算法解。如果因为一小部分导致某算法不能用的话，不妨暴力搞之然后再用这个算法。
/* *********************************************** Author :111qqz Created Time :2016年05月18日 星期三 13时44分47秒 File Name :code/poj/3368.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; pi a[N]; int q; int dp[N][20]; void init_rmq() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp[i][0] = a[i].</description></item><item><title>poj 2452 Sticks Problem (rmq+二分，需要返回最值位置)</title><link>https://111qqz.com/2016/05/poj2452/</link><pubDate>Wed, 18 May 2016 05:40:40 +0000</pubDate><guid>https://111qqz.com/2016/05/poj2452/</guid><description>
poj2452题目链接
题意：给你一组数a[n]，求满足a[i] &amp;lt; a[k] &amp;lt; a[j] (i &amp;lt;= k &amp;lt;= j)的最大的j-i。
思路：大概能想到是rmq，然后想出了一个错误复杂度的错误思路，还直到对拍才发现==
转载一篇题解：poj2452解题报告
收获最大的是：
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
只要
int _min(int l,int r) { if (a[l]&amp;lt;a[r]) return l; return r; } 这样一个函数就可以实现完美转化。。。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 13时42分56秒 File Name :code/poj/2452.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; int n; int a[N]; int dp[N][20]; int dp2[N][20]; int _min(int l,int r) { if (a[l]&amp;lt;a[r]) return l; return r; } int _max( int l,int r) { if (a[l]&amp;gt;a[r]) return l; else return r; } void max_init() { for ( int i = 1 ; i &amp;lt;= n ; i++) dp[i][0] = i; for ( int j = 1 ; (1&amp;lt;&amp;lt;j)&amp;lt;=n ; j++) for (int i = 1 ; i + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= n ;i++) dp[i][j] = _max(dp[i][j-1],dp[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } void min_init() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp2[i][0] = i; for ( int j = 1 ; (1&amp;lt;&amp;lt;j)&amp;lt;= n ; j++) for ( int i = 1 ; i + (1&amp;lt;&amp;lt;j) -1 &amp;lt;= n ; i++) dp2[i][j] = _min(dp2[i][j-1],dp2[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } int rmq_max(int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; return _max(dp[l][k],dp[r-(1&amp;lt;&amp;lt;k)+1][k]); } int rmq_min( int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; return _min(dp2[l][k],dp2[r-(1&amp;lt;&amp;lt;k)+1][k]); } int bin (int x,int l,int r) { while (l&amp;lt;=r) { if (l==r) return l; int m = (l+r)&amp;gt;&amp;gt;1; if (a[x]&amp;lt;a[rmq_min(l,m)]) l = m + 1; else r = m; } } void solve() { int ans = 0; for ( int i = 1 ; i+ans &amp;lt; n ; i++) { int r = bin(i,i+1,n); int k = rmq_max(i,r); if (a[k]&amp;gt;a[i]) ans = max(ans,k-i); } if (ans==0) puts(&amp;quot;-1&amp;quot;); else printf(&amp;quot;%d\n&amp;quot;,ans); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>lightoj 1081 Square Queries (二维rmq，降维)</title><link>https://111qqz.com/2016/05/loj1081/</link><pubDate>Mon, 16 May 2016 12:06:33 +0000</pubDate><guid>https://111qqz.com/2016/05/loj1081/</guid><description>
lightoj 1081 题目链接
题意：和上一道一样，但是由于size变成了500，如果按照之前的做法会tle + mle...
很容易发现，由于是方阵，长宽是相等的，所以有一维是可以省略的。
也就是所谓的降维？
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 19时24分26秒 File Name :code/loj/1081.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=501; int a[N][N]; int dp[N][N][9]; int n,q; void init_rmq() { for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) dp[i][j][0] = a[i][j]; for ( int i = 1 ; (1&amp;lt;&amp;lt;i)&amp;lt;= n ; i++) for ( int p = 1 ; p + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; p++) for ( int q = 1 ; q + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; q++) dp[p][q][i] = max(max(dp[p][q][i-1],dp[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1]),max(dp[p][q+(1&amp;lt;&amp;lt;(i-1))][i-1],dp[p+(1&amp;lt;&amp;lt;(i-1))][q+(1&amp;lt;&amp;lt;(i-1))][i-1])); } int rmq_max(int x1,int y1,int x2,int y2) { int k = 0; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;= x2-x1+1) k++; int tmp1 = dp[x1][y1][k]; int tmp2 = dp[x2-(1&amp;lt;&amp;lt;k)+1][y1][k]; int tmp3 = dp[x1][y2-(1&amp;lt;&amp;lt;k)+1][k]; int tmp4 = dp[x2-(1&amp;lt;&amp;lt;k)+1][y2-(1&amp;lt;&amp;lt;k)+1][k]; return max(max(tmp1,tmp2),max(tmp3,tmp4)); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2019 Cornfields (二维rmq)</title><link>https://111qqz.com/2016/05/poj2019/</link><pubDate>Mon, 16 May 2016 11:01:34 +0000</pubDate><guid>https://111qqz.com/2016/05/poj2019/</guid><description>
poj2019题目链接
题意：给一个方阵，k个查询，每个查询求某个方阵的最大值和最小值之差。
思路：二维rmq.同时用到最大值和最小值的话可以把初始化写在一起。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 18时31分23秒 File Name :code/poj/2019.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=251; int a[N][N]; int dp[N][N][8][8]; int dp2[N][N][8][8]; int n,b,q; void init_rmq() { for ( int i = 1 ;i &amp;lt;= n ; i++) for ( int j = 1 ; j &amp;lt;= n ; j++) dp[i][j][0][0] = dp2[i][j][0][0] = a[i][j]; for ( int i = 0 ; (1&amp;lt;&amp;lt;i)&amp;lt;= n ; i++) for ( int j = 0 ; (1&amp;lt;&amp;lt;j) &amp;lt;= n ; j++) if (i==0 &amp;amp;&amp;amp; j==0) continue; else for ( int p = 1 ; p + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; p++) for ( int q = 1 ; q + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= n ; q++) if (i==0) { dp[p][q][i][j] = max(dp[p][q][i][j-1],dp[p][q+(1&amp;lt;&amp;lt;(j-1))][i][j-1]); dp2[p][q][i][j] = min(dp2[p][q][i][j-1],dp2[p][q+(1&amp;lt;&amp;lt;(j-1))][i][j-1]); } else { dp[p][q][i][j] = max(dp[p][q][i-1][j],dp[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1][j]); dp2[p][q][i][j] = min(dp2[p][q][i-1][j],dp2[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1][j]); } } int _rmq(int x1,int y1,int x2,int y2) { int k1 = 0 ; int k2 = 0 ; while (1&amp;lt;&amp;lt;(k1+1)&amp;lt;=x2-x1+1) k1++; while (1&amp;lt;&amp;lt;(k2+1)&amp;lt;=y2-y1+1) k2++; int tmp1 = dp[x1][y1][k1][k2]; int tmp2 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y1][k1][k2]; int tmp3 = dp[x1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int tmp4 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int mx = max(max(tmp1,tmp2),max(tmp3,tmp4)); tmp1 = dp2[x1][y1][k1][k2]; tmp2 = dp2[x2-(1&amp;lt;&amp;lt;k1)+1][y1][k1][k2]; tmp3 = dp2[x1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; tmp4 = dp2[x2-(1&amp;lt;&amp;lt;k1)+1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int mn = min(min(tmp1,tmp2),min(tmp3,tmp4)); // cout&amp;lt;&amp;lt;&amp;quot;mx:&amp;quot;&amp;lt;&amp;lt;mx&amp;lt;&amp;lt;&amp;quot; mn:&amp;quot;&amp;lt;&amp;lt;mn&amp;lt;&amp;lt;endl; return mx - mn; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 2888 check corners (二维rmq模板题)</title><link>https://111qqz.com/2016/05/hdu2888/</link><pubDate>Mon, 16 May 2016 10:43:05 +0000</pubDate><guid>https://111qqz.com/2016/05/hdu2888/</guid><description>
hdu2888题目链接
题意：问某个矩阵内的最大值，并且问最大值是否是在四个角中出现。 思路：二维rmq.需要注意数组稍微开大1就会MLE,因为是四维数组，一维大一点，整个就会大很多==。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 16时51分00秒 File Name :code/hdu/2888.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=301; int n,m,q; int a[N][N]; int dp[N][N][9][9]; void init_rmq() { for ( int i = 1 ; i &amp;lt;= n ; i++) for ( int j = 1; j &amp;lt;= m ; j++) dp[i][j][0][0] = a[i][j]; for ( int i = 0 ; (1&amp;lt;&amp;lt;i)&amp;lt;= n ; i++) for ( int j = 0 ; (1&amp;lt;&amp;lt;j)&amp;lt;= m ;j++) if (i==0&amp;amp;&amp;amp;j==0) continue; else for ( int p = 1 ; p + (1&amp;lt;&amp;lt;i)-1 &amp;lt;= n ; p++) for ( int q = 1 ; q + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= m ;q ++) if (i==0) dp[p][q][i][j] = max(dp[p][q][i][j-1],dp[p][q+(1&amp;lt;&amp;lt;(j-1))][i][j-1]); else dp[p][q][i][j] = max(dp[p][q][i-1][j],dp[p+(1&amp;lt;&amp;lt;(i-1))][q][i-1][j]); } int rmq_max(int x1,int y1,int x2,int y2) { int k1 = 0 ; int k2 = 0 ; while (1&amp;lt;&amp;lt;(k1+1)&amp;lt;=x2-x1+1) k1++; while (1&amp;lt;&amp;lt;(k2+1)&amp;lt;=y2-y1+1) k2++; int tmp1 = dp[x1][y1][k1][k2]; int tmp2 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y1][k1][k2]; int tmp3 = dp[x1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; int tmp4 = dp[x2-(1&amp;lt;&amp;lt;k1)+1][y2-(1&amp;lt;&amp;lt;k2)+1][k1][k2]; return max(max(tmp1,tmp2),max(tmp3,tmp4)); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1636: [Usaco2007 Jan]Balanced Lineup (RMQ模板题)</title><link>https://111qqz.com/2016/05/bzoj1636/</link><pubDate>Sun, 15 May 2016 13:31:30 +0000</pubDate><guid>https://111qqz.com/2016/05/bzoj1636/</guid><description>
1636: [Usaco2007 Jan]Balanced Lineup Time Limit: 5 Sec Memory Limit: 64 MB Submit: 680 Solved: 493 [Submit][Status][Discuss]
Description For the daily milking, Farmer John's N cows (1 &amp;lt;= N &amp;lt;= 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game.</description></item></channel></rss>