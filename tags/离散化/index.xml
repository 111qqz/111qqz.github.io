<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>离散化 on 111qqz的小窝</title><link>http://example.org/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/</link><description>Recent content in 离散化 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 27 Sep 2017 10:59:46 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>hdu 1542 Atlantis (线段树+扫描线求矩形面积并，模板题)</title><link>http://example.org/2017/09/hdu-1542/</link><pubDate>Wed, 27 Sep 2017 10:59:46 +0000</pubDate><guid>http://example.org/2017/09/hdu-1542/</guid><description>hdu1542题目链接
题意： 求n(100)个矩形的面积并。
思路： 扫描线+线段树
题目是2000年中欧区域赛的题目，虽然年代久远，但是有好几个点还是很值得学习的。
首先是离散化的适用范围: 之前比较常用的是将比较大的整数值离散化，常常是因为数值太大无法作为下标。 那么其实，浮点数有的时候也需要进行离散化，比如作为数组的下标，比如用来枚举。 做法上是和将较大的整数值离散化没有区别，因为遇到的题目不多，所以特意记录一下。 第二点是扫描线的思想：
其实扫描线的思想很早就接触过，noip2011的时候，tyvj上有一道类似的题目，不过是一唯的，当时印象深刻的是@Ocean 兄的那个比喻：
一段公路上右很多区间要收不同的费用，区间的开始给一个标记，表示该段区间对答案有贡献，区间的结束拿走该标记，表示该段区间对答案的贡献结束。
这就是扫描线的思想。
第三个是处理线段覆盖问题的一般做法：
通常线段树的节点处理的都是点，处理线段的时候就会比较麻烦。
这也是处理线段覆盖问题的通用方法。对于上面引用中提到的例子中“更新[1,4]，就相当于更新标号为[1,3]的线段”，是因为标号为1的节点代表区间[1,2]，标号为2的节点代表区间[2,3],标号为3的节点代表期间[3,4]
接下来具体讨论这道题目的做法：
将矩形按平行x轴方形构建扫描线（只是思想，不用实际构造），
每个矩形2条平行x轴的边分类{上边，下边}2类，如果我们从下往上“扫描”线，那么[下边]就表示了对答案贡献的开始，[下边]就表示了对答案贡献的结束。
* 扫描线扫描的过程（建议配合代码模拟） 初始状态
扫到最下边的线, 点1→3更新为1
扫到第二根线, 此时S=lcnt!=0∗h两根线之间, 得到绿色的面积, 加到答案中去, 随后更新计数
同上, 将黄色的面积加到答案中去
同上, 将灰色的面积加到答案中去
同上, 将紫色的面积加到答案中去
/* *********************************************** Author :111qqz Created Time :2017年09月27日 星期三 16时37分39秒 File Name :1542.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=205; int n; double X[N]; //存储所有x坐标，用来离散化。 //扫描线 struct Seg { double l,r,h; //表示扫面线的起点，终点，所在的高度(y坐标） int d;//1或者-1，表示扫描线对面积是正向影响还是负向影响 Seg(){} Seg(double l,double r,double h,int d):l(l),r(r),h(h),d(d){} bool operator &amp;lt; (const Seg &amp;amp;rhs)const { return h&amp;lt;rhs.</description></item><item><title>hdu 4288 Coder (离散化， 线段树，单点更新，区间合并)</title><link>http://example.org/2017/09/hdu-4288/</link><pubDate>Tue, 26 Sep 2017 06:56:57 +0000</pubDate><guid>http://example.org/2017/09/hdu-4288/</guid><description>题目链接
题意：n（1E5）个操作，分为三种，add x表示将x加到集合中（保证集合中之前没有x)，del x表示从集合中删掉x(保证集合中一定右x),sum表示求集合中所有元素按从小到大排列后，所有的下标中满足i%5=3的a[i]的和。1=&amp;lt;x&amp;lt;=1E9
思路：很容易想到的是，由于插入和删除元素造成的位置改变是剧烈的，因此要分别维护i%5==k,k属于0..4的元素的和。
这道题的核心点在于，由于只有1E5个操作，我们可以将元素离散化，这样做的目的是，将每个数和位置一一对应，每个位置用1或者0，表示该位置对应的元素是否在集合中。
考虑线段树，维护6个域，1个是区间中，在集合中的元素个数，剩下5个域，分别表示以该区间的端点为位置1，位置x%i=k的元素的和（k属于0..4)。因此每个叶子节点都是位置1.
考虑PushUp, 区间元素和之间累加，难点在于其他5个域的维护。
假设当前区间为rt,那么对于sum[0..4] (sum代表的就是上面说的要维护的5个域），显然区间rt&amp;laquo;1的答案可以直接贡献给rt.
对于rt&amp;laquo;1|1的答案，考虑rt&amp;laquo;1|1中位置为%5==x的元素和，rt&amp;laquo;1中的元素个数为len个，那么rt&amp;laquo;1|1中sum[x]对 rt中的sum[(x+len)%5]有贡献。
反推出对rt 中 sum[i]有贡献的是rt&amp;laquo;1|1中的sum[(i-len+5)%5)]
/* *********************************************** Author :111qqz Created Time :2017年09月26日 星期二 12时42分10秒 File Name :4288.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int n; struct Node { int cnt; //区间中，在集合中存在的元素的个数。 LL sum[5]; //sum[i]表示该区间中，以区间起点为下标1开始计算时，位置为x%5==i时的元素的和。 }tree[N&amp;lt;&amp;lt;2]; struct Opt { int opt; LL val; }qu[N]; LL H[N],A[N]; int cnt; int Hash( int x) { return lower_bound(H,H+cnt,x)-H; } void PushUp( int rt) { tree[rt].</description></item><item><title>codeforces 61 E. Enemy is weak (离散化+线段树求逆序三元组)</title><link>http://example.org/2016/09/cf61e/</link><pubDate>Mon, 05 Sep 2016 08:35:49 +0000</pubDate><guid>http://example.org/2016/09/cf61e/</guid><description>题目链接 题意：给出n个数，求满足 i&amp;lt;j&amp;lt;k且a[i]&amp;gt;a[j]&amp;gt;a[k]的三元组有多少个。
思路：对于这种要求三个数满足条件的题目，老司机的经验是考虑中间那个数，这道题也不例外。
我们枚举j，通过求两次逆序对求出对于每个a[j]，满足a[i]&amp;gt;a[j]的i的个数，以及满足a[j]&amp;gt;a[k]的个数。
两个个数的乘积就是j作为中间数满足的三元组的个数，这样把所有的j累加就是答案。
其他的就是，要离散化，以及最后答案可能会爆long long?
1A，好爽啊哈哈哈。
/* *********************************************** Author :111qqz Created Time :Mon 05 Sep 2016 03:40:20 PM CST File Name :code/cf/problem/61E.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E6+7; int a[N]; int A[N]; int H[N]; int n; int m; int tree1[N&amp;lt;&amp;lt;2],tree2[N&amp;lt;&amp;lt;2]; pair&amp;lt;LL,LL&amp;gt;ans[N]; void PushUp(int rt,int *tree) { tree[rt] = tree[rt&amp;lt;&amp;lt;1] + tree[rt&amp;lt;&amp;lt;1|1]; } void update(int p,int l,int r,int rt,int *tree) { if (l==r) { tree[rt]++; return; } int m = (l+r)&amp;gt;&amp;gt;1; if (p&amp;lt;=m) update(p,lson,tree); else update(p,rson,tree); PushUp(rt,tree); } int query(int L,int R,int l,int r,int rt,int *tree) { // cout&amp;lt;&amp;lt;&amp;quot;L:&amp;quot;&amp;lt;&amp;lt;L&amp;lt;&amp;lt;&amp;quot; R:&amp;quot;&amp;lt;&amp;lt;R&amp;lt;&amp;lt;&amp;quot; l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&amp;quot; rt:&amp;quot;&amp;lt;&amp;lt;rt&amp;lt;&amp;lt;endl; if (L&amp;gt;R) return 0; if (L&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=R) return tree[rt]; int m = (l+r)&amp;gt;&amp;gt;1; int ret = 0 ; if (L&amp;lt;=m) { int res = query(L,R,lson,tree); ret+=res; } if (R&amp;gt;=m+1) { int res = query(L,R,rson,tree); ret +=res; } return ret; } int Hash( int x) { return lower_bound(H,H+m,x)-H; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces 19 D. Points (离散化+树套树（线段树+set）)</title><link>http://example.org/2016/09/cf19d/</link><pubDate>Sun, 04 Sep 2016 13:47:07 +0000</pubDate><guid>http://example.org/2016/09/cf19d/</guid><description>题目链接
题意：
1.add x,y 将点(x,y)加进坐标系。
2.remove x,y 将点(x,y)移除.
3.find x,y 找到点(x,y)右上角的点(xp&amp;gt;x,yp&amp;gt;y)。如果有多个输出x最小的。还是有多个输出y最小的。
x,y均为非负数。以上操作均合法。思路：没有思路。。。不会啊。。。以为要二维线段树什么的。。。。总之是不会做。。。
大概从中午开始看题解。。。8个小时。。。。终于完全搞懂了orz
很巧妙得把二维问题转化成了一维问题。。。
我来说一下大概做法，具体的细节见代码注释：
在x轴方向维护一课线段树，线段树的数组tree[i]存储的信息是以i节点为根节点的子树所对应的区间能达到的最大的y值。线段树的叶子节点上是一个set，set[i]是横坐标为i时的纵坐标集合，也就是所谓的树套树。
由于x很大，但是n比较小，所以我们这里采用了stl+去重的办法离散化离散化的三种办法
对于添加和删除点的操作，我们更新完对应的set把相应的x（离散化后的）在线段树中更新就好（因为线段树的update操作是和set有关的）
对于find操作，我们首先从线段树中找到（下标大于x且最小且集合中存在大于y的元素的集合）的下标
这样我们确定了x，再upper_bound一下找到对应的集合中最小的y.
初始化由于没有插入y,所以tree可以初始化为-1，不用建树。。。（反正建了也都是-1）
/* *********************************************** Author :111qqz Created Time :Sun 04 Sep 2016 07:19:05 PM CST File Name :code/cf/problem/19D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n,m; int tree[N&amp;lt;&amp;lt;2]; //记录线段树的信息，tree[i]表示的是以i节点为根节点的子树所代表的区间中的点的最大的y值。 set&amp;lt;int&amp;gt;se[N];//集合se[i]是横坐标为x的点的纵坐标的集合。 struct node //线段树套平衡树，在x轴的方向上建一棵线段树，线段树的每个叶子节点是一个set。 { int x,y; char cmd[15]; void input() { scanf(&amp;quot;%s%d%d&amp;quot;,cmd,&amp;amp;x,&amp;amp;y); } }q[N]; int H[N]; void PushUp(int rt) { tree[rt] = max(tree[rt&amp;lt;&amp;lt;1],tree[rt&amp;lt;&amp;lt;1|1]); } void update( int p,int l,int r,int rt) { if (l==r) { if (se[l].</description></item><item><title>whust 2016 warm up ||codeforces 682 B. Alyona and Mex (离散化)</title><link>http://example.org/2016/07/cf682b/</link><pubDate>Mon, 18 Jul 2016 11:56:35 +0000</pubDate><guid>http://example.org/2016/07/cf682b/</guid><description>cf682B题目链接
题意：给出n个数。。每个数可以任意减小到一个正整数。。。问进行恰当的操作后。。。最小的没有出现的正整数的最大可能取值。。
思路：傻逼题。。。直接离散化。。。。注意不能超过初始。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 12时43分41秒 File Name :code/2016whus/B.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int b[N]; int a[N]; int n; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>uva 120 Stacks of Flapjacks</title><link>http://example.org/2016/01/uva120/</link><pubDate>Mon, 25 Jan 2016 06:09:57 +0000</pubDate><guid>http://example.org/2016/01/uva120/</guid><description>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid;=8&amp;amp;page;=show_problem&amp;amp;problem;=56
题意：给出一个长度为n的序列（无重复元素），询问经过多少次flip(i)操作，使得序列升序排列。定义flip(i)为将1到n-i+1的元素反转&amp;hellip; 思路：先离散化，然后注意读入&amp;hellip;.
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 10时42分46秒 File Name :code/uva/120.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=105; int n; int a[N]; string in; struct node { int value; int id; }q[N]; int pos[N]; bool cmp1(node a,node b) { return a.</description></item><item><title>codeforces 29 C. Mail Stamps</title><link>http://example.org/2015/12/cf29c/</link><pubDate>Wed, 30 Dec 2015 12:27:15 +0000</pubDate><guid>http://example.org/2015/12/cf29c/</guid><description>http://codeforces.com/contest/29/problem/C 题意：给出n个边的关系，保证可以构成一条链。正向或者反向输出这个链。 思路：由于下标很大(1E9)，而关系个数只有1E5..需要离散化。。而且离散化的同时不能丢失边的关系。。。实际上。。直接用vector+map就好了。。。 map &amp;gt;e;即可。然后找到一个度为1的点。。做个dfs&amp;hellip;
/* *********************************************** Author :111qqz Created Time :2015年12月30日 星期三 19时55分15秒 File Name :code/cf/problem/29C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; map&amp;lt;int,vector&amp;lt;int&amp;gt; &amp;gt;e; map&amp;lt;int,bool&amp;gt;vis; map&amp;lt;int,int&amp;gt;in; map&amp;lt;int,int&amp;gt;::iterator it; int beg; int n ; void dfs( int x) { vis[x] = true; printf(&amp;quot;%d &amp;quot;,x); for ( int i = 0 ; i &amp;lt; e[x].</description></item><item><title>sgu 180 - Inversions （离散化+树状数组）</title><link>http://example.org/2015/08/sgu180/</link><pubDate>Thu, 06 Aug 2015 09:09:00 +0000</pubDate><guid>http://example.org/2015/08/sgu180/</guid><description>Inversions **Time Limit:**250MS **Memory Limit:**4096KB 64bit IO Format:%I64d &amp;amp; %I64u
Submit Status
Description
180. Inversions time limit per test: 0.25 sec.
memory limit per test: 4096 KB
input: standard
output: standard
There are N integers (1&amp;lt;=N&amp;lt;=65537) A1, A2,.. AN (0&amp;lt;=Ai&amp;lt;=10^9). You need to find amount of such pairs (i, j) that 1&amp;lt;=iA[j].
Input
The first line of the input contains the number N. The second line contains N numbers A1&amp;hellip;AN.</description></item><item><title>poj 2299 Ultra-QuickSort （树状数组＋离散化）</title><link>http://example.org/2015/08/poj2299/</link><pubDate>Tue, 04 Aug 2015 13:13:00 +0000</pubDate><guid>http://example.org/2015/08/poj2299/</guid><description>这道题可以总结的地方不少。
１：对于一组乱序数列，每次只能交换相邻元素，达到有序交换的次数就是原数列中你逆序对的个数。
　cf上好像总喜欢出这个题。。。我印象中就出现三次了。。。。。
２：原始数组a[i]和树状数组的t[i]的对应问题（？？？存在疑问。。。应该只是这道题，而不是一般规律！）
　这道题n是５０００００，如果直接开数组是可以开得下的，不需要离散化。**但是树状数组的下标对应的是原始数组的值！**也就是t[i]的下表最大可能为９９９，９９９，９９９　！　显然存不下，需要离散化。
**３：学习了离散化的又一种写法。 **
/************************************************************************* &amp;gt; File Name: code/poj/2299.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月04日 星期二 12时27分32秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int inf = 0x7fffffff; const int N=5E5+7; int n; int t[N]; int ref[N]; struct Q { int val,id; }q[N]; bool cmp(Q a,Q b) { if (a.</description></item><item><title>hdu 4022 Bombing (离散化)</title><link>http://example.org/2015/08/hdu4022/</link><pubDate>Sat, 01 Aug 2015 02:12:00 +0000</pubDate><guid>http://example.org/2015/08/hdu4022/</guid><description>wa了两次，原因是在同一个点可能有多个基地。。。
所以用set 是错误的，应该用multiset
然后因为这道题看到了map+set实现离散化的另外一种写法
我的代码：
/************************************************************************* &amp;gt; File Name: code/hdoj/4022.cpp &amp;gt; Author: 111qqz &amp;gt; Email: rkz2013@126.com &amp;gt; Created Time: 2015年08月01日 星期六 04时37分20秒 ************************************************************************/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; #define y0 abc111qqz #define y1 hust111qqz #define yn hez111qqz #define j1 cute111qqz #define tm crazy111qqz #define lr dying111qqz using namespace std; #define REP(i, n) for (int i=0;i&amp;lt;int(n);++i) typedef long long LL; typedef unsigned long long ULL; const int N=2E5+7; const int inf = 0x7fffffff; map&amp;lt;int,int&amp;gt;xmap,ymap; multiset&amp;lt;int&amp;gt;x[N]; multiset&amp;lt;int&amp;gt;y[N]; int main() { int n,m; while (scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m)!</description></item><item><title>hdu 5233 Gunner II (bc #42 B) （离散化）</title><link>http://example.org/2015/07/hdu5233/</link><pubDate>Fri, 31 Jul 2015 19:04:00 +0000</pubDate><guid>http://example.org/2015/07/hdu5233/</guid><description>Gunner II **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 1433 Accepted Submission(s): 540 **
Problem Description
Long long ago, there was a gunner whose name is Jack. He likes to go hunting very much. One day he go to the grove. There are n birds and n trees. The i-th bird stands on the top of the i-th tree. The trees stand in straight line from left to the right.</description></item></channel></rss>