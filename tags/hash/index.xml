<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hash on 111qqz的小窝</title><link>http://example.org/tags/hash/</link><description>Recent content in hash on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Mar 2017 12:20:37 +0000</lastBuildDate><atom:link href="http://example.org/tags/hash/index.xml" rel="self" type="application/rss+xml"/><item><title>murmurhash源码分析</title><link>http://example.org/2017/03/reading-murmurhash-code/</link><pubDate>Wed, 22 Mar 2017 12:20:37 +0000</pubDate><guid>http://example.org/2017/03/reading-murmurhash-code/</guid><description>分析levelDB源码的时候遇到的&amp;hellip;发现是一个广泛应用的hash算法，而且是纯c写的，于是找来了源码看。
最初的实现是C++的，但是被移植到了其他的流行语言上，包括 Python,[11]C,[12]C#,[9][13]Perl,[14]Ruby,[15]PHP,[16]Haskell,[17]、Scala[18]、Java[19][20]和JavaScript[21][22]等。
这个算法已经被若干开源计划所采纳，最重要的有libstdc++ (4.6版)、Perl[23]、nginx (不早于1.0.1版)[24]、Rubinius[25]、 libmemcached (Memcached的C语言客户端驱动)[26]、maatkit[27]、Hadoop[1]、Kyoto Cabinet[28]以及RaptorDB[29]。虽然说破天就是一个hash函数。。似乎没什么好分析的？
不过由于是第一次分析有现实意义的代码，所以简单一点也不是罪过吧orz
以及这次分析代码的重点不在hash算法本身&amp;hellip;而是算法之外的其他东西&amp;hellip;
大概感受下有现实意义的工程代码的布局之类orz
hash函数本身没有分析&amp;hellip;这个没什么好分析的吧&amp;hellip;应该是类似一种构造，看懂每一步很容易，但是你还是想不出来啊？而且一堆&amp;quot;magic number&amp;rdquo;
代码很短，也就200行,分析见注释。
/** * `main.c' - murmurhash * * copyright (c) 2014 joseph werle &amp;lt;joseph.werle@gmail.com&amp;gt; */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;inttypes.h&amp;gt; #include &amp;quot;murmurhash.h&amp;quot; static void usage () { fprintf(stderr, &amp;quot;usage: murmur [-hV] [options]\n&amp;quot;); } static void //函数类型和函数名不一行写是什么风格orz... help () { fprintf(stderr, &amp;quot;\noptions:\n&amp;quot;); fprintf(stderr, &amp;quot;\n --seed=[seed] hash seed (optional)&amp;quot;); fprintf(stderr, &amp;quot;\n&amp;quot;); } static char * read_stdin () { size_t bsize = 1024; size_t size = 1; char buf[bsize]; char *res = (char *) malloc(sizeof(char) * bsize); char *tmp = NULL; // memory issue if (NULL == res) { return NULL; } //申请内存失败了.</description></item><item><title>一致性哈希初探</title><link>http://example.org/2017/03/overview-of-consistent-hashing/</link><pubDate>Wed, 15 Mar 2017 07:58:05 +0000</pubDate><guid>http://example.org/2017/03/overview-of-consistent-hashing/</guid><description>原始论文：一致性哈希
本来不打算放的。。被批评说太不严谨orz..
说说自己的理解好了。。
大概就是。。。hash的时候。。一开始有n个桶。。你设计的函数是y=x%n&amp;hellip;看起来美滋滋。。。
然后这时候突然一个桶不见了。。。如果按照之前设计的hash函数。。就变成了x%(n-1)&amp;hellip;
这可能会造成大量的数据改变自己之前所在的桶。。。这是不可接受的。。。
或者是。。。当前的桶不够用了。。要增加一个桶。。。变成了x%(n+1)。。。也会出现类似情况。。。
我们的目的就是设计一种算法。。。使得当减少一个桶或者增加一个桶的时候。。。。变化尽可能小。。。
并且希望以后新放入的数据尽可能到新的桶中（？
桶是简化的模型。。。实际应用上。。。一致性哈希主要用在分布式系统中。。。每个桶就相当于一台服务器（？or something&amp;hellip;不是很懂分布式的术语）
一致性哈希算法 tencent2012笔试题附加题
问题描述： 例如手机朋友网有n个服务器，为了方便用户的访问会在服务器上缓存数据，因此用户每次访问的时候最好能保持同一台服务器。
已有的做法是根据ServerIPIndex[QQNUM%n]得到请求的服务器，这种方法很方便将用户分到不同的服务器上去。但是如果一台服务器死掉了，那么n就变为了n-1，那么ServerIPIndex[QQNUM%n]与ServerIPIndex[QQNUM%（n-1）]基本上都不一样了，所以大多数用户的请求都会转到其他服务器，这样会发生大量访问错误。
问： 如何改进或者换一种方法，使得：
(1) 一台服务器死掉后，不会造成大面积的访问错误，
(2)原有的访问基本还是停留在同一台服务器上；
(3)尽量考虑负载均衡。（思路：往分布式一致哈希算法方面考虑。）
1. 最土的办法还是用模余方法：做法很简单，假设有N台服务器，现在完好的是M（M&amp;lt;=N),先用N求模，如果不落在完好的机器上，然后再用N-1求模，直到M.这种方式对于坏的机器不多的情况下，具有更好的稳定性。 2. 一致性哈希算法。 下面，本文剩下部分重点来讲讲这个一致性哈希算法。
应用场景 在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括： 轮循算法（Round Robin）、哈希算法（HASH）、最少连接算法（Least Connection）、响应速度算法（Response Time）、加权法（Weighted ）等。其中哈希算法是最为常用的算法.
典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。
常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？
在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。
Consistent Hashing算法描述 下面以Memcached中的Consisten Hashing算法为例说明。
consistent hashing 算法早在 1997 年就在论文 Consistent hashing and random trees 中被提出，目前在 cache 系统中应用越来越广泛；</description></item><item><title>hash学习笔记</title><link>http://example.org/2017/03/hash/</link><pubDate>Sat, 11 Mar 2017 08:15:26 +0000</pubDate><guid>http://example.org/2017/03/hash/</guid><description>前言： hash这种东西人人都会用的东西还有必要说？起因是&amp;hellip;本问了hash中的一个细节&amp;hellip;然后&amp;hellip;我知道怎么做&amp;hellip; 结果描述的不够清楚？如果知道那个做法的名字也许就不用费劲描述了呢。。。所以来复习一下吧2333
hash函数_维基百科
说起来其实哈希只有两个东西比较重要吧。。。
一个是哈希函数的构造：
构造散列函数 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。
1. [直接定址法](https://zh.wikipedia.org/w/index.php?title=&amp;amp;action=edit&amp;amp;redlink=1)：取关键字或关键字的某个线性函数值为散列地址。即{\displaystyle hash(k)=k}![hash(k)=k](https://wikimedia.org/api/rest_v1/media/math/render/svg/92632e59ab25c8f6d526ea9fb9cf4e014912afe3) 或{，其中为常数（这种散列函数叫做自身函数） 2. 数字分析法：假设关键字是以_r_为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。 3. 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 4. 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。 5. 随机数法 6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即{\displaystyle hash(k)=k,{\bmod {,}}p}, {\displaystyle p\leq m}。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。
还有一个就是冲突的处理。。。?
* [开放定址法](https://zh.wikipedia.org/w/index.php?title=&amp;amp;action=edit&amp;amp;redlink=1)（open addressing）：{\displaystyle hash_{i}=(hash(key)+d_{i})\,{\bmod {\,}}m}![hash_{i}=(hash(key)+d_{i})\,{\bmod \,}m](https://wikimedia.org/api/rest_v1/media/math/render/svg/e9f569136022671abb3e623da1828b31313fd254) , {\displaystyle i=1,2&amp;hellip;k,(k\leq m-1)}，其中{\displaystyle hash(key)}为散列函数，{\displaystyle m}为散列表长，{\displaystyle d_{i}}为增量序列，{\displaystyle i}为已发生冲突的次数。增量序列可有下列取法：
{\displaystyle d_{i}=1,2,3...(m-1)}![d_{i}=1,2,3...(m-1)](https://wikimedia.org/api/rest_v1/media/math/render/svg/7164de5dc3e5febaa66956083e959797e265f91c) 称为 线性探测(Linear Probing)；即{\displaystyle d_{i}=i}，或者为其他线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。
{\displaystyle d_{i}=\pm 1^{2},\pm 2^{2},\pm 3^{2}...\pm k^{2}}!</description></item><item><title>poj 3274 Gold Balanced Lineup (抽屉原理？错题？)</title><link>http://example.org/2016/11/poj-3274/</link><pubDate>Wed, 30 Nov 2016 08:10:23 +0000</pubDate><guid>http://example.org/2016/11/poj-3274/</guid><description>poj 3274 题目链接
题意：给出n个数和k，每个数不超过k位二进制。现在问最长的一段区间，满足该区间中所有数相加，k个位置上的数相等。
思路：k个位置上的数都相等的话。。。那这个和应该是(k&amp;laquo;1)-1的整数倍。。。
于是抽屉原理搞了一发。。一直wa..
正解是数字hash。。。
不过我拍了一下。。。如果不是我理解错了题意的话。。。我是把一份ac代码　hack掉了。。。。。
用来对拍的ac代码：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAX 100005 #define mod 1000000 //此处mod定义为99997时，运行时间1000多MS int hash[MAX*10];//hash表储存下标 int sum[MAX][35];//第 1 头牛到第 i 头的对应属性的和 int c[MAX][35];//存放每头牛属性 j与第一个属性的差 int n,k; int Hash_key(int *cc) { int j,key=0; for(j=1;j&amp;lt;k;j++) key=key%mod+cc[j]&amp;lt;&amp;lt;2;//此处用 * 乘超时 key=abs(key)%mod;//此处得到的key可能会是负数，所以取绝对值 return key; } int main() { int i,j,x,maxlen=0;//maxlen为最大长度 scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k); int l,r; memset(hash,-1,sizeof(hash));//初始化哈希表 hash[0]=0;//hash表首位初始化 for(i=1;i&amp;lt;=n;i++) { scanf(&amp;quot;%d&amp;quot;,&amp;amp;x); for(j=0;j&amp;lt;k;j++) { sum[i][j]=sum[i-1][j]+x%2; c[i][j]=sum[i][j]-sum[i][0]; x&amp;gt;&amp;gt;=1; } int key=Hash_key(c[i]); while(hash[key]!</description></item><item><title>poj 3349 Snowflake Snow Snowflakes (利用hash分组)</title><link>http://example.org/2016/11/poj-3349/</link><pubDate>Wed, 30 Nov 2016 06:30:56 +0000</pubDate><guid>http://example.org/2016/11/poj-3349/</guid><description>题意：有n个雪花，每个雪花有６瓣，给出每一瓣的长度，问是否有两个雪花相同。（雪花相同的条件是：存在某个顺序使得两个雪花的每一瓣长度对应相等）
思路：一开始想到的是先最小表示法。。。然后hash。。。存set。。看set的大小。。。但是因为我是顺时针，逆时针都存了一次，那么如果有一个雪花顺时针和逆时针相同，就会出现错误的结果（虽然这个我应该判掉了。。。但是还是WA　orz）
归根结底我是没有搞定当hash相同的时候，如何判定这两个不是一组orz。
看了很多题解。。。（为什么大家这道题的代码都写得这么丑啊。。。。？
思路有：hash或者最小表示法，或者最小表示法＋hash
思路是，把六瓣的长度求和，作为hash的key值。。。
然后。。。只在key相同的里面找一样的。。。
其实是根据这个和分了组。。。
因为和相同的，未必雪花一样，但是雪花的一样的，和一定相同，极大的缩小了范围。
也让我对hash有了新的理解：
hash未必可以唯一确定某个值，但是可以帮助缩小范围。
/* *********************************************** Author :111qqz Created Time :2016年11月29日 星期二 19时29分11秒 File Name :code/poj/3349.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int N=1e5+7; const int inf = 0x3f3f3f3f; int n; int a[N][6]; const int prime = 19997; //素数 vector&amp;lt;int&amp;gt;block[prime]; void Hash( int val,int x) { val%=prime; block[val].</description></item><item><title>poj 1200 Crazy Search (字符串哈希)</title><link>http://example.org/2016/11/poj-1200/</link><pubDate>Tue, 22 Nov 2016 14:02:41 +0000</pubDate><guid>http://example.org/2016/11/poj-1200/</guid><description>题目链接
题意：一个字符串，其仅由nc种字符组成，问其所有长度为n的字串里，共用多少种不同的。
思路：一开始木有懂nc种字符有什么用&amp;hellip;
然后写了hash，发现会TLE。。。因为用到了map，被卡了个log..
nc的作用是，可以把字符串看成一个nc进制的数，这样做的好处是，得到的hash值可以尽可能的小而且保证了不同的字符串对应了不同的hash值。
然后就可以不用map而是一个数组，就变成了O(1)赋值和判断了。。。
（然而没有数据范围其实还是有点耍流氓的嫌疑。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std; const int N=16000005; //题目给出子串的最大和不超过16M const int NUM=257; bool Hash[N]; int m[NUM]; char str[1000000]; int n,nc,i,j,sum,seed=0,ans=0; int main() { // freopen(&amp;quot;code/in.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); memset(Hash,false,sizeof(Hash)); memset(m,0,sizeof(m)); memset(str,'\0',sizeof(str)); cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;nc&amp;gt;&amp;gt;str; int len = strlen(str); for(int i = 0 ; i &amp;lt; len; ++i) { if(!m[str[i]]) //将每个字符赋值为相应进制的数 m[str[i]]=++seed; if(seed == nc) break; } for(i=0;i&amp;lt;=len-n;++i) { sum=0; for(j=0;j&amp;lt;n;++j) //将字符串str[i],..,str[i+n-1]变为一个nc进制的整数,来判断是否重复出现过 sum=sum*nc+m[str[i+j]]-1; if(!Hash[sum]) { Hash[sum]=true; ++ans; } } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>hdu 1800 Flying to the Mars (字符串hash)</title><link>http://example.org/2016/11/hdu1800/</link><pubDate>Tue, 22 Nov 2016 11:41:34 +0000</pubDate><guid>http://example.org/2016/11/hdu1800/</guid><description>题目链接
题意：n个人，每个人有一个level值，用一个最长30位的，可能带前缀0的数字串表示，如果i的level大于j的level，那么i可以教j飞行，每个人只能有一个老师，每个人也只能收一个徒弟。师生可以共用一把扫帚飞行。现在问最少需要多少扫帚。
思路：分析发现，影响扫帚多少的是相等的数有多少，因为只要不相等，就肯定可以构成师生关系&amp;hellip;.
更确切得说，是所有数出现次数的最大值。
有一个trick点，就是带前缀0和不带前缀0的两个level被认为是相等的，hash的时候要处理前缀0.
/* *********************************************** Author :111qqz Created Time :2016年11月22日 星期二 19时18分30秒 File Name :code/hdu/1800.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned int BKDHash(char *str) { unsigned int seed = 251; unsigned int hash = 0 ; while (*str=='0') str++; //带前缀0的和不带前缀0的认为是同一个数，因此要处理前缀0.</description></item><item><title>codeforces 4C. Registration system (字符串hash)</title><link>http://example.org/2016/11/cf4c/</link><pubDate>Tue, 22 Nov 2016 11:11:26 +0000</pubDate><guid>http://example.org/2016/11/cf4c/</guid><description>题目链接
题意：网站的注册系统..处理用户要注册的用户名，如果数据库中没有重名输出OK，否则输出要注册的用户名的字符串+num,num的大小为之前一共有多少个用户试图用该用户名。
思路：hash一下。。。
/* *********************************************** Author :111qqz Created Time :2016年11月22日 星期二 19时00分58秒 File Name :code/cf/problem/4C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; unsigned int BKDHash(char *str) { unsigned int seed = 113; unsigned hash = 0 ; while (*str) hash = hash*seed+(*str++); return (hash&amp;amp;0x7fffffff); } map&amp;lt;int,int&amp;gt;mp; int n; const int N=1E5+7; char str[33]; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2503 Babelfish (字符串hash +sscanf读入技巧)</title><link>http://example.org/2016/11/poj-2503/</link><pubDate>Tue, 22 Nov 2016 10:59:16 +0000</pubDate><guid>http://example.org/2016/11/poj-2503/</guid><description>题目链接
题意：给定一个两种语言的对照关系表&amp;hellip;给出后一种语言中的单词，问对应的前一种语言的单词是什么。。。
思路：hash一下然后map存一下即可。。。。读入方式由于单词表和查询是根据空行分开的。。那么读入不能用scanf(因为会跳过空行），要用gets。。。然后再sscanf一下。。。
/* *********************************************** Author :111qqz Created Time :2016年11月20日 星期日 11时13分29秒 File Name :code/poj/2503.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char eng[N][12],fori[N][12]; char str[N]; map&amp;lt;int,int&amp;gt;mp; unsigned int BKDRHash(char *str) { unsigned int seed = 113; unsigned int hash = 0 ; while (*str) hash = hash*seed+(*str++); return (hash&amp;amp;0x7fffffff); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>hdu 1880 魔咒词典 (字符串hash)</title><link>http://example.org/2016/11/hdu-1880-hash/</link><pubDate>Sun, 20 Nov 2016 03:08:58 +0000</pubDate><guid>http://example.org/2016/11/hdu-1880-hash/</guid><description>题目链接
题意：给你一部魔咒词典。当哈利听到一个魔咒时，你的程序必须告诉他那个魔咒的功能；当哈利需要某个功能但不知道该用什么魔咒时，你的程序要替他找到相应的魔咒。如果他要的魔咒不在词典中，就输出“what?”
思路：hash裸题。。。然而怎么感觉是第一次写hash呢。。。。
/* *********************************************** Author :111qqz Created Time :2016年11月20日 星期日 10时27分05秒 File Name :code/hdu/1880.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char magic[N][25],fun[N][81]; int cnt; int n; map&amp;lt;int,int&amp;gt;mp1,mp2; unsigned int BKDRHash(char *str) { unsigned int seed = 131; unsigned int hash = 0 ; while (*str) hash = hash*seed+(*str++); return (hash&amp;amp;0x7fffffff); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>康托展开和康托逆展开</title><link>http://example.org/2016/09/</link><pubDate>Tue, 13 Sep 2016 05:14:51 +0000</pubDate><guid>http://example.org/2016/09/</guid><description>感觉就是为了记录排列。。。重复之类的。。。用到的一个hash函数。。。？
维基百科
讲解</description></item><item><title>uva 156 - Ananagrams</title><link>http://example.org/2016/01/uva156/</link><pubDate>Mon, 25 Jan 2016 09:19:56 +0000</pubDate><guid>http://example.org/2016/01/uva156/</guid><description>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=92 题意：给出一段文字，包含若干个单词，以&amp;rsquo;#&amp;lsquo;结束。按照字典序输出所有的ananagrams。所谓ananagram，是指经过任意的重排后，不能得到这段文字中的另一个单词（不区分大小写） 思路：首先是字符串的读入&amp;hellip;可以整行读入然后用空格分隔单词。由于补区分大小写，所以要都转化成小写&amp;hellip;但是输出的时候要输出原始，所以还记得保留一份。而且要能够通过新的找到原始的（我用了一个toori的map&amp;lt;string,string&amp;gt;来实现） 然后最关键的部分是如何判断两个单词经过重排是否能一样&amp;hellip;
我的做法是构造一个hash函数&amp;hellip;一个单词的hash值等于对应字母的顺序的平方和&amp;hellip;效果还不错？
单词和hash值一一对应&amp;hellip;最大也就9E5,可以存的下。然后统计每个hash值出现的次数。对于那些只出现一次的，就是我们要的答案。
还要注意的是输出要按照原始单词的字典序，而不是都变成小写以后的字典序。
所以找到之后可以先找到对应的原始单词存到set里，最后再输出。
/* *********************************************** Author :111qqz Created Time :2016年01月25日 星期一 14时26分38秒 File Name :code/uva/156.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=9E5+7; string str; int a[N]; map&amp;lt;string,int&amp;gt;mp; map&amp;lt;string,int&amp;gt;::iterator it; map&amp;lt;string,string&amp;gt;toori; struct node { string ori; string nw; }st[1005]; set&amp;lt;string&amp;gt;ans; set&amp;lt;string&amp;gt;::iterator it2; int main() { mp.</description></item><item><title>hdoj4391 Paint The Wall</title><link>http://example.org/2015/12/hdoj4391/</link><pubDate>Tue, 15 Dec 2015 08:52:37 +0000</pubDate><guid>http://example.org/2015/12/hdoj4391/</guid><description>http://acm.hdu.edu.cn/showproblem.php?pid=4391 题意：有 n 个点，每个点有一种颜色（可能相同），两种操作：1、将区间 [a,b] 染成颜色 c ; 2、询问区间 [a,b] 中颜色为 c 的点有多少个。 思路：因为颜色种类很多。。。没办法通过建很多棵线段树解决。我们用分块的办法。。。
/* *********************************************** Author :111qqz Created Time :2015年12月15日 星期二 15时00分34秒 File Name :code/hdoj/4391.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; //sqrt(n),n最大100000 int n,q,c[N]; int len ,cnt; struct HashBlock{ int siz; //块的大小，因为最后一个快的长度可能不足len, int col;//整块的颜色。当快没有被标记成统一的颜色的时候，为-1 map&amp;lt;int,int&amp;gt;mp; }a[400]; void init() { len = (int)sqrt(n*1.</description></item></channel></rss>