<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hash on 111qqz的小窝</title><link>https://111qqz.com/tags/hash/</link><description>Recent content in Hash on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 22 Mar 2017 12:20:37 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/hash/index.xml" rel="self" type="application/rss+xml"/><item><title>murmurhash源码分析</title><link>https://111qqz.com/2017/03/reading-murmurhash-code/</link><pubDate>Wed, 22 Mar 2017 12:20:37 +0000</pubDate><guid>https://111qqz.com/2017/03/reading-murmurhash-code/</guid><description>
&lt;p>分析levelDB源码的时候遇到的&amp;hellip;发现是一个广泛应用的hash算法，而且是纯c写的，于是找来了源码看。&lt;/p>
&lt;blockquote>**MurmurHash** 是一种非[加密](https://zh.wikipedia.org/wiki/)型[哈希函数](https://zh.wikipedia.org/wiki/)，适用于一般的哈希检索操作。[[1]](https://zh.wikipedia.org/wiki/Murmur#cite_note-Hadoop-1)[[2]](https://zh.wikipedia.org/wiki/Murmur#cite_note-2)[[3]](https://zh.wikipedia.org/wiki/Murmur#cite_note-3)由Austin Appleby在2008年发明，[[4]](https://zh.wikipedia.org/wiki/Murmur#cite_note-4)[[5]](https://zh.wikipedia.org/wiki/Murmur#cite_note-5) 并出现了多个变种，[[6]](https://zh.wikipedia.org/wiki/Murmur#cite_note-Murmur160-6) 都已经发布到了[公有领域](https://zh.wikipedia.org/wiki/)(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。[[7]](https://zh.wikipedia.org/wiki/Murmur#cite_note-StackExchange-7)
&lt;p>最初的实现是&lt;a href="https://zh.wikipedia.org/wiki/C">C++&lt;/a>的，但是被移植到了其他的流行语言上，包括 &lt;a href="https://zh.wikipedia.org/wiki/Python_%28programming_language%29">Python&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-11">[11]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/C">C&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-12">[12]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/C">C#&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-Horvath-9">[9]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-13">[13]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Perl">Perl&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-14">[14]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Ruby">Ruby&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-15">[15]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/PHP">PHP&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-16">[16]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Haskell">Haskell&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-17">[17]&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/Scala">Scala&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-18">[18]&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/Java_%28programming_language%29">Java&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-19">[19]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-20">[20]&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-21">[21]&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/Murmur#cite_note-22">[22]&lt;/a>等。&lt;/p></description></item><item><title>一致性哈希初探</title><link>https://111qqz.com/2017/03/overview-of-Consistent-Hashing/</link><pubDate>Wed, 15 Mar 2017 07:58:05 +0000</pubDate><guid>https://111qqz.com/2017/03/overview-of-Consistent-Hashing/</guid><description>
&lt;p>原始论文：&lt;a href="https://111qqz.com/wordpress/wp-content/uploads/2017/03/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.pdf">一致性哈希&lt;/a>&lt;/p>
&lt;p>本来不打算放的。。被批评说太不严谨orz..&lt;/p>
&lt;p>说说自己的理解好了。。&lt;/p>
&lt;p>大概就是。。。hash的时候。。一开始有n个桶。。你设计的函数是y=x%n&amp;hellip;看起来美滋滋。。。&lt;/p></description></item><item><title>hash学习笔记</title><link>https://111qqz.com/2017/03/hash/</link><pubDate>Sat, 11 Mar 2017 08:15:26 +0000</pubDate><guid>https://111qqz.com/2017/03/hash/</guid><description>
&lt;h2 id="前言">前言：&lt;/h2>
&lt;p>&lt;del>hash这种东西人人都会用的东西还有必要说？&lt;/del>&lt;/p>
&lt;p>&lt;del>&lt;/del>起因是&amp;hellip;本问了hash中的一个细节&amp;hellip;然后&amp;hellip;我知道怎么做&amp;hellip; 结果描述的不够清楚？如果知道那个做法的名字也许就不用费劲描述了呢。。。所以来复习一下吧2333&lt;/p></description></item><item><title>poj 3274 Gold Balanced Lineup (抽屉原理？错题？)</title><link>https://111qqz.com/2016/11/poj-3274/</link><pubDate>Wed, 30 Nov 2016 08:10:23 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-3274/</guid><description>
&lt;p>&lt;a href="http://poj.org/problem?id=3274">poj 3274 题目链接&lt;/a>&lt;/p>
&lt;p>题意：给出n个数和k，每个数不超过k位二进制。现在问最长的一段区间，满足该区间中所有数相加，k个位置上的数相等。&lt;/p>
&lt;p>思路：k个位置上的数都相等的话。。。那这个和应该是(k&amp;laquo;1)-1的整数倍。。。&lt;/p></description></item><item><title>poj 3349 Snowflake Snow Snowflakes (利用hash分组)</title><link>https://111qqz.com/2016/11/poj-3349/</link><pubDate>Wed, 30 Nov 2016 06:30:56 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-3349/</guid><description>
&lt;p>题意：有n个雪花，每个雪花有６瓣，给出每一瓣的长度，问是否有两个雪花相同。（雪花相同的条件是：存在某个顺序使得两个雪花的每一瓣长度对应相等）&lt;/p>
&lt;p>思路：一开始想到的是先最小表示法。。。然后hash。。。存set。。看set的大小。。。但是因为我是顺时针，逆时针都存了一次，那么如果有一个雪花顺时针和逆时针相同，就会出现错误的结果（虽然这个我应该判掉了。。。但是还是WA　orz）&lt;/p></description></item><item><title>poj 1200 Crazy Search (字符串哈希)</title><link>https://111qqz.com/2016/11/poj-1200/</link><pubDate>Tue, 22 Nov 2016 14:02:41 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-1200/</guid><description>
&lt;p>&lt;a href="http://poj.org/problem?id=1200">题目链接&lt;/a>&lt;/p>
&lt;p>题意：一个字符串，其仅由nc种字符组成，问其所有长度为n的字串里，共用多少种不同的。&lt;/p>
&lt;p>思路：一开始木有懂nc种字符有什么用&amp;hellip;&lt;/p>
&lt;p>然后写了hash，发现会TLE。。。因为用到了map，被卡了个log..&lt;/p></description></item><item><title>hdu 1800 Flying to the Mars (字符串hash)</title><link>https://111qqz.com/2016/11/hdu1800/</link><pubDate>Tue, 22 Nov 2016 11:41:34 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu1800/</guid><description>
&lt;p>&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=1800">题目链接&lt;/a>&lt;/p>
&lt;p>题意：n个人，每个人有一个level值，用一个最长30位的，可能带前缀0的数字串表示，如果i的level大于j的level，那么i可以教j飞行，每个人只能有一个老师，每个人也只能收一个徒弟。师生可以共用一把扫帚飞行。现在问最少需要多少扫帚。&lt;/p></description></item><item><title>codeforces 4C. Registration system (字符串hash)</title><link>https://111qqz.com/2016/11/cf4c/</link><pubDate>Tue, 22 Nov 2016 11:11:26 +0000</pubDate><guid>https://111qqz.com/2016/11/cf4c/</guid><description>
&lt;p>&lt;a href="http://codeforces.com/problemset/problem/4/C">题目链接&lt;/a>&lt;/p>
&lt;p>题意：网站的注册系统..处理用户要注册的用户名，如果数据库中没有重名输出OK，否则输出要注册的用户名的字符串+num,num的大小为之前一共有多少个用户试图用该用户名。&lt;/p></description></item><item><title>poj 2503 Babelfish (字符串hash +sscanf读入技巧)</title><link>https://111qqz.com/2016/11/poj-2503/</link><pubDate>Tue, 22 Nov 2016 10:59:16 +0000</pubDate><guid>https://111qqz.com/2016/11/poj-2503/</guid><description>
&lt;p>&lt;a href="http://poj.org/problem?id=2503">题目链接&lt;/a>&lt;/p>
&lt;p>题意：给定一个两种语言的对照关系表&amp;hellip;给出后一种语言中的单词，问对应的前一种语言的单词是什么。。。&lt;/p>
&lt;p>思路：hash一下然后map存一下即可。。。。读入方式由于单词表和查询是根据空行分开的。。那么读入不能用scanf(因为会跳过空行），要用gets。。。然后再sscanf一下。。。&lt;/p></description></item><item><title>hdu 1880 魔咒词典 (字符串hash)</title><link>https://111qqz.com/2016/11/hdu-1880--hash/</link><pubDate>Sun, 20 Nov 2016 03:08:58 +0000</pubDate><guid>https://111qqz.com/2016/11/hdu-1880--hash/</guid><description>
&lt;p>&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=1880">题目链接&lt;/a>&lt;/p>
&lt;p>题意：给你一部魔咒词典。当哈利听到一个魔咒时，你的程序必须告诉他那个魔咒的功能；当哈利需要某个功能但不知道该用什么魔咒时，你的程序要替他找到相应的魔咒。如果他要的魔咒不在词典中，就输出“what?”&lt;/p></description></item><item><title>康托展开和康托逆展开</title><link>https://111qqz.com/2016/09/</link><pubDate>Tue, 13 Sep 2016 05:14:51 +0000</pubDate><guid>https://111qqz.com/2016/09/</guid><description>
&lt;p>感觉就是为了记录排列。。。重复之类的。。。用到的一个hash函数。。。？&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/#.E5.BA.B7.E6.89.98.E5.B1.95.E5.BC.80.E7.9A.84.E9.80.86.E8.BF.90.E7.AE.97">维基百科&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://blog.csdn.net/lttree/article/details/24798653">讲解&lt;/a>&lt;/p></description></item><item><title>uva 156 - Ananagrams</title><link>https://111qqz.com/2016/01/uva156/</link><pubDate>Mon, 25 Jan 2016 09:19:56 +0000</pubDate><guid>https://111qqz.com/2016/01/uva156/</guid><description>
&lt;p>&lt;a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=92">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=92&lt;/a>
题意：给出一段文字，包含若干个单词，以&amp;rsquo;#&amp;lsquo;结束。按照字典序输出所有的ananagrams。所谓ananagram，是指经过任意的重排后，不能得到这段文字中的另一个单词（不区分大小写）
思路：首先是字符串的读入&amp;hellip;可以整行读入然后用空格分隔单词。由于补区分大小写，所以要都转化成小写&amp;hellip;但是输出的时候要输出原始，所以还记得保留一份。而且要能够通过新的找到原始的（我用了一个toori的map&amp;lt;string,string&amp;gt;来实现）
&lt;strong>然后最关键的部分是如何判断两个单词经过重排是否能一样&amp;hellip;&lt;/strong>&lt;/p></description></item><item><title>hdoj4391 Paint The Wall</title><link>https://111qqz.com/2015/12/hdoj4391/</link><pubDate>Tue, 15 Dec 2015 08:52:37 +0000</pubDate><guid>https://111qqz.com/2015/12/hdoj4391/</guid><description>
&lt;p>&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=4391">http://acm.hdu.edu.cn/showproblem.php?pid=4391&lt;/a>
题意：有 n 个点，每个点有一种颜色（可能相同），两种操作：1、将区间 [a,b] 染成颜色 c ; 2、询问区间 [a,b] 中颜色为 c 的点有多少个。
思路：因为颜色种类很多。。。没办法通过建很多棵线段树解决。我们用分块的办法。。。&lt;/p></description></item></channel></rss>