<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>halide on 111qqz's blog</title><link>https://111qqz.com/tags/halide/</link><description>Recent content in halide on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Mon, 18 Feb 2019 06:00:51 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/halide/index.xml" rel="self" type="application/rss+xml"/><item><title>【施工中】 halide学习笔记</title><link>https://111qqz.com/2019/02/halide-notes/</link><pubDate>Mon, 18 Feb 2019 06:00:51 +0000</pubDate><guid>https://111qqz.com/2019/02/halide-notes/</guid><description>
**Halide is a programming language designed to make it easier to write high-performance image and array processing code on modern machines. ** halide有两个特性比较吸引人。一个是对于各种平台架构的支持。
* CPU architectures: X86, ARM, MIPS, Hexagon, PowerPC * Operating systems: Linux, Windows, macOS, Android, iOS, Qualcomm QuRT * GPU Compute APIs: CUDA, OpenCL, OpenGL, OpenGL Compute Shaders, Apple Metal, Microsoft Direct X 12 另一个是把计算什么和怎么计算(何时计算)分离开来。
Halide的Schedule可以由程序员来指定一些策略，指定硬件的buffer大小，缓冲线的相关设置，这样可以根据不同的计算硬件的特性来实现高效率的计算单元的调度，而图像算法的计算实现却不需要修改。</description></item><item><title>优化学习笔记(1):Loop unrolling</title><link>https://111qqz.com/2019/01/loop-unrolling/</link><pubDate>Wed, 23 Jan 2019 11:51:46 +0000</pubDate><guid>https://111qqz.com/2019/01/loop-unrolling/</guid><description>
迫于生计，最近要学习halide
先去学习/复习一下常见的编译优化技巧。
loop unrolling，也就是循环展开，顾名思义，就是把循环展开来写。
normal loop: int x; for (x = 0; x &amp;lt; 100; x++) { delete(x); } after loop unrolling: int x; for (x = 0; x &amp;lt; 100; x += 5 ) { delete(x); delete(x + 1); delete(x + 2); delete(x + 3); delete(x + 4); } 循环展开是一种优化，可以手动实现也可以编译器自动实现。
为什么要将循环展开？ * 循环每次都需要判断终止条件，展开后可以消除这部分开销。 * 减少[分支预测](https://en.wikipedia.org/wiki/Branch_predictor)开销。循环里的分支是指“跳出循环”还是“进行下一次迭代” * [vectorization](https://en.wikipedia.org/wiki/Automatic_vectorization) for (int y = 0; y &amp;lt; 4; y++) { for (int x_outer = 0; x_outer &amp;lt; 2; x_outer++) { // The loop over x_inner has gone away, and has been // replaced by a vectorized version of the // expression.</description></item></channel></rss>