<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on 111qqz的小窝</title><link>http://example.org/tags/c++/</link><description>Recent content in c++ on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 28 Aug 2018 06:30:59 +0000</lastBuildDate><atom:link href="http://example.org/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>[设计模式] 组合模式（composite） 学习笔记</title><link>http://example.org/2018/08/Composite-Pattern-notes/</link><pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate><guid>http://example.org/2018/08/Composite-Pattern-notes/</guid><description>目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个tree 。如果某个节点是叶子节点了，那么对应的tree都为NULL. 只不过这里用了更加面向对象的实现。
具体看代码：
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月28日 星期二 14时21分51秒 File Name :composite.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Component { // 为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为 protected: string name; public: Component(string n) { name = n; } virtual ~Component() {} virtual void Add(Component* c) = 0; virtual void Remove(Component* c) = 0; virtual void Display(int depth) = 0; }; class Leaf : public Component { // 在组合中表示叶节点对象，叶节点没有子节点 public: Leaf(string name) : Component(name) {} void Add(Component* c){} // 叶节点没有Add功能，但这样做能使接口具备一致性，这就是透明方式，如果不加入Add和Remove方法，那就是安全方式。 void Remove(Component* c){} // 同上 void Display(int depth) { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; endl; } }; class Composite : public Component { // 定义有枝节点行为，用来存储子部件 private: list&amp;lt;Component* &amp;gt; children; public: Composite(string name) : Component(name) {} void Add(Component* c) { children.</description></item><item><title>把二进制文件按字节读到vector中</title><link>http://example.org/2018/08/how-to-read-binary-data-into-cpp-vector/</link><pubDate>Tue, 21 Aug 2018 06:08:56 +0000</pubDate><guid>http://example.org/2018/08/how-to-read-binary-data-into-cpp-vector/</guid><description>std::vector&amp;lt;unsigned char&amp;gt; readFromFile1(const char* filePath) { FILE* file = fopen(filePath, &amp;quot;rb&amp;quot;); std::vector&amp;lt;unsigned char&amp;gt; result; if (file == nullptr) { return result; } // 获取文件大小，尽量一次读完 size_t fileSize = getFileSize(file); if (fileSize != 0) { result.resize(fileSize); size_t n = fread(&amp;amp;result[0], 1, fileSize, file); assert(n &amp;lt;= fileSize); if (n != fileSize) { result.resize(n); } } // 在读取过程当中，有可能文件大小有变化，再尝试读取 const size_t read_len = 1024; char buf[read_len]; for (;;) { size_t n = fread(buf, 1, read_len, file); result.</description></item><item><title>记录一次因动态库符号表可见性导致的未定义的引用(undefined reference)</title><link>http://example.org/2018/08/symbol-table-visibility/</link><pubDate>Wed, 15 Aug 2018 13:12:17 +0000</pubDate><guid>http://example.org/2018/08/symbol-table-visibility/</guid><description>编译某代码，发现报错某函数未定义的引用。该函数的是先前编译得到的动态库中。
先去check了该函数的实现，还有接口与头文件中的声明是否统一。发现没有问题。
然后怀疑.cpp文件没有被编译到，于是在该函数中添加
#pragma message(&amp;quot;******************************8&amp;quot;)
发现的确被编译到了。
使用nm来查看动态库中的符号表，发现也可以找到这个函数的符号。
于是怀疑编译代码的时候没有链接到该动态库。
于是在make的时候打印详细信息。make VERBOSE=1
发现也的确链接了动态库&amp;hellip;.
见鬼了Orz
然后用readelf -s 来查看动态库，惊讶得发现要找的那个符号的BIND怎么是LOCAL..也就是只有文件内可见。
最后发现&amp;hellip;是公司内部的工具和CMakeLists中的add_library冲突&amp;hellip;
虽然这个坑的解决方案没什么价值&amp;hellip;不过因为这个坑了解了一些之前没有了解的部分，也算值得。
关于动态库的符号可见性：
控制的原因是，如果不控制，那么不同的cpp文件可能有相同的变量名字，如果把所有的符号都暴露，很可能在链接时产生冲突。 另外一个原因是，暴露没有必要的符号，会导致符号表的size变大，从而使得link时速度变慢。
参考资料:
Introduction to symbol visibility
readelf elf文件格式分析
Hiding what&amp;rsquo;s exposed in a shared library
Why is the new C++ visibility support so useful?</description></item><item><title>C++ STL Algotithms 学习笔记</title><link>http://example.org/2018/05/c-stl-algotithms-notes/</link><pubDate>Sun, 06 May 2018 09:45:50 +0000</pubDate><guid>http://example.org/2018/05/c-stl-algotithms-notes/</guid><description>迫于拙劣的cpp水平，这次来记录一些关于STL算法部分的内容。
参考内容是CS106L的course reader
Iterator Categories Iterators分为以下五种:
* Output Iterators:可以使用&amp;quot;++&amp;quot;；可以用*myItr = value,不能用value = *myItr * Input Iterators:可以使用&amp;quot;++&amp;quot;;可以用value = *myItr，不能用*myItr = value * Forward Iterators: 可以使用&amp;quot;++&amp;quot;,可以同时用value = *myItr和*myItr = value * Bidirectional Iterators:比起Forward Iterator 对了&amp;quot;--&amp;quot;,但是不能+或者+= * Random-Access Iterators：比起Bidirectional Iterators多了+和+= Algorithm Naming Conventions 一些关于STL Algorithm的命名规则
后缀_if表示只有当满足一定条件的时候该算法才会执行一定任务。
比如:
bool IsEven(int value) { return value % 2 == 0; } cout &amp;lt;&amp;lt; count_if(myVec.begin(), myVec.end(), IsEven) &amp;lt;&amp;lt; endl; _n表示执行一个特定的操作n次。
比如:
fill_n(myDeque.begin(), 10, 0); Reordering Algorithms * sort: 传入的必须是Random-Access Iterators，记得定义&amp;lt;函数 * random_shuffle:传入的必须是Random-Access Iterators,作用是将一个区间内的元素打乱重排。 可以在使用之前先使用srand函数。 * rotate：作用是循环改变容器中元素的顺序。rotate(v.</description></item><item><title>C++ IO Streams 学习笔记</title><link>http://example.org/2018/05/cpp-io-streams-notes/</link><pubDate>Fri, 04 May 2018 03:48:37 +0000</pubDate><guid>http://example.org/2018/05/cpp-io-streams-notes/</guid><description>迫于拙劣的cpp水平，来补补以前忽略掉的cpp细节。
老规矩，先放资料。
参考资料:
A Gentle Introduction to C++ IO Streams
Stream的基本认识 说说我的理解。stream(流)可以看做输入输出的抽象。我们通过流可以忽略掉device的细节，采取同样的输入输出方式。
对于任何原生的cpp类型，都可以用stream来处理。用户自定义的类，也可以通过重载&amp;laquo;和&amp;raquo;而让stream可以处理。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; // timestamp returns the current time as a string std::string timestamp(); class LogStatement; ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; ost, const LogStatement&amp;amp; ls); class LogStatement { public: LogStatement(std::string s): data(s), time_string( timestamp() ) { }; //This method handles all the outputs. friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp;, const LogStatement&amp;amp;); private: std::string data; std::string time_string; }; ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; ost, const LogStatement&amp;amp; ls) { ost&amp;lt;&amp;lt;&amp;quot;~|&amp;quot;&amp;lt;&amp;lt;ls.</description></item><item><title>Eigen: C++开源矩阵学习笔记</title><link>http://example.org/2018/04/eigen-notes/</link><pubDate>Thu, 05 Apr 2018 07:14:54 +0000</pubDate><guid>http://example.org/2018/04/eigen-notes/</guid><description>接触Eigen的原因是最近在看caffe/caffe2源码,caffe2中使用了Eigen库. Eigen 是一个基于C++模板的线性代数库，直接将库下载后放在项目目录下，然后包含头文件就能使用，非常方便。对于Linux用户,只需要把头文件放到/usr/include 下即可此外，Eigen的接口清晰，稳定高效。
之后会更新一些,Eigen中我使用过的函数.
ubuntu14.04LTS 下使用方式: sudo apt-get install libeigen3-dev cd /usr/include/eigen3 sudo cp -R Eigen /usr/include 然后尝试运行如下代码,直接编译即可.如果可以正常运行,表明安装完毕.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;Eigen/Dense&amp;gt; //using Eigen::MatrixXd; using namespace Eigen; using namespace Eigen::internal; using namespace Eigen::Architecture; using namespace std; int main() { cout&amp;lt;&amp;lt;&amp;quot;*******************1D-object****************&amp;quot;&amp;lt;&amp;lt;endl; Vector4d v1; v1&amp;lt;&amp;lt; 1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v1=\n&amp;quot;&amp;lt;&amp;lt;v1&amp;lt;&amp;lt;endl; VectorXd v2(3); v2&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v2=\n&amp;quot;&amp;lt;&amp;lt;v2&amp;lt;&amp;lt;endl; Array4i v3; v3&amp;lt;&amp;lt;1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v3=\n&amp;quot;&amp;lt;&amp;lt;v3&amp;lt;&amp;lt;endl; ArrayXf v4(3); v4&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v4=\n&amp;quot;&amp;lt;&amp;lt;v4&amp;lt;&amp;lt;endl; } map的使用办法: double arr[9]={1,2,3,4,5,6,7,8,9}; MapA(arr,3,3); 得到 1 4 7 2 5 8 3 6 9</description></item><item><title>cmake 学习笔记</title><link>http://example.org/2018/03/cmake-notes/</link><pubDate>Sun, 18 Mar 2018 10:27:26 +0000</pubDate><guid>http://example.org/2018/03/cmake-notes/</guid><description>前置技能点：
gnu make
linux下.so,.a,.o文件
cmake是一个工具，也可以看成一门语言。
学习cmake最大的障碍在于看不懂全是大写的英文学习cmake主要参考了《cmake practice》
不过感觉作者有些啰嗦&amp;hellip;不重要的东西讲了半天，重要的东西却一带而过。。。表述得也不是特别流畅。。。但是还是感谢作者的分享吧orz&amp;hellip;
cmake的定位是大型项目构建工具。
目前适用于C/C++/JAVA的项目。
可以不需要自己写makefile文件。
既然cmake可以看做一门语言，那么自然就有语法。
下面只是列举一些常用的。不常用的可以用到的时候再去查。这里也会不定期补充。
cmake的语法中，对于变量大小写敏感，对于cmake的关键字大小写不敏感，不过习惯于全部大写。
cmake有两种编译方式，一种叫in source 编译（就是直接在工程目录编译）
一种叫out of source 编译，就是在工程目录下新建build,然后在build文件夹里编译。
一般都采用out of source的方式编译，这样可以使得编译得到的结果都存放在build文件夹里，不会和源代码混在一起。
set 命令用来定义变量：
SET(HELLO_SRC main.SOURCE_PATHc)
然后就可以用${HELLO_SRC}　来引用这个变量了（例外：在if语句中，是直接使用变量名引用，而不需要${}）
ADD_EXECUTABLE来定义生成的可执行文件的名字：
ADD_EXECUTABLE(hello SRC_LIST)
表示源文件是SRC_LIST 中定义的源文件列表，生成一个文件名为hello的可执行文件。
如果有多个参数，可以写成：
ADD_EXECUTABLE(hello main.c func.c)或者 ADD_EXECUTABLE(hello main.c;func.c)
ADD_SUBDIRECTORY指令：
ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制存 放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除,比如,工程 的 example,可能就需要工程构建完成后,再进入 example 目录单独进行构建(当然,你 也可以通过定义依赖来解决此类问题)。
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})：生成动态(共享)库
语法为：ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 &amp;hellip; sourceN)
常用到的是SHARED动态库，STATIC静态库
SET_TARGET_PROPERTIES：可以修改生成的库的名字
SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &amp;ldquo;hello&amp;rdquo;)
INCLUDE_DIRECTORIES：添加头文件搜寻目录</description></item><item><title>CUDA C Best Practices Guide 阅读笔记（二） Heterogeneous Computing</title><link>http://example.org/2018/02/cuda-c-best-practices-guide-heterogeneous-computing/</link><pubDate>Tue, 13 Feb 2018 06:38:38 +0000</pubDate><guid>http://example.org/2018/02/cuda-c-best-practices-guide-heterogeneous-computing/</guid><description>CUDA 编程涉及到在不同的平台上同时运行代码:包含CPU的host 和包含GPU的device.
所以了解host和device的对性能优化是非常重要的。
2.1. Differences between Host and Device Threading resources host 上能同时运行的线程数目比较少（比如24个）
device上能同时运行的线程数目比较多（数量级通常为1E3，1E4等）
Threads 操作系统必须交换CPU执行通道上和下的线程以提供多线程功能。因此，上下文切换(当交换两个线程时)既慢又昂贵。
相比之下，GPU上的线程非常轻量级。在典型的系统中，成千上万的线程排队等待工作(每个线程有32个线程)。如果GPU必须等待 one warp of threads，它只需开始在另一个线程上执行工作。
简而言之，CPU内核被设计为每次最小化一个或两个线程的等待时间，而GPU被设计为处理大量并发的轻量级线程以最大化吞吐量。
RAM host和device 各自具有各自不同的附接物理存储器。host和device内存由PCI Express ( PCIe )总线分隔，因此host内存中的项目必须偶尔通过总线传送到device内存，反之亦然
2.2. What Runs on a CUDA-Enabled Device? 下面谈谈应该把应用的哪些部分放在device 上运行
* 大数据集上的算术运算 * 为了获得最佳性能，设备上运行的相邻线程的内存访问应该具有一定的一致性。**某些内存访问模式使硬件能够将多个数据项的读或写组合并到一个操作中**。当在CUDA上的计算中使用时，无法布局以实现合并的数据，或者没有足够的局部性来有效地使用L1或纹理缓存的数据，将倾向于看到较小的加速比。 * host和device之间的数据交换尽可能少 * **换到device上执行的数据一定会被做足够多的运算**，不然数据从Host传送到device的代价 可能与该运算在device上并行计算的优势向抵消，甚至得不偿失。 * **数据应尽可能长时间保存在设备上。**因为传输应该最小化，所以在同一数据上运行多个内核的程序应该倾向于在内核调用之间将数据保留在设备上，而不是将中间结果传输到主机，然后再将它们发送回设备进行后续计算。就是说，如果有一段连续的操作要处理某些数据，就算其中的部分操作在host上运行要比在device上快（比如不是算数运算而是逻辑处理），那么考虑到数据传输的巨大代价，将所有数据都放在device上处理可能会更好。这种处理原则即使相对较慢的内核也可能是有利的，如果它避免了一个或多个PCIe传输。</description></item><item><title>qt 5.x　初探　(5)　</title><link>http://example.org/2017/06/qt-5-notes-5/</link><pubDate>Sun, 04 Jun 2017 17:14:39 +0000</pubDate><guid>http://example.org/2017/06/qt-5-notes-5/</guid><description>qt_5.9_ui_doc
还是比直接写代码方便点。。。所以不妨学习一个！
以及。。。qt在2017年6月１号发布了5.9。。。所以之前是5.8。。。现在变成5.9了。。。
遇到了修改了ui文件却没有生效的问题。。。
解决办法：
到项目目录下去执行：uic mainwindow.ui &amp;gt; ui_mainwindow.h 时间测试的qt方法。。。
头文件#include &amp;lt;QTime&amp;gt; QTime time; time.start(); // do something qDebug()&amp;lt;&amp;lt;time.elapsed()&amp;lt;&amp;lt;&amp;quot;ms&amp;quot;; （注意单位。。。</description></item><item><title>qt 5.x初探　（４）　qt 在win下打包成exe</title><link>http://example.org/2017/06/qt-5-notes-4/</link><pubDate>Sun, 04 Jun 2017 12:54:51 +0000</pubDate><guid>http://example.org/2017/06/qt-5-notes-4/</guid><description>des的基本搞定了。。。打包。。。
在linux下打包成exe。。。。实在是。。没什么好办法的样子。。。
嘛。转念一想。老师说是打包成可执行文件。。。没说一定是exe啊。。。
然后也许我就零分了呢2333
des1.0
好了。。我又跑到windows下装了个qt&amp;hellip;安装包2.3G,记得要安装编译器&amp;hellip;
装好以后。。。开始打包。。。
注意区分：
Qt Widgets Application 和 Qt Quick Application
我的是后者。。。打包方式略有不同。。。
下面引用了详细步骤。。我来说下简略步骤好了。。。
* 将creator选到release的部署模式。。然后编译。。。 * 将exe文件单独拷贝出来，放到一个文件夹。。。 * **运行qt的命令行（不是系统的命令行！)** * **在qt的命令行中运行windeployqt helloqml.exe --qmldir C:\Qt\Qt5.4.0\5.4\mingw491_32\qml（其中qmldir后面换为qml的真实路径）** 顺便吐槽这工具有点智障。。。文件夹选项不显示后缀名就找不到helloqml　也是有毒。。。
集成开发环境 QtCreator 目前生成图形界面程序 exe 大致可以分为两类： Qt Widgets Application 和 Qt Quick Application。 下面分别介绍这两类exe 的发布方式。
1、Qt Widgets Application可执行程序发布方式 首先用 QtCreator 新建一个 Qt Widgets Application 项目，直接用默认的 QMainWindow 程序就可以了，项目名字假定是 hellomw。 然后以 Release 方式编译生成 exe 程序： 生成的程序运行正常之后，找到项目的生成目录，比如 项目源码路径： C:\QtPros\hellomw
它的项目生成目录是 C:\QtPros\build-hellomw-Desktop_Qt_5_4_0_MinGW_32bit-Release
进入这个文件夹，在进入它的子文件夹 release 里面，找到 hellomw.</description></item><item><title>qt 5.x初探 （3）</title><link>http://example.org/2017/05/qt-5-notes-3/</link><pubDate>Thu, 18 May 2017 12:47:20 +0000</pubDate><guid>http://example.org/2017/05/qt-5-notes-3/</guid><description>update3：
终于知道了正确的学习姿势&amp;hellip;
用百度把要用的东西大概描述出来，然后总能找到一个是你要的。。。
然后再去搜关键词。。。
嗯。。百度还是很有用的啊2333
qt5.8_doc_Line Edits Example
所以现在要把之前写成dialog的几个改回Line edit
update2:
老师说要把输入框中的东西随时选中复制出来check&amp;hellip;
QLabel默认好像不具有这种属性啊？
稍微查了下。。。
查到了一个叫setTextInteractionFlags的属性
以及连根拔出了。。
qt5.8 QGraphicsTextItem Class
找到了解决办法。。。
openFileNameLabel = new QLabel; openFileNameLabel-&amp;gt;setFrameStyle(frameStyle); openFileNameLabel-&amp;gt;setTextInteractionFlags(Qt::TextSelectableByMouse); //添加可选中可复制的交互属性。。。 记得要
#include &amp;lt;QGraphicsTextItem&amp;gt; update1:
扶起。。。QFile读中文路径文件毫无问题。。。
换成了cpp的 ifstream就一直报错。。。
由于我还改了其他部分。。。所以。。。
查了好久才发现是ifstream的锅。。。。
把des放了进去。。。
本来加密和解密想就用一个函数用参数调节的。。。
不过看了半天也没太懂。。。这种connnet怎么写。。。
不过对connect的理解更深了一些。。。
信号和槽果然是qt的精髓。。。看起来还算不那么无聊。。。
放一些关于信号和槽的资料好了。。。
信号与槽机制
ibm_qt的信号与槽机制
qt的信号槽
然后目前的进度是。。。
des放了进去。。。加密基本没啥问题。。。
但是有个小问题。。。
对于加密过程。。。我是用了一个全局的QString QTextSt来传递信息。。。
对于打开文件。。。过程是file-&amp;gt;QString
加密后得到密文文件。。过程是QString -&amp;gt; file
但是解密过程。。。。完全反过来了啊。。。？
在思考怎么写在一起能够不违和。。。。。</description></item><item><title>qt 5.x 学习笔记　(2)</title><link>http://example.org/2017/05/qt-5-notes-2/</link><pubDate>Tue, 16 May 2017 03:14:19 +0000</pubDate><guid>http://example.org/2017/05/qt-5-notes-2/</guid><description>先来放一波过程中用到的资料和官方文档好了。
basic layout_qt5.8
QBoxLayout Class_qt5.8
QString Class 5.8
QChar Class qt 5.8
Standard Dialogs Example qt 5.8
更新的部分还是放在最前面好了。。。
convert from QString to char *的时候有个坑。。。
举个栗子。。。。
int main(int argc, char **argv) { QApplication app(argc, argv); QString str1 = &amp;quot;Test&amp;quot;; QByteArray ba = str1.toLatin1(); const char *c_str2 = ba.data(); printf(&amp;quot;str2: %s&amp;quot;, c_str2); return app.exec(); } 目前基本框架出来了。。。
可以打开一个文件。。加密。。保存。。。
加密算法部分暂时用倒序输出代替。。。
界面布局还没搞。。。一些提示之类的还没搞。。。。。。。。
接下来要做的。。。大概就是把des写进去了。。。
放一波代码好了。。。
/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.</description></item><item><title>qt 5.x　初探(1)</title><link>http://example.org/2017/05/qt-5-notes-1/</link><pubDate>Sun, 14 May 2017 12:21:56 +0000</pubDate><guid>http://example.org/2017/05/qt-5-notes-1/</guid><description>嘛。。为了系统安全课来学一波qt&amp;hellip;
现在算是写出了一个可以打开文件，保存文件的记事本。。。
接下来要搞定的事情是。。。如何写一个自定义的事件。。。比如计算个开方之类的。。。
放一波代码好了。。。
#include &amp;lt;QAction&amp;gt; #include &amp;lt;QMenuBar&amp;gt; #include &amp;lt;QMessageBox&amp;gt; #include &amp;lt;QStatusBar&amp;gt; #include &amp;lt;QToolBar&amp;gt; #include &amp;lt;QDebug&amp;gt; #include &amp;lt;QTextEdit&amp;gt; #include &amp;lt;QFileDialog&amp;gt; #include &amp;quot;mainwindow.h&amp;quot; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { openAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Open...&amp;quot;), this); openAction-&amp;gt;setShortcuts(QKeySequence::Open); openAction-&amp;gt;setStatusTip(tr(&amp;quot;Open an existing file&amp;quot;)); saveAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Save...&amp;quot;), this); saveAction-&amp;gt;setShortcuts(QKeySequence::Save); saveAction-&amp;gt;setStatusTip(tr(&amp;quot;Save a new file&amp;quot;)); QMenu *file = menuBar()-&amp;gt;addMenu(tr(&amp;quot;&amp;amp;File&amp;quot;)); file-&amp;gt;addAction(openAction); file-&amp;gt;addAction(saveAction); QToolBar *toolBar = addToolBar(tr(&amp;quot;&amp;amp;File&amp;quot;)); toolBar-&amp;gt;addAction(openAction); toolBar-&amp;gt;addAction(saveAction); textEdit = new QTextEdit(this); setCentralWidget(textEdit); connect(openAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::openFile); connect(saveAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::saveFile); } MainWindow::~MainWindow() { } void MainWindow::openFile() { QString path = QFileDialog::getOpenFileName(this, tr(&amp;quot;Open File&amp;quot;), &amp;quot;.</description></item></channel></rss>