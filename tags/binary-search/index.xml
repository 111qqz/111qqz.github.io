<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>binary search on 111qqz的小窝</title><link>http://example.org/tags/binary-search/</link><description>Recent content in binary search on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 12 Oct 2017 08:26:53 +0000</lastBuildDate><atom:link href="http://example.org/tags/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>uvalive 7675 | 2016 北京 regional onsite H - A New Ground Heating Device （二分+多个圆面积并）</title><link>http://example.org/2017/10/uvalive-7675/</link><pubDate>Thu, 12 Oct 2017 08:26:53 +0000</pubDate><guid>http://example.org/2017/10/uvalive-7675/</guid><description>题目链接
题意： 在一个二维平面上，有n个加热设备，每个加热设备加热一个圆形，加热设备需要信号源才可以工作，信号源在原点上，但是高度不确定。假设设备的加热半径是一个与{信号源与设备的距离}有关的表达式。现在想要满足，至少有k个加热设备加热的面积大于s，问信号源的最高高度是多少。
思路： 训练的时候一眼二分，但是求圆并的时候gg了。。毫无思路。
搞定了多个圆面积并。。这题就很easy了。。
需要注意，每次二分的时候，记得初始化圆的d&amp;hellip;
/* *********************************************** Author :111qqz File Name :H.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define PB push_back #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef vector &amp;lt;int&amp;gt; VI; const int INF = 0x3f3f3f3f; const double eps = 1e-6; const int MAXN = 1E3+7; const double PI = acos(-1.</description></item><item><title>leetcode162. Find Peak Element (O(lgn)复杂度寻找峰值)</title><link>http://example.org/2017/04/leetcode-162/</link><pubDate>Fri, 14 Apr 2017 12:25:16 +0000</pubDate><guid>http://example.org/2017/04/leetcode-162/</guid><description>A peak element is an element that is greater than its neighbors.
Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[-1] = num[n] = -∞.
For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</description></item><item><title>leetcode 33. Search in Rotated Sorted Array (无重复数的旋转数组找定值)</title><link>http://example.org/2017/04/leetcode-33-search-in-rotated-sorted-array/</link><pubDate>Thu, 13 Apr 2017 06:29:37 +0000</pubDate><guid>http://example.org/2017/04/leetcode-33-search-in-rotated-sorted-array/</guid><description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
思路：找规律。。。二分。。。
0 1 2 3 4 5 6 1 2 3 4 5 6 0 2 3 4 5 6 0 1 3 4 5 6 0 1 2 4 5 6 0 1 2 3 5 6 0 1 2 3 4 6 0 1 2 3 4 5 观察发现。。。a[mid]&amp;lt;a[r]的时候，后半段有序;</description></item><item><title>leetcode 34. Search for a Range (二分，找到一段值为tar的区间)</title><link>http://example.org/2017/04/leetcode-34-search-for-a-range/</link><pubDate>Thu, 13 Apr 2017 05:34:45 +0000</pubDate><guid>http://example.org/2017/04/leetcode-34-search-for-a-range/</guid><description>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4].
思路：二分。。。
我好像根本不会二分啊？？？
二分查找
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 10时49分02秒 File Name :34.</description></item><item><title>leetcode 81. Search in Rotated Sorted Array II (有重复元素的旋转数组找给定值)</title><link>http://example.org/2017/04/leetcode-81-search-in-rotated-sorted-array-ii/</link><pubDate>Wed, 05 Apr 2017 13:17:51 +0000</pubDate><guid>http://example.org/2017/04/leetcode-81-search-in-rotated-sorted-array-ii/</guid><description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Write a function to determine if a given target is in the array.
The array may contain duplicates.
好像阿里一面的时候问过。。。
思路：肯定是二分。。。不过由于有重复元素。。。所以很恶心。。。
总的思路是。。。当发现重复元素。。并且该重复元素不是target的时候。。。缩小范围。。。
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 20时26分25秒 File Name :81.cpp ************************************************ */ class Solution { public: bool search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int siz = nums.</description></item><item><title>求旋转数组最小值（二分）</title><link>http://example.org/2017/03/</link><pubDate>Sun, 12 Mar 2017 13:19:16 +0000</pubDate><guid>http://example.org/2017/03/</guid><description>题意：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
思路：二分。。。注意有重复元素。。。
class Solution { public: int minNumberInRotateArray(vector&amp;lt;int&amp;gt; a) { int siz = a.size(); int l = 0 ; int r = siz-1; while (r-l&amp;gt;1) { int mid = (l+r)&amp;gt;&amp;gt;1; if (a[mid]&amp;gt;a[r]) l = mid; else r = mid; } return min(a[l],a[r]); } };</description></item><item><title>leetcode 74. Search a 2D Matrix</title><link>http://example.org/2017/03/leetcode-74-search-a-2d-matrix/</link><pubDate>Thu, 09 Mar 2017 11:14:05 +0000</pubDate><guid>http://example.org/2017/03/leetcode-74-search-a-2d-matrix/</guid><description>题目链接
题意：给一个二维数组。。。每一行每一列都分别递增。。问某个value是否出现过。。。
思路：单调。。显然二分。。。唯一的技巧是从右上角开始搜。
/* *********************************************** Author :111qqz Created Time :2017年03月09日 星期四 19时03分07秒 File Name :74.cpp ************************************************ */ class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int n = matrix.size(); if (n==0) return false; int m = matrix[0].size(); if (m==0) return false; int row = 0 ; int col = m-1; while (col&amp;gt;=0&amp;amp;&amp;amp;row&amp;lt;n) { if (matrix[row][col]==target) return true; else if (matrix[row][col]&amp;gt;target) col--; else row++; } return false; } };</description></item><item><title>leetcode 235. Lowest Common Ancestor of a Binary Search Tree（求一个BST中某两个节点LCA）</title><link>http://example.org/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</link><pubDate>Wed, 22 Feb 2017 13:22:08 +0000</pubDate><guid>http://example.org/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</guid><description>题目链接
题意：求一个BST中某两个节点LCA&amp;hellip;.
思路：卧槽。。。竟然求LCA&amp;hellip;直接想到的显然是Tarjan的方法或者。。。RMQ+DFS。。。但是感觉。。。leetcode怎么可能考算法。。。。于是想到。。。可以从BST下手。。。
两个节点的LCA的值一定在这两个节点之间。
可以根据这个条件做二分。。。
这道题的收获是。。。不要被已知的东西限制住思路。。。tarjan或者RMQ+DFS显然也能做。。。但是那样的相当于没有用到BST的条件。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode * Find(TreeNode* root,TreeNode* p,TreeNode *q) { if (root==NULL) return NULL; //实际上这应该不可能发生》。。。 int rt = root-&amp;gt;val; int a = p-&amp;gt;val; int b = q-&amp;gt;val; if (a&amp;lt;=rt&amp;amp;&amp;amp;rt&amp;lt;=b) return root; if (b&amp;lt;=rt&amp;amp;&amp;amp;rt&amp;lt;=a) return root; if (a&amp;lt;rt&amp;amp;&amp;amp;b&amp;lt;rt) return Find(root-&amp;gt;left,p,q); if (a&amp;gt;rt&amp;amp;&amp;amp;b&amp;gt;rt) return Find(root-&amp;gt;right,p,q); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root==NULL) return NULL; TreeNode* res = Find(root,p,q); return res; } };</description></item><item><title>codeforces 381 div 2 D. Alyona and a tree(二分+前缀和)</title><link>http://example.org/2016/11/cf740d/</link><pubDate>Mon, 28 Nov 2016 07:07:00 +0000</pubDate><guid>http://example.org/2016/11/cf740d/</guid><description>题目链接
d:题意：一棵树，给出边权和点权，定义点v控制点u，当且仅当u是v的子树中的点，并且dis(u,v)&amp;lt;=a[u]，其中dis(u,v)为点u到点v路径上的边权和，a[u]为点u的点权，现在问对于每个节点v，其能控制的点有多少个。
思路：先写了个rmq+dfs的lca。。。那么任意两个点的距离都可以O(1)得到了。然后不会了233333.upd:和lca没有什么关系，因为一个点能控制另一个点这两个点一定在一条通向根的链上，因此距离直接减一下就好了。
机智的做法：dfs的时候维护一个栈，对于栈中序列，后面一半是对当前点有贡献的。问题时求对于每个v统计其能控制多少个u，现在我们固定u，考虑能控制他的v。这些v在树上的形态时一条链 ，借助第二类前缀和的思想，对于u标记+1，对于u往上的离根最近的且能统治u的v上面的一个标记-1，然后dfs后序遍历（也就是链的起点时距离根远的那一边），距离处理的时候，只需要在递归之后更新ans就好了。
栈里面维护，到哪个节点，从根下来，边权和最大，找边权和&amp;gt;=当前边权和-a[u]的地方。
启示：由于两个存在统治关系的点在一条链上，边权都为正，边权和具有单调性，单调的东西，容易想到二分处理。
/* *********************************************** Author :111qqz Created Time :2016年11月24日 星期四 09时17分48秒 File Name :code/cf/#381/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; int n; int a[N]; LL dis[N]; vector&amp;lt; pair&amp;lt;int,LL&amp;gt; &amp;gt;edge[N]; vector&amp;lt; pair&amp;lt;LL,int&amp;gt; &amp;gt;path; int ans[N]; void dfs( int u,int pre) { ans[u]++; int idx = lower_bound(path.</description></item><item><title>codeforces #609 F. Frogs and mosquitoes (线段树+二分)</title><link>http://example.org/2016/09/codeforces-609-f-frogs-and-mosquitoes-/</link><pubDate>Tue, 20 Sep 2016 17:48:18 +0000</pubDate><guid>http://example.org/2016/09/codeforces-609-f-frogs-and-mosquitoes-/</guid><description>题目链接
题意：n只青蛙，第i只位于x[i],舌头长度为t[i]。m只蚊子，第i只蚊子所在位置为p[i],蚊子的大小为b[i]。
蚊子按照出现顺序输入。
一只青蛙能吃到蚊子当且仅当蚊子和青蛙在同一个位置，或者蚊子在青蛙右边并且与青蛙的距离小于等于该青蛙舌头的长度。
当多只青蛙可以吃到同一只蚊子的时候，最左边的那只青蛙来吃。
当一只青蛙吃掉一只蚊子以后，青蛙的舌头增加蚊子的大小。
当一只青蛙吃掉一只蚊子后，因为舌头边长而又能吃到其他蚊子的时候，这只青蛙会继续吃，只到当前没有蚊子可以被任何一只青蛙吃到，在这个过程之后才会飞来下一只蚊子。
思路：问题的关键在于，对于某只蚊子，我们如何找到能吃到该蚊子的青蛙中最左边的那只。
可以抽象成寻找区间[1,r]中，最左边的那个&amp;gt;=x的元素。
联想到一个类似的问题：对于区间[1,n]，找到最左边的&amp;gt;=x的元素。做法是线段树维护最大值，只需要每次先query左子树，就可以保证找到额是最左边的。
但是如果是区间[1,r]呢。。。
我们发现。。。区间[1..k] (k&amp;lt;=r)的最大值是随着k的增大而不减的。。。。（最大值。。。肯定不减呀）
也就是说是单调的。。。因此我们可以考虑二分。。。这很重要。。。
寻找区间[1，r]中第一个大于等于x的元素，利用单调性来二分做是一个很经典的做法，复杂度(lgn)^2,注意体会。
因此具体做法是：
建树，存的是区间中x[i]+t[i]的最大值。
对于每一只飞来的蚊子，寻找能吃到它的最左边的青蛙的编号（具体做法是，先找到最后一个位置小于等于蚊子位置的青蛙的下标，作为青蛙的下标的上界，然后二分，每次query区间最大值，不断缩小区间。）
当蚊子被吃的时候记录答案，更新青蛙的各种信息（线段树要update)
并且由于青蛙的舌头变长了，可能吃到之前没有青蛙能吃到的蚊子，因此要把之前的没有能被青蛙吃到的蚊子存进一个multiset(因为蚊子可能落在同一个位置） 然后让当前的青蛙尽可能吃这些没有被吃到的蚊子，同时更新青蛙的各种信息，并在multiset中删除这只蚊子/
没被吃的时候就扔进multiset里。
需要注意multiset erase的时候要erase一个迭代器。。。不然会把所有相同的都删掉。。。
/* *********************************************** Author :111qqz Created Time :Wed 21 Sep 2016 12:30:16 AM CST File Name :code/cf/problem/609F.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; LL ,LL &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=2E5+7; struct node { LL x,t; LL sum; int id; bool operator &amp;lt; (node b)const { return x&amp;lt;b.</description></item><item><title>poj 3579 Median (尺取法+二分)</title><link>http://example.org/2016/09/poj-3579/</link><pubDate>Mon, 19 Sep 2016 16:54:21 +0000</pubDate><guid>http://example.org/2016/09/poj-3579/</guid><description>题意：给出n个数，两两做差的绝对值，共有m=n*(n-1)/2个，问其中的中位数是多少。特别地，当m为偶数的时候，中位数为第m/2个。
思路：二分中位数。
一开始还觉得由于中位数在整数意义上不连续不能二分。。。。
但是最后结果不可能是那样的答案啊。。。
check的条件是，以k为中位数的时候，绝对值小于k的数要小于(m+1)/2个（也就是中位数所在的位置）
check的时候尺取即可。
复杂度 排序O(nlgn) + 二分(lgn)*尺取O(n) ，整体O(nlgn)
/* *********************************************** Author :111qqz Created Time :Tue 20 Sep 2016 12:18:19 AM CST File Name :code/poj/3579.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL n,m; int x[N]; bool check( int k) { int cnt = 0 ; //cnt为绝对值小于k的对数,小于中位数的对数应该小于m个。 int head = 1; int tail = 1; while (head&amp;lt;=n) { while (x[tail]-x[head]&amp;lt;k&amp;amp;&amp;amp;tail&amp;lt;=n) tail++; tail--; cnt+=(tail-head); head++; } return cnt&amp;gt;=m; } int bin() { int l = 0 ; int r = x[n] - x[1]; while (l&amp;lt;=r) { int mid = (l+r)&amp;gt;&amp;gt;1; if (check(mid)) r = mid-1; else l = mid+1; } return l-1; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>poj 2456 Aggressive cows (二分)</title><link>http://example.org/2016/09/poj2456/</link><pubDate>Mon, 19 Sep 2016 15:15:57 +0000</pubDate><guid>http://example.org/2016/09/poj2456/</guid><description>题目链接
题意：给出n个x轴上的坐标点，选取其中c个，问c个之中任意两个点的最小距离最大是多少。
思路：二分距离check合法性。
大水题。。。因为想把三分艹掉。。。三分的题又多和二分挂在一起。。。顺便就写了。。。。
/* *********************************************** Author :111qqz Created Time :Mon 19 Sep 2016 10:57:54 PM CST File Name :code/poj/2456.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; int x[N]; int n,c; bool check( int k) { int cnt = 1; int cur = x[1]; for ( int i = 2 ; i &amp;lt;= n ; i++) { if (x[i]-cur&amp;gt;=k) { cnt++; cur = x[i]; } } return cnt&amp;gt;=c; } int bin() { int l = 1; int r = x[n]-x[1]; while (l&amp;lt;=r) { int mid = (l+r)&amp;gt;&amp;gt;1; if (!</description></item><item><title>seerc 2014 Circle of digits (二分+后缀数组)</title><link>http://example.org/2016/08/seerc-2014-circle-of-digits-/</link><pubDate>Sat, 27 Aug 2016 07:37:23 +0000</pubDate><guid>http://example.org/2016/08/seerc-2014-circle-of-digits-/</guid><description>题目链接
题意：把一个长度为n的只由数字构成的串分成k个不为空的字串，使得最大的串最小（大小是说串所对应的十进制数的大小）
思路：由于长度为x的串肯定大于长度为x-1的串，因此很容易想到，我们要尽可能使得k组串的长度尽可能平均（避免出现某一个串的长度非常大的情况）
我们可以知道，最大值的串的长度一定为 LEN=(n+k-1)/k;
而每一组的长度，只可能是LEN或者LEN-1。
然后build_sa
注意循环串的几个地方记得%n
接下来二分sa数组的下标。
二分check的时候，先枚举断点，断环为链。
由于每部分最长的长度为LEN，所以0..LEN-1中一定存在一个断点。
然后贪心，尽可能取LEN
根据rk值来决定某一段的长度是LEN还是LEN-1（如果rk值比当前的大，那么就只能取LEN-1，否则取LEN）
如果此时k段的长度之和超过了n，说明此时的最大值还可能更小。
于是继续二分区间的前一半。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char s[N]; int sa[N],t[N],t2[N],c[N]; int rk[N],height[N]; int L; int n,k; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;amp;&amp;amp;r[(a+l)%n]==r[(b+l)%n];} void build_sa(int n,int m) { int *x = t; int *y = t2; //ms(cnt,0); ms(c,0); for ( int i = 0 ; i &amp;lt; n ; i++) c[x[i]=s[i]]++; for ( int i = 1 ; i &amp;lt; m ; i++) c[i]+=c[i-1]; for ( int i = n-1 ; i &amp;gt;= 0 ; i--) sa[--c[x[i]]] = i; for ( int k = 1 ; k &amp;lt;= n ; k &amp;lt;&amp;lt;=1) { int p = 0; for ( int i = 0 ; i &amp;lt; n ; i++) if (sa[i]&amp;gt;=k) y[p++] = sa[i]-k; else y[p++] = n+(sa[i]-k)%n; ms(c,0); for ( int i = 0 ; i &amp;lt; n ; i++) c[x[y[i]]]++; for ( int i = 0 ; i &amp;lt; m ; i++) c[i]+=c[i-1]; for ( int i = n-1 ; i &amp;gt;=0 ; i--) sa[--c[x[y[i]]]] = y[i]; swap(x,y); p = 1; x[sa[0]] = 0 ; for ( int i = 1 ; i &amp;lt; n ; i++) x[sa[i]] = cmp(y,sa[i-1],sa[i],k)?</description></item><item><title>whust 2016 warm up G ||codeforces 689C. Mike and Chocolate Thieves</title><link>http://example.org/2016/07/cf689c/</link><pubDate>Mon, 18 Jul 2016 12:29:16 +0000</pubDate><guid>http://example.org/2016/07/cf689c/</guid><description>cf689C
题意：给出一个m。。问恰好使得不超过某个n的a*b^3（a,b是正整数）的方案数为m的n是多少。。。
思路：暴力+二分。。。
/* *********************************************** Author :111qqz Created Time :2016年07月18日 星期一 15时58分55秒 File Name :code/2016whust/G.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; LL m,n; LL ans; LL cal( LL x) { LL res = 0LL; for ( LL i =2 ; i * i * i &amp;lt;= x ; i++) res+=x/(i*i*i); return res; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1614: [Usaco2007 Jan]Telephone Lines架设电话线 (二分+spfa)</title><link>http://example.org/2016/05/bzoj-1614/</link><pubDate>Sun, 22 May 2016 13:09:49 +0000</pubDate><guid>http://example.org/2016/05/bzoj-1614/</guid><description>1614: [Usaco2007 Jan]Telephone Lines架设电话线 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 1325 Solved: 570 [Submit][Status][Discuss]
Description Farmer John打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，FJ必须为此向电信公司支付一定的费用。 FJ的农场周围分布着N(1 &amp;lt;= N &amp;lt;= 1,000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间都没有电话线相连。一共P(1 &amp;lt;= P &amp;lt;= 10,000)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无法被连接。 第i对电话线杆的两个端点分别为A_i、B_i，它们间的距离为 L_i (1 &amp;lt;= L_i &amp;lt;= 1,000,000)。数据中保证每对{A_i，B_i}最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线杆连起来的路径，其余的电话线杆并不一定要连入电话网络。 经过谈判，电信公司最终同意免费为FJ连结K(0 &amp;lt;= K &amp;lt; N)对由FJ指定的电话线杆。对于此外的那些电话线，FJ需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线杆）。如果需要连结的电话线杆不超过 K对，那么FJ的总支出为0。 请你计算一下，FJ最少需要在电话线上花多少钱。
Input 第1行: 3个用空格隔开的整数：N，P，以及K
第2..P+1行: 第i+1行为3个用空格隔开的整数：A_i，B_i，L_i
Output 第1行: 输出1个整数，为FJ在这项工程上的最小支出。如果任务不可能完成， 输出-1 Sample Input 5 7 1 1 2 5 3 1 4 2 4 8 3 2 3 5 2 9 3 4 7 4 5 6</description></item><item><title>poj 2452 Sticks Problem (rmq+二分，需要返回最值位置)</title><link>http://example.org/2016/05/poj2452/</link><pubDate>Wed, 18 May 2016 05:40:40 +0000</pubDate><guid>http://example.org/2016/05/poj2452/</guid><description>poj2452题目链接
题意：给你一组数a[n]，求满足a[i] &amp;lt; a[k] &amp;lt; a[j] (i &amp;lt;= k &amp;lt;= j)的最大的j-i。
思路：大概能想到是rmq，然后想出了一个错误复杂度的错误思路，还直到对拍才发现==
转载一篇题解：poj2452解题报告
收获最大的是：
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
对于最大值和最小值返回val还是位置的转化竟然可以这样容易!
只要
int _min(int l,int r) { if (a[l]&amp;lt;a[r]) return l; return r; } 这样一个函数就可以实现完美转化。。。
/* *********************************************** Author :111qqz Created Time :2016年05月16日 星期一 13时42分56秒 File Name :code/poj/2452.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=5E4+7; int n; int a[N]; int dp[N][20]; int dp2[N][20]; int _min(int l,int r) { if (a[l]&amp;lt;a[r]) return l; return r; } int _max( int l,int r) { if (a[l]&amp;gt;a[r]) return l; else return r; } void max_init() { for ( int i = 1 ; i &amp;lt;= n ; i++) dp[i][0] = i; for ( int j = 1 ; (1&amp;lt;&amp;lt;j)&amp;lt;=n ; j++) for (int i = 1 ; i + (1&amp;lt;&amp;lt;j)-1 &amp;lt;= n ;i++) dp[i][j] = _max(dp[i][j-1],dp[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } void min_init() { for ( int i = 1 ;i &amp;lt;= n ; i++) dp2[i][0] = i; for ( int j = 1 ; (1&amp;lt;&amp;lt;j)&amp;lt;= n ; j++) for ( int i = 1 ; i + (1&amp;lt;&amp;lt;j) -1 &amp;lt;= n ; i++) dp2[i][j] = _min(dp2[i][j-1],dp2[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } int rmq_max(int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; return _max(dp[l][k],dp[r-(1&amp;lt;&amp;lt;k)+1][k]); } int rmq_min( int l,int r) { int k = 0 ; while (1&amp;lt;&amp;lt;(k+1)&amp;lt;=r-l+1) k++; return _min(dp2[l][k],dp2[r-(1&amp;lt;&amp;lt;k)+1][k]); } int bin (int x,int l,int r) { while (l&amp;lt;=r) { if (l==r) return l; int m = (l+r)&amp;gt;&amp;gt;1; if (a[x]&amp;lt;a[rmq_min(l,m)]) l = m + 1; else r = m; } } void solve() { int ans = 0; for ( int i = 1 ; i+ans &amp;lt; n ; i++) { int r = bin(i,i+1,n); int k = rmq_max(i,r); if (a[k]&amp;gt;a[i]) ans = max(ans,k-i); } if (ans==0) puts(&amp;quot;-1&amp;quot;); else printf(&amp;quot;%d\n&amp;quot;,ans); } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>BZOJ 1650: [Usaco2006 Dec]River Hopscotch 跳石子 (二分)</title><link>http://example.org/2016/04/bzoj-1650/</link><pubDate>Mon, 11 Apr 2016 12:07:02 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1650/</guid><description>1650: [Usaco2006 Dec]River Hopscotch 跳石子 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 440 Solved: 290 [Submit][Status][Discuss]
Description Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 &amp;lt;= L &amp;lt;= 1,000,000,000).</description></item><item><title>BZOJ 1639: [Usaco2007 Mar]Monthly Expense 月度开支 (二分)</title><link>http://example.org/2016/04/bzoj-1639/</link><pubDate>Fri, 08 Apr 2016 08:11:10 +0000</pubDate><guid>http://example.org/2016/04/bzoj-1639/</guid><description>1639: [Usaco2007 Mar]Monthly Expense 月度开支 Time Limit: 5 Sec Memory Limit: 64 MB Submit: 767 Solved: 381 [Submit][Status][Discuss]
Description Farmer John是一个令人惊讶的会计学天才，他已经明白了他可能会花光他的钱，这些钱本来是要维持农场每个月的正常运转的。他已经计算了他以后N(1&amp;lt;=N&amp;lt;=100,000)个工作日中每一天的花费moneyi(1&amp;lt;=moneyi&amp;lt;=10,000)，他想要为他连续的M(1&amp;lt;=M&amp;lt;=N)个被叫做“清算月”的结帐时期做一个预算，每一个“清算月”包含一个工作日或更多连续的工作日，每一个工作日都仅被包含在一个“清算月”当中。 FJ的目标是安排这些“清算月”，使得每个清算月的花费中最大的那个花费达到最小，从而来决定他的月度支出限制。
Input 第一行：两个用空格隔开的整数：N和M
第2..N+1行：第i+1行包含FJ在他的第i个工作日的花费
Output 第一行：能够维持每个月农场正常运转的钱数
Sample Input 7 5 100 400 300 100 500 101 400
Sample Output 500 输入细节
这里有7个工作日来被5个“清算月”划分。他花费100，400，100，500，101，和400元在他的每个工作日。
输出细节
如果FJ安排他的月度预算，他将把前两天划分在一个月中，把第三天、第四天划分在一个月当中，最后的三个工作日各自在一个月当中，所以他一个月最多花费500元，其他的方法总是得出一个较大的结果。
100 400 300 100 500 101 400 每天花费 &amp;mdash;1&amp;mdash; &amp;mdash;2&amp;mdash; -3- -4- -5- 月度标号 500 400 500 101 400 月度花费
HINT Source Silver
思路：一开始以为是贪心。挨个放，然后每放完m个sort一次。但是有可能是连续多次都划分在一个里啊。。不一定是挨个放，所以是错的。
正解是二分：check的时候因为必须是连续的区间，每次大于x了，则划分数+1，最后判断划分数是否小于等于m.需要注意的是，初始的划分数就是1.</description></item><item><title>codeforces 617 C. Tourist's Notes (二分)</title><link>http://example.org/2016/03/cf617e-2/</link><pubDate>Wed, 30 Mar 2016 15:24:59 +0000</pubDate><guid>http://example.org/2016/03/cf617e-2/</guid><description>题目链接 题意：有n天的旅行，但是只剩下了m天的旅行记录，记录格式为d[i],h[d[i]]，表示第i个记录是第d[i]天的，高度为h[d[i]],相邻两天的高度之差的绝对值不超过1.问满足以上条件的最大的h是多少。无解输出impossible. 思路：为了练习二分。 二分高度，然后check是否合法。注意边界，所以可以添加两个点。
/* *********************************************** Author :111qqz Created Time :2016年03月30日 星期三 16时53分57秒 File Name :code/cf/problem/538C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; const int M=1E9; //上界并不是h的最大值。。因为还可以继续往上走啊。。 int n,m; int h[N],d[N]; bool check (int x) { // cout&amp;lt;&amp;lt;&amp;quot;x:&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; for ( int i = 1 ; i &amp;lt;= m-1 ; i++) { if (x&amp;lt;h[i]||x&amp;lt;h[i+1]) return true; int cost = abs(x-h[i]) + abs(h[i+1]-x); // cout&amp;lt;&amp;lt;&amp;quot;cost:&amp;quot;&amp;lt;&amp;lt;cost&amp;lt;&amp;lt;endl; if (cost&amp;lt;=d[i+1]-d[i]) return true; } return false; } int bin() { int l = 0 ; int r = M ; int mid; while (l&amp;lt;=r) { mid = (l+r)/2; if (check(mid)) l = mid + 1; else r = mid -1; } if (r&amp;gt;M) return -1; return r; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>codeforces #339 div2 D</title><link>http://example.org/2016/02/cf613b/</link><pubDate>Sat, 20 Feb 2016 12:59:29 +0000</pubDate><guid>http://example.org/2016/02/cf613b/</guid><description>http://codeforces.com/contest/613/problem/B 题意：有n个技能，初始每个技能的level为a[i]，每个技能最大level为A(不妨称为满级技能)，设满级技能个数为maxnum,最小的技能level为minval,问如何将m个技能点分配到n个技能上使得cfmaxsum+cmminval (n&amp;lt;=1E5,a[i],A&amp;lt;=1E9,cf,cm&amp;lt;=1E3,m&amp;lt;=1E15)
思路：贪心。如果让有限的maxsum个技能满级的话，那么一定是让初始最大的maxsum技能满级更优。我们O(n)可以预处理一个c[i]数组，表示将i个技能变成最大值的最小花费。 然后再预处理一个前缀和数组，sum[i]表示初始最小的i个的技能的花费之和。 然后从0到n枚举变成最大值的技能的个数，在剩下的技能中二分能达到的最小值。 注意要按照原来顺序输出，所以记得记录id.
/* *********************************************** Author :111qqz Created Time :2016年02月20日 星期六 13时11分30秒 File Name :code/cf/#339/D.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; LL n,A,cf,cm,m; LL b[N]; LL c[N]; //c[i]表示将i个变为最大值需要的最少花费 LL sum[N] ; //sum[i]表示花费最少的i个的价值和 struct node { LL val; int id; bool operator &amp;lt; (node b)const { return val&amp;gt;b.</description></item><item><title>codeforces 479D. Long Jumps</title><link>http://example.org/2015/04/cf479d/</link><pubDate>Wed, 08 Apr 2015 11:52:00 +0000</pubDate><guid>http://example.org/2015/04/cf479d/</guid><description>http://codeforces.com/problemset/problem/479/D
题意是说有一把尺子，本身有一些刻度，然后需要测量x和y，问最少需要添加多少个刻度，如果需要，这些刻度分别添加在什么位置。
一开始没有看清题目，以为答案最多为4，但是发现，a[1]=0 a[n]=l这两个是确定的，所以答案最多为2，
而不会出现中间有两个刻度，无论是往前刻还是往后都会越界的情况。
先去看看已知的刻度里有没有直接满足的。
除此之外，如果在已知的刻度下无法测量x也无法测量y，我们还可以找找是否能有公用点使得只刻一个刻度就可以满足题意。公用点分两种情况，一种是在两个刻度之间，另一种是在两个刻度的同侧。
前一种没什么坑，后一种要判断是否越界！！！
如果在已知的刻度下能测量x或者能测量出y但不能同时测量的话，就没有必要找公用点。
还有就是查找的话如果线性找复杂度是O(n2)，会TLE在第27个点。
我们用二分&amp;hellip;
话说STL里竟然连二分查找也有。。。。简直orz。。。。真是省时省力。
代码：
/* *********************************************** Author :111qqz Created Time :2016年02月22日 星期一 23时42分46秒 File Name :code/cf/problem/479D.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int n,l,x,y; const int N=1E5+7; int a[N]; int ans,p,q; bool flag1,flag2,flag3,flag4; int main() { scanf(&amp;#34;%d %d %d %d&amp;#34;,&amp;amp;n,&amp;amp;l,&amp;amp;x,&amp;amp;y); flag1 = false; flag2 = false; flag3 = false; flag4 = false; for ( int i = 1 ; i &amp;lt;= n ; i++ ) scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); ans = 2; p = -1; q = 0; for ( int i = 1 ; i &amp;lt;= n ; i++ ) { if(binary_search(a,a+n+1,a[i]+x)) { flag1 = true; } if (binary_search(a,a+n+1,a[i]+y)) { flag2 = true; } if (binary_search(a,a+n+1,a[i]+x+y)) { flag3 = true; p = a[i]; } if (binary_search(a,a+n+1,a[i]+y-x)&amp;amp;&amp;amp;((a[i]+y&amp;lt;=l)||(a[i]-x&amp;gt;=0))) { flag4 = true; p = a[i]; } } if ( flag1) {ans--;q = 1 ;} if ( flag2 ){ ans--;q = 2 ;} if ( ans==2&amp;amp;&amp;amp;(flag3||flag4)) { ans--; } cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; if ( ans==2 ) { cout&amp;lt;&amp;lt;a[1]+x&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;a[1]+y&amp;lt;&amp;lt;endl; } if ( ans==1 ) { if ( p==-1 ) { if ( q==1 ) cout&amp;lt;&amp;lt;a[1]+y&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;a[1]+x&amp;lt;&amp;lt;endl; } else { if ( p+y&amp;lt;=l ) cout&amp;lt;&amp;lt;p+y&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;p-x&amp;lt;&amp;lt;endl; } } return 0; }</description></item></channel></rss>