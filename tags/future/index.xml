<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>future on 111qqz的小窝</title><link>https://111qqz.com/tags/future/</link><description>Recent content in future on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 30 Sep 2018 06:49:27 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/future/index.xml" rel="self" type="application/rss+xml"/><item><title>[c++11] std::async std::packaged_task std::promise and std::future notes</title><link>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</link><pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</guid><description>
把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::future对象.简单来说,当某个线程需要等待一个特定的一次性事件(one-off event),它可以用一个&amp;quot;future&amp;quot;来表示这个事件.
std::async 有的时候可能你需要做一个花费事件比较长的计算,但是计算结果不是立刻需要.这个时候就可以用一个新的线程来做这个计算.这里比较关键的问题是如何将在新线程进行计算的结果传回到当前线程,因为std::thread并没有提供一个类似的机制.
这个时候就需要std::async登场了.
#include &amp;lt;future&amp;gt; #include &amp;lt;iostream&amp;gt; int find_the_answer_to_ltuae(); void do_other_stuff(); int main() { std::future&amp;lt;int&amp;gt; the_answer=std::async(find_the_answer_to_ltuae); do_other_stuff(); std::cout&amp;lt;&amp;lt;&amp;quot;The answer is &amp;quot;&amp;lt;&amp;lt;the_answer.get()&amp;lt;&amp;lt;std::endl; } 当然也可以与向std::thread包装的thread function中传参数一样,向std::async中传参数,如下:
#include &amp;lt;string&amp;gt; #include &amp;lt;future&amp;gt; struct X { void foo(int,std::string const&amp;amp;); std::string bar(std::string const&amp;amp;); }; X x; auto f1=std::async(&amp;amp;X::foo,&amp;amp;x,42,&amp;quot;hello&amp;quot;); // 调用p-&amp;gt;foo(42, &amp;quot;hello&amp;quot;)，p是指向x的指针 auto f2=std::async(&amp;amp;X::bar,x,&amp;quot;goodbye&amp;quot;); // 调用tmpx.bar(&amp;quot;goodbye&amp;quot;)， tmpx是x的拷贝副本 struct Y { double operator()(double); }; Y y; auto f3=std::async(Y(),3.141); // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到 auto f4=std::async(std::ref(y),2.718); // 调用y(2.718) X baz(X&amp;amp;); std::async(baz,std::ref(x)); // 调用baz(x) class move_only { public: move_only(); move_only(move_only&amp;amp;&amp;amp;) move_only(move_only const&amp;amp;) = delete; move_only&amp;amp; operator=(move_only&amp;amp;&amp;amp;); move_only&amp;amp; operator=(move_only const&amp;amp;) = delete; void operator()(); }; auto f5=std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到 此外,std:;async还有一个可选参数,值为std::launch::deferred或std::launch:async或std::launch::deferred|std::launch:async,第三种为默认参数.</description></item><item><title>[C++11] promise &amp;&amp; future leanrning notes</title><link>https://111qqz.com/2018/08/promise-future-notes/</link><pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate><guid>https://111qqz.com/2018/08/promise-future-notes/</guid><description>
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2018/08/promise-future-notes/https://thispointer.com//wp-content/uploads/2015/06/promise.png
Disk path: /content/post/工程/https://thispointer.com//wp-content/uploads/2015/06/promise.png
Using Page Bundles: true
用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程返回的某个结果），需要通过主线程中的promise object 得到对应的future object(每个promise 对应一个 future),然后调用future 的get方法。如果附属线程没有执行作为参数传入的promise的set方法去返回结果，那么程序就会block住。
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月23日 星期四 10时37分07秒 File Name :future_sample.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; #include &amp;lt;future&amp;gt; void initiazer(std::promise&amp;lt;int&amp;gt; * promObj) { //std::cout&amp;lt;&amp;lt;&amp;quot;Inside Thread&amp;quot;&amp;lt;&amp;lt;std::endl; for ( int i = 1 ; i &amp;lt;= 2000000000 ; i++); //promObj-&amp;gt;set_value(35); } int main() { std::promise&amp;lt;int&amp;gt; promiseObj; std::future&amp;lt;int&amp;gt; futureObj = promiseObj.</description></item></channel></rss>