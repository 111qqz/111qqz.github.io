<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43;11 on 111qqz的小窝</title>
    <link>https://111qqz.com/tags/c&#43;&#43;11/</link>
    <description>Recent content in c&#43;&#43;11 on 111qqz的小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Sep 2018 06:49:27 +0000</lastBuildDate>
    
	<atom:link href="https://111qqz.com/tags/c++11/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[c&#43;&#43;11] std::async std::packaged_task std::promise and std::future notes</title>
      <link>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</link>
      <pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</guid>
      <description>把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::f</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;11] std::async std::packaged_task std::promise and std::future notes</title>
      <link>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</link>
      <pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</guid>
      <description>把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::f</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11]std::condition_variable  notes</title>
      <link>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</link>
      <pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</guid>
      <description>condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_varia</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11]std::condition_variable  notes</title>
      <link>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</link>
      <pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</guid>
      <description>condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_varia</description>
    </item>
    
    <item>
      <title>std::call_once &amp;&amp; std::once_flag  notes</title>
      <link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link>
      <pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid>
      <description>多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。 资源初始化一般遵循&amp;rdquo;lazy initialization&amp;rdqu</description>
    </item>
    
    <item>
      <title>std::call_once &amp;&amp; std::once_flag  notes</title>
      <link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link>
      <pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid>
      <description>多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。 资源初始化一般遵循&amp;rdquo;lazy initialization&amp;rdqu</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;11 ]std::move  右值引用  转移语义  完美转发 notes</title>
      <link>https://111qqz.com/2018/09/c11-stdmove-notes/</link>
      <pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid>
      <description>起因是在看，里面讲到转移一个std::thread的ownership提到了std::move. 之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;11 ]std::move  右值引用  转移语义  完美转发 notes</title>
      <link>https://111qqz.com/2018/09/c11-stdmove-notes/</link>
      <pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid>
      <description>起因是在看，里面讲到转移一个std::thread的ownership提到了std::move. 之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11 ] std::ref&amp;&amp;std::reference_wrapper  notes</title>
      <link>https://111qqz.com/2018/09/c11_ref_notes/</link>
      <pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11_ref_notes/</guid>
      <description>起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11 ] std::ref&amp;&amp;std::reference_wrapper  notes</title>
      <link>https://111qqz.com/2018/09/c11_ref_notes/</link>
      <pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11_ref_notes/</guid>
      <description>起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11] promise &amp;&amp; future leanrning notes</title>
      <link>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</link>
      <pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</guid>
      <description>用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11] promise &amp;&amp; future leanrning notes</title>
      <link>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</link>
      <pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</guid>
      <description>用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 function 与bind  学习笔记</title>
      <link>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作 见下面的例子 /* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月1</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 function 与bind  学习笔记</title>
      <link>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作 见下面的例子 /* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月1</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 记录代码运行时间</title>
      <link>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</link>
      <pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</guid>
      <description>以前用的办法太老土啦 看到一个since C++11的方法，我觉得比较优雅 #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms =</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 记录代码运行时间</title>
      <link>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</link>
      <pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</guid>
      <description>以前用的办法太老土啦 看到一个since C++11的方法，我觉得比较优雅 #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms =</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 学习笔记</title>
      <link>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>昨天终于搞定了ycm对c++11的支持&amp;hellip;. 嘛，17都快出来了，我竟然连11都不会用。 不过突然把所有的11特性给我也没办法全部吸</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 学习笔记</title>
      <link>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>昨天终于搞定了ycm对c++11的支持&amp;hellip;. 嘛，17都快出来了，我竟然连11都不会用。 不过突然把所有的11特性给我也没办法全部吸</description>
    </item>
    
  </channel>
</rss>