<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++11 on 111qqz的小窝</title><link>https://111qqz.com/tags/c++11/</link><description>Recent content in c++11 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 30 Sep 2018 06:49:27 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/c++11/index.xml" rel="self" type="application/rss+xml"/><item><title>[c++11] std::async std::packaged_task std::promise and std::future notes</title><link>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</link><pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</guid><description>
把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::future对象.简单来说,当某个线程需要等待一个特定的一次性事件(one-off event),它可以用一个&amp;quot;future&amp;quot;来表示这个事件.
std::async 有的时候可能你需要做一个花费事件比较长的计算,但是计算结果不是立刻需要.这个时候就可以用一个新的线程来做这个计算.这里比较关键的问题是如何将在新线程进行计算的结果传回到当前线程,因为std::thread并没有提供一个类似的机制.
这个时候就需要std::async登场了.
#include &amp;lt;future&amp;gt; #include &amp;lt;iostream&amp;gt; int find_the_answer_to_ltuae(); void do_other_stuff(); int main() { std::future&amp;lt;int&amp;gt; the_answer=std::async(find_the_answer_to_ltuae); do_other_stuff(); std::cout&amp;lt;&amp;lt;&amp;quot;The answer is &amp;quot;&amp;lt;&amp;lt;the_answer.get()&amp;lt;&amp;lt;std::endl; } 当然也可以与向std::thread包装的thread function中传参数一样,向std::async中传参数,如下:
#include &amp;lt;string&amp;gt; #include &amp;lt;future&amp;gt; struct X { void foo(int,std::string const&amp;amp;); std::string bar(std::string const&amp;amp;); }; X x; auto f1=std::async(&amp;amp;X::foo,&amp;amp;x,42,&amp;quot;hello&amp;quot;); // 调用p-&amp;gt;foo(42, &amp;quot;hello&amp;quot;)，p是指向x的指针 auto f2=std::async(&amp;amp;X::bar,x,&amp;quot;goodbye&amp;quot;); // 调用tmpx.bar(&amp;quot;goodbye&amp;quot;)， tmpx是x的拷贝副本 struct Y { double operator()(double); }; Y y; auto f3=std::async(Y(),3.141); // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到 auto f4=std::async(std::ref(y),2.718); // 调用y(2.718) X baz(X&amp;amp;); std::async(baz,std::ref(x)); // 调用baz(x) class move_only { public: move_only(); move_only(move_only&amp;amp;&amp;amp;) move_only(move_only const&amp;amp;) = delete; move_only&amp;amp; operator=(move_only&amp;amp;&amp;amp;); move_only&amp;amp; operator=(move_only const&amp;amp;) = delete; void operator()(); }; auto f5=std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到 此外,std:;async还有一个可选参数,值为std::launch::deferred或std::launch:async或std::launch::deferred|std::launch:async,第三种为默认参数.</description></item><item><title>[c++11 ]std::move 右值引用 转移语义 完美转发 notes</title><link>https://111qqz.com/2018/09/c11-stdmove-notes/</link><pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid><description>
起因是在看&amp;lt;CplusplusConcurrencyInAction_PracticalMultithreading&amp;gt;，里面讲到转移一个std::thread的ownership提到了std::move.
之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要用引用的时候却进行了拷贝，得到不符合期望的结果。现在的情况是，有些object或许是不支持拷贝构造的。比如std::unique_str,std::ifstream，这个时候如果我们需要传参数进去，就可以使用std::move来实现。比如下面这个例子:
void process_big_object(std::unique_ptr&amp;lt;big_object&amp;gt;); std::unique_ptr&amp;lt;big_object&amp;gt; p(new big_object); p-&amp;gt;prepare_data(42); std::thread t(process_big_object,std::move(p)); 当然这只是使用std::move的一种情形，即传递不允许拷贝构造的object作为参数。
另外，std::move可以更有效率地传递资源。内容之后补orz
实际上std::move()的作用是传进去一个object,返回这个object的右值引用（rvalue reference）
首先区分左值和右值，这其实是一个c语言中就有的概念（作为区分，右值引用是C++11中新引入的概念）
一般来说，右值是不能被取地址的值。在C++11之前，右值是不能被引用的。
语法上为了区分C++11之前的引用（也就是左值引用&amp;amp;）,右值引用的符号为&amp;amp;&amp;amp;
void process_value(int&amp;amp; i) { std::cout &amp;lt;&amp;lt; &amp;quot;LValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } void process_value(int&amp;amp;&amp;amp; i) { std::cout &amp;lt;&amp;lt; &amp;quot;RValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } int main() { int a = 0; process_value(a); process_value(1); } LValue processed: 0 RValue processed: 1 那么为什么要引入“右值引用”这个概念？ 主要有两个目的：完美转发(Perfect Forwarding)和转移语义(Move Sementics)</description></item><item><title>[C++11 ] std::ref&amp;&amp;std::reference_wrapper notes</title><link>https://111qqz.com/2018/09/reference_wrapper-notes/</link><pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate><guid>https://111qqz.com/2018/09/reference_wrapper-notes/</guid><description>
起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化std::thread的时候，如果thread funtion的参数列表中有引用，需要传入std::ref才可以得到符合预期的结果。
查阅发现std::ref是用来生成std::reference_wrapper。 按照 cppreference 上的话来说
`std::reference_wrapper` 是包装引用于可复制、可赋值对象的类模板。它常用作将容器存储入无法正常保有引用的标准容器（类似 [std::vector](https://zh.cppreference.com/w/cpp/container/vector) ）的机制。 用人话来说，就是有的时候一些地方（比如STL容器中传值，又比如std::bind）会默认使用复制，这可能与我们想使用引用的期望不符。
具体见下面的几个例子：
#include &amp;lt;functional&amp;gt; #include &amp;lt;iostream&amp;gt; void f(int&amp;amp; n1, int&amp;amp; n2, const int&amp;amp; n3) { std::cout &amp;lt;&amp;lt; &amp;quot;In function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; ++n1; // increments the copy of n1 stored in the function object ++n2; // increments the main()'s n2 // ++n3; // compile error } int main() { int n1 = 1, n2 = 2, n3 = 3; std::function&amp;lt;void()&amp;gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &amp;lt;&amp;lt; &amp;quot;Before function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; bound_f(); std::cout &amp;lt;&amp;lt; &amp;quot;After function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; } Before function: 10 11 12 In function: 1 11 12 After function: 10 12 12 我们发现直接传进去的参数n1的值没有改变，而使用std::ref传进去的值的结果符合预期。</description></item><item><title>c++11 学习笔记</title><link>https://111qqz.com/2016/08/c11-/</link><pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate><guid>https://111qqz.com/2016/08/c11-/</guid><description>
昨天终于搞定了ycm对c++11的支持....
嘛，17都快出来了，我竟然连11都不会用。
不过突然把所有的11特性给我也没办法全部吸收。
所以在这里记录下用过的c++11的用法。
auto可以代替stl的一些容器中的iterator: /****************************************************************** ******************************************************************* ******************************************************************/ set&amp;lt;int&amp;gt;se; //之前的写法遍历要这样写： for (set&amp;lt;int&amp;gt;::iterator it = se.begin() ;it!=se.end() ;it++) //用auto可以简化成这样子 for ( auto it = se.begin(); it!=se.end() ;it++)</description></item></channel></rss>