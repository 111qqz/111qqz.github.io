<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>call_once on 111qqz's blog</title><link>https://111qqz.com/tags/call_once/</link><description>Recent content in call_once on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Thu, 20 Sep 2018 12:47:46 +0000</lastBuildDate><atom:link href="https://111qqz.com/tags/call_once/index.xml" rel="self" type="application/rss+xml"/><item><title>std::call_once &amp;&amp; std::once_flag notes</title><link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link><pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate><guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid><description>
多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。
资源初始化一般遵循&amp;quot;lazy initialization&amp;quot;的原则，也就是在用到该资源最近的地方再初始化。
比较容易想到的办法是用std::mutex，将资源初始化的地方锁起来，如下:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::mutex resource_mutex; void foo() { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(resource_mutex); if(!resource_ptr) { resource_ptr.reset(new some_resource); } lk.unlock(); resource_ptr-&amp;gt;do_something(); } 这确实是一个办法。但是初始化时如果需要耗费比较多的时间，当有比较多的线程时，一个线程初始化时，其他线程会耗时间在不必要的等待上。
在c++11以后，我们可以使用std::once_flag和std::call_once来解决资源初始化时加锁的问题。比起显示调用std::mutex的好处是，资源消耗更少。
下面是两个例子:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::once_flag resource_flag; b void init_resource() { resource_ptr.reset(new some_resource); } void foo() { std::call_once(resource_flag,init_resource); resource_ptr-&amp;gt;do_something(); } class X { private: connection_info connection_details; connection_handle connection; std::once_flag connection_init_flag; void open_connection() { connection=connection_manager.open(connection_details); } public:62 C HAPTER 3 Sharing data between threads X(connection_info const&amp;amp; connection_details_): connection_details(connection_details_) {} void send_data(data_packet const&amp;amp; data) { std::call_once(connection_init_flag,&amp;amp;X::open_connection,this); connection.</description></item></channel></rss>