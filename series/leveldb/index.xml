<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>levelDB on 111qqz的小窝</title><link>https://111qqz.com/series/leveldb/</link><description>Recent content in levelDB on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sun, 06 Mar 2022 17:20:59 +0800</lastBuildDate><atom:link href="https://111qqz.com/series/leveldb/index.xml" rel="self" type="application/rss+xml"/><item><title>levelDB 代码阅读笔记 03 cache</title><link>https://111qqz.com/2022/03/leveldb-notes-03/</link><pubDate>Sun, 06 Mar 2022 17:20:59 +0800</pubDate><guid>https://111qqz.com/2022/03/leveldb-notes-03/</guid><description>
Cache接口 没有太多好说的，可以注意这里用了void*来表示任意类型数据。 在c++17之后可以考虑用std::any代替，参考 std::any 笔记
1 2 3namespace leveldb { 4 5class LEVELDB_EXPORT Cache; 6 7// Create a new cache with a fixed size capacity. This implementation 8// of Cache uses a least-recently-used eviction policy. 9LEVELDB_EXPORT Cache* NewLRUCache(size_t capacity); 10 11class LEVELDB_EXPORT Cache { 12 public: 13 Cache() = default; 14 15 Cache(const Cache&amp;amp;) = delete; 16 Cache&amp;amp; operator=(const Cache&amp;amp;) = delete; 17 18 // Destroys all existing entries by calling the &amp;#34;deleter&amp;#34; 19 // function that was passed to the constructor.</description></item><item><title>levelDB 代码阅读笔记 02 comparator</title><link>https://111qqz.com/2022/03/leveldb-notes-02/</link><pubDate>Tue, 01 Mar 2022 20:01:50 +0800</pubDate><guid>https://111qqz.com/2022/03/leveldb-notes-02/</guid><description>
levelDB是一个有序的KV存储，因此key的顺序是十分关键的 levelDB提供用户自己定义key顺序的能力
先看下comparator的接口
接口 include/leveldb/comparator.h 1 2// A Comparator object provides a total order across slices that are 3// used as keys in an sstable or a database. A Comparator implementation 4// must be thread-safe since leveldb may invoke its methods concurrently 5// from multiple threads. 6class LEVELDB_EXPORT Comparator { 7 public: 8 virtual ~Comparator(); 9 10 // Three-way comparison. Returns value: 11 // &amp;lt; 0 iff &amp;#34;a&amp;#34; &amp;lt; &amp;#34;b&amp;#34;, 12 // == 0 iff &amp;#34;a&amp;#34; == &amp;#34;b&amp;#34;, 13 // &amp;gt; 0 iff &amp;#34;a&amp;#34; &amp;gt; &amp;#34;b&amp;#34; 14 virtual int Compare(const Slice&amp;amp; a, const Slice&amp;amp; b) const = 0; 15 16 // The name of the comparator.</description></item><item><title>levelDB 代码阅读笔记 01 db.h</title><link>https://111qqz.com/2022/02/leveldb-notes-01/</link><pubDate>Sat, 26 Feb 2022 19:10:30 +0800</pubDate><guid>https://111qqz.com/2022/02/leveldb-notes-01/</guid><description>
背景 最近在做一个智能算力相关的项目，类似美团外卖广告智能算力的探索与实践 其中实现控制系统需要与数据库交互。 虽然最后技术选型并没有使用到levelDB,但是想趁机把代码读了吧。
很惊讶的发现我大三的时候声称自己度过部分levelDB代码，甚至还写了几篇相关的博客，比如
murmurhash源码分析 Lock-free vs wait-free concurrency 内存屏障（Memory Barriers） levelDB 学习笔记 但是我却一点都没印象了.... 仔细看来很多概念在当时可能都是没有充分理解的，而且从数目上来看，应该并没有完整看完levelDB代码。
所以重新开个坑，看看自己比起毕业前有没有长进【没有
先从入口 include/leveldb/db.h 开始
LEVELDB_EXPORT 看到LEVELDB_EXPORT这个macro
1 2class LEVELDB_EXPORT Snapshot { 3 protected: 4 virtual ~Snapshot(); 5}; 6 是在 include/leveldb/export.h 中定义的
1 2// 符号可见性问题，使用macro来控制在编译成动态库时暴露，在Link时不暴露符号是一种common 的做法 3// 4#if !defined(LEVELDB_EXPORT) 5 6#if defined(LEVELDB_SHARED_LIBRARY) 7#if defined(_WIN32) 8 9#if defined(LEVELDB_COMPILE_LIBRARY) 10#define LEVELDB_EXPORT __declspec(dllexport) 11#else 12#define LEVELDB_EXPORT __declspec(dllimport) 13#endif // defined(LEVELDB_COMPILE_LIBRARY) 14 15#else // defined(_WIN32) 16#if defined(LEVELDB_COMPILE_LIBRARY) 17#define LEVELDB_EXPORT __attribute__((visibility(&amp;#34;default&amp;#34;))) 18#else 19#define LEVELDB_EXPORT 20#endif 21#endif // defined(_WIN32) 22 23#else // defined(LEVELDB_SHARED_LIBRARY) 24#define LEVELDB_EXPORT 25#endif 26 27#endif // !</description></item></channel></rss>