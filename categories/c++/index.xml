<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on 111qqz的小窝</title>
    <link>https://111qqz.com/categories/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on 111qqz的小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Sep 2018 06:49:27 +0000</lastBuildDate>
    
	<atom:link href="https://111qqz.com/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[c&#43;&#43;11] std::async std::packaged_task std::promise and std::future notes</title>
      <link>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</link>
      <pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</guid>
      <description>把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::f</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;11] std::async std::packaged_task std::promise and std::future notes</title>
      <link>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</link>
      <pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdasync-stdpackaged_task-stdpromise-and-stdfuture-notes/</guid>
      <description>把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::f</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11]std::condition_variable  notes</title>
      <link>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</link>
      <pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</guid>
      <description>condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_varia</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11]std::condition_variable  notes</title>
      <link>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</link>
      <pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11stdcondition_variable-notes/</guid>
      <description>condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_varia</description>
    </item>
    
    <item>
      <title>std::call_once &amp;&amp; std::once_flag  notes</title>
      <link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link>
      <pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid>
      <description>多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。 资源初始化一般遵循&amp;rdquo;lazy initialization&amp;rdqu</description>
    </item>
    
    <item>
      <title>std::call_once &amp;&amp; std::once_flag  notes</title>
      <link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link>
      <pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid>
      <description>多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。 资源初始化一般遵循&amp;rdquo;lazy initialization&amp;rdqu</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;11 ]std::move  右值引用  转移语义  完美转发 notes</title>
      <link>https://111qqz.com/2018/09/c11-stdmove-notes/</link>
      <pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid>
      <description>起因是在看，里面讲到转移一个std::thread的ownership提到了std::move. 之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;11 ]std::move  右值引用  转移语义  完美转发 notes</title>
      <link>https://111qqz.com/2018/09/c11-stdmove-notes/</link>
      <pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid>
      <description>起因是在看，里面讲到转移一个std::thread的ownership提到了std::move. 之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11 ] std::ref&amp;&amp;std::reference_wrapper  notes</title>
      <link>https://111qqz.com/2018/09/c11_ref_notes/</link>
      <pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11_ref_notes/</guid>
      <description>起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11 ] std::ref&amp;&amp;std::reference_wrapper  notes</title>
      <link>https://111qqz.com/2018/09/c11_ref_notes/</link>
      <pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/c11_ref_notes/</guid>
      <description>起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化</description>
    </item>
    
    <item>
      <title>[设计模式] 观察者( Observer )模式学习笔记</title>
      <link>https://111qqz.com/2018/09/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-%e8%a7%82%e5%af%9f%e8%80%85-observer-%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sat, 01 Sep 2018 09:27:40 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-%e8%a7%82%e5%af%9f%e8%80%85-observer-%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>最近在学习node.js，里面讲到node.js的事件机制使用了观察者模式，因此来学习一下。 观察者模式的目的是定义对象间的一种一对多的依赖关</description>
    </item>
    
    <item>
      <title>[设计模式] 观察者( Observer )模式学习笔记</title>
      <link>https://111qqz.com/2018/09/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-%e8%a7%82%e5%af%9f%e8%80%85-observer-%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sat, 01 Sep 2018 09:27:40 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/09/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-%e8%a7%82%e5%af%9f%e8%80%85-observer-%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>最近在学习node.js，里面讲到node.js的事件机制使用了观察者模式，因此来学习一下。 观察者模式的目的是定义对象间的一种一对多的依赖关</description>
    </item>
    
    <item>
      <title>[设计模式] 组合模式（composite） 学习笔记</title>
      <link>https://111qqz.com/2018/08/c-%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f%ef%bc%88composite%ef%bc%89-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/c-%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f%ef%bc%88composite%ef%bc%89-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个*tree 。如果某个节点是叶子节点了，那</description>
    </item>
    
    <item>
      <title>[设计模式] 组合模式（composite） 学习笔记</title>
      <link>https://111qqz.com/2018/08/c-%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f%ef%bc%88composite%ef%bc%89-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/c-%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f%ef%bc%88composite%ef%bc%89-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个*tree 。如果某个节点是叶子节点了，那</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11] promise &amp;&amp; future leanrning notes</title>
      <link>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</link>
      <pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</guid>
      <description>用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;11] promise &amp;&amp; future leanrning notes</title>
      <link>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</link>
      <pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/c11-promise-future-leanrning-notes/</guid>
      <description>用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程</description>
    </item>
    
    <item>
      <title>把二进制文件按字节读到vector中</title>
      <link>https://111qqz.com/2018/08/%e6%8a%8a%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e6%8c%89%e5%ad%97%e8%8a%82%e8%af%bb%e5%88%b0vector%e4%b8%ad/</link>
      <pubDate>Tue, 21 Aug 2018 06:08:56 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/%e6%8a%8a%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e6%8c%89%e5%ad%97%e8%8a%82%e8%af%bb%e5%88%b0vector%e4%b8%ad/</guid>
      <description>std::vector&amp;lt;unsigned char&amp;gt; readFromFile1(const char* filePath) { FILE* file = fopen(filePath, &amp;quot;rb&amp;quot;); std::vector&amp;lt;unsigned char&amp;gt; result; if (file == nullptr) { return result; } // 获取文件大小，尽量一次读完 size_t fileSize = getFileSize(file); if (fileSize != 0) { result.resize(fileSize); size_t n = fread(&amp;amp;result[0], 1, fileSize, file); assert(n &amp;lt;= fileSize); if (n != fileSize) { result.resize(n); } } // 在读取过程</description>
    </item>
    
    <item>
      <title>把二进制文件按字节读到vector中</title>
      <link>https://111qqz.com/2018/08/%e6%8a%8a%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e6%8c%89%e5%ad%97%e8%8a%82%e8%af%bb%e5%88%b0vector%e4%b8%ad/</link>
      <pubDate>Tue, 21 Aug 2018 06:08:56 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/%e6%8a%8a%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e6%8c%89%e5%ad%97%e8%8a%82%e8%af%bb%e5%88%b0vector%e4%b8%ad/</guid>
      <description>std::vector&amp;lt;unsigned char&amp;gt; readFromFile1(const char* filePath) { FILE* file = fopen(filePath, &amp;quot;rb&amp;quot;); std::vector&amp;lt;unsigned char&amp;gt; result; if (file == nullptr) { return result; } // 获取文件大小，尽量一次读完 size_t fileSize = getFileSize(file); if (fileSize != 0) { result.resize(fileSize); size_t n = fread(&amp;amp;result[0], 1, fileSize, file); assert(n &amp;lt;= fileSize); if (n != fileSize) { result.resize(n); } } // 在读取过程</description>
    </item>
    
    <item>
      <title>记录一次因动态库符号表可见性导致的未定义的引用(undefined reference)</title>
      <link>https://111qqz.com/2018/08/%e8%ae%b0%e5%bd%95%e4%b8%80%e6%ac%a1%e5%9b%a0%e5%8a%a8%e6%80%81%e5%ba%93%e7%ac%a6%e5%8f%b7%e8%a1%a8%e5%8f%af%e8%a7%81%e6%80%a7%e5%af%bc%e8%87%b4%e7%9a%84%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95/</link>
      <pubDate>Wed, 15 Aug 2018 13:12:17 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/%e8%ae%b0%e5%bd%95%e4%b8%80%e6%ac%a1%e5%9b%a0%e5%8a%a8%e6%80%81%e5%ba%93%e7%ac%a6%e5%8f%b7%e8%a1%a8%e5%8f%af%e8%a7%81%e6%80%a7%e5%af%bc%e8%87%b4%e7%9a%84%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95/</guid>
      <description>编译某代码，发现报错某函数未定义的引用。该函数的是先前编译得到的动态库中。 先去check了该函数的实现，还有接口与头文件中的声明是否统一。发</description>
    </item>
    
    <item>
      <title>记录一次因动态库符号表可见性导致的未定义的引用(undefined reference)</title>
      <link>https://111qqz.com/2018/08/%e8%ae%b0%e5%bd%95%e4%b8%80%e6%ac%a1%e5%9b%a0%e5%8a%a8%e6%80%81%e5%ba%93%e7%ac%a6%e5%8f%b7%e8%a1%a8%e5%8f%af%e8%a7%81%e6%80%a7%e5%af%bc%e8%87%b4%e7%9a%84%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95/</link>
      <pubDate>Wed, 15 Aug 2018 13:12:17 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/08/%e8%ae%b0%e5%bd%95%e4%b8%80%e6%ac%a1%e5%9b%a0%e5%8a%a8%e6%80%81%e5%ba%93%e7%ac%a6%e5%8f%b7%e8%a1%a8%e5%8f%af%e8%a7%81%e6%80%a7%e5%af%bc%e8%87%b4%e7%9a%84%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%bc%95/</guid>
      <description>编译某代码，发现报错某函数未定义的引用。该函数的是先前编译得到的动态库中。 先去check了该函数的实现，还有接口与头文件中的声明是否统一。发</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 function 与bind  学习笔记</title>
      <link>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作 见下面的例子 /* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月1</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 function 与bind  学习笔记</title>
      <link>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c11-function-%e4%b8%8ebind-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作 见下面的例子 /* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月1</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 记录代码运行时间</title>
      <link>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</link>
      <pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</guid>
      <description>以前用的办法太老土啦 看到一个since C++11的方法，我觉得比较优雅 #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms =</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 记录代码运行时间</title>
      <link>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</link>
      <pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/07/c-%e8%ae%b0%e5%bd%95%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e9%97%b4/</guid>
      <description>以前用的办法太老土啦 看到一个since C++11的方法，我觉得比较优雅 #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms =</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL Algotithms 学习笔记</title>
      <link>https://111qqz.com/2018/05/c-stl-algotithms-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sun, 06 May 2018 09:45:50 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/05/c-stl-algotithms-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>迫于拙劣的cpp水平，这次来记录一些关于STL算法部分的内容。 参考内容是CS106L的course reader Iterator Categories Iterators分为以下五种: * Output</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL Algotithms 学习笔记</title>
      <link>https://111qqz.com/2018/05/c-stl-algotithms-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sun, 06 May 2018 09:45:50 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/05/c-stl-algotithms-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>迫于拙劣的cpp水平，这次来记录一些关于STL算法部分的内容。 参考内容是CS106L的course reader Iterator Categories Iterators分为以下五种: * Output</description>
    </item>
    
    <item>
      <title>C&#43;&#43; IO Streams 学习笔记</title>
      <link>https://111qqz.com/2018/05/c-io-streams-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Fri, 04 May 2018 03:48:37 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/05/c-io-streams-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>迫于拙劣的cpp水平，来补补以前忽略掉的cpp细节。 老规矩，先放资料。 参考资料: A Gentle Introduction to C++ IO Streams &#34;Designing and implementing a general input/output facility for a programming language is notoriously difficult&#34; - Bjarne Stroustrup Stream</description>
    </item>
    
    <item>
      <title>C&#43;&#43; IO Streams 学习笔记</title>
      <link>https://111qqz.com/2018/05/c-io-streams-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Fri, 04 May 2018 03:48:37 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/05/c-io-streams-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>迫于拙劣的cpp水平，来补补以前忽略掉的cpp细节。 老规矩，先放资料。 参考资料: A Gentle Introduction to C++ IO Streams &#34;Designing and implementing a general input/output facility for a programming language is notoriously difficult&#34; - Bjarne Stroustrup Stream</description>
    </item>
    
    <item>
      <title>Eigen: C&#43;&#43;开源矩阵学习笔记</title>
      <link>https://111qqz.com/2018/04/eigen-c%e5%bc%80%e6%ba%90%e7%9f%a9%e9%98%b5%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 05 Apr 2018 07:14:54 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/04/eigen-c%e5%bc%80%e6%ba%90%e7%9f%a9%e9%98%b5%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>接触Eigen的原因是最近在看caffe/caffe2源码,caffe2中使用了Eigen库. Eigen 是一个基于C++模板的线性代数库，直接将库下</description>
    </item>
    
    <item>
      <title>Eigen: C&#43;&#43;开源矩阵学习笔记</title>
      <link>https://111qqz.com/2018/04/eigen-c%e5%bc%80%e6%ba%90%e7%9f%a9%e9%98%b5%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 05 Apr 2018 07:14:54 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/04/eigen-c%e5%bc%80%e6%ba%90%e7%9f%a9%e9%98%b5%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>接触Eigen的原因是最近在看caffe/caffe2源码,caffe2中使用了Eigen库. Eigen 是一个基于C++模板的线性代数库，直接将库下</description>
    </item>
    
    <item>
      <title>linux 下 .o 文件， .a文件，.so文件</title>
      <link>https://111qqz.com/2018/03/linux-%e4%b8%8b-o-%e6%96%87%e4%bb%b6%ef%bc%8c-a%e6%96%87%e4%bb%b6%ef%bc%8c-so%e6%96%87%e4%bb%b6/</link>
      <pubDate>Sat, 17 Mar 2018 12:56:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/03/linux-%e4%b8%8b-o-%e6%96%87%e4%bb%b6%ef%bc%8c-a%e6%96%87%e4%bb%b6%ef%bc%8c-so%e6%96%87%e4%bb%b6/</guid>
      <description>发现我对工程一无所知QAQ 参考资料： LibraryArchives-StaticAndDynamic 简单得说就是：A .a file is a static library, while a .so file is a shared object (dynamic) library similar to a DLL on Windows. 至于.o文件，其实就相当于win下的obj</description>
    </item>
    
    <item>
      <title>linux 下 .o 文件， .a文件，.so文件</title>
      <link>https://111qqz.com/2018/03/linux-%e4%b8%8b-o-%e6%96%87%e4%bb%b6%ef%bc%8c-a%e6%96%87%e4%bb%b6%ef%bc%8c-so%e6%96%87%e4%bb%b6/</link>
      <pubDate>Sat, 17 Mar 2018 12:56:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/03/linux-%e4%b8%8b-o-%e6%96%87%e4%bb%b6%ef%bc%8c-a%e6%96%87%e4%bb%b6%ef%bc%8c-so%e6%96%87%e4%bb%b6/</guid>
      <description>发现我对工程一无所知QAQ 参考资料： LibraryArchives-StaticAndDynamic 简单得说就是：A .a file is a static library, while a .so file is a shared object (dynamic) library similar to a DLL on Windows. 至于.o文件，其实就相当于win下的obj</description>
    </item>
    
    <item>
      <title>CUDA C Best Practices Guide 阅读笔记（二） Heterogeneous Computing</title>
      <link>https://111qqz.com/2018/02/cuda-c-best-practices-guide-%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%ef%bc%88%e4%ba%8c%ef%bc%89-heterogeneous-computing/</link>
      <pubDate>Tue, 13 Feb 2018 06:38:38 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-c-best-practices-guide-%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%ef%bc%88%e4%ba%8c%ef%bc%89-heterogeneous-computing/</guid>
      <description>CUDA 编程涉及到在不同的平台上同时运行代码:包含CPU的host 和包含GPU的device. 所以了解host和device的对性能优化是非常重要</description>
    </item>
    
    <item>
      <title>CUDA C Best Practices Guide 阅读笔记（二） Heterogeneous Computing</title>
      <link>https://111qqz.com/2018/02/cuda-c-best-practices-guide-%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%ef%bc%88%e4%ba%8c%ef%bc%89-heterogeneous-computing/</link>
      <pubDate>Tue, 13 Feb 2018 06:38:38 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-c-best-practices-guide-%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%ef%bc%88%e4%ba%8c%ef%bc%89-heterogeneous-computing/</guid>
      <description>CUDA 编程涉及到在不同的平台上同时运行代码:包含CPU的host 和包含GPU的device. 所以了解host和device的对性能优化是非常重要</description>
    </item>
    
    <item>
      <title>CUDA C Best Practices Guide 阅读笔记（1） 并行计算方法论(APOD)</title>
      <link>https://111qqz.com/2018/02/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e8%ae%ba%ef%bc%88%e4%b8%80%ef%bc%89/</link>
      <pubDate>Mon, 12 Feb 2018 04:58:31 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e8%ae%ba%ef%bc%88%e4%b8%80%ef%bc%89/</guid>
      <description>APOD指的是Assess, Parallelize, Optimize, Deploy 如图所示，APOD过程是一个循环的过程，每次只进行一部分，从A到P到O到D,然后再进行下一轮的APOD Assess 对</description>
    </item>
    
    <item>
      <title>CUDA C Best Practices Guide 阅读笔记（1） 并行计算方法论(APOD)</title>
      <link>https://111qqz.com/2018/02/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e8%ae%ba%ef%bc%88%e4%b8%80%ef%bc%89/</link>
      <pubDate>Mon, 12 Feb 2018 04:58:31 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e8%ae%ba%ef%bc%88%e4%b8%80%ef%bc%89/</guid>
      <description>APOD指的是Assess, Parallelize, Optimize, Deploy 如图所示，APOD过程是一个循环的过程，每次只进行一部分，从A到P到O到D,然后再进行下一轮的APOD Assess 对</description>
    </item>
    
    <item>
      <title>CUDA 7.5: 用指令级性能分析精确找到性能问题</title>
      <link>https://111qqz.com/2018/02/cuda-7-5-%e7%94%a8%e6%8c%87%e4%bb%a4%e7%ba%a7%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%b2%be%e7%a1%ae%e6%89%be%e5%88%b0%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98/</link>
      <pubDate>Sun, 11 Feb 2018 08:06:14 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-7-5-%e7%94%a8%e6%8c%87%e4%bb%a4%e7%ba%a7%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%b2%be%e7%a1%ae%e6%89%be%e5%88%b0%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98/</guid>
      <description>原文： CUDA 7.5: Pinpoint Performance Problems with Instruction-Level Profiling 主要是介绍了CUDA 7.5 以上的版本的 NVIDIA Visual Profiler 加入的新特性 可以细粒度到指令级，分析出性能的瓶颈（在这之前，只能分析到kern</description>
    </item>
    
    <item>
      <title>CUDA 7.5: 用指令级性能分析精确找到性能问题</title>
      <link>https://111qqz.com/2018/02/cuda-7-5-%e7%94%a8%e6%8c%87%e4%bb%a4%e7%ba%a7%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%b2%be%e7%a1%ae%e6%89%be%e5%88%b0%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98/</link>
      <pubDate>Sun, 11 Feb 2018 08:06:14 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-7-5-%e7%94%a8%e6%8c%87%e4%bb%a4%e7%ba%a7%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%b2%be%e7%a1%ae%e6%89%be%e5%88%b0%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98/</guid>
      <description>原文： CUDA 7.5: Pinpoint Performance Problems with Instruction-Level Profiling 主要是介绍了CUDA 7.5 以上的版本的 NVIDIA Visual Profiler 加入的新特性 可以细粒度到指令级，分析出性能的瓶颈（在这之前，只能分析到kern</description>
    </item>
    
    <item>
      <title>cuda c&#43;&#43;  基础算法库 thrust 学习笔记</title>
      <link>https://111qqz.com/2018/02/cuda-c-%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%e5%ba%93-thrust-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sat, 10 Feb 2018 08:43:54 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-c-%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%e5%ba%93-thrust-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>可以了解成并行版的STL(? 过了一遍nvidia的官方网文档 发现如果熟悉STL的话,thrust没什么太多好说的,看起来很简单&amp;hellip</description>
    </item>
    
    <item>
      <title>cuda c&#43;&#43;  基础算法库 thrust 学习笔记</title>
      <link>https://111qqz.com/2018/02/cuda-c-%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%e5%ba%93-thrust-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sat, 10 Feb 2018 08:43:54 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-c-%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%e5%ba%93-thrust-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>可以了解成并行版的STL(? 过了一遍nvidia的官方网文档 发现如果熟悉STL的话,thrust没什么太多好说的,看起来很简单&amp;hellip</description>
    </item>
    
    <item>
      <title>cuda error checking 学习笔记</title>
      <link>https://111qqz.com/2018/02/cuda-error-checking-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Fri, 09 Feb 2018 06:55:00 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-error-checking-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>由于发现cuda c++ 的 debug方式和c++ 差别很大,因此打算再开一篇,专门记录一些和error checking 以及debug有关的内容. Error checks in CUDA code can help catch CUDA</description>
    </item>
    
    <item>
      <title>cuda error checking 学习笔记</title>
      <link>https://111qqz.com/2018/02/cuda-error-checking-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Fri, 09 Feb 2018 06:55:00 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-error-checking-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>由于发现cuda c++ 的 debug方式和c++ 差别很大,因此打算再开一篇,专门记录一些和error checking 以及debug有关的内容. Error checks in CUDA code can help catch CUDA</description>
    </item>
    
    <item>
      <title>C&#43;&#43;  Linux下使用popen()执行shell命令</title>
      <link>https://111qqz.com/2018/02/c-linux%e4%b8%8b%e4%bd%bf%e7%94%a8popen%e6%89%a7%e8%a1%8cshell%e5%91%bd%e4%bb%a4/</link>
      <pubDate>Mon, 05 Feb 2018 12:54:23 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/c-linux%e4%b8%8b%e4%bd%bf%e7%94%a8popen%e6%89%a7%e8%a1%8cshell%e5%91%bd%e4%bb%a4/</guid>
      <description>由于需要在Linux平台下，通过cpp获取某个进程所占用的物理内存，得知了这个东西。 感觉还挺厉害的orz.. 下面是一段示例代码 #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;  Linux下使用popen()执行shell命令</title>
      <link>https://111qqz.com/2018/02/c-linux%e4%b8%8b%e4%bd%bf%e7%94%a8popen%e6%89%a7%e8%a1%8cshell%e5%91%bd%e4%bb%a4/</link>
      <pubDate>Mon, 05 Feb 2018 12:54:23 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/c-linux%e4%b8%8b%e4%bd%bf%e7%94%a8popen%e6%89%a7%e8%a1%8cshell%e5%91%bd%e4%bb%a4/</guid>
      <description>由于需要在Linux平台下，通过cpp获取某个进程所占用的物理内存，得知了这个东西。 感觉还挺厉害的orz.. 下面是一段示例代码 #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std;</description>
    </item>
    
    <item>
      <title>cuda 学习笔记</title>
      <link>https://111qqz.com/2018/02/cuda-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 01 Feb 2018 07:20:04 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>uodate:有毒吧。kernel中出问题原来是不会报错的。。。。 请教了组里的hust学长orz..、 学到了cuda-memcheck命令和</description>
    </item>
    
    <item>
      <title>cuda 学习笔记</title>
      <link>https://111qqz.com/2018/02/cuda-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 01 Feb 2018 07:20:04 +0000</pubDate>
      
      <guid>https://111qqz.com/2018/02/cuda-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>uodate:有毒吧。kernel中出问题原来是不会报错的。。。。 请教了组里的hust学长orz..、 学到了cuda-memcheck命令和</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中头文件（.h）和源文件（.cpp）都应该写些什么（转载）</title>
      <link>https://111qqz.com/2017/05/c%e4%b8%ad%e5%a4%b4%e6%96%87%e4%bb%b6%ef%bc%88-h%ef%bc%89%e5%92%8c%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88-cpp%ef%bc%89%e9%83%bd%e5%ba%94%e8%af%a5%e5%86%99%e4%ba%9b%e4%bb%80%e4%b9%88%ef%bc%88%e8%bd%ac/</link>
      <pubDate>Tue, 16 May 2017 07:07:06 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/05/c%e4%b8%ad%e5%a4%b4%e6%96%87%e4%bb%b6%ef%bc%88-h%ef%bc%89%e5%92%8c%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88-cpp%ef%bc%89%e9%83%bd%e5%ba%94%e8%af%a5%e5%86%99%e4%ba%9b%e4%bb%80%e4%b9%88%ef%bc%88%e8%bd%ac/</guid>
      <description>感觉其实。。。更像是一种规范。。。？而不是一种具体要求吧。。。 ### [转自](http://www.cnblogs.com/fenghuan/p</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中头文件（.h）和源文件（.cpp）都应该写些什么（转载）</title>
      <link>https://111qqz.com/2017/05/c%e4%b8%ad%e5%a4%b4%e6%96%87%e4%bb%b6%ef%bc%88-h%ef%bc%89%e5%92%8c%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88-cpp%ef%bc%89%e9%83%bd%e5%ba%94%e8%af%a5%e5%86%99%e4%ba%9b%e4%bb%80%e4%b9%88%ef%bc%88%e8%bd%ac/</link>
      <pubDate>Tue, 16 May 2017 07:07:06 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/05/c%e4%b8%ad%e5%a4%b4%e6%96%87%e4%bb%b6%ef%bc%88-h%ef%bc%89%e5%92%8c%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88-cpp%ef%bc%89%e9%83%bd%e5%ba%94%e8%af%a5%e5%86%99%e4%ba%9b%e4%bb%80%e4%b9%88%ef%bc%88%e8%bd%ac/</guid>
      <description>感觉其实。。。更像是一种规范。。。？而不是一种具体要求吧。。。 ### [转自](http://www.cnblogs.com/fenghuan/p</description>
    </item>
    
    <item>
      <title>g&#43;&#43; 编译多个源文件（转载）</title>
      <link>https://111qqz.com/2017/05/g-%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</link>
      <pubDate>Tue, 16 May 2017 06:40:03 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/05/g-%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</guid>
      <description>参考资料 一. 常用编译命令选项 假设源程序文件名为test.c。 无选项编译链接 用法：#gcc test.c 作用：将test.c预处理、汇编、编译并链接形成可</description>
    </item>
    
    <item>
      <title>g&#43;&#43; 编译多个源文件（转载）</title>
      <link>https://111qqz.com/2017/05/g-%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</link>
      <pubDate>Tue, 16 May 2017 06:40:03 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/05/g-%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</guid>
      <description>参考资料 一. 常用编译命令选项 假设源程序文件名为test.c。 无选项编译链接 用法：#gcc test.c 作用：将test.c预处理、汇编、编译并链接形成可</description>
    </item>
    
    <item>
      <title>Lock-free vs wait-free concurrency</title>
      <link>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</link>
      <pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</guid>
      <description>参考资料 看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？ There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free,</description>
    </item>
    
    <item>
      <title>Lock-free vs wait-free concurrency</title>
      <link>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</link>
      <pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</guid>
      <description>参考资料 看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？ There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free,</description>
    </item>
    
    <item>
      <title>C&#43;&#43; const 用法总结（转载）</title>
      <link>https://111qqz.com/2017/03/c-const-%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</link>
      <pubDate>Sat, 18 Mar 2017 12:22:32 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/c-const-%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</guid>
      <description>基本全文照搬了：关于C++ const 的全面总结 总结全面还是要一点时间的orz..感谢原作者，暂时没发现有什么错误（? 其中对我而言比较陌生的是“con</description>
    </item>
    
    <item>
      <title>C&#43;&#43; const 用法总结（转载）</title>
      <link>https://111qqz.com/2017/03/c-const-%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</link>
      <pubDate>Sat, 18 Mar 2017 12:22:32 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/c-const-%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</guid>
      <description>基本全文照搬了：关于C++ const 的全面总结 总结全面还是要一点时间的orz..感谢原作者，暂时没发现有什么错误（? 其中对我而言比较陌生的是“con</description>
    </item>
    
    <item>
      <title>C&#43;&#43; sort学习笔记</title>
      <link>https://111qqz.com/2017/03/c-sort%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Wed, 01 Mar 2017 07:27:12 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/c-sort%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>回想起大一的时候打cf&amp;hellip;那个时候对C++还不怎么熟悉。。。用sort不会自定义排序方式。。 于是手写快排。。。直接取中间元素没加</description>
    </item>
    
    <item>
      <title>C&#43;&#43; sort学习笔记</title>
      <link>https://111qqz.com/2017/03/c-sort%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Wed, 01 Mar 2017 07:27:12 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/c-sort%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>回想起大一的时候打cf&amp;hellip;那个时候对C++还不怎么熟悉。。。用sort不会自定义排序方式。。 于是手写快排。。。直接取中间元素没加</description>
    </item>
    
    <item>
      <title>cpp vector学习笔记</title>
      <link>https://111qqz.com/2017/02/cpp-vector%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Tue, 28 Feb 2017 07:21:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/cpp-vector%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>起因是百度实习二面的时候被问了一道类似这样的题： 给我下面的代码，问有没有什么问题。 /* *********************************************** Author :111qqz Created Time :2017年02月28日 星期二 14时49分37</description>
    </item>
    
    <item>
      <title>cpp vector学习笔记</title>
      <link>https://111qqz.com/2017/02/cpp-vector%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Tue, 28 Feb 2017 07:21:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/cpp-vector%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>起因是百度实习二面的时候被问了一道类似这样的题： 给我下面的代码，问有没有什么问题。 /* *********************************************** Author :111qqz Created Time :2017年02月28日 星期二 14时49分37</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 学习笔记</title>
      <link>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>昨天终于搞定了ycm对c++11的支持&amp;hellip;. 嘛，17都快出来了，我竟然连11都不会用。 不过突然把所有的11特性给我也没办法全部吸</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 学习笔记</title>
      <link>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>昨天终于搞定了ycm对c++11的支持&amp;hellip;. 嘛，17都快出来了，我竟然连11都不会用。 不过突然把所有的11特性给我也没办法全部吸</description>
    </item>
    
    <item>
      <title>c语言中static的作用</title>
      <link>https://111qqz.com/2016/01/c%e8%af%ad%e8%a8%80%e4%b8%adstatic%e7%9a%84%e4%bd%9c%e7%94%a8/</link>
      <pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate>
      
      <guid>https://111qqz.com/2016/01/c%e8%af%ad%e8%a8%80%e4%b8%adstatic%e7%9a%84%e4%bd%9c%e7%94%a8/</guid>
      <description>一般有两个 static int a; int b; void func(void) { static int c=0; int d; } 在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static</description>
    </item>
    
    <item>
      <title>c语言中static的作用</title>
      <link>https://111qqz.com/2016/01/c%e8%af%ad%e8%a8%80%e4%b8%adstatic%e7%9a%84%e4%bd%9c%e7%94%a8/</link>
      <pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate>
      
      <guid>https://111qqz.com/2016/01/c%e8%af%ad%e8%a8%80%e4%b8%adstatic%e7%9a%84%e4%bd%9c%e7%94%a8/</guid>
      <description>一般有两个 static int a; int b; void func(void) { static int c=0; int d; } 在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static</description>
    </item>
    
  </channel>
</rss>