<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on 111qqz的小窝</title>
    <link>https://111qqz.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on 111qqz的小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 01 Feb 2019 11:19:29 +0000</lastBuildDate>
    
	<atom:link href="https://111qqz.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C语言变长参数</title>
      <link>https://111qqz.github.io/2019/02/variadic-function-of-c/</link>
      <pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2019/02/variadic-function-of-c/</guid>
      <description>说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。 stdarg.h 中提供以一套</description>
    </item>
    
    <item>
      <title>std::call_once &amp;&amp; std::once_flag  notes</title>
      <link>https://111qqz.github.io/2018/09/stdcall_once-stdonce_flag-notes/</link>
      <pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/09/stdcall_once-stdonce_flag-notes/</guid>
      <description>多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。 资源初始化一般遵循&amp;rdquo;lazy initialization&amp;rdqu</description>
    </item>
    
    <item>
      <title>linux 下 .o 文件， .a文件，.so文件</title>
      <link>https://111qqz.github.io/2018/03/linux-%e4%b8%8b-o-%e6%96%87%e4%bb%b6%ef%bc%8c-a%e6%96%87%e4%bb%b6%ef%bc%8c-so%e6%96%87%e4%bb%b6/</link>
      <pubDate>Sat, 17 Mar 2018 12:56:33 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/03/linux-%e4%b8%8b-o-%e6%96%87%e4%bb%b6%ef%bc%8c-a%e6%96%87%e4%bb%b6%ef%bc%8c-so%e6%96%87%e4%bb%b6/</guid>
      <description>发现我对工程一无所知QAQ 参考资料： LibraryArchives-StaticAndDynamic 简单得说就是：A .a file is a static library, while a .so file is a shared object (dynamic) library similar to a DLL on Windows. 至于.o文件，其实就相当于win下的obj</description>
    </item>
    
    <item>
      <title>CUDA C Best Practices Guide 阅读笔记（二） Heterogeneous Computing</title>
      <link>https://111qqz.github.io/2018/02/cuda-c-best-practices-guide-%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%ef%bc%88%e4%ba%8c%ef%bc%89-heterogeneous-computing/</link>
      <pubDate>Tue, 13 Feb 2018 06:38:38 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/cuda-c-best-practices-guide-%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%ef%bc%88%e4%ba%8c%ef%bc%89-heterogeneous-computing/</guid>
      <description>CUDA 编程涉及到在不同的平台上同时运行代码:包含CPU的host 和包含GPU的device. 所以了解host和device的对性能优化是非常重要</description>
    </item>
    
    <item>
      <title>CUDA C Best Practices Guide 阅读笔记（1） 并行计算方法论(APOD)</title>
      <link>https://111qqz.github.io/2018/02/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e8%ae%ba%ef%bc%88%e4%b8%80%ef%bc%89/</link>
      <pubDate>Mon, 12 Feb 2018 04:58:31 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e8%ae%ba%ef%bc%88%e4%b8%80%ef%bc%89/</guid>
      <description>APOD指的是Assess, Parallelize, Optimize, Deploy 如图所示，APOD过程是一个循环的过程，每次只进行一部分，从A到P到O到D,然后再进行下一轮的APOD Assess 对</description>
    </item>
    
    <item>
      <title>CUDA 7.5: 用指令级性能分析精确找到性能问题</title>
      <link>https://111qqz.github.io/2018/02/cuda-7-5-%e7%94%a8%e6%8c%87%e4%bb%a4%e7%ba%a7%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%b2%be%e7%a1%ae%e6%89%be%e5%88%b0%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98/</link>
      <pubDate>Sun, 11 Feb 2018 08:06:14 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/cuda-7-5-%e7%94%a8%e6%8c%87%e4%bb%a4%e7%ba%a7%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%b2%be%e7%a1%ae%e6%89%be%e5%88%b0%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98/</guid>
      <description>原文： CUDA 7.5: Pinpoint Performance Problems with Instruction-Level Profiling 主要是介绍了CUDA 7.5 以上的版本的 NVIDIA Visual Profiler 加入的新特性 可以细粒度到指令级，分析出性能的瓶颈（在这之前，只能分析到kern</description>
    </item>
    
    <item>
      <title>cuda c&#43;&#43;  基础算法库 thrust 学习笔记</title>
      <link>https://111qqz.github.io/2018/02/cuda-c-%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%e5%ba%93-thrust-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Sat, 10 Feb 2018 08:43:54 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/cuda-c-%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%e5%ba%93-thrust-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>可以了解成并行版的STL(? 过了一遍nvidia的官方网文档 发现如果熟悉STL的话,thrust没什么太多好说的,看起来很简单&amp;hellip</description>
    </item>
    
    <item>
      <title>cuda error checking 学习笔记</title>
      <link>https://111qqz.github.io/2018/02/cuda-error-checking-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Fri, 09 Feb 2018 06:55:00 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/cuda-error-checking-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>由于发现cuda c++ 的 debug方式和c++ 差别很大,因此打算再开一篇,专门记录一些和error checking 以及debug有关的内容. Error checks in CUDA code can help catch CUDA</description>
    </item>
    
    <item>
      <title>C&#43;&#43;  Linux下使用popen()执行shell命令</title>
      <link>https://111qqz.github.io/2018/02/c-linux%e4%b8%8b%e4%bd%bf%e7%94%a8popen%e6%89%a7%e8%a1%8cshell%e5%91%bd%e4%bb%a4/</link>
      <pubDate>Mon, 05 Feb 2018 12:54:23 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/c-linux%e4%b8%8b%e4%bd%bf%e7%94%a8popen%e6%89%a7%e8%a1%8cshell%e5%91%bd%e4%bb%a4/</guid>
      <description>由于需要在Linux平台下，通过cpp获取某个进程所占用的物理内存，得知了这个东西。 感觉还挺厉害的orz.. 下面是一段示例代码 #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.h&amp;gt; using namespace std;</description>
    </item>
    
    <item>
      <title>cuda 学习笔记</title>
      <link>https://111qqz.github.io/2018/02/cuda-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 01 Feb 2018 07:20:04 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2018/02/cuda-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>uodate:有毒吧。kernel中出问题原来是不会报错的。。。。 请教了组里的hust学长orz..、 学到了cuda-memcheck命令和</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中头文件（.h）和源文件（.cpp）都应该写些什么（转载）</title>
      <link>https://111qqz.github.io/2017/05/c%e4%b8%ad%e5%a4%b4%e6%96%87%e4%bb%b6%ef%bc%88-h%ef%bc%89%e5%92%8c%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88-cpp%ef%bc%89%e9%83%bd%e5%ba%94%e8%af%a5%e5%86%99%e4%ba%9b%e4%bb%80%e4%b9%88%ef%bc%88%e8%bd%ac/</link>
      <pubDate>Tue, 16 May 2017 07:07:06 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2017/05/c%e4%b8%ad%e5%a4%b4%e6%96%87%e4%bb%b6%ef%bc%88-h%ef%bc%89%e5%92%8c%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88-cpp%ef%bc%89%e9%83%bd%e5%ba%94%e8%af%a5%e5%86%99%e4%ba%9b%e4%bb%80%e4%b9%88%ef%bc%88%e8%bd%ac/</guid>
      <description>感觉其实。。。更像是一种规范。。。？而不是一种具体要求吧。。。 ### [转自](http://www.cnblogs.com/fenghuan/p</description>
    </item>
    
    <item>
      <title>g&#43;&#43; 编译多个源文件（转载）</title>
      <link>https://111qqz.github.io/2017/05/g-%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</link>
      <pubDate>Tue, 16 May 2017 06:40:03 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2017/05/g-%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa%e6%ba%90%e6%96%87%e4%bb%b6%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</guid>
      <description>参考资料 一. 常用编译命令选项 假设源程序文件名为test.c。 无选项编译链接 用法：#gcc test.c 作用：将test.c预处理、汇编、编译并链接形成可</description>
    </item>
    
    <item>
      <title>Lock-free vs wait-free concurrency</title>
      <link>https://111qqz.github.io/2017/03/lock-free-vs-wait-free-concurrency/</link>
      <pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2017/03/lock-free-vs-wait-free-concurrency/</guid>
      <description>参考资料 看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？ There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free,</description>
    </item>
    
    <item>
      <title>C&#43;&#43; const 用法总结（转载）</title>
      <link>https://111qqz.github.io/2017/03/c-const-%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</link>
      <pubDate>Sat, 18 Mar 2017 12:22:32 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2017/03/c-const-%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93%ef%bc%88%e8%bd%ac%e8%bd%bd%ef%bc%89/</guid>
      <description>基本全文照搬了：关于C++ const 的全面总结 总结全面还是要一点时间的orz..感谢原作者，暂时没发现有什么错误（? 其中对我而言比较陌生的是“con</description>
    </item>
    
    <item>
      <title>C&#43;&#43; sort学习笔记</title>
      <link>https://111qqz.github.io/2017/03/c-sort%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Wed, 01 Mar 2017 07:27:12 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2017/03/c-sort%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>回想起大一的时候打cf&amp;hellip;那个时候对C++还不怎么熟悉。。。用sort不会自定义排序方式。。 于是手写快排。。。直接取中间元素没加</description>
    </item>
    
    <item>
      <title>cpp vector学习笔记</title>
      <link>https://111qqz.github.io/2017/02/cpp-vector%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Tue, 28 Feb 2017 07:21:49 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2017/02/cpp-vector%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>起因是百度实习二面的时候被问了一道类似这样的题： 给我下面的代码，问有没有什么问题。 /* *********************************************** Author :111qqz Created Time :2017年02月28日 星期二 14时49分37</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 学习笔记</title>
      <link>https://111qqz.github.io/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
      <pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2016/08/c11-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</guid>
      <description>昨天终于搞定了ycm对c++11的支持&amp;hellip;. 嘛，17都快出来了，我竟然连11都不会用。 不过突然把所有的11特性给我也没办法全部吸</description>
    </item>
    
    <item>
      <title>c语言中static的作用</title>
      <link>https://111qqz.github.io/2016/01/c%e8%af%ad%e8%a8%80%e4%b8%adstatic%e7%9a%84%e4%bd%9c%e7%94%a8/</link>
      <pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate>
      
      <guid>https://111qqz.github.io/2016/01/c%e8%af%ad%e8%a8%80%e4%b8%adstatic%e7%9a%84%e4%bd%9c%e7%94%a8/</guid>
      <description>一般有两个 static int a; int b; void func(void) { static int c=0; int d; } 在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static</description>
    </item>
    
  </channel>
</rss>