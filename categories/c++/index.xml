<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on 111qqz的小窝</title><link>https://111qqz.com/categories/c++/</link><description>Recent content in c++ on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 01 Feb 2019 11:19:29 +0000</lastBuildDate><atom:link href="https://111qqz.com/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。
stdarg.h 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考x86-calling-conventions 简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **
在实现上，需要了解的是：
* va_list，一个类型，可以看做是变长参数列表； * [va_start](http://en.cppreference.com/w/cpp/utility/variadic/va_start)，用来初始化变长参数列表的宏，声明为void va_start( va_list ap, parm_n ); ap为va_list变量，parm_n为变长参数前一个变量（C语言要求至少有一个named variable作为函数的parameter) * [va_arg](http://en.cppreference.com/w/cpp/utility/variadic/va_arg),用来得到下一个参数的宏，声明为T va_arg( va_list ap, T ); **返回的类型取决于传入的类型T。特别注意:&amp;quot;If `va_arg` is called when there are no more arguments in `ap`, the behavior is undefined.&amp;quot;** * [va_end](http://en.cppreference.com/w/cpp/utility/variadic/va_end) ,用来将va_list释放的宏。 下面看一个例子就明白怎么用了orz
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* print all args one at a time until a negative argument is seen; all args are assumed to be of int type */ void printargs(int arg1, .</description></item><item><title>Lock-free vs wait-free concurrency</title><link>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</link><pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate><guid>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</guid><description>
参考资料
看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？
There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free, and wait-free. Their meaning is often confused. In lock-free systems, while any particular computation may be blocked for some period of time, all CPUs are able to continue performing other computations. To put it differently, while a given thread might be blocked by other threads in a lock-free system, all CPUs can continue doing other useful work without stalls.</description></item><item><title>c++11 学习笔记</title><link>https://111qqz.com/2016/08/c11-/</link><pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate><guid>https://111qqz.com/2016/08/c11-/</guid><description>
昨天终于搞定了ycm对c++11的支持....
嘛，17都快出来了，我竟然连11都不会用。
不过突然把所有的11特性给我也没办法全部吸收。
所以在这里记录下用过的c++11的用法。
auto可以代替stl的一些容器中的iterator: /****************************************************************** ******************************************************************* ******************************************************************/ set&amp;lt;int&amp;gt;se; //之前的写法遍历要这样写： for (set&amp;lt;int&amp;gt;::iterator it = se.begin() ;it!=se.end() ;it++) //用auto可以简化成这样子 for ( auto it = se.begin(); it!=se.end() ;it++)</description></item><item><title>c语言中static的作用</title><link>https://111qqz.com/2016/01/cstatic/</link><pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate><guid>https://111qqz.com/2016/01/cstatic/</guid><description>
一般有两个
static int a; int b; void func(void) { static int c=0; int d; } 在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。 ** c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用(而不是初始值0，初始化只会在函数第一次被调用的时候执行)**</description></item></channel></rss>