<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on 111qqz's blog</title><link>https://111qqz.com/categories/c++/</link><description>Recent content in c++ on 111qqz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 01 Feb 2019 11:19:29 +0000</lastBuildDate><atom:link href="https://111qqz.com/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。
stdarg.h 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考x86-calling-conventions 简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **
在实现上，需要了解的是：
* va_list，一个类型，可以看做是变长参数列表； * [va_start](http://en.cppreference.com/w/cpp/utility/variadic/va_start)，用来初始化变长参数列表的宏，声明为void va_start( va_list ap, parm_n ); ap为va_list变量，parm_n为变长参数前一个变量（C语言要求至少有一个named variable作为函数的parameter) * [va_arg](http://en.cppreference.com/w/cpp/utility/variadic/va_arg),用来得到下一个参数的宏，声明为T va_arg( va_list ap, T ); **返回的类型取决于传入的类型T。特别注意:&amp;quot;If `va_arg` is called when there are no more arguments in `ap`, the behavior is undefined.&amp;quot;** * [va_end](http://en.cppreference.com/w/cpp/utility/variadic/va_end) ,用来将va_list释放的宏。 下面看一个例子就明白怎么用了orz
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* print all args one at a time until a negative argument is seen; all args are assumed to be of int type */ void printargs(int arg1, .</description></item><item><title>std::call_once &amp;&amp; std::once_flag notes</title><link>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</link><pubDate>Thu, 20 Sep 2018 12:47:46 +0000</pubDate><guid>https://111qqz.com/2018/09/stdcall_once-stdonce_flag-notes/</guid><description>
多线程保护数据时，一种较为特殊的情况是只需要保护资源的初始化。
资源初始化一般遵循&amp;quot;lazy initialization&amp;quot;的原则，也就是在用到该资源最近的地方再初始化。
比较容易想到的办法是用std::mutex，将资源初始化的地方锁起来，如下:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::mutex resource_mutex; void foo() { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(resource_mutex); if(!resource_ptr) { resource_ptr.reset(new some_resource); } lk.unlock(); resource_ptr-&amp;gt;do_something(); } 这确实是一个办法。但是初始化时如果需要耗费比较多的时间，当有比较多的线程时，一个线程初始化时，其他线程会耗时间在不必要的等待上。
在c++11以后，我们可以使用std::once_flag和std::call_once来解决资源初始化时加锁的问题。比起显示调用std::mutex的好处是，资源消耗更少。
下面是两个例子:
std::shared_ptr&amp;lt;some_resource&amp;gt; resource_ptr; std::once_flag resource_flag; b void init_resource() { resource_ptr.reset(new some_resource); } void foo() { std::call_once(resource_flag,init_resource); resource_ptr-&amp;gt;do_something(); } class X { private: connection_info connection_details; connection_handle connection; std::once_flag connection_init_flag; void open_connection() { connection=connection_manager.open(connection_details); } public:62 C HAPTER 3 Sharing data between threads X(connection_info const&amp;amp; connection_details_): connection_details(connection_details_) {} void send_data(data_packet const&amp;amp; data) { std::call_once(connection_init_flag,&amp;amp;X::open_connection,this); connection.</description></item><item><title>Lock-free vs wait-free concurrency</title><link>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</link><pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate><guid>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</guid><description>
参考资料
看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？
There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free, and wait-free. Their meaning is often confused. In lock-free systems, while any particular computation may be blocked for some period of time, all CPUs are able to continue performing other computations. To put it differently, while a given thread might be blocked by other threads in a lock-free system, all CPUs can continue doing other useful work without stalls.</description></item><item><title>C++ const 用法总结（转载）</title><link>https://111qqz.com/2017/03/cpp-const/</link><pubDate>Sat, 18 Mar 2017 12:22:32 +0000</pubDate><guid>https://111qqz.com/2017/03/cpp-const/</guid><description>
基本全文照搬了：关于C++ const 的全面总结
总结全面还是要一点时间的orz..感谢原作者，暂时没发现有什么错误（?
其中对我而言比较陌生的是“const修饰成员函数”的用法。。已经加粗。
 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。 Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。
一、Const作用
** **如下表所示：
**No.** **作用** **说明** **参考代码** 1 可以定义const常量 const int Max = 100; 2 便于进行类型检查 const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误 void f(const int i) { .........} //对传入的参数进行类型检查，不匹配进行提示
3 可以保护被修饰的东西 防止意外的修改，增强程序的健壮性。 void f(const int i) { i=10;//error!</description></item><item><title>C++ sort学习笔记</title><link>https://111qqz.com/2017/03/c-sort/</link><pubDate>Wed, 01 Mar 2017 07:27:12 +0000</pubDate><guid>https://111qqz.com/2017/03/c-sort/</guid><description>
回想起大一的时候打cf...那个时候对C++还不怎么熟悉。。。用sort不会自定义排序方式。。
于是手写快排。。。直接取中间元素没加随机化。。。跪了。。。
后来知道sort怎么写以后。。发现sort是可以通过的。。。
于是我就一直以为sort是带随机化的快排。。。
然而实际上是：
sort在数据量比较大的时候用quick_sort...当分段后的数据量小于某个门槛，为了避免对此递归带来的额外负担。。采取插入排序的策略。。
Image not found a.warning-link { color: inherit !important; font-weight: inherit !important; text-decoration: underline !important; border-bottom: none !important; } Web path: /2017/03/c-sort/https://111qqz.com/wordpress/wp-content/uploads/2017/03/Workspace-1_015.png
Disk path: /content/post/工程/https://111qqz.com/wordpress/wp-content/uploads/2017/03/Workspace-1_015.png
Using Page Bundles: true
以及。。。快排在最快情况下还是会到达平方的复杂度。。。
于是有人发明了introsort...中文翻译叫内省排序。。。？
维基百科_introsort
这个算法其实就是。。对于数据量大的时候。。。一开始还是快排。。。但是当递归深度过深时。。用堆排。。。
据说现在的STL一般都是用了introsort....</description></item><item><title>cpp vector学习笔记</title><link>https://111qqz.com/2017/02/cpp-vector/</link><pubDate>Tue, 28 Feb 2017 07:21:49 +0000</pubDate><guid>https://111qqz.com/2017/02/cpp-vector/</guid><description>
起因是百度实习二面的时候被问了一道类似这样的题：
给我下面的代码，问有没有什么问题。
/* *********************************************** Author :111qqz Created Time :2017年02月28日 星期二 14时49分37秒 File Name :vector.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;ctime&amp;gt; using namespace std; int func( int x ) //此处函数的条件是不单调...这样才可以触发问题. { return (x-50)*(x-50)+1; } int main() { vector&amp;lt;int&amp;gt;vec; int *pint = NULL; for ( int i = 0 ; i &amp;lt; 100 ; i++) { int x = func(i); vec.push_back(x); if (x&amp;lt;500) { pint = &amp;amp; vec[0]; } } if (pint) *pint = 0 ; int siz = vec.</description></item><item><title>c++11 学习笔记</title><link>https://111qqz.com/2016/08/c11-/</link><pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate><guid>https://111qqz.com/2016/08/c11-/</guid><description>
昨天终于搞定了ycm对c++11的支持....
嘛，17都快出来了，我竟然连11都不会用。
不过突然把所有的11特性给我也没办法全部吸收。
所以在这里记录下用过的c++11的用法。
auto可以代替stl的一些容器中的iterator: /****************************************************************** ******************************************************************* ******************************************************************/ set&amp;lt;int&amp;gt;se; //之前的写法遍历要这样写： for (set&amp;lt;int&amp;gt;::iterator it = se.begin() ;it!=se.end() ;it++) //用auto可以简化成这样子 for ( auto it = se.begin(); it!=se.end() ;it++)</description></item><item><title>c语言中static的作用</title><link>https://111qqz.com/2016/01/cstatic/</link><pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate><guid>https://111qqz.com/2016/01/cstatic/</guid><description>
一般有两个
static int a; int b; void func(void) { static int c=0; int d; } 在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。 ** c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用(而不是初始值0，初始化只会在函数第一次被调用的时候执行)**</description></item></channel></rss>