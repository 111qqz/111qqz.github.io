<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 111qqz的小窝</title><link>https://111qqz.com/categories/c++/</link><description>Recent content in C++ on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Fri, 01 Feb 2019 11:19:29 +0000</lastBuildDate><atom:link href="https://111qqz.com/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
&lt;p&gt;说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Stdarg.h#.3Cvarargs.h.3E"&gt;stdarg.h&lt;/a&gt; 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考&lt;a href="https://111qqz.com/2019/01/x86-calling-conventions/"&gt;x86-calling-conventions&lt;/a&gt;   简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **&lt;/p&gt;</description></item><item><title>Lock-free vs wait-free concurrency</title><link>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</link><pubDate>Tue, 21 Mar 2017 09:24:56 +0000</pubDate><guid>https://111qqz.com/2017/03/lock-free-vs-wait-free-concurrency/</guid><description>
&lt;p&gt;&lt;a href="https://rethinkdb.com/blog/lock-free-vs-wait-free-concurrency/"&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看leveldb源码中遇到的，关于lock-free 和 wait-free..感觉这个讲得不错，我试着翻译一下？&lt;/p&gt;
&lt;blockquote&gt;There are two types of [non-blocking thread synchronization](http://en.wikipedia.org/wiki/Non-blocking_synchronization) algorithms - lock-free, and wait-free. Their meaning is often confused. In lock-free systems, while any particular computation may be blocked for some period of time, all CPUs are able to continue performing other computations. To put it differently, while a given thread might be blocked by other threads in a lock-free system, all CPUs can continue doing other useful work without stalls. Lock-free algorithms increase the overall throughput of a system by occassionally increasing the latency of a particular transaction. Most high- end database systems are based on lock-free algorithms, to varying degrees.&lt;/blockquote&gt;
&lt;p&gt;有两种 &lt;a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm"&gt;无阻塞线程同步算法&lt;/a&gt;，一种是lock-free，一种是wait-free，它们的含义经常被搞混。在一个lock-free系统中，尽管某个特定的计算会被阻碍一段时间，所有的cpu还是能够继续其他计算。换一种说法，尽管在一个lock-free的系统里，一个线程可能被其他线程阻碍，所有的cpu仍然可以继续做其他工作而不做停顿。lock-free算法通过偶然增加一个特定事物的延迟，增加了系统总体的吞吐率。大多数高端数据库系统都在某种程度上基于lock-free 算法。&lt;/p&gt;</description></item><item><title>c++11 学习笔记</title><link>https://111qqz.com/2016/08/c11-/</link><pubDate>Thu, 18 Aug 2016 07:37:49 +0000</pubDate><guid>https://111qqz.com/2016/08/c11-/</guid><description>
&lt;p&gt;昨天终于搞定了ycm对c++11的支持....&lt;/p&gt;
&lt;p&gt;嘛，17都快出来了，我竟然连11都不会用。&lt;/p&gt;
&lt;p&gt;不过突然把所有的11特性给我也没办法全部吸收。&lt;/p&gt;
&lt;p&gt;所以在这里记录下用过的c++11的用法。&lt;/p&gt;</description></item><item><title>c语言中static的作用</title><link>https://111qqz.com/2016/01/cstatic/</link><pubDate>Mon, 11 Jan 2016 06:55:04 +0000</pubDate><guid>https://111qqz.com/2016/01/cstatic/</guid><description>
&lt;p&gt;一般有两个&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;7&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;在这里，a与b都是全局变量，二者的区别是，b可以被别的文件使用，a只能在本文件中使用，这是static对全局变量的作用。&lt;/strong&gt;
** c和d的区别是，d是一个自动变量，func函数执行完后，d会自动被释放。但c却不会被释放，下一次调用func函数时，c的值会保留上次的值继续使用(而不是初始值0，初始化只会在函数第一次被调用的时候执行)**&lt;/p&gt;</description></item></channel></rss>