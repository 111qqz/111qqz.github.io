<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mooc on 111qqz的小窝</title><link>https://111qqz.com/categories/mooc/</link><description>Recent content in Mooc on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 26 Jun 2021 18:18:52 +0800</lastBuildDate><atom:link href="https://111qqz.com/categories/mooc/index.xml" rel="self" type="application/rss+xml"/><item><title>[施工完成] CSAPP shell lab</title><link>https://111qqz.com/2021/06/csapp-shelllab/</link><pubDate>Sat, 26 Jun 2021 18:18:52 +0800</pubDate><guid>https://111qqz.com/2021/06/csapp-shelllab/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>动手实现一个简单的Lab，主要依赖于课本第八章的内容
感觉主要是05比较难。。发现执行的顺序不太对。。原因是SIGCHLD里面waitpid参数没写对。。
后面的就相对简单了
累计大概花了10个小时的样子&lt;/p></description></item><item><title>(CSE 599W)Reverse Mode Autodiff</title><link>https://111qqz.com/2021/04/reverse-mode-autodiff/</link><pubDate>Mon, 05 Apr 2021 14:44:25 +0800</pubDate><guid>https://111qqz.com/2021/04/reverse-mode-autodiff/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>怎么算微分。。通常有三种方法。&lt;/p>
&lt;ul>
&lt;li>Symbolic Differentiation&lt;/li>
&lt;li>Numerical Differentiation&lt;/li>
&lt;li>Automatic Differentiation (auto diff)&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://img.so/image/gqMwii">
&lt;img class="image_figure image_external" loading="lazy" src="https://111qqz.com/images/migrated/myximage/c8589036cb6d845eb07a05441e2d32f8.md.png" alt="c8589036cb6d845eb07a05441e2d32f8.md.png" />
&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://img.so/image/gqMENj">
&lt;img class="image_figure image_external" loading="lazy" src="https://111qqz.com/images/migrated/myximage/7f409550ef544562ea67816c7a884fcb.md.png" alt="7f409550ef544562ea67816c7a884fcb.md.png" />
&lt;/a>&lt;/p>
&lt;p>auto diff中两种主流的方式分别是forward-mode和reverse-mode
由于forward-mode的方法中，计算的时间复杂度是O(n),n是输入的参数个数。而reverse-mode中，计算的时间复杂度是O(m),m是输出节点的个数。在dnn中，n往往很大，远大于m，因此这里主要介绍reverse-mode auto diff方法。&lt;/p></description></item><item><title>[施工完成] CSAPP Malloc lab</title><link>https://111qqz.com/2021/04/csapp-malloclab/</link><pubDate>Sun, 14 Mar 2021 16:05:42 +0800</pubDate><guid>https://111qqz.com/2021/04/csapp-malloclab/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>动手实现一个memory allocator,体会core到爆炸的乐趣(不是&lt;/p>
&lt;h2 id="trace-file-结构分析">trace file 结构分析&lt;/h2>
&lt;p>trace file 是对allocator的输入的描述，可以从mdriver.c中的&lt;/p></description></item><item><title>[施工完成] CSAPP Cachelab</title><link>https://111qqz.com/2020/12/csapp-cache-lab/</link><pubDate>Sat, 26 Dec 2020 16:40:42 +0800</pubDate><guid>https://111qqz.com/2020/12/csapp-cache-lab/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>CSAPP:3e 的配套实验 &lt;a href="http://csapp.cs.cmu.edu/3e/README-cachelab">地址&lt;/a>
分成了两个部分，第一部分是模拟一下cache的miss,hit,evict的规则。第二部分是优化一个矩阵的转置，使得miss尽可能少。&lt;/p></description></item><item><title>【施工完成】CSAPP archlab</title><link>https://111qqz.com/2020/02/csapp-archlab/</link><pubDate>Wed, 26 Feb 2020 22:54:33 +0800</pubDate><guid>https://111qqz.com/2020/02/csapp-archlab/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>CSAPP:3e第四章配套的实验。 第四章是讲处理器架构的，章节的重点是实现一个六阶段流水线。&lt;/p>
&lt;p>lab的内容也是，需要实现一个Y86-64的流水线，并进行性能调优。&lt;/p></description></item><item><title>【施工完成】CSAPP attacklab</title><link>https://111qqz.com/2020/02/csapp-attacklab/</link><pubDate>Sat, 15 Feb 2020 23:24:23 +0800</pubDate><guid>https://111qqz.com/2020/02/csapp-attacklab/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>CSAPP 处理器那章快看完了，猛然发现竟然还有个attacklab.. 之前以为每一章只有一个lab&lt;/p>
&lt;p>这个lab是教大家如何找到程序的漏洞并实施攻击。
知道如何实施攻击，才能更好地写出安全的代码。&lt;/p></description></item><item><title>【施工完成】CSAPP bomb lab</title><link>https://111qqz.com/2020/02/csapp-bomblab/</link><pubDate>Sat, 01 Feb 2020 19:36:23 +0800</pubDate><guid>https://111qqz.com/2020/02/csapp-bomblab/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>疫情肆虐,在家百无聊赖,于是开始拆炸弹.
炸弹分为6个阶段,每个阶段必须输入一个特定的字符串,否则炸弹就会爆炸.
提供给我们的是一个.c文件和一个linux可执行文件bomb&lt;/p></description></item><item><title>The Programming Language Course</title><link>https://111qqz.com/2019/10/The-Programming-Language-Course/</link><pubDate>Sat, 19 Oct 2019 19:04:01 +0800</pubDate><guid>https://111qqz.com/2019/10/The-Programming-Language-Course/</guid><description>
&lt;p>花了三个月的时间,终于跟完了这门编程语言课.
&lt;img class="image_figure image_external" loading="lazy" src="https://111qqz.com/images/migrated/loli/xDFXnKT3yWGvdQp.png" alt="课程成绩.png" />
课程内容非常赞,而且也充分发挥了coursera平台的作用.
非要说缺点的话,就是这门课时间有点短,以及peers&amp;rsquo; assignments总是找不到人&amp;hellip;&lt;/p></description></item><item><title>【施工中】MIT 6.828 lab 3: User Environments</title><link>https://111qqz.com/2019/03/mit-6-828-lab-3-user-environments/</link><pubDate>Sun, 03 Mar 2019 12:45:25 +0000</pubDate><guid>https://111qqz.com/2019/03/mit-6-828-lab-3-user-environments/</guid><description>
&lt;p>JOS的environments基本可以理解成&amp;quot;process&amp;quot;进程的同义词，但是由于&amp;quot;process&amp;quot;是一个unix术语，因此使用environment这个词．&lt;/p></description></item><item><title>【施工完成】CSAPP data lab</title><link>https://111qqz.com/2019/02/csapp-data-lab/</link><pubDate>Thu, 28 Feb 2019 14:06:42 +0000</pubDate><guid>https://111qqz.com/2019/02/csapp-data-lab/</guid><description>
&lt;p>CSAPP第二章的内容以前组成原理基本都学过&amp;hellip;所以就简单翻了翻。&lt;/p>
&lt;p>对应的lab是用位运算实现各种有的没的&amp;hellip;&lt;/p>
&lt;p>题目基本都很tricky&amp;hellip;&lt;/p></description></item><item><title>【施工完毕】MIT 6.828 lab 2: Memory Management</title><link>https://111qqz.com/2019/02/mit-6-828-lab-2/</link><pubDate>Thu, 14 Feb 2019 14:01:46 +0000</pubDate><guid>https://111qqz.com/2019/02/mit-6-828-lab-2/</guid><description>
&lt;h3 id="2019年2月24完成了除了challenge以外的全部练习和问题-总共花费15个小时">2019年2月24:完成了除了&amp;quot;Challenge&amp;quot;以外的全部练习和问题. 总共花费15个小时.&lt;/h3>
&lt;h3 id="2019年2月26完成challenge-2应该是最简单的一个orz只花了不到一个小时">2019年2月26:完成&amp;quot;Challenge 2&amp;quot;(应该是最简单的一个orz，只花了不到一个小时)&lt;/h3>
&lt;h2 id="part-1-physical-page-management">Part 1: Physical Page Management&lt;/h2>
&lt;p>操作系统必须时刻追踪哪些物理内存在使用，哪些物理内存没有在使用。&lt;/p></description></item><item><title>C语言变长参数</title><link>https://111qqz.com/2019/02/variadic-function-of-c/</link><pubDate>Fri, 01 Feb 2019 11:19:29 +0000</pubDate><guid>https://111qqz.com/2019/02/variadic-function-of-c/</guid><description>
&lt;p>说起C语言的变长参数，可能听起来比较陌生，因为很少会需要自己实现。不过想一下scanf和printf，参数个数的确是不固定的。&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Stdarg.h#.3Cvarargs.h.3E">stdarg.h&lt;/a> 中提供以一套机制来实现变长参数。以及，要说明的是，变长参数不是什么黑魔法，原理依赖于stack frame的结构，具体可以参考&lt;a href="https://111qqz.com/2019/01/x86-calling-conventions/">x86-calling-conventions&lt;/a>   简单来说，由于函数参数入栈的顺序是固定的，**因此一旦我们知道某函数帧的栈上的一个固定参数的位置，我们完全有可能推导出其他变长参数的位置 **&lt;/p></description></item><item><title>x86 calling conventions</title><link>https://111qqz.com/2019/01/x86-calling-conventions/</link><pubDate>Thu, 31 Jan 2019 12:12:22 +0000</pubDate><guid>https://111qqz.com/2019/01/x86-calling-conventions/</guid><description>
&lt;p>x86的调用约定主要说的是这几件事:&lt;/p>
&lt;blockquote>
&lt;blockquote>
&lt;/blockquote>
&lt;pre>&lt;code> * The order in which atomic (scalar) parameters, or individual parts of a complex parameter, are allocated
* How parameters are passed (pushed on the stack, placed in registers, or a mix of both)
* Which registers the called function must preserve for the caller (also known as: callee-saved registers or non-volatile registers)
* How the task of preparing the stack for, and restoring after, a function call is divided between the caller and the callee
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>调用约定实际上并不唯一&lt;/p></description></item><item><title>【施工完成】MIT 6.828 lab 1: C, Assembly, Tools and Bootstrapping</title><link>https://111qqz.com/2019/01/mit-6-828-lab-1/</link><pubDate>Thu, 24 Jan 2019 12:27:58 +0000</pubDate><guid>https://111qqz.com/2019/01/mit-6-828-lab-1/</guid><description>
&lt;h2 id="花费了30小时终于搞定了orz">花费了30+小时，终于搞定了orz&lt;/h2>
&lt;h2 id="part-1-pc-bootstrap">Part 1: PC Bootstrap&lt;/h2>
&lt;h3 id="the-pcs-physical-address-space">The PC&amp;rsquo;s Physical Address Space&lt;/h3>
&lt;h4 id="80868088时代">8086/8088时代&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="o">+------------------+&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mh">0x00100000&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="n">MB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="n">BIOS&lt;/span> &lt;span class="n">ROM&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="o">+------------------+&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mh">0x000F0000&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">960&lt;/span>&lt;span class="n">KB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">bit&lt;/span> &lt;span class="n">devices&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="n">expansion&lt;/span> &lt;span class="n">ROMs&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="o">+------------------+&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mh">0x000C0000&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">768&lt;/span>&lt;span class="n">KB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="n">VGA&lt;/span> &lt;span class="n">Display&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="o">+------------------+&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mh">0x000A0000&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">640&lt;/span>&lt;span class="n">KB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="n">Low&lt;/span> &lt;span class="n">Memory&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">&lt;span class="o">|&lt;/span> &lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">&lt;span class="o">+------------------+&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="mh">0x00000000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于8086/8088只有20跟地址线，因此物理内存空间就是2^20=1MB.地址空间从0x00000到0xFFFFF.其中从0x00000开始的640k空间被称为&amp;quot;low memory&amp;quot;，是PC真正能使用的RAM。从 0xA0000 到 0xFFFFF　的384k的non-volatile memory被硬件保留，用作video display buffers和BIOS等。&lt;/p></description></item><item><title>【施工中】MIT 6.828 Operating System Engineering 学习笔记</title><link>https://111qqz.com/2019/01/mit-6-828-overview/</link><pubDate>Tue, 15 Jan 2019 16:39:18 +0000</pubDate><guid>https://111qqz.com/2019/01/mit-6-828-overview/</guid><description>
&lt;p>&lt;a href="https://pdos.csail.mit.edu/6.828/2018/index.html">课程主页&lt;/a>&lt;/p>
&lt;p>这课稍微有点硬核&amp;hellip;感觉基础稍微有些不扎实就做不下去orz.&lt;/p>
&lt;p>网上似乎是有博客写了6.828的学习笔记，不过我更希望自己能够独立完成，二手的知识，谁知道是对的错的呢&amp;hellip;况且课程本身给的参考资料应该还是足够多的。&lt;/p></description></item></channel></rss>