<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>其他 on 111qqz的小窝</title><link>https://111qqz.com/categories/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Sat, 26 Feb 2022 19:10:30 +0800</lastBuildDate><atom:link href="https://111qqz.com/categories/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>levelDB 代码阅读笔记 01</title><link>https://111qqz.com/2022/02/leveldb-notes-01/</link><pubDate>Sat, 26 Feb 2022 19:10:30 +0800</pubDate><guid>https://111qqz.com/2022/02/leveldb-notes-01/</guid><description>
背景 最近在做一个智能算力相关的项目，类似美团外卖广告智能算力的探索与实践 其中实现控制系统需要与数据库交互。 虽然最后技术选型并没有使用到levelDB,但是想趁机把代码读了吧。
很惊讶的发现我大三的时候声称自己度过部分levelDB代码，甚至还写了几篇相关的博客，比如
murmurhash源码分析 Lock-free vs wait-free concurrency 内存屏障（Memory Barriers） levelDB 学习笔记 但是我却一点都没印象了.... 仔细看来很多概念在当时可能都是没有充分理解的，而且从数目上来看，应该并没有完整看完levelDB代码。
所以重新开个坑，看看自己比起毕业前有没有长进【没有
先从入口 include/leveldb/db.h 开始
LEVELDB_EXPORT 看到LEVELDB_EXPORT这个macro
1 2class LEVELDB_EXPORT Snapshot { 3 protected: 4 virtual ~Snapshot(); 5}; 6 是在 include/leveldb/export.h 中定义的
1 2// 符号可见性问题，使用macro来控制在编译成动态库时暴露，在Link时不暴露符号是一种common 的做法 3// 4#if !defined(LEVELDB_EXPORT) 5 6#if defined(LEVELDB_SHARED_LIBRARY) 7#if defined(_WIN32) 8 9#if defined(LEVELDB_COMPILE_LIBRARY) 10#define LEVELDB_EXPORT __declspec(dllexport) 11#else 12#define LEVELDB_EXPORT __declspec(dllimport) 13#endif // defined(LEVELDB_COMPILE_LIBRARY) 14 15#else // defined(_WIN32) 16#if defined(LEVELDB_COMPILE_LIBRARY) 17#define LEVELDB_EXPORT __attribute__((visibility(&amp;#34;default&amp;#34;))) 18#else 19#define LEVELDB_EXPORT 20#endif 21#endif // defined(_WIN32) 22 23#else // defined(LEVELDB_SHARED_LIBRARY) 24#define LEVELDB_EXPORT 25#endif 26 27#endif // !</description></item><item><title>博客除草</title><link>https://111qqz.com/2022/02/better-blog/</link><pubDate>Wed, 02 Feb 2022 19:56:49 +0800</pubDate><guid>https://111qqz.com/2022/02/better-blog/</guid><description>
博客要长草了。。趁着过年时间多，打理一下。。
添加google analytics hugo本身已经集成了这个功能 要点是集成的是旧版本的universal analytics (对应的是UA-ID) 而目前google主推得其实是新版本google analytics 4(对应的是GA4-ID)
更换主题 更换主题为 hugo-clarity
最主要的原因是之前的博客主题语法高亮有些问题...
cpp中代码添加了注释后，会将代码显示在注释的同一行 proto文件不能正确换行 所以换了个可以正确解析语法的主题...
问题1 github actions执行正常，访问渲染好的页面提示
1 2This page contains the following errors: 3error on line 50 at column 394: PCDATA invalid Char value 8 4 最终发现原因是没有清除掉旧theme的 git submodule 清除后问题解决
同时更新了一下github actions中 hugo的版本为extented版本
问题2 algolia 更新报错，似乎是json文件没生成。 由于搜索功能使用频率也不太高，暂时禁止掉
1- name:upload algolia data2uses:actions/setup-node@v23with:4node-version:&amp;#39;12&amp;#39;5- run:npm run algolia问题3 图片无法显示，提示&amp;quot;error not found&amp;quot;
目测是blog的一个bug,已经提了issue
暂时fork了一份，修改了代码绕过去
故障修复</description></item><item><title>Goodbye 2021</title><link>https://111qqz.com/2022/01/goodbye-2021/</link><pubDate>Mon, 03 Jan 2022 16:27:20 +0800</pubDate><guid>https://111qqz.com/2022/01/goodbye-2021/</guid><description>
在公司做ppt做到吐血，恰好想起2021年终总结还没有写
过去的一年 总的来说,2021年真的是无比辛苦的一年。 转行互联网的阵痛期这句话其实完全不是开玩笑。从CV转来做推荐，技术栈看起来接近，但是问题的重点变得很不一样。
推荐场景存在大量稀疏特征，而CV下大部分特征都是稠密的 推荐模型更新频繁，几分钟就要做一次更新，而CV模型的迭代速度是以天或者周来计算的 离线请求和在线serving. 当然这点其实并不是CV/推荐 带来的不同 以至于对于行业内一些人尽皆知的概念，我第一次听到也一头雾水。比如&amp;quot;看一下服务的流量分布&amp;quot;，比如“统计下p99”最初这一个个简单的概念都让工作比较吃力
说起&amp;quot;阵痛期&amp;quot;，前两个月组里本来来了个商汤的前同事，做PPL(商汤自研的推理框架)的。然后也是感到了极大的不适应，于是在被折磨了两个月之后跑路到其他组了233
再加上腾讯内部的基础设施非常的烂，不仅仅是PCG内部的，导致最初的几个月过得无比煎熬。
基础设置有多烂呢，拿内部CI/CD平台蓝盾举例，我们每次提交代码会触发5条流水线(有不同tensorflow版本，以及gpu/cpu的区别)，所有流水线都通过代码才能被合入。 在有一段时间里，5条流水线同时通过的概率接近为0,原因就是蓝盾上的各种组件非常不稳定。 不是这个挂，就是那个挂。 挂了之后的解决办法就是拉群，然后helper让你这样试试，那样试试，解决不了就再拉人进群。通常一个小问题的三天以上才能解决，有的甚至要一周以上。在解决的过程中是不是做自己的工作就好了呢？ 想的太美好了。蓝盾常常会让你进行一个尝试，并声称“这样改一下就可以了”。本来的一个问题在改过会变成新的三个问题，并拉更多的人进群解决。那么平台出问题的频率是怎么样的呢？ 大概每周一次吧，非常频繁。 以至于甚至总监在开会的时候都会安慰大家&amp;quot;(腾讯)内部的工具就是这样，大家不要太因为这些工具的不稳定而感到气馁&amp;quot;233
总的来说，转行可真苦
展望 腾讯也要过冬了
&amp;quot;留给PCG的时间也不多了“
2022预计会比2021艰难许多
苟住，我们2023年见</description></item><item><title>使用github actions来部署 github pages</title><link>https://111qqz.com/2020/01/using-github-actions-to-deploy-gh-pages/</link><pubDate>Sat, 23 Jan 2021 17:08:00 +0800</pubDate><guid>https://111qqz.com/2020/01/using-github-actions-to-deploy-gh-pages/</guid><description>
目前我的博客是部署在github pages上，源码是一个repo,渲染出来的静态页面是一个repo. 更新的时候是把后者作为前者的submodule. 感觉这种方式有些落后了，简直和某司内部的平台有的一比。因此尝试采用了下github actions，来自动化这个部署的流程。
build github pages 其实类似gitlab ci. 最开始我以为需要自己配置服务器，结果发现并不需要，直接用公用的就可以。 详细内容可以阅读github actions
遇到的主要问题其实是，在一个repo的github actions的pipeline 里推送到另外一个repo提示一些权限方面的错误。 解决的办法是配置下ssh key. 假设源码的repo称为A,渲染得到的静态页面的repo称为B 那么先生成一对ssh-key 然后在 A里，settings-&amp;gt;secrets 添加一个secret,名称为&amp;quot;ACTIONS_DEPLOY_KEY&amp;quot;，内容为private key的内容 然后在B里，settings-&amp;gt;deploy keys, 添加一个key,名称无所谓，内容为public key的内容
这样每次push到源码的repo A,就可以自动触发github actions,将静态页面推送到repo B.然后repo B 自动触发github pages机制
附一个github actions的配置文件
1# This is a basic workflow to help you get started with Actions23name:CI45# Controls when the action will run. 6on:7# Triggers the workflow on push or pull request events but only for the master branch8push:9branches:[master ]10pull_request:11branches:[master ]1213# Allows you to run this workflow manually from the Actions tab14workflow_dispatch:1516# A workflow run is made up of one or more jobs that can run sequentially or in parallel17jobs:18# This workflow contains a single job called &amp;#34;build&amp;#34;19build:20# The type of runner that the job will run on21runs-on:ubuntu-18.</description></item><item><title>2020年终总结</title><link>https://111qqz.com/2020/01/my-2020/</link><pubDate>Sun, 03 Jan 2021 16:54:57 +0800</pubDate><guid>https://111qqz.com/2020/01/my-2020/</guid><description>
本来不知道写什么所以不打算写了，不过后来觉得可以把今年做的一些重大的决定写出来，把当时的分析和想法记录下来。这样若干年后再回看，就能找到，是哪些明智或愚蠢的决定，对人生产生了巨大的影响。
职业选择 在商汤待了1234天之后，还是离开了这个一毕业就在地方。新的岗位完全远离了cv方向，主要和推荐相关了。
在换工作方面其实一直特别迷茫，迷茫在我不知道我在商汤的岗位是在做什么。想起19年的时候，猎头都是先默认我是做cv算法的。当得知我虽然不是做算法研究的，就没兴趣聊了2333. 或者有些猎头会觉得，既然不是做算法研究的那就是做工程的了，那对后端一定很熟悉吧？ 我觉得这个也和行业内重刷点，轻落地的氛围有很大关系。
这个氛围感觉2020年有了很大好转，有很多拿着“算法工程”的岗位jd的猎头出现，聊起来都是说，客户暂时不需要能训模型的人，比较急需做算法工程的同学。这个时候就感觉，我做的内容终于配有一个岗位名字了2333. 也感觉到市场上对岗位的需求比之前旺盛了很多。
这里想起了一件趣事。一个关系比较好的猎头和我吐槽给b站招算法工程的人，找了好久也找不到合适的。然后看了下要求。。是在算法工程领域有五年以上经验。。。 我就拉着猎头小姐姐算了一下，2020年的五年前是2015年。 15年那个时候，大部分公司可能还没有组建算法团队，甚至后面还要经历过几年疯狂的刷点比拼。。。 甚至cv落地里面非常重要的TensorRT的前身GIE都还没有公布出来。。。
虽然感觉市场需求开始旺盛了。。但是基本没有考虑再去一个cv公司，只是用某友商练了个手。 原因是我觉得，这些公司有的和商汤半斤八两，有的还不如商汤。尤其是从规模和抗风险能力上。商汤遇到的问题在这些公司上可能都会有（除了盘子太大以至于太烧钱）。
出来面了一圈非cv创业公司发现，面试的岗位真的是奇奇怪怪，做什么的都有。有推我去做算子优化的（类似优化矩乘),有推我去做k8s服务调度的，稍显正常的其实就是做移动端推理框架和机器学习平台的了。被推到各种岗位其实不是什么好事，因为这说明没有什么岗位是完全匹配的。我觉得这主要是因为商汤的to B属性，和互联网公司的技术栈其实是有区别的。次要原因可能就是，cv在小的创业公司需求旺盛，但是在互联网公司好像真的有些鸡肋。面了一圈，只有一个做超市购物结算的美帝公司和某个友商面试问过我和cv相关的问题。
其实本来倾向于去字节的。。花了半年时间刷了700 leetcode。 可惜最初投的部门面试体验比较差，后面又约了另一个部门。。感觉完全不匹配。。。我再也不相信字节hr所谓的“很match”了。。。 之后先前面的鹅厂一直就在催答复。。感觉包裹也算有诚意。。做的事情也算比较理想。。。向朋友们打听了一圈。。给的评价都还可以。。。 尤其是被frog学姐强推。。就接了offer。。。 接了之后又被字节三个不同的部门捞了一遍。。。其中一个部门的hr说。。部门老大看了我的面评一定要聊一下。。。 那似乎面评中没有什么很糟糕的部分。。算是比较欣慰吧。。 有缘再见。
其他 毕业两年半，厉害的同学已经年薪百万了orz
虽然说当年读CS的时候就业还是红牌，也不是为了钱。但是财务上相对自由才能有更大的自由去做自己喜欢的事情吧。 所以还是挺羡慕
2021,希望自己变得更强！</description></item><item><title>k8s nodes is forbidden user cannot list resource nodes in api group at the cluster scope</title><link>https://111qqz.com/2020/05/install-k8s-get-nodes-forbidden-error/</link><pubDate>Thu, 07 May 2020 16:01:52 +0800</pubDate><guid>https://111qqz.com/2020/05/install-k8s-get-nodes-forbidden-error/</guid><description>
继续将k8s用于模型转换和部署的自动化流程...然后发现之前安装k8s的文档不work了．． 时间是2020年5月7日，当前最新的k8s版本是　v1.18.2
报错如下:
1 2 3&amp;lt;2kzzqw6rsjid0 --discovery-token-ca-cert-hash sha256:c6c72bdc96c0ff4d59559ff915eee61ba7ac5e8b93c0b2f9e11e813412387ec2 --v=5 4W0507 15:45:12.608784 4768 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set. 5I0507 15:45:12.608822 4768 join.go:371] [preflight] found NodeName empty; using OS hostname as NodeName 6I0507 15:45:12.608853 4768 initconfiguration.go:103] detected and using CRI socket: /var/run/dockershim.sock 7[preflight] Running pre-flight checks 8I0507 15:45:12.608902 4768 preflight.go:90] [preflight] Running general checks 9I0507 15:45:12.608933 4768 checks.go:249] validating the existence and emptiness of directory /etc/kubernetes/manifests 10I0507 15:45:12.</description></item><item><title>thinkpad t430 manjaro系统安装nvidia驱动</title><link>https://111qqz.com/2020/04/Install-nvidia-Driver-on-Thinkpad-T430-Manjaro/</link><pubDate>Sun, 12 Apr 2020 07:10:14 +0800</pubDate><guid>https://111qqz.com/2020/04/Install-nvidia-Driver-on-Thinkpad-T430-Manjaro/</guid><description>
前几天装驱动把笔记本搞崩溃了..重新装了kde桌面环境的manjaro
首先根据 Configure NVIDIA (non-free) settings and load them on Startup
直接装驱动。 装之后mhwd -li命令会显示新安装的驱动，带有nvidia字样的。
然而发现inxi -G 命令下，nvidia GPU显示的drivier是 N/A
参考Inxi -G in Terminal: Graphics card N/A?
发现需要手动load driver
执行 sudo modprobe nvidia 后发现inxi -G 命令可以找到驱动了，nvidia-smi也可以正常显示了。
接下来是设置开启加载driver.
参考Automatic module loading with systemd
需要修改 /etc/modules-load.d/modules.conf
加入一行
1 2nvidia 3 重启后发现仍然不work.
然后看到/etc/modules-load.d/ doesn’t load nvidia on boot
发现原因是nvidia驱动被设置为黑名单了。 在 /usr/lib/modprobe.d/bumblebee.conf 文件中，把所有内容注释掉即可。
重新启动，发现已经可以正常加载驱动了。</description></item><item><title>2020 to do List</title><link>https://111qqz.com/2020/02/2020-to-do-list/</link><pubDate>Fri, 21 Feb 2020 20:12:51 +0800</pubDate><guid>https://111qqz.com/2020/02/2020-to-do-list/</guid><description>
就..终于再次出现了to do list. 原因是之前一直不知道如何置顶文章....
竟然一下子就2020年了...
学习模型量化 学习onnx CSAPP（随缘 ai system 课程</description></item><item><title>yuv 图像格式初探</title><link>https://111qqz.com/2019/07/Yuv-Image-Format/</link><pubDate>Wed, 03 Jul 2019 20:31:11 +0800</pubDate><guid>https://111qqz.com/2019/07/Yuv-Image-Format/</guid><description>
概述 YUV是一种图像编码方式,或者称为色彩空间,与RGB是同级的概念. YUV是三个分量,Y,U和V,其中:
Y 表示明亮度(Luminance或Luma),也就是灰度值, U,V表示色度,浓度（Chrominance、Chroma）,可以简单理解成用来表示某个像素的颜色的量. YUV格式的特点是,在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。 也就是说,YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。
其中YCbCr是YUV压缩和偏移的版本。YCbCr的Y与YUV中的Y含义一致，Cb和Cr与UV同样都指色彩，Cb指蓝色色度，Cr指红色色度，在应用上很广泛，JPEG、MPEG、DVD、摄影机、数字电视等皆采此一格式。因此一般俗称的YUV大多是指YCbCr。
YUV采样方式 主流的采样方式有三种: 其中Y 分量用叉表示，UV 分量用圆圈表示。
YUV4:4:4 YUV4:2:2 YUV4:2:0 下面三张图分别为YUV444,YUV422和YUV420的采样方式. 但是注意,上面的三张图只是说明了每个分量的比例,并不能说明排列方式.
需要注意的是yuv420并不是说只采样U分量或者只采样V分量,而是指，在每一行扫描时，只扫描一种色度分量（U 或者 V），和 Y 分量按照 2 : 1 的方式采样。比如，第一行扫描时，YU 按照 2 : 1 的方式采样，那么第二行扫描时，YV 分量按照 2:1 的方式采样
YUV封装格式 采样方式主要是告诉我们各个分量的比例,下面看一下封装格式. YUV格式有两大类：planar和packed。
planar: 先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 packed: 每个像素点的Y,U,V是连续交错存储的。 其中,planar格式还分为SEMI PLANAR和PLANAR
semi planar:先连续存储所有的Y, 然后UV交错存储. planar:先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 以YUV420为例,前面的图为平面的封装格式,也就是YUV420P(Planar) 后面的图为半平面的封装格式,也就是YUV420SP(semi planar) 或者以1920*1080的图片具体举例:
左边的图为平面的封装格式,也就是YUV420P(Planar) 右边的图为半平面的封装格式,也就是YUV420SP(semi planar) YUV格式的名称,傻傻分不清楚 由于最近使用的YUV420格式的,因此主要会涉及这一种. YUV420分为YUV420P和YUV420SP两种. 其中YUV420P又有两种,一种是Y(w×h) + U(w×h/4) + V(w×h/4)的格式,这一种也叫I420或者420P或者IYUV(存疑,参考opencv convert_color函数文档) 另一种是Y(w×h) + V(w×h/4) + U(w×h/4)的格式,这一种也叫YV12</description></item><item><title>写在毕业一年之后</title><link>https://111qqz.com/2019/06/one-yeaf-after-graduation/</link><pubDate>Sat, 29 Jun 2019 01:04:09 +0800</pubDate><guid>https://111qqz.com/2019/06/one-yeaf-after-graduation/</guid><description>
转眼毕业一整年了，是时候做一个复盘了。 依稀记得刚入职的时候leader提醒我要有职业规划时的场景。总体来说，这一年虽然没有完全走在最正确的路线上，但是大方向应该没有太偏。
工作之中 其实前半年做的事情非常杂，c++,java,爬虫，前端... 技术的广度和深度，我个人觉得是深度更重要的。 但是在规模不够大的公司，很多时候不得已去现学一些个人技术栈以外的东西。好在后半年以及之后的工作都会比较focus.
总体来说，这一年里主要是如下技能得到了一些提升：
c++/cuda 图像编解码 CV算法 还点了一些奇奇怪怪的技能点，我觉得算不上什么竞争力，就不写了。
工作之外 这一年里，工作之外，主要做了两个方面的事情。 第一个方面补了一下计算机专业课，主要是操作系统和计算机网络。具体来说，看完了&amp;quot;自顶向下方法&amp;quot;，还有&amp;quot;OS:Three easy pieces&amp;quot;,MIT 的6.828做了一部分。 补这部分的内容是因为它们很重要,而我在学校的时候又没怎么听过课。没听课是因为当时沉迷ACM，而且觉得学院课程的质量和深度都不够理想。
第二个方面是学了更多的CV相关的知识。最开始的想法是，身边的同事好多是CS名校的Phd,又在CV领域有着丰富的经验，如果在商汤的职业生涯中，没能在这方面取得比较大的收货，其实是有点亏的。但是后来发现，这其实对我的工作也很有帮助。所以可能并不是一个任务来了之后，才发现去要学习什么，而是技术栈变宽了之后，才有机会做以前没机会做的任务吧。
一些其他感悟 毕业之前觉得，代码能力是很重要的能力。现在觉得，某个领域的知识和经验才是核心，代码能力只是锦上添花。
对我而言，职业初期，最不重要的其实是薪水。最重要的是个人成长，其次是职业声誉的积累，最后才是薪水吧。当然个人成长其实是一个很难衡量的东西，我觉得并不是学会了之前不会的东西就是成长，只有掌握了与主线有关的内容才是成长。 至于主线是什么呢，目前希望能在系统优化和CV算法两个方面获得一些收获。
结语 工作一年，整体体验还是非常好的。 感觉比起在学校的日子要开心得多，因为在学校还要应付奇奇怪怪，没什么用的考试，而在公司，可以比较纯粹得学习技术，并用新学到的东西解决一个又一个问题，非常有成就感。 工作上虽然说不上顺风顺水，但是也没遇到过什么大的困难。 虽然要学习好多新的内容，但是ICPC的经历是会给人很多信心的（虽然我很菜），那就是只要时间充足，没有什么学不会的东西。当然，能学会的东西未必值得去学，不过迫于生计嘛，有的时候也是没办法的事情。
新的周期，加油！</description></item><item><title>迁移博客到hugo</title><link>https://111qqz.com/2019/05/hello-hugo/</link><pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate><guid>https://111qqz.com/2019/05/hello-hugo/</guid><description>
发现工作之后更新博客的频率低了很多，以及迫于不想在自己维护服务器了，因此决定把博客迁移到hugo上。
由于原本的博客内容实在是太多了，因此目前只做了大致的迁移，基本可以保证每篇文章都是可以访问的。
原博客 在2023年之前应该仍然可以访问，不过会逐步停止维护。</description></item><item><title>BattleBlock Theater linux下无法启动的解决办法　（　void* MemoryBlock::Alloc(unsigned int): Assertion failed ）</title><link>https://111qqz.com/2019/05/battleblock-theater-linux-start-failed/</link><pubDate>Wed, 01 May 2019 12:09:18 +0000</pubDate><guid>https://111qqz.com/2019/05/battleblock-theater-linux-start-failed/</guid><description>
在steam上买了　BattleBlock Theater，　官方说支持linux，但是却无法启动。
在steam里启动看不到log,于是找到游戏的安装目录。
/home/coder/.steam/steam/steamapps/common/BattleBlock Theater
在终端下启动，报错:
BattleBlockTheater: /media/BGBS/BBT_Linux/Core/MemorySystem.cpp:161: void* MemoryBlock::Alloc(unsigned int): Assertion `(!&amp;quot;Got request for zero bytes!&amp;quot;)' failed. ^C[1] 22303 abort (core dumped) ./BattleBlockTheater
google了一下发现这似乎是游戏本身的bug,这里有一个workaround
办法是使用hex editor将游戏的可执行文件中， 从offset 0x24F2BE 开始的6个字节替换成0x90
我使用的hex editor 是hexcurse,　这里有一个使用指南　可以参考。</description></item><item><title>manjaro /archlinux 下 steam 文明5/6(civilization V/VI)的运行方法</title><link>https://111qqz.com/2019/02/manjaro-archlinux-civilization/</link><pubDate>Sat, 23 Feb 2019 14:28:01 +0000</pubDate><guid>https://111qqz.com/2019/02/manjaro-archlinux-civilization/</guid><description>
系统版本为Manjaro 18.0.3 Illyria
运行文明5比较容易，只需要设置启动选项为:
LD_PRELOAD=/usr/lib32/libopenal.so.1 %command%
文明6运行会报错 undefined symbol: FT_Done_MM_Var
解决办法是 在终端中用如下办法运行steam:
LD_PRELOAD=/usr/lib/libfreetype.so steam
参考链接</description></item><item><title>2019 to do list</title><link>https://111qqz.com/2019/01/2019-to-do-list/</link><pubDate>Tue, 01 Jan 2019 13:13:04 +0000</pubDate><guid>https://111qqz.com/2019/01/2019-to-do-list/</guid><description>
* &amp;lt;del&amp;gt;Operating Systems: Three Easy Pieces&amp;lt;/del&amp;gt; * fluent python * &amp;lt;del&amp;gt;《计算机网络:自顶向下方法》&amp;lt;/del&amp;gt; * 《mysql必知必会》 * PC Assembly Language ( for mit 6.828 )</description></item><item><title>我在公司的服务器上执行了sudo rm -rf /*</title><link>https://111qqz.com/2018/11/when-I-execute-sudo-rm-rf-on-the-company-server/</link><pubDate>Sat, 24 Nov 2018 08:31:19 +0000</pubDate><guid>https://111qqz.com/2018/11/when-I-execute-sudo-rm-rf-on-the-company-server/</guid><description>
TL;DR
* 依靠人的小心谨慎是不靠谱的，人总有失误的时候 * 看了下docker volume的权限机制，貌似是从docker image中继承。 * 写了两个脚本，用来把rm alias到mv，避免手滑 又是一个可以摸鱼的周五晚上，sensespider系统测试了一天，fix了几个Bug,似乎可以发布了。系统一直是部署在了docker中..这几天测试产生了不少结果文件在host的volume中... 看着不舒服，干脆删一下好了
嗯？怎么所有者是root。。。那我sudo一下，也没什么大不了的嘛
然而手滑了... 打了个 sudo rm -rf /* ...
提示无法删除/boot device is busy...
吓了一跳，下意识Ctrl-C...
从新在本地ssh到服务器，发现已经登不上去了...报错在找不到sh
看了一下，果然服务器的/bin 目录已经被删干净了...
google了一些从rm中恢复文件的帖子...
试图用 sudo apt-get install 装一些工具包...
这个时候已经提示我找不到apt-get 了。。。
非常慌。花了3分钟思考了我到目前为止的一生
看了下scp命令还在，赶紧趁着这个终端回话还没关，把本地的/bin目录拷贝了上来。
试了下，ssh命令可以用了。 这样至少后续的修复（在不麻烦IT同事的情况下)不用跑机房了。有些镇定。
然后发现apt-get 命令还是用不了。。。思考了1分钟。。。
然后发现服务器用的是centos.......
再试了各种常用命令，试了docker相关的各种命令，都可以正常工作。
然而整个人都被吓傻了....睡了一觉才回过神。
又查了下docker volume权限的事情，发现挂载目录继承docker image中用户的权限是feature Volumes files have root owner when running docker with non-root user. 那似乎就没办法了。
以及写了两个脚本，来避免手滑，分别是zsh环境和bash环境下的。
kkrm</description></item><item><title>docker network 与 本地 network 网段冲突</title><link>https://111qqz.com/2018/11/docker-network-conflict-with-local-subnetwork/</link><pubDate>Tue, 20 Nov 2018 08:33:20 +0000</pubDate><guid>https://111qqz.com/2018/11/docker-network-conflict-with-local-subnetwork/</guid><description>
起因: 公司部署在hk的爬虫服务器突然挂掉了。后来发现只是在深圳办公区无法访问。排查后发现原因是docker的网络(包括docker network的subnet或者是某个容器的ip)与该host在内网的ip段相同，导致冲突。
排查过程： 有两个方面需要排查。一个是docker服务启动时的默认网络。
默认网络使用bridge桥接模式，是容器与宿主机进行通讯的默认办法。
修改默认网段可以参考 http://blog.51cto.com/wsxxsl/2060761
除此之外，还需要注意docker创建的network的网段。
使用docker network ls 命令查看当前的网络
然后可以使用docker inspect 查看每个network的详细信息。
也可以直接使用ip addr 来查看各种奇怪的虚拟网卡的ip,是否有前两位的地址和host的ip地址相同的。
解决办法: 本想在docker-compose up 时指定默认网络的subnet
结果发现好像并不支持？version 1.10.0 error on gateway spec
Was there any discussion on that? I do need to customize the network, because my company uses the 172.16.0.0/16 address range at some segments and Docker will simply clash with that by default, so every single Docker server in the whole company needs a forced network setting.</description></item><item><title>记一次在 docker compose 中使用volume的踩坑记录</title><link>https://111qqz.com/2018/11/docker-compose-default-volume-name-makes-me-confused/</link><pubDate>Wed, 14 Nov 2018 08:06:57 +0000</pubDate><guid>https://111qqz.com/2018/11/docker-compose-default-volume-name-makes-me-confused/</guid><description>
现象: 使用docker compose 挂载 named volume 无效（且没有错误提示)
排查过程: 一开始是没有使用docker-compose命令，直接使用docker run -v 命令，挂载两个绝对路径，没有问题。
然后使用named volume，在这里使用了local-persist 插件，来指定数据卷(volume)在host上的位置。直接用docker run -v 命令，依然没有问题。
接下里打算放到docker compose里面，发现并没有挂载成功。
但是在docker compose里面，挂载两个绝对路径是ok的。
于是怀疑是volume的问题
此时使用docker inspect 查看 用docker compose 启动起来的，挂载named volume的容器
发现mount里面，挂载的named volume并不是我在docker-compose.yml填写的名称，而是多了一个前缀，这个前缀恰好是docker-compose.yml 文件所在的目录名称。
查了一下，发现果然不止我一个人被坑到orz Docker-compose prepends directory name to named volumes
其实应该直接使用docker inspect来排查的...应该会更快找到问题
解决办法： 有几种解决办法：
* 不手动创建volume，而是在docker-compose.yml中，设置volume的mountpoint * 在docker-compose.yml中，添加external: true的选项到 volume中，参考[external](https://docs.docker.com/compose/compose-file/#external) 顺便附上我的docker-compose.yml文件
version: '3' services: django: image: &amp;quot;registry.sensetime.com/spider/sensespider:v1.0&amp;quot; volumes: - spiderdata:/data privileged: true ports: - &amp;quot;8000:8000&amp;quot; working_dir: /home/renkuanze/workspace/sensespider entrypoint: bash run.</description></item><item><title>How to use Scrapy with Django Application（转自medium）</title><link>https://111qqz.com/2018/11/how-to-use-scrapy-with-django-application/</link><pubDate>Tue, 06 Nov 2018 13:33:00 +0000</pubDate><guid>https://111qqz.com/2018/11/how-to-use-scrapy-with-django-application/</guid><description>
在meidum上看到一篇很赞的文章...无奈关键部分一律无法加载出来...挂了梯子也不行，很心塞...刚刚突然发现加载出来了...以防之后再次无法访问，所以搬运过来．
There are couple of articles on how to integrate Scrapy into a Django Application (or vice versa?). But most of them don’t cover a full complete example that includes triggering spiders from Django views. Since this is a web application, that must be our main goal.
What do we need ? Before we start, it is better to specify what we want and how we want it. Check this diagram:</description></item><item><title>lua学习笔记</title><link>https://111qqz.com/2018/10/lua-notes/</link><pubDate>Fri, 26 Oct 2018 02:47:59 +0000</pubDate><guid>https://111qqz.com/2018/10/lua-notes/</guid><description>
lua是一门轻量级的脚本语言...好像比较适合写游戏？在 太阳神三国杀 中见过很多lua脚本。 由于splash 的渲染脚本需要用lua来写，因此来学习一波。
直接上语法...看到了python和pascal的影子orz
-- Two dashes start a one-line comment. --[[ Adding two ['s and ]'s makes it a multi-line comment. --]] ---------------------------------------------------- -- 1. Variables and flow control. ---------------------------------------------------- num = 42 -- All numbers are doubles. -- Don't freak out, 64-bit doubles have 52 bits for -- storing exact int values; machine precision is -- not a problem for ints that need &amp;lt; 52 bits. s = 'walternate' -- Immutable strings like Python.</description></item><item><title>golang 学习笔记</title><link>https://111qqz.com/2018/10/golang-notes/</link><pubDate>Sat, 20 Oct 2018 11:06:56 +0000</pubDate><guid>https://111qqz.com/2018/10/golang-notes/</guid><description>
先放资料,可能比较侧重于go在系统调用方面的内容.
这里不会记录详细的go的语法,只会记录学习的过程,踩到的坑,以及其他我认为值得记录的内容.
go的switch语句终于是人类思维的语句了...匹配中了不需要加break..
defer关键字可以延迟语句到上层函数退出时再执行,而且是会把延迟的语句压入栈,然后按照FILO的顺序执行...好像有点有意思?
参数列表..如果有多个变量的类型相同,只写一个类型关键字就行...
:=并不是pascal中的赋值符号(浪费感情...,而是简洁定义变量的语法,不能使用在函数以外.
感觉go中同时有一点C++和很多python的影子...
30分钟上手GO语言--基础语法
A Go Programmer’s Guide to Syscalls
视频笔记：Go 和 syscall - Liz Rice</description></item><item><title>爬虫学习笔记</title><link>https://111qqz.com/2018/10/web-crawler-notes/</link><pubDate>Fri, 19 Oct 2018 08:18:53 +0000</pubDate><guid>https://111qqz.com/2018/10/web-crawler-notes/</guid><description>
再次迫于生计。。。
参考了面向新人的 Python 爬虫学习资料
大致的学习路线为:
一： 简单的定向脚本爬虫（ request --- bs4 --- re ） 二： 大型框架式爬虫（ Scrapy 框架为主）
三：浏览器模拟爬虫 （ Mechanize 模拟 和 Selenium 模拟）
有Python基础和一点html基础的话。。。貌似上手是0难度的
年轻人的第一个爬虫(虽然代码是直接copy的...
''' 抓取百度贴吧---生活大爆炸吧的基本内容 爬虫线路： requests - bs4 Python版本： 3.6 OS： mac os 12.12.4 ''' import requests import time from bs4 import BeautifulSoup # 首先我们写好抓取网页的函数 def get_html(url): try: r = requests.get(url, timeout=30) r.raise_for_status() # 这里我们知道百度贴吧的编码是utf-8，所以手动设置的。爬去其他的页面时建议使用： # r.endcodding = r.apparent_endconding r.encoding = 'utf-8' return r.text except: return &amp;quot; ERROR &amp;quot; def get_content(url): ''' 分析贴吧的网页文件，整理信息，保存在列表变量中 ''' # 初始化一个列表来保存所有的帖子信息： comments = [] # 首先，我们把需要爬取信息的网页下载到本地 html = get_html(url) # 我们来做一锅汤 soup = BeautifulSoup(html, 'lxml') # 按照之前的分析，我们找到所有具有‘ j_thread_list clearfix’属性的li标签。返回一个列表类型。 liTags = soup.</description></item><item><title>java-grpc 踩坑记录</title><link>https://111qqz.com/2018/10/java-grpc-notes/</link><pubDate>Wed, 17 Oct 2018 03:29:03 +0000</pubDate><guid>https://111qqz.com/2018/10/java-grpc-notes/</guid><description>
最近的项目需要java和python之间的进程通信，想到了之前使用过的的grpc.
参考官方quickstart
* JDK: version 7 or higher 看起来只依赖jdk,美滋滋
然后按照文档执行
./gradlew installDist
报错:
Task :grpc-compiler:compileJava_pluginExecutableJava_pluginCpp FAILED FAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':grpc-compiler:compileJava_pluginExecutableJava_pluginCpp'. &amp;gt; No tool chain is available to build for platform 'x86_64': - Tool chain 'visualCpp' (Visual Studio): Visual Studio is not available on this operating system. - Tool chain 'gcc' (GNU GCC): Could not determine GCC metadata: could not find vendor in output of /usr/local/gcc-4.</description></item><item><title>2018 to do list</title><link>https://111qqz.com/2018/10/2018-to-do-list/</link><pubDate>Sun, 14 Oct 2018 15:30:52 +0000</pubDate><guid>https://111qqz.com/2018/10/2018-to-do-list/</guid><description>
迫于最近的事情有点多，还是记录一下。 果然to do list什么的，还是要按照年份记录啊。
* &amp;lt;del&amp;gt;了解linux strace命令&amp;lt;/del&amp;gt; * 速成go语言，并了解go于系统调用https://hackernoon.com/strace-in-60-lines-of-go-b4b76e3ecd64 * 熟悉hustoj V2版本目前的代码 * &amp;lt;del&amp;gt;看完&amp;lt;code in practice&amp;gt;&amp;lt;/del&amp;gt; * mit 6.828 lab1。。。感觉要咕 * 看完&amp;lt;unix 系统系统手册&amp;gt;的20，21章信号部分, 为hustoj的重构补充基础知识.</description></item><item><title>spring 学习笔记</title><link>https://111qqz.com/2018/10/spring-notes/</link><pubDate>Wed, 10 Oct 2018 09:56:46 +0000</pubDate><guid>https://111qqz.com/2018/10/spring-notes/</guid><description>
迫于生计，又要从零开始学习spring.
在这篇文章之前，对java的基础是2015年写过一个java大作业，对spring是一无所知。
为了学习spring，我按顺序做了以下事情:
* 学习了一下java语法，教程关键词是&amp;quot;java tutorial for cpp programmers&amp;quot;,比如[Learning a New Programming Language: Java for C++ Programmers ](http://pages.cs.wisc.edu/~hasti/cs368/JavaTutorial/) * 对spring有个大体的了解。视频教程要比官方文档或者博客迅速得多。推荐java brains的 [spring boot quick start](https://javabrains.io/courses/spring_bootquickstart/) ,一天时间就基本可以了解个大概。 * 简单看了下java brains的另一门课程 [spring_core](https://javabrains.io/courses/spring_core/)，主要是为了了解spring中一些常见概念，比如bean,依赖注入，以及常用注解。 * 然后了解了下spring与数据库的连接，这里有一个比官网更详细的教程[Spring Boot, MySQL, JPA, Hibernate Restful CRUD API Tutorial](https://www.callicoder.com/spring-boot-rest-api-tutorial-with-mysql-jpa-hibernate/) ，代码整理在[github](https://github.com/111qqz/Spring-Boot-mysql-sample) ,这个时候感受到了代码直接操作数据库（而不用写sql语句)的美妙。</description></item><item><title>spring 依赖注入</title><link>https://111qqz.com/2018/10/spring-dependency-injection/</link><pubDate>Tue, 09 Oct 2018 07:45:17 +0000</pubDate><guid>https://111qqz.com/2018/10/spring-dependency-injection/</guid><description>
真是个不明觉厉的术语...其实是个特别简单的概念orz
用白话讲，如果一个class A中用到了class B的实例，那么class B的实例就是class A的依赖，如果不是在class A中定义class B的实例，而是通过某个接口，将class B的实例传入classA,就叫依赖注入。
public class Example { // private DatabaseThingie myDatabase; // public Example() { // myDatabase = new DatabaseThingie(); // } public Example(DatabaseThingie useThisDatabaseInstead) { myDatabase = useThisDatabaseInstead; } public void DoStuff() { ... myDatabase.GetData(); ... } } 依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。
简单来说，a依赖b，但a不控制b的创建和销毁，仅使用b，那么b的控制权交给a之外处理，这叫控制反转（IOC），而a要依赖b，必然要使用b的instance，那么
1. 通过a的接口，把b传入； 2. 通过a的构造，把b传入； 3. 通过设置a的属性，把b传入； 这个过程叫依赖注入（DI）。
那么什么是IOC Container？
随着DI的频繁使用，要实现IOC，会有很多重复代码，甚至随着技术的发展，有更多新的实现方法和方案，那么有人就把这些实现IOC的代码打包成组件或框架，来避免人们重复造轮子。
所以实现IOC的组件或者框架，我们可以叫它IOC Container。</description></item><item><title>解决ubuntu 14.04 下 壁纸软件 variety 崩溃 ValueError: bad marshal data (unknown type code) 的问题</title><link>https://111qqz.com/2018/09/the-way-to-fix-variety-crash-on-ubuntu-14-04/</link><pubDate>Sun, 30 Sep 2018 08:59:31 +0000</pubDate><guid>https://111qqz.com/2018/09/the-way-to-fix-variety-crash-on-ubuntu-14-04/</guid><description>
系统为ubuntu 14.04
迫于特别想定时换壁纸，查了下解决方案。
发现只要删除掉/usr目录下所有的'.pyc'文件就可以
命令为:sudo find /usr -name '*.pyc' -delete</description></item><item><title>[c++11] std::async std::packaged_task std::promise and std::future notes</title><link>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</link><pubDate>Sun, 30 Sep 2018 06:49:27 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-async-packaged-ask-promise-future-notes/</guid><description>
把std::async,std::packaged_task,std::promise三个放在一起来说,是因为他们都可以返回一个std::future对象.简单来说,当某个线程需要等待一个特定的一次性事件(one-off event),它可以用一个&amp;quot;future&amp;quot;来表示这个事件.
std::async 有的时候可能你需要做一个花费事件比较长的计算,但是计算结果不是立刻需要.这个时候就可以用一个新的线程来做这个计算.这里比较关键的问题是如何将在新线程进行计算的结果传回到当前线程,因为std::thread并没有提供一个类似的机制.
这个时候就需要std::async登场了.
#include &amp;lt;future&amp;gt; #include &amp;lt;iostream&amp;gt; int find_the_answer_to_ltuae(); void do_other_stuff(); int main() { std::future&amp;lt;int&amp;gt; the_answer=std::async(find_the_answer_to_ltuae); do_other_stuff(); std::cout&amp;lt;&amp;lt;&amp;quot;The answer is &amp;quot;&amp;lt;&amp;lt;the_answer.get()&amp;lt;&amp;lt;std::endl; } 当然也可以与向std::thread包装的thread function中传参数一样,向std::async中传参数,如下:
#include &amp;lt;string&amp;gt; #include &amp;lt;future&amp;gt; struct X { void foo(int,std::string const&amp;amp;); std::string bar(std::string const&amp;amp;); }; X x; auto f1=std::async(&amp;amp;X::foo,&amp;amp;x,42,&amp;quot;hello&amp;quot;); // 调用p-&amp;gt;foo(42, &amp;quot;hello&amp;quot;)，p是指向x的指针 auto f2=std::async(&amp;amp;X::bar,x,&amp;quot;goodbye&amp;quot;); // 调用tmpx.bar(&amp;quot;goodbye&amp;quot;)， tmpx是x的拷贝副本 struct Y { double operator()(double); }; Y y; auto f3=std::async(Y(),3.141); // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到 auto f4=std::async(std::ref(y),2.718); // 调用y(2.718) X baz(X&amp;amp;); std::async(baz,std::ref(x)); // 调用baz(x) class move_only { public: move_only(); move_only(move_only&amp;amp;&amp;amp;) move_only(move_only const&amp;amp;) = delete; move_only&amp;amp; operator=(move_only&amp;amp;&amp;amp;); move_only&amp;amp; operator=(move_only const&amp;amp;) = delete; void operator()(); }; auto f5=std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到 此外,std:;async还有一个可选参数,值为std::launch::deferred或std::launch:async或std::launch::deferred|std::launch:async,第三种为默认参数.</description></item><item><title>[C++11]std::condition_variable notes</title><link>https://111qqz.com/2018/09/condition_variable-notes/</link><pubDate>Sun, 23 Sep 2018 08:42:33 +0000</pubDate><guid>https://111qqz.com/2018/09/condition_variable-notes/</guid><description>
condition_variable 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 condition_variable 。 用人话来说,condition_variable，也就是条件变量，是线程间通信的一种方式。
线程之间在很多时候需要通信，比如经典的生产者消费者问题
一个比较naive的方案是，用mutex来保护一个flag,然后另一线程不停得check这个flag的状态是否改变。以及在这个方案上的改进:让另一个线程check之后，可以先睡一段时间。
但是这两种方法都不够好。第一种不好的原因当然是不停得check，肯定会耗费大量的资源。而第二种，由于没办法准确估计要休眠的时间，因此不够实际。
这个时候我们可以考虑使用条件变量。
条件变量是可以用在如下场景: 一个或者多个线程在等某个条件的成立，而这个条件由另外的线程所控制。当该条件成立时，控制该条件的线程会主动通知这些线程，将这些线程唤醒。
如下是一个最简单的例子:
std::mutex mut; std::queue&amp;lt;data_chunk&amp;gt; data_queue; // 1 std::condition_variable data_cond; void data_preparation_thread() { while(more_data_to_prepare()) { data_chunk const data=prepare_data(); std::lock_guard&amp;lt;std::mutex&amp;gt; lk(mut); data_queue.push(data); // 2 data_cond.notify_one(); // 3 } } void data_processing_thread() { while(true) { std::unique_lock&amp;lt;std::mutex&amp;gt; lk(mut); // 4 data_cond.wait( lk,[]{return !data_queue.empty();}); // 5 data_chunk data=data_queue.front(); data_queue.pop(); lk.unlock(); // 6 process(data); if(is_last_chunk(data)) break; } } 接下来是一个较为复杂的例子，一个线程安全的队列的实现,
#include &amp;lt;queue&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;lt;mutex&amp;gt; #include &amp;lt;condition_variable&amp;gt; template&amp;lt;typename T&amp;gt; class threadsafe_queue { private: mutable std::mutex mut; // 1 互斥量必须是可变的 std::queue&amp;lt;T&amp;gt; data_queue; std::condition_variable data_cond; public: threadsafe_queue() {} threadsafe_queue(threadsafe_queue const&amp;amp; other) { std::lock_guard&amp;lt;std::mutex&amp;gt; lk(other.</description></item><item><title>react 中setState的更新策略</title><link>https://111qqz.com/2018/09/react-setstate-Update-strategy/</link><pubDate>Tue, 18 Sep 2018 13:31:06 +0000</pubDate><guid>https://111qqz.com/2018/09/react-setstate-Update-strategy/</guid><description>
起因是想更新一个array类型的state,结果setState更新之后用console.log() debug 结果，发现结果特别玄学。。。
查了下发现this.setState是个异步操作。。。
参考资料:
深入理解React 组件状态（State）
React中setState同步更新策略
https://react.docschina.org/docs/react-component.html</description></item><item><title>learn java in 21 minutes for C++ Programmers</title><link>https://111qqz.com/2018/09/learn-java-in-21-minutes-for-c-programmers/</link><pubDate>Mon, 10 Sep 2018 11:53:31 +0000</pubDate><guid>https://111qqz.com/2018/09/learn-java-in-21-minutes-for-c-programmers/</guid><description>
先放资料:
Learning a New Programming Language: Java for C++ Programmers
java package 先说几条重要的人话:
* 一个java文件第一行可以声明该文件所属于的package，package的名字必须与整个工作目录的路径名相同。 * 同一个package下的class默认有互相访问的权限。 * 访问属性设置为public的class，如果该class所在的file声明了package，那么可以被其他package下的class访问到。 * .java的文件名必须与文件中设置为public的class名保持一致（如果没有public的类，那么名称任意) * Every class is part of some _package_. * All classes in a file are part of the same package. * You can specify the package using a _package declaration_: * package
name ; as the first (non-comment) line in the file. * Multiple files can specify the same package name.</description></item><item><title>[c++11 ]std::move 右值引用 转移语义 完美转发 notes</title><link>https://111qqz.com/2018/09/c11-stdmove-notes/</link><pubDate>Sun, 09 Sep 2018 13:01:45 +0000</pubDate><guid>https://111qqz.com/2018/09/c11-stdmove-notes/</guid><description>
起因是在看&amp;lt;CplusplusConcurrencyInAction_PracticalMultithreading&amp;gt;，里面讲到转移一个std::thread的ownership提到了std::move.
之前[C++11 ] std::ref&amp;amp;&amp;amp;std::reference_wrapper notes 提到的情况是在我们想要用引用的时候却进行了拷贝，得到不符合期望的结果。现在的情况是，有些object或许是不支持拷贝构造的。比如std::unique_str,std::ifstream，这个时候如果我们需要传参数进去，就可以使用std::move来实现。比如下面这个例子:
void process_big_object(std::unique_ptr&amp;lt;big_object&amp;gt;); std::unique_ptr&amp;lt;big_object&amp;gt; p(new big_object); p-&amp;gt;prepare_data(42); std::thread t(process_big_object,std::move(p)); 当然这只是使用std::move的一种情形，即传递不允许拷贝构造的object作为参数。
另外，std::move可以更有效率地传递资源。内容之后补orz
实际上std::move()的作用是传进去一个object,返回这个object的右值引用（rvalue reference）
首先区分左值和右值，这其实是一个c语言中就有的概念（作为区分，右值引用是C++11中新引入的概念）
一般来说，右值是不能被取地址的值。在C++11之前，右值是不能被引用的。
语法上为了区分C++11之前的引用（也就是左值引用&amp;amp;）,右值引用的符号为&amp;amp;&amp;amp;
void process_value(int&amp;amp; i) { std::cout &amp;lt;&amp;lt; &amp;quot;LValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } void process_value(int&amp;amp;&amp;amp; i) { std::cout &amp;lt;&amp;lt; &amp;quot;RValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } int main() { int a = 0; process_value(a); process_value(1); } LValue processed: 0 RValue processed: 1 那么为什么要引入“右值引用”这个概念？ 主要有两个目的：完美转发(Perfect Forwarding)和转移语义(Move Sementics)</description></item><item><title>[C++11 ] std::ref&amp;&amp;std::reference_wrapper notes</title><link>https://111qqz.com/2018/09/reference_wrapper-notes/</link><pubDate>Sun, 09 Sep 2018 11:28:53 +0000</pubDate><guid>https://111qqz.com/2018/09/reference_wrapper-notes/</guid><description>
起因是在看《CplusplusConcurrencyInAction_PracticalMultithreading》的时候，里面讲到初始化std::thread的时候，如果thread funtion的参数列表中有引用，需要传入std::ref才可以得到符合预期的结果。
查阅发现std::ref是用来生成std::reference_wrapper。 按照 cppreference 上的话来说
`std::reference_wrapper` 是包装引用于可复制、可赋值对象的类模板。它常用作将容器存储入无法正常保有引用的标准容器（类似 [std::vector](https://zh.cppreference.com/w/cpp/container/vector) ）的机制。 用人话来说，就是有的时候一些地方（比如STL容器中传值，又比如std::bind）会默认使用复制，这可能与我们想使用引用的期望不符。
具体见下面的几个例子：
#include &amp;lt;functional&amp;gt; #include &amp;lt;iostream&amp;gt; void f(int&amp;amp; n1, int&amp;amp; n2, const int&amp;amp; n3) { std::cout &amp;lt;&amp;lt; &amp;quot;In function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; ++n1; // increments the copy of n1 stored in the function object ++n2; // increments the main()'s n2 // ++n3; // compile error } int main() { int n1 = 1, n2 = 2, n3 = 3; std::function&amp;lt;void()&amp;gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &amp;lt;&amp;lt; &amp;quot;Before function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; bound_f(); std::cout &amp;lt;&amp;lt; &amp;quot;After function: &amp;quot; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; n3 &amp;lt;&amp;lt; '\n'; } Before function: 10 11 12 In function: 1 11 12 After function: 10 12 12 我们发现直接传进去的参数n1的值没有改变，而使用std::ref传进去的值的结果符合预期。</description></item><item><title>前端To do list</title><link>https://111qqz.com/2018/09/front-end-to-do-list/</link><pubDate>Thu, 06 Sep 2018 09:56:57 +0000</pubDate><guid>https://111qqz.com/2018/09/front-end-to-do-list/</guid><description>
20181014update: 可以不写了，开心
迫于生计，要从零开始学习前端。
由于之前的to do list 年代久远+ 前端的技术栈可之前几乎没有关系，因此新开一篇记录。
* css盒子模型 * 布局,flex * 前端debug的方法 * &amp;lt;del&amp;gt;javascript,&amp;lt;/del&amp;gt;有空可以使用js刷leetcode练习语法 * &amp;lt;del&amp;gt;typescript&amp;lt;/del&amp;gt; * jsx，以及jsx的typescript版tsx * 学习axios https://alligator.io/react/axios-react/ * 学习dva: https://github.com/sorrycc/blog/issues/62 * 学习umijs https://umijs.org/zh/guide/with-dva.html#</description></item><item><title>typescript学习笔记</title><link>https://111qqz.com/2018/09/typescript-notes/</link><pubDate>Wed, 05 Sep 2018 08:02:42 +0000</pubDate><guid>https://111qqz.com/2018/09/typescript-notes/</guid><description>
先放参考资料:
TypeScript 入门教程
React &amp;amp; Webpack
react-typescript-cheatsheet (强推一波，讲了很多react+ts的实践）
typescript是javascript的语法扩展。。。好处是提供了类型。。可以在编译（结果为js文件)的时候提供静态的类型检查。。。
typescript的问号语法:标记某个参数为可选。
例子:
export class Thread { id: string; lastMessage: Message; name: string; avatarSrc: string; constructor(id?: string, name?: string, avatarSrc?: string) { this.id = id || uuid(); this.name = name; this.avatarSrc = avatarSrc; } } 关于typescript的类型推断。。如果在定义时直接赋值则会进行推断，否则会推断类型为any.
let myFavoriteNumber = 'seven'; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. //上面的写法会编译错误，原因是定义时已经推断类型为string //但是下面的写法没有问题 let myFavoriteNumber; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; let myFavoriteNumber: string | number; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; 这里的 let myFavoriteNumber: string | number 的含义是， 允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</description></item><item><title>[设计模式] 观察者( Observer )模式学习笔记</title><link>https://111qqz.com/2018/09/observer-pattern-notes/</link><pubDate>Sat, 01 Sep 2018 09:27:40 +0000</pubDate><guid>https://111qqz.com/2018/09/observer-pattern-notes/</guid><description>
最近在学习node.js，里面讲到node.js的事件机制使用了观察者模式，因此来学习一下。
观察者模式的目的是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
因此观察者模式又叫发布-订阅模式。
下面放一个简化之后的例子:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Secretary; // 看股票的同事类（观察对象，观察者） class StockObserver { public: StockObserver(string strName, Secretary* strSub) { name = strName; sub = strSub; } void Update(); private: string name; Secretary* sub;我所理解的设计模式（C++实现）——观察者模式（Observer Pattern） }; // 秘书类（主题对象，通知者） class Secretary { public: string action; void Add(StockObserver ob) { observers.push_back(ob); } void Remove(int addIndex) { if(addIndex &amp;gt;=0 &amp;amp;&amp;amp; addIndex &amp;lt; observers.size()) observers.erase(observers.begin() + addIndex); } void Notify() { vector&amp;lt;StockObserver&amp;gt;::iterator it; for (it=observers.</description></item><item><title>Redux 学习笔记</title><link>https://111qqz.com/2018/08/redux-notes/</link><pubDate>Thu, 30 Aug 2018 12:05:35 +0000</pubDate><guid>https://111qqz.com/2018/08/redux-notes/</guid><description>
Redux是Flux架构的一种实现。
至于Flux架构是什么，可以参考Flux 架构入门教程
粗略得讲，和MVC架构是同一类东西，最大的区别是单向数据流，禁止了Model和VIEW层之间数据的流动。</description></item><item><title>JavaScript 学习笔记</title><link>https://111qqz.com/2018/08/javascript-notes/</link><pubDate>Thu, 30 Aug 2018 03:42:19 +0000</pubDate><guid>https://111qqz.com/2018/08/javascript-notes/</guid><description>
暂时没空从头开始搞...用到哪里先记录一下好了orz
我觉得不行，还是要先大致了解一下。
参考资料:
A re-introduction to JavaScript (JS tutorial)
继承与原型链
// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b： // {a: 1, b: 2} // o 的 [[Prototype]] 有属性 b 和 c： // {b: 3, c: 4} // 最后, o.[[Prototype]].[[Prototype]] 是 null. // 这就是原型链的末尾，即 null， // 根据定义，null 没有[[Prototype]]. // 综上，整个原型链如下: // {a:1, b:2} ---&amp;gt; {b:3, c:4} ---&amp;gt; null console.log(o.a); // 1 // a是o的自身属性吗？是的，该属性的值为1 console.log(o.b); // 2 // b是o的自身属性吗？是的，该属性的值为2 // 原型上也有一个'b'属性,但是它不会被访问到.这种情况称为&amp;quot;属性遮蔽 (property shadowing)&amp;quot; console.</description></item><item><title>react学习笔记</title><link>https://111qqz.com/2018/08/react-notes/</link><pubDate>Tue, 28 Aug 2018 10:16:16 +0000</pubDate><guid>https://111qqz.com/2018/08/react-notes/</guid><description>
首先介绍一个fb家的快速开发react的工具 create-react-app
这个东西依赖node6.0或者更高版本。
关于在ubuntu 14.04上安装node ，可以参考这个链接
发现执行nvm install 6.0会没有任何相应...但是实际上已经安装好了。
接下来安装create-react-app
命令是: npm install --global create-react-app
然后创建一个react app
命令为:create-react-app first_react_app
挂着代理大概需要半小时左右。
或者可以使用淘宝npm镜像:
设置方法为：npm config set registry https://registry.npm.taobao.org，设置完成后，重新执行create-react-app first-app
实现的第一个组件，功能是点击按钮增加计数...
import React, { Component } from 'react'; class ClickCounter extends Component{ constructor(props){ super(props); this.onClickButton = this.onClickButton.bind(this); this.state = {count:0}; } onClickButton(){ this.setState({count: this.state.count+1}); } render(){ return( &amp;lt;div&amp;gt; &amp;lt;button onClick={this.onClickButton}&amp;gt;Who am I?&amp;lt;/button&amp;gt; &amp;lt;div&amp;gt; click Count: {this.state.count} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) } } export default ClickCounter; JSX是JS的语法扩展。JSX中使用的元素包含html中的元素和React中的组件。React 判断一个元素是 HTML 元素还是 React 组件的原则就是看第一个字母是否大 写。</description></item><item><title>[设计模式] 组合模式（composite） 学习笔记</title><link>https://111qqz.com/2018/08/Composite-Pattern-notes/</link><pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate><guid>https://111qqz.com/2018/08/Composite-Pattern-notes/</guid><description>
目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个tree 。如果某个节点是叶子节点了，那么对应的tree都为NULL. 只不过这里用了更加面向对象的实现。
具体看代码：
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月28日 星期二 14时21分51秒 File Name :composite.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Component { // 为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为 protected: string name; public: Component(string n) { name = n; } virtual ~Component() {} virtual void Add(Component* c) = 0; virtual void Remove(Component* c) = 0; virtual void Display(int depth) = 0; }; class Leaf : public Component { // 在组合中表示叶节点对象，叶节点没有子节点 public: Leaf(string name) : Component(name) {} void Add(Component* c){} // 叶节点没有Add功能，但这样做能使接口具备一致性，这就是透明方式，如果不加入Add和Remove方法，那就是安全方式。 void Remove(Component* c){} // 同上 void Display(int depth) { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; endl; } }; class Composite : public Component { // 定义有枝节点行为，用来存储子部件 private: list&amp;lt;Component* &amp;gt; children; public: Composite(string name) : Component(name) {} void Add(Component* c) { children.</description></item><item><title>[C++11] promise &amp;&amp; future leanrning notes</title><link>https://111qqz.com/2018/08/promise-future-notes/</link><pubDate>Thu, 23 Aug 2018 02:45:53 +0000</pubDate><guid>https://111qqz.com/2018/08/promise-future-notes/</guid><description>
用人话就是，主线程传给附属线程一个promise Object,然后主线程想要获取附属线程set给promise Object的值（也就是该线程返回的某个结果），需要通过主线程中的promise object 得到对应的future object(每个promise 对应一个 future),然后调用future 的get方法。如果附属线程没有执行作为参数传入的promise的set方法去返回结果，那么程序就会block住。
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月23日 星期四 10时37分07秒 File Name :future_sample.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; #include &amp;lt;future&amp;gt; void initiazer(std::promise&amp;lt;int&amp;gt; * promObj) { //std::cout&amp;lt;&amp;lt;&amp;quot;Inside Thread&amp;quot;&amp;lt;&amp;lt;std::endl; for ( int i = 1 ; i &amp;lt;= 2000000000 ; i++); //promObj-&amp;gt;set_value(35); } int main() { std::promise&amp;lt;int&amp;gt; promiseObj; std::future&amp;lt;int&amp;gt; futureObj = promiseObj.get_future(); std::thread th(initiazer, &amp;amp;promiseObj); std::cout&amp;lt;&amp;lt;futureObj.get()&amp;lt;&amp;lt;std::endl; th.join(); return 0; } 参考资料:</description></item><item><title>把二进制文件按字节读到vector中</title><link>https://111qqz.com/2018/08/how-to-read-binary-data-into-cpp-vector/</link><pubDate>Tue, 21 Aug 2018 06:08:56 +0000</pubDate><guid>https://111qqz.com/2018/08/how-to-read-binary-data-into-cpp-vector/</guid><description>
std::vector&amp;lt;unsigned char&amp;gt; readFromFile1(const char* filePath) { FILE* file = fopen(filePath, &amp;quot;rb&amp;quot;); std::vector&amp;lt;unsigned char&amp;gt; result; if (file == nullptr) { return result; } // 获取文件大小，尽量一次读完 size_t fileSize = getFileSize(file); if (fileSize != 0) { result.resize(fileSize); size_t n = fread(&amp;amp;result[0], 1, fileSize, file); assert(n &amp;lt;= fileSize); if (n != fileSize) { result.resize(n); } } // 在读取过程当中，有可能文件大小有变化，再尝试读取 const size_t read_len = 1024; char buf[read_len]; for (;;) { size_t n = fread(buf, 1, read_len, file); result.</description></item><item><title>boost:property_tree 学习笔记</title><link>https://111qqz.com/2018/08/boost_property_tree-notes/</link><pubDate>Mon, 20 Aug 2018 08:10:16 +0000</pubDate><guid>https://111qqz.com/2018/08/boost_property_tree-notes/</guid><description>
先放资料:
How to use boost::property_tree to load and write JSON
How to iterate a boost property tree?
不出现key的方法遍历一个json文件:
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月17日 星期五 15时29分23秒 File Name :ptree.cpp ************************************************ */ #include &amp;lt;boost/property_tree/ptree.hpp&amp;gt; #include &amp;lt;boost/property_tree/json_parser.hpp&amp;gt; #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; using boost::property_tree::ptree; string indent(int level) { string s; for (int i=0; i&amp;lt;level; i++) s += &amp;quot; &amp;quot;; return s; } void printTree (ptree &amp;amp;pt, int level) { if (pt.</description></item><item><title>记录一次因动态库符号表可见性导致的未定义的引用(undefined reference)</title><link>https://111qqz.com/2018/08/symbol-table-visibility/</link><pubDate>Wed, 15 Aug 2018 13:12:17 +0000</pubDate><guid>https://111qqz.com/2018/08/symbol-table-visibility/</guid><description>
编译某代码，发现报错某函数未定义的引用。该函数的是先前编译得到的动态库中。
先去check了该函数的实现，还有接口与头文件中的声明是否统一。发现没有问题。
然后怀疑.cpp文件没有被编译到，于是在该函数中添加
#pragma message(&amp;quot;******************************8&amp;quot;)
发现的确被编译到了。
使用nm来查看动态库中的符号表，发现也可以找到这个函数的符号。
于是怀疑编译代码的时候没有链接到该动态库。
于是在make的时候打印详细信息。make VERBOSE=1
发现也的确链接了动态库....
见鬼了Orz
然后用readelf -s 来查看动态库，惊讶得发现要找的那个符号的BIND怎么是LOCAL..也就是只有文件内可见。
最后发现...是公司内部的工具和CMakeLists中的add_library冲突...
虽然这个坑的解决方案没什么价值...不过因为这个坑了解了一些之前没有了解的部分，也算值得。
关于动态库的符号可见性：
控制的原因是，如果不控制，那么不同的cpp文件可能有相同的变量名字，如果把所有的符号都暴露，很可能在链接时产生冲突。 另外一个原因是，暴露没有必要的符号，会导致符号表的size变大，从而使得link时速度变慢。
参考资料:
Introduction to symbol visibility
readelf elf文件格式分析
Hiding what's exposed in a shared library
Why is the new C++ visibility support so useful?</description></item><item><title>使用python计算误差代码</title><link>https://111qqz.com/2018/08/calculate-error-with-python/</link><pubDate>Mon, 06 Aug 2018 11:54:35 +0000</pubDate><guid>https://111qqz.com/2018/08/calculate-error-with-python/</guid><description>
import os import math ave_err=0.0 max_err=0.0 max_err_rate=0.0 length=0 with open(&amp;quot;cpu_result.txt&amp;quot;,&amp;quot;r&amp;quot;) as fp1, open(&amp;quot;cuda_ppl_result.txt&amp;quot;,&amp;quot;r&amp;quot;) as fp2: for l1 in fp1: l2 = fp2.readline() l1=l1[:-2] l2=l2[:-2] lst = l1.split(' ') lst2 = l2.split(' ') #print lst lst = [float(x) for x in lst ] length = length + len(lst) lst2 = [float(x) for x in lst2] #print (lst) #print (lst2)
for index,x in enumerate(lst): y = lst2[index] ave_err = ave_err + abs(x-y) max_err = max(max_err,abs(x-y)) max_err_rate = max(max_err_rate,abs(x-y)/x) print(&amp;quot;len=&amp;quot;,length) print(&amp;quot;max_err=&amp;quot;,max_err) print(&amp;quot;max_err_rate=&amp;quot;,max_err_rate*100,&amp;quot;%&amp;quot;) print(&amp;quot;ave_err=&amp;quot;,ave_err/length) 需要提供两个文件，并且两个文件的数据格式相同。</description></item><item><title>c++11 function 与bind 学习笔记</title><link>https://111qqz.com/2018/07/cpp11-function-bind-notes/</link><pubDate>Thu, 19 Jul 2018 10:46:26 +0000</pubDate><guid>https://111qqz.com/2018/07/cpp11-function-bind-notes/</guid><description>
C++11 std::function 是一种通用、多态的函数封装,它的实例可以对任何可 以调用的目标实体进行存储、复制和调用操作
见下面的例子
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月19日 星期四 17时41分00秒 File Name :bind.cpp ************************************************ */ #include &amp;lt;functional&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; float foo( int x,int y,int z){return x+y+z+1.;} int main() { function&amp;lt;int(int,int)&amp;gt;func = foo; int y = 10; function&amp;lt;int(int)&amp;gt;fun = [&amp;amp;]( int value)-&amp;gt;int { return 1+value+y; }; cout&amp;lt;&amp;lt;func(15,4,9)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;fun(8)&amp;lt;&amp;lt;endl; return 0; } std::bind 则是用来绑定函数调用的参数的,它解决的需求是我们有时候可 能并不一定能够一次性获得调用某个函数的全部参数,通过这个函数,我们可以将 部分调用参数提前绑定到函数身上成为一个新的对象,然后在参数齐全后,完成调 用
看下面的例子:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;functional&amp;gt; using namespace std; int FUN( int x,int y,int z) { return x+y+z; } int main() { using namespace std::placeholders; //int (*fp)(int ,int,int) = FUN; auto bindfoo = bind(FUN,_1,1,2); int ans = bindfoo(0); cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl; return 0; }</description></item><item><title>intel tbb 学习笔记</title><link>https://111qqz.com/2018/07/intel-tbb-notes/</link><pubDate>Wed, 18 Jul 2018 06:57:38 +0000</pubDate><guid>https://111qqz.com/2018/07/intel-tbb-notes/</guid><description>
tbb是**Threading Building Blocks library的缩写,**是一个为开发者提供并行解决方案的库.
先放个文档https://www.threadingbuildingblocks.org/intel-tbb-tutorial
再放一个代码示例:
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月18日 星期三 14时20分54秒 File Name :parallel_for.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;quot;tbb/tbb.h&amp;quot; #include &amp;lt;chrono&amp;gt; using namespace std; using namespace tbb; const int N=1E9+7; float a[N+5]; void Foo(float &amp;amp;x) { x -= 100; } void SerialApplyFoo( float a[], size_t n ) { for( size_t i=0; i!=n; ++i ) Foo(a[i]); } class ApplyFoo { float *const my_a; public: void operator()(const blocked_range&amp;lt;size_t&amp;gt; &amp;amp;r) const { float *a = my_a; for (size_t i = r.</description></item><item><title>C++ 记录代码运行时间</title><link>https://111qqz.com/2018/07/Record-code-run-time-with-cpp/</link><pubDate>Tue, 10 Jul 2018 02:26:50 +0000</pubDate><guid>https://111qqz.com/2018/07/Record-code-run-time-with-cpp/</guid><description>
以前用的办法太老土啦
看到一个since C++11的方法，我觉得比较优雅
#include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; //#include &amp;lt;ratio&amp;gt; #include &amp;lt;thread&amp;gt; void f() { std::this_thread::sleep_for(std::chrono::seconds(1)); } int main() { auto t1 = std::chrono::high_resolution_clock::now(); f(); auto t2 = std::chrono::high_resolution_clock::now(); // floating-point duration: no duration_cast needed std::chrono::duration&amp;lt;double, std::milli&amp;gt; fp_ms = t2 - t1; // integral duration: requires duration_cast auto int_ms = std::chrono::duration_cast&amp;lt;std::chrono::milliseconds&amp;gt;(t2 - t1); // converting integral duration to integral duration of shorter divisible time unit: // no duration_cast needed std::chrono::duration&amp;lt;long, std::micro&amp;gt; int_usec = int_ms; std::cout &amp;lt;&amp;lt; &amp;quot;f() took &amp;quot; &amp;lt;&amp;lt; fp_ms.</description></item><item><title>gdb学习笔记</title><link>https://111qqz.com/2018/07/gdb-notes/</link><pubDate>Fri, 06 Jul 2018 07:44:38 +0000</pubDate><guid>https://111qqz.com/2018/07/gdb-notes/</guid><description>
用gdb调试c++的时候，需要添加-g编译选项add_compile_options(-g)，并且关掉各种编译优化
如果是多线程程序，可以用info threads 查看每个线程的信息
然后用thread [id] 查看指定线程，并用bt查看调用栈。
gdb调试的时候，可以用ctrl+c 停住程序，来查看调用栈，然后按c(continue)继续程序的运行。
emmm
先放一些相关的。
Linux 下如何产生core文件（core dump设置）
ulimit -a 查看限制
ulimit -c unlimited 表示这只为不限制core文件大小
用gdb的调试命令如下:
gdb ./test core.2065</description></item><item><title>Kafka 学习笔记</title><link>https://111qqz.com/2018/07/kafka-notes/</link><pubDate>Mon, 02 Jul 2018 08:56:52 +0000</pubDate><guid>https://111qqz.com/2018/07/kafka-notes/</guid><description>
先放资料．
kafka简明教程</description></item><item><title>linux 下C++ 连接mysql 数据库</title><link>https://111qqz.com/2018/07/connect-mysql-with-cpp-under-linux/</link><pubDate>Mon, 02 Jul 2018 07:02:28 +0000</pubDate><guid>https://111qqz.com/2018/07/connect-mysql-with-cpp-under-linux/</guid><description>
资料推荐这个:MySQL C API programming tutorial
环境为ubuntu 14.04 lts
需要安装mysql 和mysql 开发包
sudo apt-get install libmysqlclient15-dev mysql-server mysql-client
先在mysql 中建立test数据库和test表格
　mysql&amp;gt;create database test; mysql&amp;gt;use test; //切换到test数据库中 mysql&amp;gt; create table test(name varchar(255),num int(10) ); //创建一个叫test的表 mysql&amp;gt;show create table test; //显示刚才创建的表信息 mysql&amp;gt; select * from test; //查询test表中数据 mysql&amp;gt;quit 然后用如下cpp代码连接
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;mysql.h&amp;gt; #include &amp;lt;cstring&amp;gt; int main(int argc,char *argv[]) { MYSQL conn; int res; mysql_init(&amp;amp;conn); if (mysql_real_connect(&amp;amp;conn,&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;2254965&amp;quot;,&amp;quot;test&amp;quot;,0,NULL,CLIENT_FOUND_ROWS)) { puts(&amp;quot;connect success&amp;quot;); res = mysql_query(&amp;amp;conn,&amp;quot;insert into test values('sensetime','23333')&amp;quot;); if (res) puts(&amp;quot;error&amp;quot;); else puts(&amp;quot;success&amp;quot;); printf(&amp;quot;res=%d\n&amp;quot;,res); } return 0; } 编译:</description></item><item><title>使用haproxy中转酸酸流量</title><link>https://111qqz.com/2018/05/shadowsocks-with-haproxy/</link><pubDate>Tue, 15 May 2018 06:27:35 +0000</pubDate><guid>https://111qqz.com/2018/05/shadowsocks-with-haproxy/</guid><description>
一个国内vps，一个国外vps.
前提是国外vps已经配置好。
接下来，我们在国内vps上安装haproxy
yum -y install haproxy 或者 apt-get install haproxy
然后修改配置文件,位置在/etc/haproxy/haproxy.cfg
global defaults log global mode tcp option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend ss-in bind *:[port] default_backend ss-out backend ss-out server server1 [ip]:[port] maxconn 20480 把其中的[ip]和[port]替换成国外vps的ip和相应服务的port
然后在客户端，ip填写国内vps的ip,密码还是酸酸的密码，其他保持一致。</description></item><item><title>wordpress 开启全站https</title><link>https://111qqz.com/2018/05/enable-https-for-wordpress/</link><pubDate>Mon, 14 May 2018 13:08:30 +0000</pubDate><guid>https://111qqz.com/2018/05/enable-https-for-wordpress/</guid><description>
20190511更新:
证书到期了,写一下更换证书的流程.
重新申请好证书之后,直接把Apache里面对应的123放到/data/cert文件夹.
其中1对应server-ca.crt,2对应server.crt,3对应server.key
由于从套路云转移到良心云，迫于国内某些蛋疼的政策，以及一些其他原因，决定全站上https.
首先是申请SSL证书，这个良心云就可以申请，也有其他地方。
这里要注意的是，有些证书是只能对应一个域名，腾讯云貌似就是这样，不过好像www.111qqz.com的证书也可以用于111qqz.com
得到证书中有Apache,Nginx,Tomcat和IIS四个文件夹，由于我们使用的是Apache，所以其他三个不用管。
1. 将证书上传到服务器证书目录：/data/cert（没有cert目录可以自己新建） 2. 在/etc/httpd/conf.d目录下新建一个https配置文件，假设命名为mydomain-ssl.conf。 3. 拷贝下面的https配置文件模板到mydomain-ssl.conf文件中，并保存 &amp;lt;VirtualHost *:443&amp;gt; ServerName www.111qqz.com ServerAlias 111qqz.com DocumentRoot &amp;quot;/data/wwwroot/default/wordpress&amp;quot; #ErrorLog &amp;quot;logs/www.mydomain.com-error_log&amp;quot; #CustomLog &amp;quot;logs/www.mydomain.com-access_log&amp;quot; common &amp;lt;Directory &amp;quot;/data/wwwroot/default/wordpress&amp;quot;&amp;gt; Options Indexes FollowSymlinks AllowOverride All Require all granted &amp;lt;/Directory&amp;gt; SSLEngine on SSLCertificateFile /data/cert/server.crt SSLCertificateKeyFile /data/cert/server.key SSLCertificateChainFile /data/cert/server-ca.crt &amp;lt;/VirtualHost&amp;gt; 需要注意的是，servername那里要写带www的域名，不带www的写在serveralias 4. 修改配置文件中相关项，并保存 ServerName #主域名，务必修改 ServerAlias #副域名，可选项 DocumentRoot #网站路径，务必填写网站实际路径，例如:/data/wwwroot/default/wordpress Directory #同上 SSLCertificateFile #证书，务必填写网站实际路径 SSLCertificateKeyFile #证书私钥，务必填写网站实际路径 SSLCertificateChainFile #证书链（CA文件），务必填写网站实际路径
然后由于我是迁移了服务器，很大可能是主页可以访问，但任何一个其他页面都会因报错500 internal error 之类，查看日志，位置在/var/log/httpd 里面，发现报错AH00124: Request exceeded the limit of 10 internal redirects due to probable configuration error.</description></item><item><title>C++ STL Algotithms 学习笔记</title><link>https://111qqz.com/2018/05/c-stl-algotithms-notes/</link><pubDate>Sun, 06 May 2018 09:45:50 +0000</pubDate><guid>https://111qqz.com/2018/05/c-stl-algotithms-notes/</guid><description>
迫于拙劣的cpp水平，这次来记录一些关于STL算法部分的内容。
参考内容是CS106L的course reader
Iterator Categories Iterators分为以下五种:
* Output Iterators:可以使用&amp;quot;++&amp;quot;；可以用*myItr = value,不能用value = *myItr * Input Iterators:可以使用&amp;quot;++&amp;quot;;可以用value = *myItr，不能用*myItr = value * Forward Iterators: 可以使用&amp;quot;++&amp;quot;,可以同时用value = *myItr和*myItr = value * Bidirectional Iterators:比起Forward Iterator 对了&amp;quot;--&amp;quot;,但是不能+或者+= * Random-Access Iterators：比起Bidirectional Iterators多了+和+= Algorithm Naming Conventions 一些关于STL Algorithm的命名规则
后缀_if表示只有当满足一定条件的时候该算法才会执行一定任务。
比如:
bool IsEven(int value) { return value % 2 == 0; } cout &amp;lt;&amp;lt; count_if(myVec.begin(), myVec.end(), IsEven) &amp;lt;&amp;lt; endl; _n表示执行一个特定的操作n次。
比如:
fill_n(myDeque.begin(), 10, 0); Reordering Algorithms * sort: 传入的必须是Random-Access Iterators，记得定义&amp;lt;函数 * random_shuffle:传入的必须是Random-Access Iterators,作用是将一个区间内的元素打乱重排。 可以在使用之前先使用srand函数。 * rotate：作用是循环改变容器中元素的顺序。rotate(v.</description></item><item><title>C++ IO Streams 学习笔记</title><link>https://111qqz.com/2018/05/cpp-io-streams-notes/</link><pubDate>Fri, 04 May 2018 03:48:37 +0000</pubDate><guid>https://111qqz.com/2018/05/cpp-io-streams-notes/</guid><description>
迫于拙劣的cpp水平，来补补以前忽略掉的cpp细节。
老规矩，先放资料。
参考资料:
A Gentle Introduction to C++ IO Streams
"Designing and implementing a general input/output facility for a programming language is notoriously difficult" - Bjarne Stroustrup Stream的基本认识 说说我的理解。stream(流)可以看做输入输出的抽象。我们通过流可以忽略掉device的细节，采取同样的输入输出方式。
对于任何原生的cpp类型，都可以用stream来处理。用户自定义的类，也可以通过重载&amp;lt;&amp;lt;和&amp;gt;&amp;gt;而让stream可以处理。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; // timestamp returns the current time as a string std::string timestamp(); class LogStatement; ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; ost, const LogStatement&amp;amp; ls); class LogStatement { public: LogStatement(std::string s): data(s), time_string( timestamp() ) { }; //This method handles all the outputs.</description></item><item><title>vim 插件 NERDTree 学习笔记</title><link>https://111qqz.com/2018/04/vim-NERDTree-plugin/</link><pubDate>Mon, 30 Apr 2018 05:54:33 +0000</pubDate><guid>https://111qqz.com/2018/04/vim-NERDTree-plugin/</guid><description>
迫于要在服务器上写cpp代码，又由于各种原因，没办法把同步到本地。因此要在服务器上配置一个cpp的环境orz.
我是用vim-plug来管理插件的，只需要添加
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } 就好了。 下面记录一些会用到的快捷键:
ctrl+w类似tmux里面的功能键。
crtl+w+w: 光标自动在左右侧窗口切换
cril+w+r:调换左右侧窗口的布局位置
t 在新 Tab 中打开选中文件/书签，并跳到新 Tab T 在新 Tab 中打开选中文件/书签，但不跳到新 Tab gT 前一个 tab gt 后一个 tab</description></item><item><title>gRPC学习笔记</title><link>https://111qqz.com/2018/04/grpc-notes/</link><pubDate>Sun, 29 Apr 2018 16:18:47 +0000</pubDate><guid>https://111qqz.com/2018/04/grpc-notes/</guid><description>
gRPC 是 google 最新发布的开源 RPC 框架, 声称是&amp;quot;一个高性能，开源，将移动和HTTP/2放在首位的通用的RPC框架.&amp;quot;. 技术栈非常的新, 基于HTTP/2, netty4.1, proto3, 拥有非常丰富而实用的特性, 堪称新一代RPC框架的典范.
//上面这段话是我抄的，其实我之前连RPC是什么都不知道，
关于RPC，如果你和我一样根本不知道是什么，请参考这里 
我对RPC的理解就是，一层封装，使得不在同一个机器上的程序A可以一个调用另一个程序B，而不需要考虑这两台机器，以及这两个程序使用的语言的不同。
而gRPC是诸多RPC框架中比较新，也比较好用的一个。
学习gRPC需要会使用protobuf3,关于protobuf，可以参考protobuf学习笔记
官方文档 还是要给出的，虽然我没怎么看就是了orz
gRPC的安装 参考这个，从源码编译安装
$ [sudo] apt-get install build-essential autoconf libtool pkg-config $ [sudo] apt-get install libgflags-dev libgtest-dev $ [sudo] apt-get install clang libc++-dev $ git clone -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc $ cd grpc $ git submodule update --init $ make $ [sudo] make install 如果出现
configure: error: cannot find install-sh, install.</description></item><item><title>8102年了，来更新一波vim配置</title><link>https://111qqz.com/2018/04/vim-config-in-2018/</link><pubDate>Wed, 25 Apr 2018 16:46:51 +0000</pubDate><guid>https://111qqz.com/2018/04/vim-config-in-2018/</guid><description>
现在用的vim配置还是2015年7月的时候写的。
三年过去了，vim到了8.0,很多功能也有了更多选择。因此打算来更新一波vim配置。目前还在更新过程中。。。等差不多折腾完再来记录一些信息。
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; for vim &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; set ru set nu set clipboard+=unnamed &amp;quot; 映射全选+复制 ctrl+a map &amp;lt;C-A&amp;gt; ggvG&amp;quot;+Y &amp;quot;去空行 nnoremap &amp;lt;F2&amp;gt; :g/^\s*$/d&amp;lt;CR&amp;gt; &amp;quot; 自动缩进 set autoindent set tabstop=4 set softtabstop=4 set shiftwidth=4 filetype on &amp;quot; 载入文件类型插件 filetype plugin on &amp;quot; 为特定文件类型载入相关缩进文件 filetype indent on &amp;quot; 高亮显示匹配的括号 set showmatch &amp;quot; 高亮当前行 set cursorline hi CursorLine cterm=bold ctermbg=blue ctermfg=yellow &amp;quot;C，C++ 按F5编译运行 map &amp;lt;F5&amp;gt; :call CompileRunGcc()&amp;lt;CR&amp;gt; func! CompileRunGcc() exec &amp;quot;w&amp;quot; if &amp;amp;filetype == 'c' exec &amp;quot;!</description></item><item><title>protobuf学习笔记</title><link>https://111qqz.com/2018/04/protobuf-notes/</link><pubDate>Tue, 24 Apr 2018 03:05:09 +0000</pubDate><guid>https://111qqz.com/2018/04/protobuf-notes/</guid><description>
Protobuff 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。
之前由于要用levelDB存feature,而levelDB的key只能是string(?,反正不能是一个数组)， 使用了protobuf. protobuf本身还比较easy,不过目前似乎protobuf2仍然是主流，但是由于最近在看gRPC的缘故，要使用protobuf3.　如果protobuf2没有卸载干净，绝对欲仙欲死...记录一些坑．详细一点的笔记之后补．
// protobuf3坑好多啊...语法全靠猜，也是有毒 
行吧，怪我没找到orz,生成的cpp语法部分在 这里。
先放参考资料好了。一开始找到一个pdf文档，说是官方文档的翻译版...但实际上感觉，讲得很烂。直接看官方文档比较好。
其中Language Guide (proto3) 讲了protobuf3的proto文件的语法相关。
Protocol Buffer Basics: C++ 讲了怎么从编写proto文件到在cpp中使用的一般步骤（注意此处貌似是按照protobuf2讲的）
C++ Generated Code 讲了生成的cpp代码的接口，并且强调了protobuf2和protobuf3的区别。
syntax = &amp;quot;proto3&amp;quot;; package test; message Feature { int32 ver = 1; int32 idx = 2; int32 len = 3; repeated float feat = 4; } 生成相应代码的语法为: protoc --cpp_out=. test.proto
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;quot;test.pb.h&amp;quot; using namespace std; using namespace test; int main() { float arr[10]={4,5,6,7,8,9}; Feature feature; puts(&amp;quot;def feature&amp;quot;); float ft; for ( int i = 0 ; i &amp;lt; 4 ; i++) { feature.</description></item><item><title>levelDB 使用笔记</title><link>https://111qqz.com/2018/04/leveldb-notes/</link><pubDate>Thu, 19 Apr 2018 15:58:40 +0000</pubDate><guid>https://111qqz.com/2018/04/leveldb-notes/</guid><description>
2022-02-26 update:
说学习笔记听起来像在分析代码。。。但是实际上什么都没干，还是写&amp;quot;使用笔记&amp;quot;好了
大三的时候看过一点levelDB的源码，不过没有怎么用过。
最近有个需求是存人脸的feature到硬盘，似乎使用levelDB比较合适，因此来学习一下使用。
先放参考资料。
关于levelDB的语法，看这里就好了。
以及由于caffe中使用了levelDB，因此也可以参考下caffe源码。不过caffe中对levelDB的使用是又封装了一层。
具体可以参考：
#ifdef USE_LEVELDB #ifndef CAFFE_UTIL_DB_LEVELDB_HPP #define CAFFE_UTIL_DB_LEVELDB_HPP #include &amp;lt;string&amp;gt; #include &amp;quot;leveldb/db.h&amp;quot; #include &amp;quot;leveldb/write_batch.h&amp;quot; #include &amp;quot;caffe/util/db.hpp&amp;quot; namespace caffe { namespace db { class LevelDBCursor : public Cursor { public: explicit LevelDBCursor(leveldb::Iterator* iter) : iter_(iter) { SeekToFirst(); CHECK(iter_-&amp;gt;status().ok()) &amp;lt;&amp;lt; iter_-&amp;gt;status().ToString(); } ~LevelDBCursor() { delete iter_; } virtual void SeekToFirst() { iter_-&amp;gt;SeekToFirst(); } virtual void Next() { iter_-&amp;gt;Next(); } virtual string key() { return iter_-&amp;gt;key().ToString(); } virtual string value() { return iter_-&amp;gt;value().</description></item><item><title>Eigen: C++开源矩阵学习笔记</title><link>https://111qqz.com/2018/04/eigen-notes/</link><pubDate>Thu, 05 Apr 2018 07:14:54 +0000</pubDate><guid>https://111qqz.com/2018/04/eigen-notes/</guid><description>
接触Eigen的原因是最近在看caffe/caffe2源码,caffe2中使用了Eigen库. Eigen 是一个基于C++模板的线性代数库，直接将库下载后放在项目目录下，然后包含头文件就能使用，非常方便。对于Linux用户,只需要把头文件放到/usr/include 下即可此外，Eigen的接口清晰，稳定高效。
之后会更新一些,Eigen中我使用过的函数.
ubuntu14.04LTS 下使用方式: sudo apt-get install libeigen3-dev cd /usr/include/eigen3 sudo cp -R Eigen /usr/include 然后尝试运行如下代码,直接编译即可.如果可以正常运行,表明安装完毕.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;Eigen/Dense&amp;gt; //using Eigen::MatrixXd; using namespace Eigen; using namespace Eigen::internal; using namespace Eigen::Architecture; using namespace std; int main() { cout&amp;lt;&amp;lt;&amp;quot;*******************1D-object****************&amp;quot;&amp;lt;&amp;lt;endl; Vector4d v1; v1&amp;lt;&amp;lt; 1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v1=\n&amp;quot;&amp;lt;&amp;lt;v1&amp;lt;&amp;lt;endl; VectorXd v2(3); v2&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v2=\n&amp;quot;&amp;lt;&amp;lt;v2&amp;lt;&amp;lt;endl; Array4i v3; v3&amp;lt;&amp;lt;1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v3=\n&amp;quot;&amp;lt;&amp;lt;v3&amp;lt;&amp;lt;endl; ArrayXf v4(3); v4&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v4=\n&amp;quot;&amp;lt;&amp;lt;v4&amp;lt;&amp;lt;endl; } map的使用办法: double arr[9]={1,2,3,4,5,6,7,8,9}; Map A(arr,3,3); 得到 1 4 7 2 5 8 3 6 9</description></item><item><title>linux/win双系统 更新win后 grub 出现 Error: unknown filesystem 的解决办法</title><link>https://111qqz.com/2018/04/the-way-to-fix-unkown-filesystem-error-in-grub/</link><pubDate>Sun, 01 Apr 2018 06:28:30 +0000</pubDate><guid>https://111qqz.com/2018/04/the-way-to-fix-unkown-filesystem-error-in-grub/</guid><description>
windows自己更新把grub更新挂了....
更新的时候要重启几次,重启一次挂一次...
讲真,windows(或者说win10?) 是我见过的最辣鸡的OS了... 自己把自己弄挂这事不是一两次了.
下面说修复办法:
先ls,得到一堆诸如(hd0,gpt7) 这种
然后选设X=第一个(x,y)形式的输出
之后
&amp;lt;code&amp;gt;set root=X set prefix=X/boot/grub insmod normal normal &amp;lt;/code&amp;gt; 然后记得要进入linux分区..... 执行: sudo update-grub sudo grub-install /dev/sda
总结:珍爱生命,远离辣鸡windows!!!!! 珍爱生命,远离辣鸡windows!!!!! 珍爱生命,远离辣鸡windows!!!!!</description></item><item><title>cmake 学习笔记</title><link>https://111qqz.com/2018/03/cmake-notes/</link><pubDate>Sun, 18 Mar 2018 10:27:26 +0000</pubDate><guid>https://111qqz.com/2018/03/cmake-notes/</guid><description>
前置技能点：
gnu make
linux下.so,.a,.o文件
cmake是一个工具，也可以看成一门语言。
学习cmake最大的障碍在于看不懂全是大写的英文
学习cmake主要参考了《cmake practice》
不过感觉作者有些啰嗦...不重要的东西讲了半天，重要的东西却一带而过。。。表述得也不是特别流畅。。。但是还是感谢作者的分享吧orz...
cmake的定位是大型项目构建工具。
目前适用于C/C++/JAVA的项目。
可以不需要自己写makefile文件。
既然cmake可以看做一门语言，那么自然就有语法。
下面只是列举一些常用的。不常用的可以用到的时候再去查。这里也会不定期补充。
cmake的语法中，对于变量大小写敏感，对于cmake的关键字大小写不敏感，不过习惯于全部大写。
cmake有两种编译方式，一种叫in source 编译（就是直接在工程目录编译）
一种叫out of source 编译，就是在工程目录下新建build,然后在build文件夹里编译。
一般都采用out of source的方式编译，这样可以使得编译得到的结果都存放在build文件夹里，不会和源代码混在一起。
set 命令用来定义变量：
SET(HELLO_SRC main.SOURCE_PATHc)
然后就可以用${HELLO_SRC}　来引用这个变量了（例外：在if语句中，是直接使用变量名引用，而不需要${}）
ADD_EXECUTABLE来定义生成的可执行文件的名字：
ADD_EXECUTABLE(hello SRC_LIST)
表示源文件是SRC_LIST 中定义的源文件列表，生成一个文件名为hello的可执行文件。
如果有多个参数，可以写成：
ADD_EXECUTABLE(hello main.c func.c)或者 ADD_EXECUTABLE(hello main.c;func.c)
ADD_SUBDIRECTORY指令：
ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制存 放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除,比如,工程 的 example,可能就需要工程构建完成后,再进入 example 目录单独进行构建(当然,你 也可以通过定义依赖来解决此类问题)。
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})：生成动态(共享)库
语法为：ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)
常用到的是SHARED动态库，STATIC静态库
SET_TARGET_PROPERTIES：可以修改生成的库的名字
SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &amp;quot;hello&amp;quot;)</description></item><item><title>mysql 出现　innoDB: Cannot allocate memory for the buffer pool　的解决办法</title><link>https://111qqz.com/2018/03/the-way-to-fix-mysql-innodb-cannot-allocate-memory/</link><pubDate>Thu, 15 Mar 2018 04:56:58 +0000</pubDate><guid>https://111qqz.com/2018/03/the-way-to-fix-mysql-innodb-cannot-allocate-memory/</guid><description>
emmm,博客的数据库又挂了。
看了下log，发现innoDB: Cannot allocate memory for the buffer pool　的error
查了下，貌似是内存不够了？　orz
用free 命令看了下，阿里云ecs貌似是默认没有swap分区的。
于是参考云服务器 ECS Linux SWAP 配置概要说明 
设置了swap分区。看下还会不会挂orz</description></item><item><title>推荐系统之 LFM (Latent Factor Model) 隐因子模型 学习笔记</title><link>https://111qqz.com/2018/02/Latent-Factor-Model-notes/</link><pubDate>Fri, 09 Feb 2018 13:02:06 +0000</pubDate><guid>https://111qqz.com/2018/02/Latent-Factor-Model-notes/</guid><description>
起因是被assgin了一个新的任务.....要死.
参考资料:
推荐系统学习笔记之三 LFM (Latent Factor Model) 隐因子模型 + SVD (singular value decomposition) 奇异值分解
基于矩阵分解的隐因子模型
实时推荐系统的三种方式
先说下我的理解...
隐因子模型(LFM)是一种推荐算法,&amp;quot;隐&amp;quot;可以理解成用户喜欢某个item的间接原因.
该算法的核心思想是转化成一个矩阵分解问题..
然后用传统机器学习算法去优化分解得到的矩阵...
主要的优势如下： * 比较容易编程实现，随机梯度下降方法依次迭代即可训练出模型。 * 预测的精度比较高，预测准确率要高于基于领域的协同过滤以及基于内容CBR等方法。 * 比较低的时间和空间复杂度，高维矩阵映射为两个低维矩阵节省了存储空间，训练过程比较费时，但是可以离线完成；评分预测一般在线计算，直接使用离线训练得到的参数，可以实时推荐。 * 非常好的扩展性，如由SVD拓展而来的SVD++和 TIME SVD++。 矩阵分解的不足主要有：
* 训练模型较为费时。 * 推荐结果不具有很好的可解释性，无法用现实概念给分解出来的用户和物品矩阵的每个维度命名，只能理解为潜在语义空间。 我们用user1,2,3表示用户，item 1,2,3表示物品，Rij表示用户i对于物品j的评分，也就是喜好度。那么我们需要得到一个关于用户-物品的二维矩阵，如下面的R。
常见的系统中，R是一个非常稀疏的矩阵，因为我们不可能得到所有用户对于所有物品的评分。于是利用稀疏的R，填充得到一个满矩阵R’就是我们的目的。
下面我们就来看看LFM是如何解决上面的问题的？对于一个给定的用户行为数据集（数据集包含的是所有的user, 所有的item，以及每个user有过行为的item列表），使用LFM对其建模后，我们可以得到如下图所示的模型：（假设数据集中有3个user, 4个item, LFM建模的分类数为4）
 R矩阵是user-item矩阵，矩阵值Rij表示的是user i 对item j的兴趣度，这正是我们要求的值。对于一个user来说，当计算出他对所有item的兴趣度后，就可以进行排序并作出推荐。LFM算法从数据集中抽取出若干主题，作为user和item之间连接的桥梁，将R矩阵表示为P矩阵和Q矩阵相乘。其中P矩阵是user-class矩阵，矩阵值Pij表示的是user i对class j的兴趣度；Q矩阵式class-item矩阵，矩阵值Qij表示的是item j在class i中的权重，权重越高越能作为该类的代表。所以LFM根据如下公式来计算用户U对物品I的兴趣度
我们发现使用LFM后，
1. 我们不需要关心分类的角度，结果都是基于用户行为统计自动聚类的，全凭数据自己说了算。 2. 不需要关心分类粒度的问题，通过设置LFM的最终分类数就可控制粒度，分类数越大，粒度约细。 3. 对于一个item，并不是明确的划分到某一类，而是计算其属于每一类的概率，是一种标准的软分类。 4.</description></item><item><title>20171214</title><link>https://111qqz.com/2017/12/20171214/</link><pubDate>Thu, 14 Dec 2017 12:31:33 +0000</pubDate><guid>https://111qqz.com/2017/12/20171214/</guid><description>
记得之前被人在群里刷“宽神是我们的红太阳”还不理解...
为什么我这种菜鸡要被如此对待
现在想想，大概是觉得，“111qqz那么菜的人都还一直坚持打竞赛，我为什么放弃呢”2333
hust有2年没icpc的金了，今年N队终于拿了一个很好名次的金，还是很开心。
其实一直都有一种奇怪的自责，因为自己作为壮年选手的时候，恰好是华科实力最弱的几年，总觉得是没有担当起应有的责任。 为什么是奇怪的自责...因为我的实力并不能决定华科的upper bound 。。。
现在有了训练场地，有了各方面的支持，17级还有个很厉害的学弟，希望明年或者后年能进final吧，期待
其实我科是传统弱校，就算进过final，但是感觉更多取决于选手的意志，而和学校关系不大。
希望我科能成为一个三线强校吧orz，不过还是有点难，因为华科好玩的团队实在太多了...
以及突然开始了毕设... 据说我司或者是其他这样的公司的配置都是几个Phd+一票能打的实习生发论文...
想想自己，好像并不很能打啊？不过还有点时间，虽然也不多了。
希望自己能成为一个“能打的实习生”吧orz</description></item><item><title>unicode 汉字表示不唯一的问题 (cjk字符集)</title><link>https://111qqz.com/2017/12/unicode-char-not-unique/</link><pubDate>Tue, 05 Dec 2017 02:44:46 +0000</pubDate><guid>https://111qqz.com/2017/12/unicode-char-not-unique/</guid><description>
update:
遇到的汉字：
丹：63838
李：63969
昨天写的正则发现死活识别不了 &amp;quot;年&amp;quot;字...
放到unicode编码转化公式 查了下发现竟然是不同的字orz..
其实猜想到也许是日文的&amp;quot;年&amp;quot;...结果查询了下发现是韩文的锅?
具体参考为何Unicode中有字形完全相同的CJK字符？
以及兼容汉字的参考表:UF900</description></item><item><title>正则匹配中文及常用正则表达式 (转载)</title><link>https://111qqz.com/2017/12/Common-regular-expression/</link><pubDate>Mon, 04 Dec 2017 11:34:06 +0000</pubDate><guid>https://111qqz.com/2017/12/Common-regular-expression/</guid><description>
先放一个同事安利给我的网站:regex101
查询匹配的中文字符unicode编码
正则表达式用于字符串处理、表单验证、日志数据分析等场合，实用高效。现将自己走网上搜索并总结的常用方法收集了一下：
匹配中文字符的正则表达式： [\u4e00-\u9fa5] 注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^\x00-\xff] 注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：\n\s*\r 注：可以用来删除空白行
匹配HTML标记的正则表达式：&amp;lt;(\S_?)[^&amp;gt;]&amp;gt;.?&amp;lt;/&amp;gt;|&amp;lt;._? /&amp;gt; 注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^\s_|\s_$ 注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)* 注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^\s]* 注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]$ 注：表单验证时很实用
匹配国内电话号码：\d-\d|\d-\d 注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9] 注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]\d(?!\d) 注：中国邮政编码为6位数字
匹配身份证：\d|\d 注：中国的身份证为15位或18位
匹配ip地址：\d+.\d+.\d+.\d+ 注：提取ip地址时有用
匹配特定数字： ^[1-9]\d_$　//匹配正整数 ^-[1-9]\d_$ //匹配负整数 ^-?[1-9]\d_$　//匹配整数 ^[1-9]\d_|0$　//匹配非负整数（正整数 + 0） ^-[1-9]\d_|0$　//匹配非正整数（负整数 + 0） ^[1-9]\d_.\d_|0.\d_[1-9]\d_$　//匹配正浮点数 ^-([1-9]\d_.\d_|0.\d_[1-9]\d_)$　//匹配负浮点数 ^-?([1-9]\d_.\d_|0.\d_[1-9]\d_|0?.0+|0)$　//匹配浮点数 ^[1-9]\d_.\d_|0.\d_[1-9]\d_|0?.0+|0$　//匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d_.\d_|0.\d_[1-9]\d*))|0?.0+|0$　//匹配非正浮点数（负浮点数 + 0） 注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串： ^[A-Za-z]+$　//匹配由26个英文字母组成的字符串 ^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串 ^[a-z]+$　//匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$　//匹配由数字和26个英文字母组成的字符串 ^\w+$　//匹配由数字、26个英文字母或者下划线组成的字符串 注：最基本也是最常用的一些表达式</description></item><item><title>基础 Haskell 学习笔记</title><link>https://111qqz.com/2017/11/haskell-notes/</link><pubDate>Fri, 24 Nov 2017 03:18:01 +0000</pubDate><guid>https://111qqz.com/2017/11/haskell-notes/</guid><description>
出于对函数式编程语言这一技能点的缺失...以及退役之后闲得蛋疼
打算浅尝辄止地学一下haskell
这篇笔记不会写成文档那样的详尽..毕竟函数式编程语言也是编程语言...有很多和其他编程语言(命令式？)相似的地方...
所以只会写一些简单的语法+让我感到惊讶的地方orz
总体的感觉...在里面看到了些python和pascal的影子orz...比如子界...已经好久没见到了
变量 * 命令式语言中，变量用来跟踪状态（keeping track of state）。 * Haskell中，变量保存了一个值，**然后再也不可以修改它了。** * 变量不仅可以保存像3.14这样的数值，还可以保存任何Haskell表达式 函数 * 函数中的函数 Prelude&amp;gt; let areaRect l w = l * w Prelude&amp;gt; let areaSquare s = areaRect s s Prelude&amp;gt; areaSquare 5 25 列表 * 创建列表/添加元素 Prelude&amp;gt; let numbers = [1,2,3,4] Prelude&amp;gt; numbers [1,2,3,4] Prelude&amp;gt; 0:numbers [0,1,2,3,4] Prelude&amp;gt; 1:0:numbers [1,0,1,2,3,4] Prelude&amp;gt; 2:1:0:numbers [2,1,0,1,2,3,4] Prelude&amp;gt; 5:4:3:2:1:0:numbers [5,4,3,2,1,0,1,2,3,4] * 事实上所有的列表都是在一个空的列表（`[]`）的基础上通过附加数据创建的。逗号与方括号的记法实际上是一种**语法糖**般的令人愉快的形式。 换句话说，`[1,2,3,4,5]`精确地等同于`1:2:3:4:5:[]` * 列表中的元素必须有相同的类型 * 列表的嵌套(二维以及高维度) * 列表大概可以类比数组或者python 中的list * 将两个List合并是很常见的操作，这可以通过++运算符实现。运算时会遍历左边的list,**因此用:运算符往一个List前端插入元素会是更好的选择。** * 若是要按照索引取得List中的元素，可以使用!</description></item><item><title>在wordpress 中输入数学公式</title><link>https://111qqz.com/2017/10/input-formula-on-wordpress/</link><pubDate>Tue, 31 Oct 2017 15:26:25 +0000</pubDate><guid>https://111qqz.com/2017/10/input-formula-on-wordpress/</guid><description>
查了一些资料。。发现不是要装各种插件（还不一定能用，比如和crayon冲突。。就是讲得很不清楚orz。。
又下一个win下的公式编辑器之类的软件是什么鬼啊？
干脆记录一下必要步骤。只有一步。
1. 配置mathjax. 加入下面代码到该主题的header.php中 &amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间（要放在**&amp;lt;?php wp_head(); ?&amp;gt;**） &amp;lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'&amp;gt;&amp;lt;/script&amp;gt; * **换行显示（displayed mathematics）**，它的分隔符是 $$...$$和 \[...\] ， * **行内显示（in-line mathematics）**，它的分割符号是 \\(...\\) (只有一个\) 不记得公式语法去latex online 查看即可</description></item><item><title>archlinux/manjaro fcitx 与 chrome 不兼容 中文掉字 解决办法</title><link>https://111qqz.com/2017/10/manjaro-fcitx-drop-chinese-words-randomly/</link><pubDate>Wed, 11 Oct 2017 16:24:11 +0000</pubDate><guid>https://111qqz.com/2017/10/manjaro-fcitx-drop-chinese-words-randomly/</guid><description>
[已解决]最近两个版本的 chrome（aura界面）有两个问题
https://github.com/fcitx/fcitx/issues/197
解决办法： 安装fcitx-im 包即可</description></item><item><title>20170929</title><link>https://111qqz.com/2017/09/20170929/</link><pubDate>Fri, 29 Sep 2017 17:10:29 +0000</pubDate><guid>https://111qqz.com/2017/09/20170929/</guid><description>
刚刚看了TBBT season 11 episode 1
Sheldon 和Amy 订婚了，Bernadette又怀孕了。
想想上一季结束的时候，大概半年前。
我好像还是只单身狗，手头没啥能看的offer，还有巨大的学业压力在前方。
感觉这半年收获了好多，多了一份担当，多了几个offer，可能是16年的运气真的太差了吧。
就沈阳打铁这事。。。就真的令人窒息。
这半年真的不知道是怎么过来的，虽然也知道“成年人的事情没有容易二字”，
也不是很愿意太过矫情...
而且日常警惕那种“毫无意义的自我感动”
不过还是真的想说
感谢菊苣@sxg的陪伴
感谢身边那些，在我最低沉最痛苦最萎靡的时候，一直给我加油打气，给我信心的小伙伴。
还要感谢自己....在最艰难的时候，也未曾想过放弃。
这几年真的是...过得太痛苦了...
真的好想大哭一场啊....</description></item><item><title>MPI 学习笔记</title><link>https://111qqz.com/2017/08/mpi-notes/</link><pubDate>Thu, 31 Aug 2017 03:04:27 +0000</pubDate><guid>https://111qqz.com/2017/08/mpi-notes/</guid><description>
参考资料：
消息传递接口（MPI）维基百科
MPI_TUTORIAL
MPI 在大规模机器学习领域的前景如何？
因为要和平台组对接工作以及写我们自己的BN同步...所以来了解一下MPI相关...感谢平台组@gyz 菊苣提供指导。
下面写一些自己的理解 ^_^
OVERVIEW MPI是一个跨语言的通讯协议，用于并行相关
MPI不是一种具体的语言实现，而是一种标准或者说接口，类比sql在关系型数据库中的地位，具体用的时候我们是用某个特定的实现，例如openmpi或者mpich2
对于机器学习问题，MPI很适合用在超算上...
下面随便补一些我认为需要了解的：
** **_communicator _是一个进程的group,该group里的所有进程可以相互通信。
在这组进程中，每个进程有一个唯一的rank,通信按照rank进行（做身份标识的作用？
MPI支持的通信方式有point-to-point 和 collective 两种，也就是点对点和广播
下面分别介绍这两种方式。
Blocking point-to-point communication Blocking communication 就是阻塞通信
**阻塞通信**是指消息发送方的send调用需要接受方的recv调用的配合才可完成 对于非阻塞通信，不必等到通信操作完全完成便可以返回，该通信操作可以交给特定的通信硬件去完成，在该通信硬件完成该通信操作的同时，处理机可以同时进行计算操作，这样便实现了计算与通信的重叠。通过计算与通信的重叠，可以大大提高程序执行的效率。这一方法和通过异步I/O实现I/O与计算的重叠思路是完全一样的。
MPI Send and Receive</description></item><item><title>python只获取当前目录下的文件夹及文件名</title><link>https://111qqz.com/2017/08/python-get-dir-name-in-current-path/</link><pubDate>Wed, 16 Aug 2017 08:21:41 +0000</pubDate><guid>https://111qqz.com/2017/08/python-get-dir-name-in-current-path/</guid><description>
list = os.listdir(rootdir)#列出目录下的所有文件和目录 for line in list: filepath = os.path.join(rootdir,line) if os.path.isdir(filepath):#如果filepath是目录 print &amp;quot;dir:&amp;quot; + filepath else: print &amp;quot;file:&amp;quot; + filepath
如果需要遍历文件夹下的所以文件，可以使用os.walk()方法。
os.walk()返回一个三元素的tuple：当前路径、子文件夹名称、文件列表。 import os for root, dirs, files in os.walk(path): for filename in files: print filename for dirname in dirs: print dirname 举个列处当前目录所有文件夹的例子：
from os import listdir from os.path import isfile, join import os dir =os.listdir() for line in dir: if os.path.isdir(line): print (line) 参考资料</description></item><item><title>峰度（Kurtosis）和偏度（Skewness）</title><link>https://111qqz.com/2017/08/kurtosisskewness/</link><pubDate>Wed, 02 Aug 2017 01:34:58 +0000</pubDate><guid>https://111qqz.com/2017/08/kurtosisskewness/</guid><description>
昨天pinduoduo笔试遇到了，看心情蒙的2333，来学习一下
** 峰度（Kurtosis）和偏度（Skewness）**
重点：正太分布的峰度和偏度都是0
峰度是描述总体中所有取值分布形态陡缓程度的统计量。这个统计量需要与正态分布相比较，峰度为0表示该总体数据分布与正态分布的陡缓程度相同；峰度大于0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰；峰度小于0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。峰度的绝对值数值越大表示其分布形态的陡缓程度与正态分布的差异程度越大。
峰度的具体计算公式为：
[![](http://images.51cto.com/files/uploadimg/20100408/161046770.jpg) ](http://images.51cto.com/files/uploadimg/20100408/161046770.jpg) 偏度与峰度类似，它也是描述数据分布形态的统计量，其描述的是某总体取值分布的对称性。这个统计量同样需要与正态分布相比较，**偏度为0表示其数据分布形态与正态分布的偏斜程度相同**；偏度大于0表示其数据分布形态与正态分布相比为正偏或右偏，即有一条长尾巴拖在右边，数据右端有较多的极端值；偏度小于0表示其数据分布形态与正态分布相比为负偏或左偏，即有一条长尾拖在左边，数据左端有较多的极端值。偏度的绝对值数值越大表示其分布形态的偏斜程度越大。 偏度的具体计算公式为：
[![](http://images.51cto.com/files/uploadimg/20100408/161111811.jpg) ](http://images.51cto.com/files/uploadimg/20100408/161111811.jpg)</description></item><item><title>manjaro(archlinux) 安装 YouCompleteMe</title><link>https://111qqz.com/2017/07/install-YouCompleteMe-on-manjaro/</link><pubDate>Fri, 28 Jul 2017 09:13:34 +0000</pubDate><guid>https://111qqz.com/2017/07/install-YouCompleteMe-on-manjaro/</guid><description>
来来回回折腾了好多次，aur直接安装或者手动编译，安装后都无法补全
ycm的log文件是在/tmp目录下的。
发现问题是缺少libtinfo.so.5
2017-07-28 17:02:12,667 - ERROR - Error occurred while loading global extra conf /home/coder/.ycm_extra_conf.py Traceback (most recent call last): File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/extra_conf_store.py&amp;quot;, line 94, in _CallGlobalExtraConfMethod module = Load( global_ycm_extra_conf, force = True ) File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/extra_conf_store.py&amp;quot;, line 173, in Load module = LoadPythonSource( _RandomName(), module_file ) File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/utils.py&amp;quot;, line 400, in LoadPythonSource return imp.load_source( name, pathname ) File &amp;quot;/home/coder/.ycm_extra_conf.py&amp;quot;, line 32, in &amp;lt;module&amp;gt; import ycm_core ImportError: libtinfo.so.5: cannot open shared object file: No such file or directory 2017-07-28 17:02:12,667 - ERROR - libtinfo.</description></item><item><title>python numpy 用法 简明手册</title><link>https://111qqz.com/2017/07/python-numpy-notes/</link><pubDate>Mon, 24 Jul 2017 03:08:35 +0000</pubDate><guid>https://111qqz.com/2017/07/python-numpy-notes/</guid><description>
原文链接
感谢stanford,感谢原作者的翻译，我调整了一下代码格式，可以当做手册来用了，毕竟之前没怎么写过py 23333
**译者注**：本文[智能单元](https://zhuanlan.zhihu.com/intelligentunit)首发，翻译自斯坦福CS231n课程笔记[Python Numpy Tutorial](http://link.zhihu.com/?target=http//cs231n.github.io/python-numpy-tutorial/)，由课程教师[Andrej Karpathy](http://link.zhihu.com/?target=http//cs.stanford.edu/people/karpathy/)授权进行翻译。本篇教程由[杜客](https://www.zhihu.com/people/du-ke)翻译完成，[Flood Sung](https://www.zhihu.com/people/flood-sung)、[SunisDown](https://www.zhihu.com/people/sunisdown)、[巩子嘉](https://www.zhihu.com/people/gong-zi-jia-57)和一位不愿透露ID的知友对本翻译亦有贡献。 原文如下 这篇教程由Justin Johnson创作。
我们将使用Python编程语言来完成本课程的所有作业。Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。
我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。
一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 numpy for Matlab users页面。
你们还可以查看本教程的IPython notebook版。该教程是由Volodymyr Kuleshov和Isaac Caswell为课程CS 228创建的。
内容列表：
* Python * 基本数据类型 * 容器 * 列表 * 字典 * 集合 * 元组 * 函数 * 类 * Numpy * 数组 * 访问数组 * 数据类型 * 数组计算 * 广播 * SciPy * 图像操作 * MATLAB文件 * 点之间的距离 * Matplotlib * 绘制图形 * 绘制多个图形 * 图像 Python Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：</description></item><item><title>archlinux/manjaro 下 安装 qq/tim</title><link>https://111qqz.com/2017/06/install-qq-on-manjaro/</link><pubDate>Mon, 26 Jun 2017 16:09:19 +0000</pubDate><guid>https://111qqz.com/2017/06/install-qq-on-manjaro/</guid><description>
参考资料：install qq/tim on linux with wine
wine运行qq不能输入账号
This tutorial introduces how to install QQ/TIM in Linux with Wine, which had been tested on ArchLinux with Wine 2.4.
Prerequisites Before start, you need to get the latest Wine. I'm not sure whether QQ/TIM can run on lower version of Wine. In ArchLinux, you can easily get the latest Wine using following command:
?
pacman -S wine However, in Debian, you need to install Wine with some more steps.</description></item><item><title>libgfortran.so.4 missing under archlinux</title><link>https://111qqz.com/2017/06/libgfortran-so-4-missing-under-archlinux/</link><pubDate>Fri, 09 Jun 2017 20:12:41 +0000</pubDate><guid>https://111qqz.com/2017/06/libgfortran-so-4-missing-under-archlinux/</guid><description>
。。。哭了哦。。终于解决了这个bug
参考资料：
libgfortran broken?
libgfortran=3.0 should not be install with numpy &amp;lt;= 1.9
[SOLVED] libgfortran.so.3:cannot open shared object file: No such file
[Replacing gcc-libs-libs with gcc-multilib arch
conflict with gcc-libs and gcc-libs-multilib on latest update
一开始以为是anaconda相关。。。搞了半天。。。
然后又按照第一个资料里。。。试图把libgfortran用libgcc替代。。
发现删掉libgfortran会同时删掉scripy...
然后又觉得。。或许是scripy有什么问题？
查了一会也没发现什么。。。
后来又想也许是dlib的问题？
看了下dlib的github,说是pip 的安装方式可能存在问题，我又用源码安装了一边，问题依旧....
然后本来打算睡觉了。。。
突然梦到。。。也许是arch的问题呢。。。
一搜果然是。。。MGJ。。。这bug出现的时间。。。貌似是2017年5月30号以后。。。（具体参照最后一个资料的日期。。。
而且这。。。谁能想到是arch的锅啊。。。更别说是这么新鲜的bug...
所以说arch是不是不适合跑深度学习，做科学计算之类的啊orz....
最后说下解决办法：
:: gcc-libs 与 gcc-libs-multilib 有冲突。删除 gcc-libs-multilib 吗？ [y/N] y 错误：无法准备事务处理 (无法满足依赖关系) :: gcc-multilib：移除 gcc-libs-multilib 将破坏依赖关系 'gcc-libs-multilib=6.3.1-2' (tensorflow) [coder@111qqz-pc github]$ sudo pacman -S gcc-libs --force 正在解决依赖关系.</description></item><item><title>manjaro installation guide</title><link>https://111qqz.com/2017/06/manjaro-installation-guide/</link><pubDate>Thu, 08 Jun 2017 18:26:14 +0000</pubDate><guid>https://111qqz.com/2017/06/manjaro-installation-guide/</guid><description>
20180214 update:
第一个版本已经比较久了，于是更新一下，顺便写了个脚本orz
pacman-mirrors -c China echo &amp;quot; [archlinuxcn] &amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot; SigLevel = Optional TrustedOnly &amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot; Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot;[arch4edu]&amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot;SigLevel = Never&amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf echo &amp;quot;Server = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/\$arch &amp;quot; &amp;gt;&amp;gt; /etc/pacman.conf pacman -Syyu pacman -S archlinuxcn-keyring pacman -S yakuake fish gvim pacman -S google-chrome chromium pacman -S wget aria2 remarkable netease-cloud-music pacman -S fcitx fcitx-configtool fcitx-sogoupinyin fcitx-im kcm-fcitx pacman -S shadowsocks-qt5 pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts cat &amp;gt;&amp;gt; ~/.</description></item><item><title>conda升级anaconda　ValueError的解决办法</title><link>https://111qqz.com/2017/06/how-to-fix-conda-upgrade-valueerror/</link><pubDate>Thu, 08 Jun 2017 13:03:51 +0000</pubDate><guid>https://111qqz.com/2017/06/how-to-fix-conda-upgrade-valueerror/</guid><description>
conda update anaconda　后提示
ValueError: unsupported format character ')' (0x29) at index 49 查到了这个：anaconda update issue
I have narrowed this down to the following packages: package build psutil-1.2.1 py27_0 hard-link pycparser-2.10 py27_0 hard-link pykit-0.1.0 np18py27_2 hard-link pyparsing-2.0.1 py27_0 hard-link by calling "</description></item><item><title>数字图像处理大作业(初步）</title><link>https://111qqz.com/2017/06/digital-image-processing-course-final-project/</link><pubDate>Wed, 07 Jun 2017 06:53:36 +0000</pubDate><guid>https://111qqz.com/2017/06/digital-image-processing-course-final-project/</guid><description>
...先随便记录一下好了。。。
* 神经网络识别数字或者字母？ * 识别车牌号？ * not hot dog? 安装python pandas pandas
发现之前装caffe的时候...装了这个东西。。。
但是就是检测不到？于是卸载重装。。。。
需要注意的是，如果是python2,要用pip2 install pandas,如果是python3,要用pip3 install pandas.
安装tensorflow...直接sudo pacman -Syu python-tensorflow 即可。。。
然后装好之后检测不到orz...感觉还是pip的安装方式比较靠谱。。。
pip2 install tensorflow
tensorflow_pip安装
我的环境是python2.7
# Ubuntu/Linux 64-bit, CPU only, Python 2.7 $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.10.0-cp27-none-linux_x86_64.whl sudo pip install --upgrade $TF_BINARY_URL 安装成功。。然后发现。。numpy挂了（？？？？？
SO上给出的建议 感觉之后还会各种遇到不同python版本导致的问题。。。。那就上anaconda好了。。。
试了anaconda...想法挺好。。但是貌似还不成熟.。。比如用anaconda安装numpy会报错orz..
最后解决办法是。。。卸载了python-numpy以及所有依赖python-numpy的a包；卸载了python2-numpy以及所有a依赖python２-numpy的包
然后重新安装了python2-numpy
以及发现。。。还有些坑是shellaa相关的.。。y所以暂时不要用fish了。。。
然后提示Missing required dependencies ['dateutil']
解决办法是安装python2-datautil
以及各种pip安装。。都记得要pip2而不是pip
中间缺少一堆库。。。大部分直接安装就好了。。。记得要安装python2对应的版本。。。
然后对于ImportError: No module named tensorboard.plugins
解决办法　是将tensorflow升级到1.</description></item><item><title>vim下python 的配置</title><link>https://111qqz.com/2017/06/vimrc-for-python/</link><pubDate>Wed, 07 Jun 2017 06:21:12 +0000</pubDate><guid>https://111qqz.com/2017/06/vimrc-for-python/</guid><description>
由于最近要做数字图像处理的大作业，以及之后一段时间，估计写python多一些，所以打算花些时间配置下vim. 1. 一键执行 其实之前一直有的。。不过没有效果，就没有管。发现问题是，python对应的filetype为&amp;quot;python&amp;quot;，而不是&amp;quot;py&amp;quot; func! CompileRunGcc() exec &amp;quot;w&amp;quot; if &amp;amp;filetype == 'c' exec &amp;quot;!g++ % -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'cpp' exec &amp;quot;!g++ % -std=gnu++11 -Wall -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'java' exec &amp;quot;!javac %&amp;quot; exec &amp;quot;!java %&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'sh' :!./% elseif &amp;amp;filetype == 'python' &amp;quot; exec &amp;quot;!python %&amp;quot; &amp;quot; exec &amp;quot;!python %&amp;lt;&amp;quot; exec &amp;quot;!python2.7 %&amp;quot; endif endfunc 2.代码补全 不想折腾了。。既然ycm也支持python,就先用用看好了。。不行再换别的。 放一段ycm　for python的配置文件 &amp;quot;默认配置文件路径&amp;quot; let g:ycm_global_ycm_extra_conf = '~/.</description></item><item><title>vundle error detected while processing function</title><link>https://111qqz.com/2017/06/vundle-error-detected-while-processing-function/</link><pubDate>Wed, 07 Jun 2017 05:50:27 +0000</pubDate><guid>https://111qqz.com/2017/06/vundle-error-detected-while-processing-function/</guid><description>
好久没装新插件了，最新要配下python,发现安装时候满屏的错误。。。 最后发现是shell的锅，因为我用的是fish,在.vimrc文件中添加 set shell=/bin/bash 即可。 以及说下可能的其他原因，虽然我没遇到 * 对于arch系，可能从aur中安装的版本out ot data * 可能没有把.vimrc中vundle的配置从set rtp+=~/.vim/bundle/vundle更新成set rtp+=~/.vim/bundle/vundle.vim * 可能项目名称用了&amp;quot; 而不是' 以及顺手查了下bundle和Plugin的区别。。。 简单来说。。Plugin是新写法，bundle是正在被淘汰的写法，不过由于兼容性的原因，仍然在使用。。。 以后使用plugin的写法就好。 参考资料</description></item><item><title>边界的链码，归一化链码，差分玛，形状数</title><link>https://111qqz.com/2017/06/digital-image-processing-course-review/</link><pubDate>Tue, 06 Jun 2017 11:42:37 +0000</pubDate><guid>https://111qqz.com/2017/06/digital-image-processing-course-review/</guid><description>
复习一下数字图像处理。 按照我自己的理解简单来说： 原链码：按照任意起点走边界一周，方向按照上图对应的表示，得到的数字序列就是原链码。 归一化链码：为了解决原链码中起点不唯一而产生的序列不唯一的问题，规定，对于所有起点得到的原链码中，字典序最小的即为归一化链码（由于序列都是自然数，因此字典序最小也可以理解成，把该序列看成有前导０的自然数之后的数值之后的数值最小。 差分码：为了解决图形旋转之后，原链码和归一化链码都会发生变化，引入差分码。n位原链码（或归一化链码，由于归一化链码只是一种特殊的原链码，之后不再单独强调）可以得到n-1位差分码。具体来说，对于原链码ai，可以得到差分码b[i],_b[i] = ((a[i+1] - a[i])+mod)%mod(i属于1..n-1)，_mod根据实际有几个方向决定，通常为４或者８。 形状数：需要强调的是，形状数也是一个序列，而不是一个数。其实形状数就是把差分码按照字典序排序之后，最小的序列。形状数的阶数是该序列的长度。 Freeman链码（弗雷曼链码）是指用曲线起始点的坐标和边界点方向代码来描述曲线或边界的方法，常被用来在图像处理、计算机图形学、模式识别等领域中表示曲线和区域边界。它是一种边界的编码表示法，用边界方向作为编码依据，为简化边界的描述，一般描述的是边界点集。
常用的链码按照中心像素点邻接方向个数的不同，分为4连通链码和8连通链码。4连通链码的邻接点有4个，分别在中心点的上、下、左和右。8连通链码比4连通链码增加了4个斜方向，因为任意一个像素周围均有8个邻接点，而8连通链码正好与像素点的实际情况相符，能够准确地描述中心像素点与其邻接点的信息。因此，8连通链码的使用相对较多。
(a)四方向链码的方向符； （b）八方向链码的方向符。
八链码如下：
链码的定义 按照水平、垂直和两条对角线方向，可以为相邻的两个像素点定义4个方向符：0、1、2、3，分别表示0°、90°、180°和270°四个方向。同样，也可以定义8个方向符：0、1、2、3、4、5、6、7。链码就是用线段的起点加上由这几个方向符所构成的一组数列，通常称之为Freeman链码。用Freeman链码表示曲线时需要曲线的起点，对8链码而言，奇数码和偶数码的对应线段长度不等，规定偶数码单位长度为1，奇数码的单位长度为1.414。
2. 曲线的链码表示
（1）原链码 从边界（曲线）起点S开始，按顺时针方向观察每一线段走向，并用相应的指向符表示，结果就形成表示该边界（曲线）的数码序列，称为原链码，表示为
其中，S表示边界（曲线）的起点坐标，N=4或8时分别表示四链码和八链码。当边界（曲线）闭合时，会回到起点，S可省略。
（2）归一化链码
原链码具有平移不变性（平移时不改变指向符），但当改变起点S时，会得到不同的链码表示，即不具备唯一性。为此可引入归一化链码，其方法是：
对于闭合边界，任选一起点S得到原链码，将链码看作由各方向数构成的n位自然数，将该码按一个方向循环，使其构成的n位自然数最小，此时就形成起点唯一的链码，称为归一化链码，也称为规格化链码。我们将这样转换后所对应的链码起点作为这个边界的归—化链码的起点。
（3）链码的旋转归一化
用链码表示给定目标的边界时，如果目标平移，链码不会发生变化。
但是，如果目标旋转则链码会发生变化。为了得到具有旋转不变性的链码，我们可定义所谓的差分码。链码对应的差分码定义为：
对差分码进行（起点）归一化，就可得到归一化（唯一）的差分码，它具有平移和旋转不变性，也具有唯一性。
3. 边界的形状数表示
由于归一化的差分码既具有唯一性，也具有目标物平移和旋转不变性，因此可用来表示边界，称为形状数。形状数序列的长度(位数)称为形状数的阶,它可作为闭合边界的周长。
如上图所示的目标边界，其
原链码为：42120606454 ，
差分码为 ： 6716626617 ，
形状数: 1662661767 ，
形状数的阶为10 。
参考资料：
图像形状特征（三）--链码及形状数
中南大学_第7章 目标表达和描述技术</description></item><item><title>qt 5.x　初探　(5)　</title><link>https://111qqz.com/2017/06/qt-5-notes-5/</link><pubDate>Sun, 04 Jun 2017 17:14:39 +0000</pubDate><guid>https://111qqz.com/2017/06/qt-5-notes-5/</guid><description>
qt_5.9_ui_doc
还是比直接写代码方便点。。。所以不妨学习一个！
以及。。。qt在2017年6月１号发布了5.9。。。所以之前是5.8。。。现在变成5.9了。。。
遇到了修改了ui文件却没有生效的问题。。。
解决办法：
到项目目录下去执行：uic mainwindow.ui &amp;gt; ui_mainwindow.h 时间测试的qt方法。。。
头文件#include &amp;lt;QTime&amp;gt; QTime time; time.start(); // do something qDebug()&amp;lt;&amp;lt;time.elapsed()&amp;lt;&amp;lt;&amp;quot;ms&amp;quot;; （注意单位。。。</description></item><item><title>qt 5.x初探　（４）　qt 在win下打包成exe</title><link>https://111qqz.com/2017/06/qt-5-notes-4/</link><pubDate>Sun, 04 Jun 2017 12:54:51 +0000</pubDate><guid>https://111qqz.com/2017/06/qt-5-notes-4/</guid><description>
des的基本搞定了。。。打包。。。
在linux下打包成exe。。。。实在是。。没什么好办法的样子。。。
嘛。转念一想。老师说是打包成可执行文件。。。没说一定是exe啊。。。
然后也许我就零分了呢2333
des1.0
好了。。我又跑到windows下装了个qt...安装包2.3G,记得要安装编译器...
装好以后。。。开始打包。。。
注意区分：
Qt Widgets Application 和 Qt Quick Application
我的是后者。。。打包方式略有不同。。。
下面引用了详细步骤。。我来说下简略步骤好了。。。
* 将creator选到release的部署模式。。然后编译。。。 * 将exe文件单独拷贝出来，放到一个文件夹。。。 * **运行qt的命令行（不是系统的命令行！)** * **在qt的命令行中运行windeployqt helloqml.exe --qmldir C:\Qt\Qt5.4.0\5.4\mingw491_32\qml（其中qmldir后面换为qml的真实路径）** 顺便吐槽这工具有点智障。。。文件夹选项不显示后缀名就找不到helloqml　也是有毒。。。
Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll， 如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。 因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe。 以官方 Qt 5.4.0+MinGW 开发环境为例， 从开始菜单--》Qt 5.4.0--》5.4--》MinGW 4.9 (32-bit)--》Qt 5.4 for Desktop (MinGW 4.9 32 bit)，可以打开 Qt 命令行，从这里就可以执行 windeployqt 工具。 集成开发环境 QtCreator 目前生成图形界面程序 exe 大致可以分为两类： Qt Widgets Application 和 Qt Quick Application。 下面分别介绍这两类exe 的发布方式。</description></item><item><title>关于恋爱模式的一点思考</title><link>https://111qqz.com/2017/05/think-about-Love-relationship/</link><pubDate>Tue, 30 May 2017 06:03:09 +0000</pubDate><guid>https://111qqz.com/2017/05/think-about-Love-relationship/</guid><description>
最近和妹子闹了一点小矛盾，不过已经problem solved.
大概是因为，我聊到了妹子很不喜欢的话题，导致妹子情绪变得负面而我还没意识到...
我是感觉...就像写代码一样，代码没有bug(初始时）是不太现实的，关键是要debug?
所以人际关系，更具体的说是和妹子相处....也不可能没有矛盾吧...
尤其是两个人成长环境如果相差得比较多的情况下...接触的时间越长，暴露的矛盾应该就越多...
一个好的coder会惧怕代码中有bug吗？当然不会...
所以矛盾似乎也没什么可怕的...
不过一个熟练的coder大概可能写出的bug会越来越少吧。
所以我觉得，找到一种合适的机制，去解决矛盾是非常必要的....
这种机制不是说解决矛盾的方法本身，而是更通用的为解决矛盾提供的环境？
另外，其实有矛盾也不是什么坏事....如果矛盾是客观存在的，大概越早暴露越好...
越早暴露应该越好解决吧orz
所以大概....下次遇到，至少是这一类的问题，我们应该能解决的更好了吧...
用coding的思维考虑恋爱关系想想其实也没有那么奇怪啊...
我一直觉得，每一对情侣之间都有他们自己相处的模式吧....
所以其实使用这一类方法（不过不代表全部套用...就好像觉得某种语言的某个特性好不代表以后就只使用这种语言一样2333）
对于我们来说应该是种挺高效的模式吧。。。
其实这也可以归结成“见什么人说什么话”？
就想起那次和室友们打《优势物种》...解释规则的时候，“资源的实例”的说法软院的学生都会明白而又不会显得冗杂..
就好像某次和妹子去光谷浪，看到很多家烤串店纠结去哪一家的时候....“遍历一下”也比能想到的其他说法更加准确高效....</description></item><item><title>安装win10后导致grub 引导缺失的解决办法</title><link>https://111qqz.com/2017/05/missing-grub-after-install-windows10/</link><pubDate>Sun, 28 May 2017 04:10:35 +0000</pubDate><guid>https://111qqz.com/2017/05/missing-grub-after-install-windows10/</guid><description>
我之前是单系统manjaro，装了win10以后，grub menu直接消失不见...
ubuntu 的live cd进去，用神器boot-repair也没作用...
最后的解决办法是：
用随便一个什么linux的live cd,进入live模式
使用某种方法（fdisk?gparted?自己记得？）确认linux安装在哪个分区（如果有安装了多个，应该以最后一个为准）我的linux安装在了sda5
挂载linux分区:
sudo mount /dev/sda5 /mnt #Replace sda5 with your partition number
4.挂载其他必要的文件夹
for i in /sys /proc /run /dev; do sudo mount --bind &amp;quot;$i&amp;quot; &amp;quot;/mnt$i&amp;quot;; done 5:chroot进你的系统
sudo chroot /mnt 6.重装并更新grub引导
grub-install /dev/sda update-grub exit sudo reboot 完美解决！</description></item><item><title>archlinux安装记</title><link>https://111qqz.com/2017/05/install-archlinux-notes/</link><pubDate>Sun, 21 May 2017 18:41:27 +0000</pubDate><guid>https://111qqz.com/2017/05/install-archlinux-notes/</guid><description>
实在不忍心x1c吃灰。。。
打算装个arch玩。。。
第一次失败了，原因是忘记配置引导相关...
第二次就成功了...
教程满大街都是就不再写了....
似乎装好以后，和manjaro区别不大？
有空来更新下配置吧。。。
（越来越觉得折腾linux的时间还不如用来陪妹子...
所以不一定什么时候会更了2333</description></item><item><title>qt 5.x初探 （3）</title><link>https://111qqz.com/2017/05/qt-5-notes-3/</link><pubDate>Thu, 18 May 2017 12:47:20 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-3/</guid><description>
update3：
终于知道了正确的学习姿势...
用百度把要用的东西大概描述出来，然后总能找到一个是你要的。。。
然后再去搜关键词。。。
嗯。。百度还是很有用的啊2333
qt5.8_doc_Line Edits Example
所以现在要把之前写成dialog的几个改回Line edit
update2:
老师说要把输入框中的东西随时选中复制出来check...
QLabel默认好像不具有这种属性啊？
稍微查了下。。。
查到了一个叫setTextInteractionFlags的属性
以及连根拔出了。。
qt5.8 QGraphicsTextItem Class
找到了解决办法。。。
openFileNameLabel = new QLabel; openFileNameLabel-&amp;gt;setFrameStyle(frameStyle); openFileNameLabel-&amp;gt;setTextInteractionFlags(Qt::TextSelectableByMouse); //添加可选中可复制的交互属性。。。 记得要
#include &amp;lt;QGraphicsTextItem&amp;gt; update1:
扶起。。。QFile读中文路径文件毫无问题。。。
换成了cpp的 ifstream就一直报错。。。
由于我还改了其他部分。。。所以。。。
查了好久才发现是ifstream的锅。。。。
把des放了进去。。。
本来加密和解密想就用一个函数用参数调节的。。。
不过看了半天也没太懂。。。这种connnet怎么写。。。
不过对connect的理解更深了一些。。。
信号和槽果然是qt的精髓。。。看起来还算不那么无聊。。。
放一些关于信号和槽的资料好了。。。
信号与槽机制
ibm_qt的信号与槽机制
qt的信号槽
然后目前的进度是。。。
des放了进去。。。加密基本没啥问题。。。
但是有个小问题。。。
对于加密过程。。。我是用了一个全局的QString QTextSt来传递信息。。。
对于打开文件。。。过程是file-&amp;gt;QString
加密后得到密文文件。。过程是QString -&amp;gt; file
但是解密过程。。。。完全反过来了啊。。。？
在思考怎么写在一起能够不违和。。。。。</description></item><item><title>C++中头文件（.h）和源文件（.cpp）都应该写些什么（转载）</title><link>https://111qqz.com/2017/05/cpp-header-file-and-source-file/</link><pubDate>Tue, 16 May 2017 07:07:06 +0000</pubDate><guid>https://111qqz.com/2017/05/cpp-header-file-and-source-file/</guid><description>
感觉其实。。。更像是一种规范。。。？而不是一种具体要求吧。。。
转自 头文件(.h)： 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。
在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：
#ifndef CIRCLE_H #define CIRCLE_H //你的代码写在这里 #endif
这样做是为了防止重复编译，不这样做就有可能出错。
至于CIRCLE_H这个名字实际上是无所谓的，你叫什么都行，只要符合规范都行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。
源文件（.cpp）：
**源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。**那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。
下面举个最简单的例子来描述一下，咱就求个圆面积。
第1步，建立一个空工程（以在VS2003环境下为例）。
第2步，在头文件的文件夹里新建一个名为Circle.h的头文件，它的内容如下：
#ifndef CIRCLE_H #define CIRCLE_H class Circle { private: double r;//半径 public: Circle();//构造函数 Circle(double R);//构造函数 double Area();//求面积函数 }; #endif
注意到开头结尾的预编译语句。在头文件里，并不写出函数的具体实现。
第3步，要给出Circle类的具体实现，因此，在源文件夹里新建一个Circle.cpp的文件，它的内容如下：
#include &amp;quot;Circle.h&amp;quot; Circle::Circle() { this-&amp;gt;r=5.0; } Circle::Circle(double R) { this-&amp;gt;r=R; } double Circle:: Area() { return 3.</description></item><item><title>g++ 编译多个源文件（转载）</title><link>https://111qqz.com/2017/05/g++-compile-multi-file/</link><pubDate>Tue, 16 May 2017 06:40:03 +0000</pubDate><guid>https://111qqz.com/2017/05/g++-compile-multi-file/</guid><description>
参考资料
一. 常用编译命令选项 假设源程序文件名为test.c。
无选项编译链接 用法：#gcc test.c 作用：将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。
选项 -o 用法：#gcc test.c -o test 作用：将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。
选项 -E 用法：#gcc -E test.c -o test.i 作用：将test.c预处理输出test.i文件。
选项 -S 用法：#gcc -S test.i 作用：将预处理输出文件test.i汇编成test.s文件。
选项 -c 用法：#gcc -c test.s 作用：将汇编输出文件test.s编译输出test.o文件。
无选项链接 用法：#gcc test.o -o test 作用：将编译输出文件test.o链接成最终可执行文件test。
选项-O 用法：#gcc -O1 test.c -o test 作用：使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。
二. 多源文件的编译方法
如果有多个源文件，基本上有两种编译方法： [假设有两个源文件为test.c和testfun.c]
多个文件一起编译 **用法：#gcc testfun.</description></item><item><title>qt 5.x 学习笔记　(2)</title><link>https://111qqz.com/2017/05/qt-5-notes-2/</link><pubDate>Tue, 16 May 2017 03:14:19 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-2/</guid><description>
先来放一波过程中用到的资料和官方文档好了。
basic layout_qt5.8
QBoxLayout Class_qt5.8
QString Class 5.8
QChar Class qt 5.8
Standard Dialogs Example qt 5.8
更新的部分还是放在最前面好了。。。
convert from QString to char *的时候有个坑。。。
In order to convert a QString to a char*, then you first need to get a latin1 representation of the string by calling toLatin1() on it which will return a QByteArray. Then call data() on the QByteArray to get a pointer to the data stored in the byte array.</description></item><item><title>qt 5.x　初探(1)</title><link>https://111qqz.com/2017/05/qt-5-notes-1/</link><pubDate>Sun, 14 May 2017 12:21:56 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-1/</guid><description>
嘛。。为了系统安全课来学一波qt...
现在算是写出了一个可以打开文件，保存文件的记事本。。。
接下来要搞定的事情是。。。如何写一个自定义的事件。。。比如计算个开方之类的。。。
放一波代码好了。。。
#include &amp;lt;QAction&amp;gt; #include &amp;lt;QMenuBar&amp;gt; #include &amp;lt;QMessageBox&amp;gt; #include &amp;lt;QStatusBar&amp;gt; #include &amp;lt;QToolBar&amp;gt; #include &amp;lt;QDebug&amp;gt; #include &amp;lt;QTextEdit&amp;gt; #include &amp;lt;QFileDialog&amp;gt; #include &amp;quot;mainwindow.h&amp;quot; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { openAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Open...&amp;quot;), this); openAction-&amp;gt;setShortcuts(QKeySequence::Open); openAction-&amp;gt;setStatusTip(tr(&amp;quot;Open an existing file&amp;quot;)); saveAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Save...&amp;quot;), this); saveAction-&amp;gt;setShortcuts(QKeySequence::Save); saveAction-&amp;gt;setStatusTip(tr(&amp;quot;Save a new file&amp;quot;)); QMenu *file = menuBar()-&amp;gt;addMenu(tr(&amp;quot;&amp;amp;File&amp;quot;)); file-&amp;gt;addAction(openAction); file-&amp;gt;addAction(saveAction); QToolBar *toolBar = addToolBar(tr(&amp;quot;&amp;amp;File&amp;quot;)); toolBar-&amp;gt;addAction(openAction); toolBar-&amp;gt;addAction(saveAction); textEdit = new QTextEdit(this); setCentralWidget(textEdit); connect(openAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::openFile); connect(saveAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::saveFile); } MainWindow::~MainWindow() { } void MainWindow::openFile() { QString path = QFileDialog::getOpenFileName(this, tr(&amp;quot;Open File&amp;quot;), &amp;quot;.</description></item><item><title>20170504近况</title><link>https://111qqz.com/2017/05/20170504/</link><pubDate>Thu, 04 May 2017 12:58:06 +0000</pubDate><guid>https://111qqz.com/2017/05/20170504/</guid><description>
啊。。在准备考试QAQ
明天约了鹅厂面试。。。然而从四月就开始一直考试考试考试....感觉药丸啊？
MS的结果貌似明天也要出了orz...
之前没收到positive以为是跪了，结果听说有人没收到positive也拿到了offer啊？
以及，被之前拿到的某厂追加了类似sp之类的东西....
虽然说实习工资什么的的确不是很重要，不过比初始的offer 多了60%的工资还是美滋滋的啊？
而且貌似是我们组的boss帮我争取到的T T
好感动啊。。。。
哦还有。。后半学期有门叫大数据与云计算的课。。。
大概是做一些，和hadoop,spark,caffe有关的实验orz
我本以为我虽然菜了一点。。。但是毕竟一直在linux环境下。。。
这些东西还是能应付的。。。
结果关键步骤几乎全靠妹子carry啊orz....我好菜.jpg
所以虽然我们因为课程太多没办法像其他情侣一样出去玩。。。
一起在写代码，一起debug也算是另一种浪漫吧（强行自我安慰）
增强了专业水平又促进了感情orz
哦还有校赛。。。
虽然是菜鸡。。。不过校赛帮忙出题我觉得是老年选手的义务吧。。。。
但是听说dp和数学题已经够多了。。。马丹这两个最好出了吧orz...
尤其我半年没写过题。。。。我当时的idea...早就过时了吧orz...
而且还是校赛...武汉高校都会来吧。。。
万一因为我出的题太差影响了hust的形象那可就。。。。太糟糕了啊。。。</description></item><item><title>ubuntu 包管理(apt-get)损坏的解决办法</title><link>https://111qqz.com/2017/04/fix-ubuntu-package-manager-broken-problem/</link><pubDate>Sun, 30 Apr 2017 06:58:27 +0000</pubDate><guid>https://111qqz.com/2017/04/fix-ubuntu-package-manager-broken-problem/</guid><description>
症状是不管安装什么，都会说有一大堆依赖无法安装。。。
大概是: a depends b[i],but b[i] is not be installed. (b==0..n)
最后会提示Unable to correct problems, you have held broken packages
解决办法：用synaptic工具，把可能存在问题的包都清除掉。
参考资料
顺便想吐槽。。。ubuntu的包管理工具好辣鸡啊。。
随便装点东西竟然就损坏了？
我刚才装chrome,然后出了错误，提示我apt-get -f install 解决问题。。。
然后包管理就挂了？
想起当年虽然装的第一个发行版是ubuntu,但是并不好用啊？
好好使用的第一个还是mint
所以其实ubuntu不是很适合新手吧。。。只不过知名度高。。。。资料多。。。
要我说 manjaro 或者 linux mint 都要比ubuntu新手友好的多啊orz</description></item><item><title>install galliumOS on chromebook with chrx</title><link>https://111qqz.com/2017/04/install-galliumos-with-chrx-on-chromebook/</link><pubDate>Sat, 29 Apr 2017 15:09:51 +0000</pubDate><guid>https://111qqz.com/2017/04/install-galliumos-with-chrx-on-chromebook/</guid><description>
我的chromebook 是　samsung 3
查阅Hardware Compatibility 可以知道我的cb支持　gallium,对应的cpu 是Intel Braswell
然后去galliumos　官网　下载相应版本。  (发现这种做法并不需要自己下载。。。)
安装　galliumOS大体有两种方法，一种是完全去掉chromeOS,这种方法需要需要拆机去除写保护。。。我嫌麻烦。。。于是打算另一种，使用chrx　
步骤如下：
1. Enable [Developer Mode](http://www.chromium.org/chromium-os/developer-information-for-chrome-os-devices) (process is model-specific; for Acer C720, press `ESC+F3(Refresh)+Power`), then reboot 2. Load ChromeOS by pressing `CTRL+D` at the white &amp;quot;OS verification is OFF&amp;quot; screen 3. Configure your Wi-Fi network if necessary, then log in (Guest account is fine) 4. Open the ChromeOS Terminal by pressing `CTRL+ALT+T`, and enter `shell` at the prompt 5.</description></item><item><title>为什么。。。为什么会变成这样呢。。。</title><link>https://111qqz.com/2017/04/why-is-it-like-this/</link><pubDate>Thu, 27 Apr 2017 07:53:22 +0000</pubDate><guid>https://111qqz.com/2017/04/why-is-it-like-this/</guid><description>
连着考试。。。
取消考试周这做法就是蠢。。。
白天上课晚上考试。。。
说得好像没有考试周大家就不会复习了一样。。。
结果就只能是在白天的课上复习。。。
又影响听新的课，又影响复习。。。。
然后昨天还推了鹅厂的面试。。。不知道会不会留下什么不好的印象T T
连着考试真心要死啊。。。
身体完全受不了。。。
这还只是期中。。。
想想我们前半学期学完了 文档+专业英语+信号+测试+uml+游戏+计网，7门课。。。。
那就意味着期末还有12门。。。。。。。。
感觉真的。。。。。。。为什么。。。要这么多课呢。。。。。。。</description></item><item><title>20140419</title><link>https://111qqz.com/2017/04/20140419/</link><pubDate>Wed, 19 Apr 2017 12:56:13 +0000</pubDate><guid>https://111qqz.com/2017/04/20140419/</guid><description>
最让你恶心痛苦的那些人，你必要从他们身上学到最重要和有用的东西。 所有的痛苦都不能白受，克我者必生我。 在知乎看到这句话，不禁在想
人无疑是zhangk，可是学到了什么呢？
好像什么都没学到T T
那我好亏啊~~~~(&amp;gt;_&amp;lt;)~~~~</description></item><item><title>murmurhash源码分析</title><link>https://111qqz.com/2017/03/reading-murmurhash-code/</link><pubDate>Wed, 22 Mar 2017 12:20:37 +0000</pubDate><guid>https://111qqz.com/2017/03/reading-murmurhash-code/</guid><description>
分析levelDB源码的时候遇到的...发现是一个广泛应用的hash算法，而且是纯c写的，于是找来了源码看。
**MurmurHash** 是一种非[加密](https://zh.wikipedia.org/wiki/)型[哈希函数](https://zh.wikipedia.org/wiki/)，适用于一般的哈希检索操作。[[1]](https://zh.wikipedia.org/wiki/Murmur#cite_note-Hadoop-1)[[2]](https://zh.wikipedia.org/wiki/Murmur#cite_note-2)[[3]](https://zh.wikipedia.org/wiki/Murmur#cite_note-3)由Austin Appleby在2008年发明，[[4]](https://zh.wikipedia.org/wiki/Murmur#cite_note-4)[[5]](https://zh.wikipedia.org/wiki/Murmur#cite_note-5) 并出现了多个变种，[[6]](https://zh.wikipedia.org/wiki/Murmur#cite_note-Murmur160-6) 都已经发布到了[公有领域](https://zh.wikipedia.org/wiki/)(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。[[7]](https://zh.wikipedia.org/wiki/Murmur#cite_note-StackExchange-7) 最初的实现是C++的，但是被移植到了其他的流行语言上，包括 Python,[11]C,[12]C#,[9][13]Perl,[14]Ruby,[15]PHP,[16]Haskell,[17]、Scala[18]、Java[19][20]和JavaScript[21][22]等。
这个算法已经被若干开源计划所采纳，最重要的有libstdc++ (4.6版)、Perl[23]、nginx (不早于1.0.1版)[24]、Rubinius[25]、 libmemcached (Memcached的C语言客户端驱动)[26]、maatkit[27]、Hadoop[1]、Kyoto Cabinet[28]以及RaptorDB[29]。
虽然说破天就是一个hash函数。。似乎没什么好分析的？
不过由于是第一次分析有现实意义的代码，所以简单一点也不是罪过吧orz
以及这次分析代码的重点不在hash算法本身...而是算法之外的其他东西...
大概感受下有现实意义的工程代码的布局之类orz
hash函数本身没有分析...这个没什么好分析的吧...应该是类似一种构造，看懂每一步很容易，但是你还是想不出来啊？而且一堆&amp;quot;magic number&amp;quot;
代码很短，也就200行,分析见注释。
/** * `main.c' - murmurhash * * copyright (c) 2014 joseph werle &amp;lt;joseph.werle@gmail.com&amp;gt; */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;inttypes.h&amp;gt; #include &amp;quot;murmurhash.h&amp;quot; static void usage () { fprintf(stderr, &amp;quot;usage: murmur [-hV] [options]\n&amp;quot;); } static void //函数类型和函数名不一行写是什么风格orz... help () { fprintf(stderr, &amp;quot;\noptions:\n&amp;quot;); fprintf(stderr, &amp;quot;\n --seed=[seed] hash seed (optional)&amp;quot;); fprintf(stderr, &amp;quot;\n&amp;quot;); } static char * read_stdin () { size_t bsize = 1024; size_t size = 1; char buf[bsize]; char *res = (char *) malloc(sizeof(char) * bsize); char *tmp = NULL; // memory issue if (NULL == res) { return NULL; } //申请内存失败了.</description></item><item><title>内存屏障（Memory Barriers）</title><link>https://111qqz.com/2017/03/memory-barriers/</link><pubDate>Wed, 22 Mar 2017 05:16:53 +0000</pubDate><guid>https://111qqz.com/2017/03/memory-barriers/</guid><description>
起因是最近在看levelDB源码，其中port里的atomic_pointer.h文件用到了内存屏障。。
于是来学习一下。。
粗略得说下我自己的理解。
代码的顺序并不和执行的顺序完全对应，出于对效率的追求，cpu和编译器会对一些顺序指令重排，以期得到最大的执行效率。
比如下面这段代码：
// example 2 // void *ptr, v, _store; v = ptr; _store = v; somefunc(); v = _store; v的值是没有改变的，那么编译器可能会认为_store = v; v = _store; 是多余的，就直接把这一段给“优化”掉了。这段代码在单线程中确实是多余的，但是在多线程环境下，可能在somefunc()被调用的时候，另一个线程把v的值给改变了，而这种情况是编译器无法发现的。因此，为了避免这种情况。。。内存屏障登场！
摘自维基百科：
**内存屏障**，也称**内存栅栏**，**内存栅障**，**屏障指令**等，是一类[同步屏障](https://zh.wikipedia.org/wiki/)指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。 大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。
语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。
在多线程环境里需要使用某种技术来使程序结果尽快可见。。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为**内存屏障或内存栅栏**。 再看一个例子
// get start time for (int i = 0; i != 100000; i++) { MemoryBarrier() } // get end time 这段代码，是想知道for循环空转100000次的耗时，这里就需要加入一个MemoryBarrier，如果不加，那么编译器可能就会直接把这个无意义的for循环直接优化掉了。
除了编译器，cpu由于指令流水线或者超流水线等计数，也可能导致出现乱序执行的情况。
内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。
不过内存平展由于阻碍了cpu和编译器的部分优化。。。因此对性能的影响是不忽略的。
为了达到最佳性能，最好是把要解决的问题模块化，这样处理器可以按单元执行任务，然后在任务单元的边界放上所有需要的内存屏障。采用这个方法可以让处理器不受限的执行一个任务单元。合理的内存屏障组合还有一个好处是：缓冲区在第一次被刷后开销会减少，因为再填充改缓冲区不需要额外工作了。 内存屏障的实现不同平台差别很大。。。因为我们可以看到atomic_pointer.h文件中 一堆和平台相关的条件编译...
// Copyright (c) 2011 The LevelDB Authors.</description></item><item><title>AWK 初探</title><link>https://111qqz.com/2017/03/awk-/</link><pubDate>Sun, 19 Mar 2017 10:02:58 +0000</pubDate><guid>https://111qqz.com/2017/03/awk-/</guid><description>
参考资料：
awk_维基百科
awk简明教程
awk是一门比较古老但是很好用的文本处理工具（语言?）
语法还是很好懂的。。。转载了一篇文章。。。算是简明手册？ 不过台词有点糟糕orz
有一些网友看了前两天的《[Linux下应该知道的技巧](http://coolshell.cn/articles/8883.html)》希望我能教教他们用awk和sed，所以，出现了这篇文章。我估计这些80后的年轻朋友可能对awk/sed这类上古神器有点陌生了，所以需要我这个老家伙来炒炒冷饭。**况且，AWK是贝尔实验室1977年搞出来的文本出现神器，今年是蛇年，是AWK的本命年，而且年纪和我相仿，所以非常有必要为他写篇文章**。 之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《The AWK Programming Language》，它在豆瓣上的评分是9.4分！在亚马逊上居然卖1022.30元。
我在这里的教程并不想面面俱到，本文和我之前的Go语言简介一样，全是示例，基本无废话。
我只想达到两个目的：
1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。
2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。
废话少说，我们开始脱吧（注：这里只是topless）。
起步上台 我从netstat命令中提取了如下信息作为用例：
$ cat netstat.txt Proto Recv-Q Send-Q Local-Address Foreign-Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN tcp 0 0 coolshell.cn:80 124.205.5.146:18245 TIME_WAIT tcp 0 0 coolshell.cn:80 61.140.101.185:37538 FIN_WAIT2 tcp 0 0 coolshell.</description></item><item><title>2017年3月更新archlinux后没有声音问题的解决办法</title><link>https://111qqz.com/2017/03/20173archlinux/</link><pubDate>Thu, 16 Mar 2017 06:37:25 +0000</pubDate><guid>https://111qqz.com/2017/03/20173archlinux/</guid><description>
系统信息：
表现为不管外放还是耳机。。都没有声音。。。
解决办法：
pacmd set-card-profile alsa_card.pci-0000_00_1b.0 output:analog-stereo+input:analog-stereo 参考资料</description></item><item><title>一致性哈希初探</title><link>https://111qqz.com/2017/03/overview-of-Consistent-Hashing/</link><pubDate>Wed, 15 Mar 2017 07:58:05 +0000</pubDate><guid>https://111qqz.com/2017/03/overview-of-Consistent-Hashing/</guid><description>
原始论文：一致性哈希
本来不打算放的。。被批评说太不严谨orz..
说说自己的理解好了。。
大概就是。。。hash的时候。。一开始有n个桶。。你设计的函数是y=x%n...看起来美滋滋。。。
然后这时候突然一个桶不见了。。。如果按照之前设计的hash函数。。就变成了x%(n-1)...
这可能会造成大量的数据改变自己之前所在的桶。。。这是不可接受的。。。
或者是。。。当前的桶不够用了。。要增加一个桶。。。变成了x%(n+1)。。。也会出现类似情况。。。
我们的目的就是设计一种算法。。。使得当减少一个桶或者增加一个桶的时候。。。。变化尽可能小。。。
并且希望以后新放入的数据尽可能到新的桶中（？
桶是简化的模型。。。实际应用上。。。一致性哈希主要用在分布式系统中。。。每个桶就相当于一台服务器（？or something...不是很懂分布式的术语）
一致性哈希算法 tencent2012笔试题附加题
问题描述： 例如手机朋友网有n个服务器，为了方便用户的访问会在服务器上缓存数据，因此用户每次访问的时候最好能保持同一台服务器。
已有的做法是根据ServerIPIndex[QQNUM%n]得到请求的服务器，这种方法很方便将用户分到不同的服务器上去。但是如果一台服务器死掉了，那么n就变为了n-1，那么ServerIPIndex[QQNUM%n]与ServerIPIndex[QQNUM%（n-1）]基本上都不一样了，所以大多数用户的请求都会转到其他服务器，这样会发生大量访问错误。
问： 如何改进或者换一种方法，使得：
(1) 一台服务器死掉后，不会造成大面积的访问错误，
(2)原有的访问基本还是停留在同一台服务器上；
(3)尽量考虑负载均衡。（思路：往分布式一致哈希算法方面考虑。）
1. 最土的办法还是用模余方法：做法很简单，假设有N台服务器，现在完好的是M（M&amp;lt;=N),先用N求模，如果不落在完好的机器上，然后再用N-1求模，直到M.这种方式对于坏的机器不多的情况下，具有更好的稳定性。 2. 一致性哈希算法。 下面，本文剩下部分重点来讲讲这个一致性哈希算法。
应用场景 在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括： 轮循算法（Round Robin）、哈希算法（HASH）、最少连接算法（Least Connection）、响应速度算法（Response Time）、加权法（Weighted ）等。其中哈希算法是最为常用的算法.
典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。
常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？
在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。
Consistent Hashing算法描述 下面以Memcached中的Consisten Hashing算法为例说明。
consistent hashing 算法早在 1997 年就在论文 Consistent hashing and random trees 中被提出，目前在 cache 系统中应用越来越广泛；</description></item><item><title>Linux 下各个目录的作用及内容</title><link>https://111qqz.com/2017/03/common-linux-files/</link><pubDate>Wed, 15 Mar 2017 06:29:36 +0000</pubDate><guid>https://111qqz.com/2017/03/common-linux-files/</guid><description>
参考：[wiki_FHS](http://Filesystem Hierarchy Standard)
其实这东西。。。虽然有一个统一的标准。。。但是不同发行版。。。或者同一个发行版的不同版本。。。差异貌似都蛮大的。。。所以只是理论上各个目录的作用。。。可能和具体的发行版不符。。。
Linux 目录 在 Linux 下，我们看到的是文件夹（目录）： 在早期的 UNIX 系统中，各个厂家各自定义了自己的 UNIX 系统文件目录，比较混乱。Linux 面世不久后，对文件目录进行了标准化，于1994年对根文件目录做了统一的规范，推出 FHS ( Filesystem Hierarchy Standard ) 的 Linux 文件系统层次结构标准。FHS 标准规定了 Linux 根目录各文件夹的名称及作用，统一了Linux界命名混乱的局面。
无论何种版本的 Linux 发行版，桌面、应用是 Linux 的外衣，文件组织、目录结构才是Linux的内心。
FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。 FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。
第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。
FHS 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会维持更新，FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示：
/：根目录，一般根目录下只存放目录，不要存放件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中
/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</description></item><item><title>压缩算法初探（科普向，转载）</title><link>https://111qqz.com/2017/03/Overview-of-Compression-Algorithms/</link><pubDate>Wed, 15 Mar 2017 02:55:56 +0000</pubDate><guid>https://111qqz.com/2017/03/Overview-of-Compression-Algorithms/</guid><description>
参考链接
简要概述原理： 每个文件都由各种不同代码组成，比如01代码。这类文件只有数字0与1组合。 压缩原理就是 【通过寻找其中的规律，简化数字的排列】。 比如 00000110001111111111 可以简化成 5个0,2个1,3个0,10个1的排列 100000000000 可以简化成数学的 10^10
至于@yskin 说 没见过2G压缩到十几兆的。 实际上在极限压缩方式下其实28.1G压到25.8M都可以。 &amp;lt;img src=&amp;quot;https://pic1.zhimg.com/893534a767ddb047cc04dd66e2a43900_b.jpg&amp;quot; data-rawwidth=&amp;quot;773&amp;quot; data-rawheight=&amp;quot;235&amp;quot; class=&amp;quot;origin_image zh-lightbox-thumb&amp;quot; width=&amp;quot;773&amp;quot; data-original=&amp;quot;https://pic1.zhimg.com/893534a767ddb047cc04dd66e2a43900_r.jpg&amp;quot;&amp;gt;附下载 附下载 2^31-1 [AviSynth 16x16 60.000fps AVC-Lossless-yuv420p8]__
打开看后基本都能理解这个压缩的大概原理了。
下面是几种常见文件压缩算法原理介绍：
字典算法
字典算法是最为简单的压缩算法之一。它是把文本中出现频率比较多的单词或词汇组合做成一个对应的字典列表，并用特殊代码来表示这个单词或词汇。例如： 有字典列表： 00=Chinese 01=People 02=China 源文本：I am a Chinese people,I am from China 压缩后的编码为：I am a 00 01,I am from 02。压缩编码后的长度显著缩小，这样的编码在SLG游戏等专有名词比较多的游戏中比较容易出现，比如《SD高达》。 固定位长算法（Fixed Bit Length Packing）
这种算法是把文本用需要的最少的位来进行压缩编码。 比 如八个十六进制数：1，2，3，4，5，6，7，8。转换为二进制为：00000001，00000010，00000011，00000100， 00000101，00000110，00000111，00001000。每个数只用到了低4位，而高4位没有用到（全为0），因此对低4位进行压缩编 码后得到：0001，0010，0011，0100，0101，0110，0111，1000。然后补充为字节得到：00010010， 00110100，01010110，01111000。所以原来的八个十六进制数缩短了一半，得到4个十六进制数：12，34，56，78。 这也是比较常见的压缩算法之一。 RLE（Run Length Encoding）
是一个针对无损压缩的非常简单的算法。它用重复字节和重复的次数来简单描述来代替重复的字节。尽管简单并且对于通常的压缩非常低效，但它有的时候却非常有用（例如，JPEG就使用它）。 &amp;lt;img src=&amp;quot;https://pic3.</description></item><item><title>缓存淘汰算法之LRU（转载）</title><link>https://111qqz.com/2017/03/lru/</link><pubDate>Wed, 15 Mar 2017 00:34:50 +0000</pubDate><guid>https://111qqz.com/2017/03/lru/</guid><description>
参考博客
计组块忘光了呜呜呜。。。来复习一波。。
1. LRU 1.1. 原理
LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。
1.2. 实现 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：
1. 新数据插入到链表头部；
2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3. 当链表满的时候，将链表尾部的数据丢弃。
1.3. 分析 【命中率】
当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。
【复杂度】
实现简单。
【代价】
命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。
2. LRU-K 2.1. 原理 LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。
2.2. 实现 相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：
1. 数据第一次被访问，加入到访问历史列表；
2. 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；
3. 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；
4. 缓存数据队列中被再次访问后，重新排序；
5. 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。
LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。
2.3. 分析 【命中率】
LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。
【复杂度】
LRU-K队列是一个优先级队列，算法复杂度和代价比较高。
【代价】
由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。
LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。
3. Two queues（2Q） 3.1. 原理 Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。
3.2. 实现 当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：
1. 新访问的数据插入到FIFO队列；
2. 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</description></item><item><title>大数据top K 问题总结（转载）</title><link>https://111qqz.com/2017/03/top-k-problems/</link><pubDate>Tue, 14 Mar 2017 06:21:24 +0000</pubDate><guid>https://111qqz.com/2017/03/top-k-problems/</guid><description>
转自：http://blog.csdn.net/v_july_v/article/details/6279498
第一部分、十道海量数据处理面试题
1、海量日志数据，提取出某日访问百度次数最多的那个IP。
首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。
或者如下阐述（雪域之鹰）： 算法思想：分而治之+Hash
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)24值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；
**2、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。 ** 假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。
典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。
文中，给出的最终算法是： 第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）； 第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。
或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
方案：顺序读文件中，对于每个词x，取hash(x)00，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。
如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。
还是典型的TOP K算法，解决方案如下： 方案1： 顺序读取10个文件，按照hash(query)的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。
对这10个文件进行归并排序（内排序与外排序相结合）。
方案2： 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。
方案3： 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
遍历文件a，对每个url求取hash(url)00，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。
遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。
方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。
Bloom filter日后会在本BLOG内详细阐述。 6、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。
方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。
方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。 7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法： **方案1：**oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。
dizengrong： **方案2：**这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。
然后将这40亿个数分成两类: 1.</description></item><item><title>局部敏感哈希算法(Locality Sensitive Hashing)初探</title><link>https://111qqz.com/2017/03/locality-sensitive-hashing/</link><pubDate>Sat, 11 Mar 2017 07:59:00 +0000</pubDate><guid>https://111qqz.com/2017/03/locality-sensitive-hashing/</guid><description>
前言： 其实有了前文simhash算法的基础，局部敏感hash算法已经不存在理解上的问题了吧。。。毕竟simhash算法应该是局部敏感哈希算法的一种。。所以我就直接转载几篇我认为比较好的文档结合一下好了。。。会把比较重要的概念或者定义标记重点。
局部敏感哈希(Locality Sensitive Hashing，LSH)算法是我在前一段时间找工作时接触到的一种衡量文本相似度的算法。局部敏感哈希是近似最近邻搜索算法中最流行的一种，它有坚实的理论依据并且在高维数据空间中表现优异。它的主要作用就是从海量的数据中挖掘出相似的数据，可以具体应用到文本相似度检测、网页搜索等领域。 1. 基本思想 局部敏感哈希的基本思想类似于一种空间域转换思想，LSH算法基于一个假设，如果两个文本在原有的数据空间是相似的，那么分别经过哈希函数转换以后的****它们也具有很高的相似度；相反，如果它们本身是不相似的，那么经过转换后它们应仍不具有相似性。
哈希函数，大家一定都很熟悉，那么什么样的哈希函数可以具有上述的功能呢，可以保持数据转化前后的相似性？当然，答案就是局部敏感哈希。
回到顶部
2. 局部敏感哈希LSH 局部敏感哈希的最大特点就在于保持数据的相似性，我们通过一个反例来具体介绍一下。
假设一个哈希函数为Hash(x) = x%8，那么我们现在有三个数据分别为255、257和1023，我们知道255和257本身在数值上具有很小的差距，也就是说它们在三者中比较相似。我们将上述的三个数据通过Hash函数转换：
Hash(255) = 255%8 = 7;
Hash(257) = 257%8 = 1;
Hash(1023) = 1023%8 = 7;
我们通过上述的转换结果可以看出，本身很相似的255和257在转换以后变得差距很大，而在数值上差很多的255和1023却对应相同的转换结果。从这个例子我们可以看出，上述的Hash函数从数值相似度角度来看，它不是一个局部敏感哈希，因为经过它转换后的数据的相似性丧失了。
我们说局部敏感哈希要求能够保持数据的相似性，那么很多人怀疑这样的哈希函数是否真的存在。我们这样去思考这样一个极端的条件，假设一个局部敏感哈希函数具有10个不同的输出值，而现在我们具有11个完全没有相似度的数据，那么它们经过这个哈希函数必然至少存在两个不相似的数据变为了相似数据。从这个假设中，我们应该意识到局部敏感哈希是相对的，而且我们所说的保持数据的相似度不是说保持100%的相似度，而是保持最大可能的相似度。
对于局部敏感哈希“保持最大可能的相似度”的这一点，我们也可以从数据降维的角度去考虑。数据对应的维度越高，信息量也就越大，相反，如果数据进行了降维，那么毫无疑问数据所反映的信息必然会有损失。哈希函数从本质上来看就是一直在扮演数据降维的角色。
回到顶部
3. 文档相似度计算 我们通过利用LSH来实现文档的相似度计算这个实例来介绍一下LSH的具体用法。
3.1 Shingling 假设现在有4个网页，我们将它们分别进行Shingling（将待查询的字符串集进行映射，映射到一个集合里，如字符串“abcdeeee&amp;quot;, 映射到集合”(a,b,c,d,e)&amp;quot;, 注意集合中元素是无重复的，这一步骤就叫做Shingling, 意即构建文档中的短字符串集合，即shingle集合。），得到如下的特征矩阵：
其中“1”代表对应位置的Shingles在文档中出现过，“0”则代表没有出现过。
在衡量文档的相似度中，我们有很多的方法去完成，比如利用欧式距离、编辑距离、余弦距离、Jaccard距离等来进行相似度的度量。在这里我们运用Jaccard相似度。接下来我们就要去找一种哈希函数，使得在hash后尽量还能保持这些文档之间的Jaccard相似度，即：
我们的目标就是找到这样一种哈希函数，如果原来文档的Jaccard相似度高，那么它们的hash值相同的概率高，如果原来文档的Jaccard相似度低，那么它们的hash值不相同的概率高，我们称之为Min-hashing(最小哈希)。
3.2 Min-hashing Min-hashing定义为：特征矩阵按行进行一个随机的排列后，第一个列值为1的行的行号。举例说明如下，假设之前的特征矩阵按行进行的一个随机排列如下：
元素 S1 S2 S3 S4 他 0 0 1 0 成功 0 0 1 1 我 1 0 0 0 减肥 1 0 1 1 要 0 1 0 1 最小哈希值：h(S1)=3，h(S2)=5，h(S3)=1，h(S4)=2.</description></item><item><title>文本相似度判断-simhash算法学习笔记</title><link>https://111qqz.com/2017/03/simhash/</link><pubDate>Fri, 10 Mar 2017 03:33:08 +0000</pubDate><guid>https://111qqz.com/2017/03/simhash/</guid><description>
先放原始论文。。。以此表达对这个算法的敬意orz
论文链接
问题引出： 那天百度一面，frog学姐问了我如何判断两篇新闻稿的相似度的问题....我满篇口胡...也只是回答了一些诸如从图片上考虑。。或者去掉stop word之后得到特征向量然后计算余弦值之类得到传统想法。。。
今天看到了google在用的网页去重的算法（？。。。感觉好神奇。。。准备面试到现在，第一个让我感到惊异而不是套路的算法orz
对于处理**大规模文本（500字以上吧）**的时候效果很好。。。但是算法思想却又非常简单。
这才是算法的美丽之处吧。。。。leetcode上的那些纱布技巧也好意思叫算法。。。？
网页去重，其实本质还是网页相似度的计算....首先是两篇，之后还可以推广到海量数据。
算法初探： simhash算法。。。字面上也可以看出。。是一种hash算法。。。那么它和一般的hash有什么不同呢？
最大的问题在于。。。传统hash的设计目的之一是使得映射后的值的分布尽可能均匀...对于同样的key会有同样的value,但是每当key有轻微的变化的时候，value就会千差万别。
举个例子：
“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 通过simhash计算结果为：
1000010010101101111111100000101011010001001111100001001011001011
1000010010101101011111100000101011010001001111100001101010001011
通过 hashcode计算为：
1111111111111111111111111111111110001000001100110100111011011110
1010010001111111110010110011101
也就是说。。。没办法通过hash之后得到的值的差异，去分析key的相似程度。
而simhash就是通过某种方法进行hash，使得hash之后得到的value可以反应key的相似度。
流程 simhash算法分为5个步骤：分词、hash、加权、合并、降维，具体过程如下所述： * 分词 * 给定一段语句，进行分词，得到有效的特征向量，然后为每一个特征向量设置1-5等5个级别的权重（如果是给定一个文本，那么特征向量可以是文本中的词，其权重可以是这个词出现的次数）。例如给定一段语句：“CSDN博客结构之法算法之道的作者July”，分词后为：“CSDN 博客 结构 之 法 算法 之 道 的 作者 July”，然后为每个特征向量赋予权值：CSDN(4) 博客(5) 结构(3) 之(1) 法(2) 算法(3) 之(1) 道(2) 的(1) 作者(5) July(5)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。 * hash * 通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“CSDN”的hash值Hash(CSDN)为100101，“博客”的hash值Hash(博客)为“101011”。就这样，字符串就变成了一系列数字。 * 加权 * 在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“CSDN”的hash值“100101”加权得到：W(CSDN) = 100101 _4 = 4 -4 -4 4 -4 4，给“博客”的hash值“101011”加权得到：W(博客)=101011 _5 = 5 -5 5 -5 5 5，其余特征向量类似此般操作。 * 合并 * 将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“CSDN”的“4 -4 -4 4 -4 4”和“博客”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。 * 降维 * 对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 0 1 0 1 1”，从而形成它们的simhash签名。 每篇文档得到SimHash签名值后，接着计算两个签名的海明距离即可。根据经验值，对64位的 SimHash值，海明距离在3以内的可认为相似度比较高。</description></item><item><title>蓄水池抽样算法概述(Reservoir Sampling Algorithm)[转载]</title><link>https://111qqz.com/2017/03/reservoir-sampling-algorithm/</link><pubDate>Thu, 09 Mar 2017 12:14:11 +0000</pubDate><guid>https://111qqz.com/2017/03/reservoir-sampling-algorithm/</guid><description>
面京东被这个问题卡了QAQ，来补补这方面的课。
转自：链接
蓄水池抽样算法随机算法的一种，用来从 N 个样本中随机选择 K 个样本，其中 N 非常大（以至于 N 个样本不能同时放入内存）或者 N 是一个未知数。其时间复杂度为 O(N),包含下列步骤 (假设有一维数组 S, 长度未知，需要从中随机选择 k 个元素, 数组下标从 1 开始), 伪代码如下:
array R[k]; // result integer i, j; // fill the reservoir array for each i in 1 to k do R[i] := S[i] done; // replace elements with gradually decreasing probability for each i in k+1 to length(S) do j := random(1, i); // important: inclusive range if j &amp;lt;= k then R[j] := S[i] fi done 算法首先创建一个长度为 k 的数组（蓄水池）用来存放结果，初始化为 S 的前 k 个元素。然后从 k+1 个元素开始迭代直到数组结束，在 S 的第 i 个元素，算法生成一个随机数 j∈[1,i]j∈[1,i]， 如果 j &amp;lt;= k， 那么蓄水池的第 j 个元素被替换为 S 的第 i 个元素。</description></item><item><title>软件体系结构复习笔记</title><link>https://111qqz.com/2017/01/Software-Architecture-course-review/</link><pubDate>Tue, 03 Jan 2017 03:26:39 +0000</pubDate><guid>https://111qqz.com/2017/01/Software-Architecture-course-review/</guid><description>
Cha1 软件架构概念： 是系统的一个或多个结构，它们由软件组件，组件的外部可见属性以及组件之间的关系组成。 组件的外部可见属性是指其他组件对该组件所做的假设。 软件架构的多个结构： 静态的角度： 模块结构 分析类结构 类结构 动态的角度： 进程结构 数据流 控制流 使用结构 调用结构 层次结构 部署的角度： 物理结构
架构不止是功能需求的结果 Ch2: 需求包含三要素:功能，质量，限制条件 质量属性：系统在其生命周期过程中所表现出来的各种特征 质量属性的关系： 一个质量属性的获取对其他质量属性可能产生正面或者负面的影响。 任何质量属性都不可能在不考虑其他属性情况下单独获取。 质量属性举例： 运行时可见属性：性能，可用性，安全性 维护时可见属性：可修改，可扩展，可移植 易用性： 可学习性 可记忆性 错误避免 错误处理 满意度 质量场景创建的参与人员： 最终用户 系统管理员 维护人员 客户 开发组织 构架本身的质量属性： 一致性 正确性和完整性 可构建性 生成质量属性场景的目的和意义： 帮助构架师生成有意义的质量属性需求 使质量属性需求的描述规范化 某一场景是一类场景的代表，系统将以完全相同的方式做出反应。 构架的商业属性（限制）： 上市时间 成本和收益 预期系统生命周期长短 目标市场 推出计划 与老系统的集成 第三章： 软件架构样式的种类： 以数据为中心 数据流 虚拟机 调用-返回 独立组件 C/S 构架的异质性： 局部异质 层次异质 并行异质 ISO/OSI七层参考模型： 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 软件框架： 提取特定领域软件的共性部分形成的体系结构。 框架和架构的关系： 框架不是构架。 构架确定了系统整体结构、层次划分、不同部分之间的协作等设计老驴。 框架比构架更具体，更偏重于技术。 一个框架对应一个架构，一个架构可以有多个框架。 第四章： 架构战术：影响质量属性的设计决策。 架构策略：架构中所采用的战术的集合。 可用性的战术： 错误检测的战术： 回声 心跳 异常 错误恢复的战术： 表决 主动冗余 被动冗余 备件 状态再同步 检查点/回滚 错误预防的战术： 进程监视器 从服务中删除 事物 可修改性的战术： 局部化修改的战术： 维持语义一致性 预期期望的变更 泛化模块 限制可能的选择 防止连锁反应的战术： 信息隐藏 维持现有的接口 添加结构 添加适配器 提供一个占位程序 推迟绑定时间的战术： 运行时注册 配置文件 多态 组件更换 遵守已定义的协议 实施性能的战术： 影响响应时间的两个基本因素： 资源消耗 阻塞时间： 资源争用 资源的可用性 对其他计算的依赖性 控制对资源需求的战术： 减少处理一个事件所需要的资源： 提高计算效率 减少计算开销 减少需要同时处理： 管理事件率 控制采样频率 控制系统的使用： 限制执行时间 限制队列的大小 资源管理的战术： 引入并发 维持数据或计算的多个副本 增加可用资源 资源仲裁常见的调度策略： 先进/先出 固定优先级：语义重要性；时限时间单调；速率单调 动态优先级调度：轮转；时限时间最早优先 静态调度 实施安全性的战术： 用于抵抗攻击的战术： 对用户进行身份验证 对用户进行授权 维护数据的机密性 维护完整性 限制暴露的信息 限制访问 检测攻击的战术： 从攻击中恢复的战术： 回复状态 识别攻击者 易用性的战术： 运行时战术： 维持任务的一个模型 维护用户的一个模型 维护系统的一个模型 设计时战术： 软件架构样式与战术的关系： 软件架构样式是从战略层面解决质量问题，战术是从具体部署上给猪解决质量问题的局部策略。 第五章：设计构架 基于构架的开发步骤： 为软件系统创建一个商业案例 弄清系统需求 构建构架 正确表述此构架，并与有关各方进行交流 对此构架进行分析和评价 实现基于构架的系统并保证与构架相一致 系统维护时，构架文档应同步维护 构架驱动的因素： 功能 质量 部分限制条件（限制条件的某个子集） 良好架构的评判原则（判断题常考）： 设计构架过程的建议: 架的设计应该由一门设计师来完成 设计师应该全面掌握对系统的技术需求，以及对各项定性指标的优先级清单。 构架的文档完备，并蚕蛹所有人员认可的文档形式。 构架设计文档应让各风险承担者积极评估。 通过对构架分析，得出明确的定性与定量指标。 构架设计应该有助于具体实现。 允许构架带来一定的资源争用，并给出可行的解决方案。 关于构架的结构的建议： 构架由定义良好的模块组成，各个模块的功能划分应该基于信息隐藏。 模块的划分应体现出相互独立的原则。 把计算机基础结构的特性封装在一定的模块 构架尽量不依赖某个特定版本的商品产品或工具。 产生数据的功能和使用数据的功能应分属于不同的模块。 对并发系统，构架应充分考虑进程与模块结构的不对应。 进程编写要考虑到与特定处理器的关系，并容易改变关系。 构架应尽量采用一些已知的设计模式。 ADD构架设计的步骤： 样本输入 选择要分解的模块 根据下列5个步骤对模块进行求精（重点）： 从具体的质量场景和功能需求集合中选择构架驱动因素。 选择满足构架驱动因素的构架模式。 实例化模块并根据用例分配功能，使用多个视图进行表示 定义子模块的接口 验证用例和质量场景并对其进行求精，使它们称为子模块的限制。 对需求进一步分解的每个模块重复上述步骤。 创建骨架系统： 思想：提供一种基本能力，以一种对项目有利的顺序实现系统的功能。 好处： 提高开发效率，鼓舞士气。 能更早发现复杂的依赖关系。 使开发人员更多关注最难实现的部分。 能够缩短系统集成时间，降低其成本，并使集成成本更明确。 便于评审和测试。 步骤： 实现处理构架组件交互的软件部分 选择组件逐步添加到系统中。 逐步进行测试。 架构师的职责： 了解所在组织的业务目标，使架构更好地支持业务目标。 规划产品的开发与严禁 规划和建设架构级的重用etc 分析软件构架的原因(重要): 它是风险承担者之间的交流平台，是早期设计决策的体现，是可传递的模型。 软件质量不可能在软件开发的最后阶段追加上去，必须在设计之初就考虑到。 第七章： 构架评审： 成本： 人员时间成本 构架评审部门的组织开销 构架评审部分要求高级设计人员参与的代价（不就是人员时间成本吗。。。 收益： 及早发现构架中存在的问题 构架的改进 财务收益 强制位评审做准备 捕获构架设计的基本思想 验证需求的有效性 评审实施： 按问题的重要性进行分类 强调那些与偶家相符或相悖的重要问题 必须记载评审中所提的每个问题 构架评审的主要指导原则： 把由独立部门实施的正规的构架评审作为项目开发周期规划的一部分。 选择评审的最佳时间，尽早预审一次。 选择恰当的评审技巧 签署评审合同 限制所要品神的质量属性的个数 要保证评审小组中有构架方面的专家，领域专家，资料员，后勤员。 一定要有系统设计师。 收集各种场景数据，并在此基础上形成评审清单。 第八章： 架构权衡分析法（ATAM)： 特点：不仅可以揭示出构架满足特定质量目标的情况，而且可以让我们更清楚地认识质量目标之间的联系。 输入：用场景集合捕获的质量要求。 输出： 简介的框架表述 表述清楚的业务目标 构架决策到质量需求的映射 所确定的敏感点和权衡点集合 有风险决策和无风险决策 风险主题的集合 阶段： 评估小组和项目决策者共同决定评估细节 评估小组收集信息和分析 风险承担着参与评估 评估小组自我检查和改进，提交书面报告 步骤（重点）： ATAM方法的表述 商业动机的表述 构架的表述 对构架方法进行分类 生成质量属性效用树 分析构架方法 集体讨论并确定场景优先级 再次分析构架方法 结果的表述 第九章： 文档： 目的与作用：让不同的风险承担者都能快速找到和理解他们需要的信息。 基本原则：从读者的角度出发。</description></item><item><title>manjaro安(zhe)装(teng)记</title><link>https://111qqz.com/2016/12/manjarozheteng/</link><pubDate>Tue, 27 Dec 2016 04:40:53 +0000</pubDate><guid>https://111qqz.com/2016/12/manjarozheteng/</guid><description>
噫。。之前x200上装的是win7+fedora25 gnome。。。
虽然感觉gnome对于09年的老电脑来说有点吃力...不过也懒得换..
结果硬盘挂了2333 于是换了块硬盘
以及被人安利了manjaro，一个基于arch的linux发行版
还有就是因为平安夜又没有代码可以写又没有妹子可以陪觉得人生寂寞如雪
官网下好镜像以后，一开始用dd命令做u盘，发现启动不了。
无奈到win下用了poweriso制作，成功。
安装很顺利...基本就是傻瓜操作...
装好以后...装了vim...shadowsocks...chrome...fish...搜狗输入法。。。
添加了archcn的源
发现不能切换输入法。。。
解决办法：
在~/.xprofile 文件中添加如下内容 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot; 其他都挺顺利的。。
结果今天用着用着发现renkz2011这账户无法登录了。。。提示密码错误。。。
root账户是可以登录的。。。
于是我跑到root下登录。。。是可以的。。。
于是改了下renkz2011的密码。。。发现依然提示错误。。。
但是呢。。。我在root下做需要renkz2011权限的事情。。。输入密码就是没有问题的。。
我新建了一个账户。。。发现登录也没有问题。。。
奇怪啊。。。回想一下。。。我改了什么。。。
添加了archcn的源。。。
应该没关系。。。
还有就是。。。remove了zsh..?
于是我尝试着重新装回zsh...
再登录。。发现可以了。。。
回想一下。。。我在renkz2011账户下曾经设置默认shell为zsh...
卸载以后好像忘记更改了orz
但是。。。为什么和shell有关呢。。。</description></item><item><title>discourse邮件服务无法使用的解决方案</title><link>https://111qqz.com/2016/12/discourse/</link><pubDate>Sun, 25 Dec 2016 07:27:48 +0000</pubDate><guid>https://111qqz.com/2016/12/discourse/</guid><description>
解决办法:https://blog.discourse.org/2016/03/switching-your-discourse-from-mandrill-to-mailgun/</description></item><item><title>编译原理实验：词法分析器</title><link>https://111qqz.com/2016/12/</link><pubDate>Mon, 12 Dec 2016 09:02:12 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
实验一　设计实现简单语言的词法分析器 1、实验目的
通过该实验,熟练应用编译原理关于词法分析的基本理论和方法；学会用C/C++高级程序设计语言设计一个词法分析器；加深对编译原理理论的分析理解，提高实际操作和解决具体问题的能力。
2、实验条件
计算机上安装C/C++编译处理软件。
3、实验内容及要求
对下述单词表定义的语言设计编制一个词法分析器。单词符号及种别表和词法分析器功能及基本要求如下：
（1）单词符号及种别表
单词符号 种别编码 单词值 main 1 int 2 float 3 double 4 char 5 if 6 else 7 do 8 while 9 l(l|d)* 10 内部字符串 ( +|-|ε ) dd*(.</description></item><item><title>一些计划。。。</title><link>https://111qqz.com/2016/12/</link><pubDate>Fri, 09 Dec 2016 09:51:40 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
感觉owncloud的确很赞的样子。。。
小电影什么的。。我倒是需求不大。。。
不过作为同步盘感觉蛮赞的。。。
然而现在手头的服务器。。。除了论坛的vultr...都不是辣么有名的公司貌似。。。（国内的阿里云就算了。。。
所以现在的计划是。。。
等明年８月班瓦工到期。。。以及。。。不知道什么时候说不定就会tj的论坛。。。
打算买一个好一点的服务器orz，ss,owncloud，博客也搬过去吧...</description></item><item><title>fedora/centos　服务器搭建shadowsocks超时的解决办法</title><link>https://111qqz.com/2016/12/fedoracentosshadowsocks/</link><pubDate>Thu, 08 Dec 2016 07:42:54 +0000</pubDate><guid>https://111qqz.com/2016/12/fedoracentosshadowsocks/</guid><description>
操作肯定没有错，就是连接不上，显示超时
发现是防火墙的锅
具体请看：github_shadowsocks_issues_477</description></item><item><title>搭建论坛历程</title><link>https://111qqz.com/2016/12/</link><pubDate>Mon, 05 Dec 2016 08:32:38 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
。。。由于一些不可描述的原因。。。
和某个华师计科的妹子一拍即合。。。打算搞一个论坛出来。。。
算是做一些微小的贡献2333
一开始打算尝试dz...毕竟社区比较丰富...服务器的话。。先拿个免费的搭起来再说https://www.hostinger.com.hk/
不过安装失败了...还是数据库的问题...
加上被gyz安利了discourse...稍微看了下，感觉还是挺不错的。。。
不过考虑到，社交登陆方面,discourse貌似对fb,google+,twitter之类的支持良好..但是对于国内的....
至少对于我来讲，我是不愿意再多注册一个账号的..
而且日后可能要加一些功能。。。要自己写的那种。。。discourse的技术链。。。我真是一点也不懂2333（虽然php我懂的也不多。。。。
基于以上原因。。我还是先打算继续搞dz...
20161207update:搭好了。。。免费的服务器太不稳定。。。于是买了日本某公司的服务器2333.一个月１０刀。。。暂时我们三个人平摊吧。。。
然后选择了discourese...其实还是不错的2333
接下来的问题。。就是如何吸引第一批成员加入。。。
这个就交给她们两个了。。。</description></item><item><title>关于代码插件　crayon　无法高亮的解决方案</title><link>https://111qqz.com/2016/11/crayon/</link><pubDate>Wed, 30 Nov 2016 08:37:57 +0000</pubDate><guid>https://111qqz.com/2016/11/crayon/</guid><description>
在最后一个标签　加上两个
（空格的字符表示　＆　＋　nbsp） 就好了。。。。</description></item><item><title>database connection error 的解决方案</title><link>https://111qqz.com/2016/10/database-connection-error-/</link><pubDate>Mon, 10 Oct 2016 10:37:14 +0000</pubDate><guid>https://111qqz.com/2016/10/database-connection-error-/</guid><description>
其实 东西之前出现过...不过好像重启一下服务器就可以了？
这次比较麻烦。
一开始我是直接google 了这条错误信息，结果答案五花八门，或者说...可能的原因非常多。
排查了几个。。。还是没有搞定。。。
突然想到。。。。为何不直接看log....我好傻啊。
2016-10-10 10:36:54 3755 [Note] IPv6 is not available. 2016-10-10 10:36:54 3755 [Note] - '0.0.0.0' resolves to '0.0.0.0'; 2016-10-10 10:36:54 3755 [Note] Server socket created on IP: '0.0.0.0'. 2016-10-10 10:36:54 3755 [ERROR] /alidata/server/mysql/bin/mysqld: Table './mysql/user' is marked as crashed and last (automatic?) repair failed 2016-10-10 10:36:54 3755 [ERROR] Fatal error: Can't open and lock privilege tables: Table './mysql/user' is marked as crashed and last (automatic?</description></item><item><title>[solved ]fedora 24 "Tap to click" not working</title><link>https://111qqz.com/2016/09/solved-fedora-24-tap-to-click-not-working/</link><pubDate>Thu, 01 Sep 2016 08:16:07 +0000</pubDate><guid>https://111qqz.com/2016/09/solved-fedora-24-tap-to-click-not-working/</guid><description>
链接</description></item><item><title>using your computer without mouse</title><link>https://111qqz.com/2016/09/using-your-computer-without-mouse/</link><pubDate>Thu, 01 Sep 2016 07:44:31 +0000</pubDate><guid>https://111qqz.com/2016/09/using-your-computer-without-mouse/</guid><description>
键盘足够爽了以后。。。
鼠标明显降低效率。。。
学会逐步脱离鼠标吧orz.
首先是chrome插件vimium
vimium教程
Vimium 常用的按键功能解释： * **j：向下细微滚动窗口 k：向上细微滚动窗口** * J：(**Shift+j的意思，以下大写全部表示加Shift)** 下一个标签页 K：上一个标签页 * d：向下滚动半个屏幕 u：向上移动半个屏幕 * **g+g（连续按两下g）：回到顶部** * **G：到达页面底部** * H：后退 L： 前进 * f：将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框。如果按的是F，那么将在新窗口中打开页面（见上图） * g+i：将光标 定位到输入框，如果有多个可以按Tab键切换 * x：关闭当前页面 X：恢复刚刚关闭的页面 * o：相当于Chrome中的地址栏，可以匹配历史记录、收藏夹并在当前窗口打开，或者直接打开一个网址或者搜索一个关键字（Chrome在全屏的时候地址栏死都出不来，有了它就解决这个一直困扰我的问题了！～），如果按的是O，则可以在新窗口中打开，非常非常方便！ * g+s：查看网页的源代码 * r：重新载入当前网页（顺便提一句，这点上新浪微博和它是一样的，光标没有定位在发送框时，即便没有安装这个插件你也可以用j/k来控制页面上下滚动，用r在刷新，用f或者p来定位到发送框。而Gmail的快捷键如j,k上下移动光标也是类似，有兴趣大家可以再自己去了解一下一些常用web应用的快捷键）</description></item><item><title>fedora 24 cannot modify keyboard delay and rate</title><link>https://111qqz.com/2016/08/fedora-24-cannot-modify-keyboard-delay-and-rate/</link><pubDate>Thu, 25 Aug 2016 08:58:50 +0000</pubDate><guid>https://111qqz.com/2016/08/fedora-24-cannot-modify-keyboard-delay-and-rate/</guid><description>
最近入手了x1 c
然后发现没办法支持 f22.....
没办法，只好上f24了。。。虽然明知道一堆bug...
最近发现。。之前在系统设置-&amp;gt;键盘-&amp;gt;打字 中的调整键盘延迟和速率的选项。。。不见了。。。
找了好久终于找到了解决办法：
/××××××××××××××××××××××××××××××××××××××××××××××××/ xset r rate 250 30
链接：参考</description></item><item><title>实训相关。。。。</title><link>https://111qqz.com/2016/07/</link><pubDate>Sat, 02 Jul 2016 07:44:27 +0000</pubDate><guid>https://111qqz.com/2016/07/</guid><description>
列个技能表。。。。。
java.... mysql... tomcat apache jsp..... idea...?
tomcat是apache的进化。。。。？？？
hibernate...持久层的设计模式。。？？ http://docs.jboss.org/hibernate/orm/</description></item><item><title>geekos project 1 （ELF文件相关）</title><link>https://111qqz.com/2016/06/geekos-project-1-elf/</link><pubDate>Sat, 18 Jun 2016 19:43:34 +0000</pubDate><guid>https://111qqz.com/2016/06/geekos-project-1-elf/</guid><description>
一、目的 熟悉ELF文件格式，了解GeekOS系统如何将ELF格式的可执行程序装入到内存，建立内核进程并运行的实现技术。 二、流程 1、修改/geekos/elf.c文件：在函数Parse_ELF_Executable( )中添加代码，分析ELF格式的可执行文件（包括分析得出ELF文件头、程序头，获取可执行文件长度，代码段、数据段等信息），并填充Exe_Format数据结构中的域值。 2、在Linux环境下编译系统得到GeekOS镜像文件。 3、编写一个相应的bochs配置文件。 4、在bochs中运行GeekOS系统显示结果。
编译以及启动bochs同project0... project0遇到的那些错误还是都会遇到一遍233.
然后在project1/src/geekos/ 目录下的elf.c中添加函数：int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength, struct Exe_Format *exeFormat)
原理部分不过多阐释，具体可见我参考的博客。
最后实现为：
int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength, struct Exe_Format *exeFormat) { elfHeader* header = exeFileData; programHeader* pHeader = (exeFileData+header-&amp;gt;phoff); exeFormat-&amp;gt;numSegments = header-&amp;gt;phnum; exeFormat-&amp;gt;entryAddr = header-&amp;gt;entry; int i = 0; for (; i&amp;lt; header-&amp;gt;phnum; i++) { exeFormat-&amp;gt;segmentList[i].offsetInFile = pHeader-&amp;gt;offset; exeFormat-&amp;gt;segmentList[i].lengthInFile = pHeader-&amp;gt;fileSize; exeFormat-&amp;gt;segmentList[i].startAddress = pHeader-&amp;gt;vaddr; exeFormat-&amp;gt;segmentList[i].sizeInMemory = pHeader-&amp;gt;memSize; exeFormat-&amp;gt;segmentList[i].protFlags = pHeader-&amp;gt;flags; pHeader++; } return 0; //!</description></item><item><title>geek OS project 0 （下）</title><link>https://111qqz.com/2016/06/geek-os-project-0-/</link><pubDate>Sat, 18 Jun 2016 09:48:06 +0000</pubDate><guid>https://111qqz.com/2016/06/geek-os-project-0-/</guid><description>
现在我们环境已经搭好了，参考 geekos实验环境的搭建
在main.c中新加个函数，命名为projecto,函数的代码如下：
/* * GeekOS C code entry point * Copyright (c) 2001,2003,2004 David H. Hovemeyer &amp;lt;daveho@cs.umd.edu&amp;gt; * Copyright (c) 2003, Jeffrey K. Hollingsworth &amp;lt;hollings@cs.umd.edu&amp;gt; * Copyright (c) 2004, Iulian Neamtiu &amp;lt;neamtiu@cs.umd.edu&amp;gt; * $Revision: 1.51 $ * * This is free software. You are permitted to use, * redistribute, and modify it as specified in the file &amp;quot;COPYING&amp;quot;. */ #include &amp;lt;geekos/bootinfo.h&amp;gt; #include &amp;lt;geekos/string.h&amp;gt; #include &amp;lt;geekos/screen.h&amp;gt; #include &amp;lt;geekos/mem.h&amp;gt; #include &amp;lt;geekos/crc32.h&amp;gt; #include &amp;lt;geekos/tss.</description></item><item><title>geekok project0（上）（实验环境的搭建）</title><link>https://111qqz.com/2016/06/geekok-project0/</link><pubDate>Sat, 18 Jun 2016 08:35:49 +0000</pubDate><guid>https://111qqz.com/2016/06/geekok-project0/</guid><description>
apt-get install build-essential apt-get install bochs bochs-x nasm
此处下载的bochs应该是比较新的...如果之后遇到
failed assertion in init_idt :g_handlersizenoterr == g_handlersizeerr 这个错误，建议安装比较老的nasm版本，比如2.08.02链接
下载geekos-0.3软件包，地址为： geekOS下载地址
然后解压到~/work目录。
然后进入到 /work/geekos-0.3.0/src/project0/build 目录下
之后的操作都是在这个目录下进行的。
rkz2013@111qqz-ThinkPad-X200 ~/work/geekos-0.3.0/src/project0/build $ make depend Makefile:249: depend.mak: 没有那个文件或目录 touch depend.mak gcc -M -O -Wall -Werror -g -DGEEKOS -I../include \ ../src/geekos/idt.c ../src/geekos/int.c ../src/geekos/trap.c ../src/geekos/irq.c ../src/geekos/io.c ../src/geekos/keyboard.c ../src/geekos/screen.c ../src/geekos/timer.c ../src/geekos/mem.c ../src/geekos/crc32.c ../src/geekos/gdt.c ../src/geekos/tss.c ../src/geekos/segment.c ../src/geekos/bget.c ../src/geekos/malloc.c ../src/geekos/synch.c ../src/geekos/kthread.c ../src/geekos/main.c \ | perl -n -e 's,^(\S),geekos/$1,;print' \ &amp;gt; depend.mak gcc -M -O -Wall -Werror -I.</description></item><item><title>OS课设之geek os 非最终版</title><link>https://111qqz.com/2016/06/osgeek-os-/</link><pubDate>Fri, 17 Jun 2016 04:09:37 +0000</pubDate><guid>https://111qqz.com/2016/06/osgeek-os-/</guid><description>
参考了这篇博客
流程部分不再具体描述，可以参考上面的博客。
只详细给出我遇到的问题。
我的pc环境是：Linux 111qqz-ThinkPad-X200 3.16.0-38-generic #52~14.04.1-Ubuntu SMP Fri May 8 09:43:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
linux mint 17.2 cinnamon
apt-get install build-essential apt-get install bochs bochs-x nasm http://sourceforge.net/projects/geekos/files/ 下载geekos软件包并且解压
$ cd ~/geekos-0.3.0/src/project0/build$ $ make depend $ make 报错。。
解法办法：修改/home/rkz2013/geekos-0.3.0/src/project0/build
目录下的Makefile文件。
CC_GENERAL_OPTS := $(GENERAL_OPTS) -Werror 改为 CC_GENERAL_OPTS := $(GENERAL_OPTS) make后再次出现错误：
fmtout.c:(.text+0xa16)：对‘__stack_chk_fail’未定义的引用 解决办法：
在project0/build 目录下的makefile文件的148行 添加编译选项 -fno-stack-protector 然后又报错
i386 architecture of input file `geekos/lowlevel.o' is incompatible with i386:x86-64 output 解决办法：</description></item><item><title>linux下的对拍写法</title><link>https://111qqz.com/2016/05/linux/</link><pubDate>Mon, 16 May 2016 13:44:16 +0000</pubDate><guid>https://111qqz.com/2016/05/linux/</guid><description>
首先先生成三个程序： $ g++ a+b.cpp -o a+b $ g++ a+b2.cpp -o a+b2 $ g++ make.cpp -o make 然后生成数据 $ ./make &amp;gt; in.txt 然后运行两个程序 $ ./a+b &amp;lt; in.txt &amp;gt; out.txt $ ./a+b2 &amp;lt; in.txt &amp;gt; ans.txt 最后对拍 $ diff out.txt ans.txt 输出的结果可以man diff查阅一下相关文档中关于输出含义的内容 注：上面的$都是命令提示符，复制粘贴时不需要</description></item><item><title>tmp</title><link>https://111qqz.com/2016/04/tmp/</link><pubDate>Wed, 13 Apr 2016 12:10:55 +0000</pubDate><guid>https://111qqz.com/2016/04/tmp/</guid><description>
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int N=1E4+7; int n,k,Q; int siz; int pos[N]; int sum[N]; int dis[N]; bool vis[N]; vector &amp;lt; pair&amp;lt;int,int&amp;gt; &amp;gt; edge[N]; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (pos[l]==pos[b.l]) return r&amp;lt;b.r; return pos[l]&amp;lt;pos[b.l]; } }q[N]; void dfs( int u,int val) { vis[u] = true; dis[u+1] = val; int Siz = edge[u].</description></item><item><title>NYOJ 505 因子和阶乘</title><link>https://111qqz.com/2016/01/nyoj-505-/</link><pubDate>Wed, 20 Jan 2016 07:08:01 +0000</pubDate><guid>https://111qqz.com/2016/01/nyoj-505-/</guid><description>
http://acm.nyist.net/JudgeOnline/problem.php?pid=509 题意：中文题目。。。 思路：快速筛即可。。。妈蛋。。。这个oj不能用宏编译==。。。然后一直TLE...去掉了就好了。。sad
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 13时53分54秒 File Name :code/nyoj/509.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=10500; int n; int pri[N]={0}; int npri[N]={1,1}; int num[N]; int cnt; void pre() { cnt = 0 ; for ( int i = 2 ; i &amp;lt; N ; i++) { if (!</description></item><item><title>poj 1350 Cabric Number Problem</title><link>https://111qqz.com/2016/01/poj1350/</link><pubDate>Wed, 20 Jan 2016 05:29:46 +0000</pubDate><guid>https://111qqz.com/2016/01/poj1350/</guid><description>
http://poj.org/problem?id=1350
题意：6174问题。。。一个四位数。。四个数字重排。。。最大的减去最小的得到新的数字。最后一定能得到6174或者0.除非这个四位数的四个数字都一样。写出变化的过程。
思路：。。。可能不是不四位数。。略坑。然后写了下字符串和数字相互转化的两个函数。嗯。
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 12时51分41秒 File Name :code/poj/1350.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int cnt; int get_next( int x) { int a,b,len; char st[10]; sprintf(st,&amp;quot;%d&amp;quot;,x); len = strlen(st); // if (len&amp;lt;4) return -1; if (st[0]==st[1]&amp;amp;&amp;amp;st[1]==st[2]&amp;amp;&amp;amp;st[2]==st[3]&amp;amp;&amp;amp;st[3]==st[0]) return -1; for ( int i = 0 ; i &amp;lt; len ; i++) for ( int j = i+1 ; j &amp;lt; len ; j++) if (st[i]&amp;lt;st[j]) swap(st[i],st[j]); sscanf(st,&amp;quot;%d&amp;quot;,&amp;amp;a); // cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; for ( int i = 0 ;i &amp;lt; len/2 ; i++) swap(st[i],st[len-1-i]); // cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; sscanf(st,&amp;quot;%d&amp;quot;,&amp;amp;b); printf(&amp;quot;%d-%d=%d\n&amp;quot;,a,b,a-b); return a-b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>linux mint gedit 中文乱码</title><link>https://111qqz.com/2015/12/linux-mint-gedit-/</link><pubDate>Mon, 28 Dec 2015 12:46:05 +0000</pubDate><guid>https://111qqz.com/2015/12/linux-mint-gedit-/</guid><description>
gconftool-2 --set --type=list --list-type=string /apps/gedit-2/preferences/encodings/auto_detected &amp;quot;[UTF-8,CURRENT,GB18030,ISO-8859-15,UTF-16]&amp;quot;</description></item><item><title>在linux mint 上安装 Oracle JDK 的方法</title><link>https://111qqz.com/2015/12/linux-mint--oracle-jdk-/</link><pubDate>Mon, 28 Dec 2015 08:17:03 +0000</pubDate><guid>https://111qqz.com/2015/12/linux-mint--oracle-jdk-/</guid><description>
Open up the Terminal (Alt + F2 &amp;gt; Terminal).
Remove OpenJDK installation.
sudo apt-get update &amp;amp;&amp;amp; apt-get remove openjdk*
Download Oracle JDK from here. You are looking for a linux version with tar.gz extension. Also choose the right version from 32-bit (x86) and 64bit (x64) one.
Change directory into one with downloaded tarball. In my case $HOME/Downloads.
cd ~/Downloads
Extract tarball.</description></item><item><title>codeforces 519 C. A and B and Team Training</title><link>https://111qqz.com/2015/12/cf519c/</link><pubDate>Mon, 14 Dec 2015 10:53:21 +0000</pubDate><guid>https://111qqz.com/2015/12/cf519c/</guid><description>
http://codeforces.com/problemset/problem/519/C 题意：两种组队方式，3人一组，1个大牛+2个蒟蒻或者1个蒟蒻+2个大牛。给定大牛和蒟蒻的个数。问最多能组多少队。 思路：线性规划。设两种队分别有x,y个即可。 突然发现这题以前做过。。。比当时的代码简单了一些。还不错。
/* *********************************************** Author :111qqz Created Time :2015年12月14日 星期一 18时31分10秒 File Name :code/cf/problem/519C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces #334 div 2 C. Alternative Thinking</title><link>https://111qqz.com/2015/12/codeforces-334-div-2-c-alternative-thinking/</link><pubDate>Wed, 02 Dec 2015 08:54:38 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-334-div-2-c-alternative-thinking/</guid><description>
题意：给定一个01串。要进行一次变换：选一段连续的非空的字串，将这段串的0和1反转（0变成1,1变成0） 然后问能得到的最长的0,1交替的序列的长度是多少（不一定连续）
比赛的时候想出来两种会将答案增加的可能情况。一种是10000001 中间有大于等于3个的连续字符，这样可以把中间反转一下，答案会+2 另外一种是 1001001 这样。。有至少两段的连续两个以上的相同字符被另一个字符隔开的情况。只要将1001001变成1010101。答案还是会+2。。。然后发现这两种情况实际上可以统一起来。即：有至少两段的连续相同字符。 注意000 也算有两段。 如果有两段或者以上，那么答案+2.
/* *********************************************** Author :111qqz Created Time :2015年12月02日 星期三 00时36分47秒 File Name :code/cf/#334/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N]; int n; char tow(char ch) { if (ch=='0') return '1'; if (ch=='1') return '0'; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>test</title><link>https://111qqz.com/2015/12/test/</link><pubDate>Tue, 01 Dec 2015 07:04:19 +0000</pubDate><guid>https://111qqz.com/2015/12/test/</guid><description>
应大家的要求，写一篇博客来介绍下vim在ACM中的简单使用。
写本文的目的，只是为了给广大acmer一个入门vim的指导。不喜勿喷！ 不想看到的请远离！
vim大法好，远离sublime、cb保平安！
从13年开始，平时写程序和比赛都是用的vim，也一直在推荐大家使用vim，至于为何要用vim，原因很多。
为何要使用vim？1) 可以装逼，vim显得高端大气上档次，现场赛你打开的是丑陋的CB，别人打开的是VIM，高下立判。 2) 用vim可以明显提高写代码的感觉，加快代码速度。3) vim大法好。
当然，前面纯粹个人胡扯，要用啥都是个人偏好而已。
下面简单介绍VIM的使用。
比赛篇 首先介绍vim在比赛使用的使用。
先大致介绍现场赛vim的配置方法。
现场赛比赛系统是ubuntu， 都是安装好了vim的。
ubuntu系统下打开终端（终端一般在左侧有了，没有就按Ctrl+Alt+T启动，然后可以锁定在左侧），打开终端输入vim就进入vim了。
配置方法是输入 vim ~/.vimrc (这样是用vim编辑配置文件，或者用 gedit ~/.vimrc 就是用gedit编辑了)
配置的话，按照自己习惯加几句配置文件就可以使用了。
我一般配置下面几个：
C++
syntax on set nu set tabstop=4 set shiftwidth=4 colo evening set mouse=a set cin
&amp;lt;table class=&amp;quot;crayon-table&amp;quot; &amp;gt; &amp;lt;tr class=&amp;quot;crayon-row&amp;quot; &amp;gt; 1
2
3
4
5
6
7
syntax on
set nu
set tabstop=4
set shiftwidth=4
colo evening
set mouse=a</description></item><item><title>atom在linux下安装插件失败的解决方案</title><link>https://111qqz.com/2015/12/atomlinux/</link><pubDate>Mon, 30 Nov 2015 17:27:17 +0000</pubDate><guid>https://111qqz.com/2015/12/atomlinux/</guid><description>
gyp info it worked if it ends with ok gyp info using node-gyp@2.0.2 gyp info using node@0.10.40 | linux | x64 gyp http GET https://atom.io/download/atom-shell/v0.34.0/node-v0.34.0.tar.gz gyp WARN install got an error, rolling back install gyp ERR! install error gyp ERR! stack Error: This is most likely not a problem with node-gyp or the package itself and gyp ERR! stack is related to network connectivity. In most cases you are behind a proxy or have bad gyp ERR!</description></item><item><title>wordpress无法创建目录/没有写权限的解决方案</title><link>https://111qqz.com/2015/11/wordpress/</link><pubDate>Mon, 30 Nov 2015 02:44:19 +0000</pubDate><guid>https://111qqz.com/2015/11/wordpress/</guid><description>
终于解决了。
的确是权限问题。
但是由于初始化的时候，我错误的设置了数据库目录。应该为/alidata/www/serve/mysql ，而我设置成了/home/mysql
之前一直是在改alidata下的权限...现在可以了QAQ</description></item><item><title>博客算是搭好了？</title><link>https://111qqz.com/2015/11/</link><pubDate>Sun, 29 Nov 2015 11:18:01 +0000</pubDate><guid>https://111qqz.com/2015/11/</guid><description>
然而不能上传...
插件也是。在线安装也不可以。
google遍了只看到说是权限问题。
然而wp-content整个目录都已经chmod 777了...依然不可以。
日了狗了。</description></item><item><title>世界，您好！</title><link>https://111qqz.com/2015/11/hello-world/</link><pubDate>Sun, 29 Nov 2015 08:13:34 +0000</pubDate><guid>https://111qqz.com/2015/11/hello-world/</guid><description>
欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</description></item></channel></rss>