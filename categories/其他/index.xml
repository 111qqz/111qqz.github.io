<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>其他 on 111qqz的小窝</title><link>https://111qqz.com/categories/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on 111qqz的小窝</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2012-2022 all rights reserved.</copyright><lastBuildDate>Wed, 02 Feb 2022 19:56:49 +0800</lastBuildDate><atom:link href="https://111qqz.com/categories/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>博客除草</title><link>https://111qqz.com/2022/02/better-blog/</link><pubDate>Wed, 02 Feb 2022 19:56:49 +0800</pubDate><guid>https://111qqz.com/2022/02/better-blog/</guid><description>
博客要长草了。。趁着过年时间多，打理一下。。
添加google analytics hugo本身已经集成了这个功能 要点是集成的是旧版本的universal analytics (对应的是UA-ID) 而目前google主推得其实是新版本google analytics 4(对应的是GA4-ID)
更换主题 更换主题为 hugo-clarity
最主要的原因是之前的博客主题语法高亮有些问题...
cpp中代码添加了注释后，会将代码显示在注释的同一行 proto文件不能正确换行 所以换了个可以正确解析语法的主题...
问题1 github actions执行正常，访问渲染好的页面提示
1 2This page contains the following errors: 3error on line 50 at column 394: PCDATA invalid Char value 8 4 最终发现原因是没有清除掉旧theme的 git submodule 清除后问题解决
同时更新了一下github actions中 hugo的版本为extented版本
问题2 algolia 更新报错，似乎是json文件没生成。 由于搜索功能使用频率也不太高，暂时禁止掉
1- name:upload algolia data2uses:actions/setup-node@v23with:4node-version:&amp;#39;12&amp;#39;5- run:npm run algolia问题3 图片无法显示，提示&amp;quot;error not found&amp;quot;
目测是blog的一个bug,已经提了issue
暂时fork了一份，修改了代码绕过去
故障修复</description></item><item><title>yuv 图像格式初探</title><link>https://111qqz.com/2019/07/Yuv-Image-Format/</link><pubDate>Wed, 03 Jul 2019 20:31:11 +0800</pubDate><guid>https://111qqz.com/2019/07/Yuv-Image-Format/</guid><description>
概述 YUV是一种图像编码方式,或者称为色彩空间,与RGB是同级的概念. YUV是三个分量,Y,U和V,其中:
Y 表示明亮度(Luminance或Luma),也就是灰度值, U,V表示色度,浓度（Chrominance、Chroma）,可以简单理解成用来表示某个像素的颜色的量. YUV格式的特点是,在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。 也就是说,YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。
其中YCbCr是YUV压缩和偏移的版本。YCbCr的Y与YUV中的Y含义一致，Cb和Cr与UV同样都指色彩，Cb指蓝色色度，Cr指红色色度，在应用上很广泛，JPEG、MPEG、DVD、摄影机、数字电视等皆采此一格式。因此一般俗称的YUV大多是指YCbCr。
YUV采样方式 主流的采样方式有三种: 其中Y 分量用叉表示，UV 分量用圆圈表示。
YUV4:4:4 YUV4:2:2 YUV4:2:0 下面三张图分别为YUV444,YUV422和YUV420的采样方式. 但是注意,上面的三张图只是说明了每个分量的比例,并不能说明排列方式.
需要注意的是yuv420并不是说只采样U分量或者只采样V分量,而是指，在每一行扫描时，只扫描一种色度分量（U 或者 V），和 Y 分量按照 2 : 1 的方式采样。比如，第一行扫描时，YU 按照 2 : 1 的方式采样，那么第二行扫描时，YV 分量按照 2:1 的方式采样
YUV封装格式 采样方式主要是告诉我们各个分量的比例,下面看一下封装格式. YUV格式有两大类：planar和packed。
planar: 先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 packed: 每个像素点的Y,U,V是连续交错存储的。 其中,planar格式还分为SEMI PLANAR和PLANAR
semi planar:先连续存储所有的Y, 然后UV交错存储. planar:先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。 以YUV420为例,前面的图为平面的封装格式,也就是YUV420P(Planar) 后面的图为半平面的封装格式,也就是YUV420SP(semi planar) 或者以1920*1080的图片具体举例:
左边的图为平面的封装格式,也就是YUV420P(Planar) 右边的图为半平面的封装格式,也就是YUV420SP(semi planar) YUV格式的名称,傻傻分不清楚 由于最近使用的YUV420格式的,因此主要会涉及这一种. YUV420分为YUV420P和YUV420SP两种. 其中YUV420P又有两种,一种是Y(w×h) + U(w×h/4) + V(w×h/4)的格式,这一种也叫I420或者420P或者IYUV(存疑,参考opencv convert_color函数文档) 另一种是Y(w×h) + V(w×h/4) + U(w×h/4)的格式,这一种也叫YV12</description></item><item><title>How to use Scrapy with Django Application（转自medium）</title><link>https://111qqz.com/2018/11/how-to-use-scrapy-with-django-application/</link><pubDate>Tue, 06 Nov 2018 13:33:00 +0000</pubDate><guid>https://111qqz.com/2018/11/how-to-use-scrapy-with-django-application/</guid><description>
在meidum上看到一篇很赞的文章...无奈关键部分一律无法加载出来...挂了梯子也不行，很心塞...刚刚突然发现加载出来了...以防之后再次无法访问，所以搬运过来．
There are couple of articles on how to integrate Scrapy into a Django Application (or vice versa?). But most of them don’t cover a full complete example that includes triggering spiders from Django views. Since this is a web application, that must be our main goal.
What do we need ? Before we start, it is better to specify what we want and how we want it. Check this diagram:</description></item><item><title>lua学习笔记</title><link>https://111qqz.com/2018/10/lua-notes/</link><pubDate>Fri, 26 Oct 2018 02:47:59 +0000</pubDate><guid>https://111qqz.com/2018/10/lua-notes/</guid><description>
lua是一门轻量级的脚本语言...好像比较适合写游戏？在 太阳神三国杀 中见过很多lua脚本。 由于splash 的渲染脚本需要用lua来写，因此来学习一波。
直接上语法...看到了python和pascal的影子orz
-- Two dashes start a one-line comment. --[[ Adding two ['s and ]'s makes it a multi-line comment. --]] ---------------------------------------------------- -- 1. Variables and flow control. ---------------------------------------------------- num = 42 -- All numbers are doubles. -- Don't freak out, 64-bit doubles have 52 bits for -- storing exact int values; machine precision is -- not a problem for ints that need &amp;lt; 52 bits. s = 'walternate' -- Immutable strings like Python.</description></item><item><title>golang 学习笔记</title><link>https://111qqz.com/2018/10/golang-notes/</link><pubDate>Sat, 20 Oct 2018 11:06:56 +0000</pubDate><guid>https://111qqz.com/2018/10/golang-notes/</guid><description>
先放资料,可能比较侧重于go在系统调用方面的内容.
这里不会记录详细的go的语法,只会记录学习的过程,踩到的坑,以及其他我认为值得记录的内容.
go的switch语句终于是人类思维的语句了...匹配中了不需要加break..
defer关键字可以延迟语句到上层函数退出时再执行,而且是会把延迟的语句压入栈,然后按照FILO的顺序执行...好像有点有意思?
参数列表..如果有多个变量的类型相同,只写一个类型关键字就行...
:=并不是pascal中的赋值符号(浪费感情...,而是简洁定义变量的语法,不能使用在函数以外.
感觉go中同时有一点C++和很多python的影子...
30分钟上手GO语言--基础语法
A Go Programmer’s Guide to Syscalls
视频笔记：Go 和 syscall - Liz Rice</description></item><item><title>爬虫学习笔记</title><link>https://111qqz.com/2018/10/web-crawler-notes/</link><pubDate>Fri, 19 Oct 2018 08:18:53 +0000</pubDate><guid>https://111qqz.com/2018/10/web-crawler-notes/</guid><description>
再次迫于生计。。。
参考了面向新人的 Python 爬虫学习资料
大致的学习路线为:
一： 简单的定向脚本爬虫（ request --- bs4 --- re ） 二： 大型框架式爬虫（ Scrapy 框架为主）
三：浏览器模拟爬虫 （ Mechanize 模拟 和 Selenium 模拟）
有Python基础和一点html基础的话。。。貌似上手是0难度的
年轻人的第一个爬虫(虽然代码是直接copy的...
''' 抓取百度贴吧---生活大爆炸吧的基本内容 爬虫线路： requests - bs4 Python版本： 3.6 OS： mac os 12.12.4 ''' import requests import time from bs4 import BeautifulSoup # 首先我们写好抓取网页的函数 def get_html(url): try: r = requests.get(url, timeout=30) r.raise_for_status() # 这里我们知道百度贴吧的编码是utf-8，所以手动设置的。爬去其他的页面时建议使用： # r.endcodding = r.apparent_endconding r.encoding = 'utf-8' return r.text except: return &amp;quot; ERROR &amp;quot; def get_content(url): ''' 分析贴吧的网页文件，整理信息，保存在列表变量中 ''' # 初始化一个列表来保存所有的帖子信息： comments = [] # 首先，我们把需要爬取信息的网页下载到本地 html = get_html(url) # 我们来做一锅汤 soup = BeautifulSoup(html, 'lxml') # 按照之前的分析，我们找到所有具有‘ j_thread_list clearfix’属性的li标签。返回一个列表类型。 liTags = soup.</description></item><item><title>解决ubuntu 14.04 下 壁纸软件 variety 崩溃 ValueError: bad marshal data (unknown type code) 的问题</title><link>https://111qqz.com/2018/09/the-way-to-fix-variety-crash-on-ubuntu-14-04/</link><pubDate>Sun, 30 Sep 2018 08:59:31 +0000</pubDate><guid>https://111qqz.com/2018/09/the-way-to-fix-variety-crash-on-ubuntu-14-04/</guid><description>
系统为ubuntu 14.04
迫于特别想定时换壁纸，查了下解决方案。
发现只要删除掉/usr目录下所有的'.pyc'文件就可以
命令为:sudo find /usr -name '*.pyc' -delete</description></item><item><title>[设计模式] 组合模式（composite） 学习笔记</title><link>https://111qqz.com/2018/08/Composite-Pattern-notes/</link><pubDate>Tue, 28 Aug 2018 06:30:59 +0000</pubDate><guid>https://111qqz.com/2018/08/Composite-Pattern-notes/</guid><description>
目的是忽略单一对象和组合对象的不同。 有点像以前写过的用链表定义一个树结构，每个节点是一个val + 多个tree 。如果某个节点是叶子节点了，那么对应的tree都为NULL. 只不过这里用了更加面向对象的实现。
具体看代码：
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年08月28日 星期二 14时21分51秒 File Name :composite.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; class Component { // 为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为 protected: string name; public: Component(string n) { name = n; } virtual ~Component() {} virtual void Add(Component* c) = 0; virtual void Remove(Component* c) = 0; virtual void Display(int depth) = 0; }; class Leaf : public Component { // 在组合中表示叶节点对象，叶节点没有子节点 public: Leaf(string name) : Component(name) {} void Add(Component* c){} // 叶节点没有Add功能，但这样做能使接口具备一致性，这就是透明方式，如果不加入Add和Remove方法，那就是安全方式。 void Remove(Component* c){} // 同上 void Display(int depth) { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; endl; } }; class Composite : public Component { // 定义有枝节点行为，用来存储子部件 private: list&amp;lt;Component* &amp;gt; children; public: Composite(string name) : Component(name) {} void Add(Component* c) { children.</description></item><item><title>使用python计算误差代码</title><link>https://111qqz.com/2018/08/calculate-error-with-python/</link><pubDate>Mon, 06 Aug 2018 11:54:35 +0000</pubDate><guid>https://111qqz.com/2018/08/calculate-error-with-python/</guid><description>
import os import math ave_err=0.0 max_err=0.0 max_err_rate=0.0 length=0 with open(&amp;quot;cpu_result.txt&amp;quot;,&amp;quot;r&amp;quot;) as fp1, open(&amp;quot;cuda_ppl_result.txt&amp;quot;,&amp;quot;r&amp;quot;) as fp2: for l1 in fp1: l2 = fp2.readline() l1=l1[:-2] l2=l2[:-2] lst = l1.split(' ') lst2 = l2.split(' ') #print lst lst = [float(x) for x in lst ] length = length + len(lst) lst2 = [float(x) for x in lst2] #print (lst) #print (lst2)
for index,x in enumerate(lst): y = lst2[index] ave_err = ave_err + abs(x-y) max_err = max(max_err,abs(x-y)) max_err_rate = max(max_err_rate,abs(x-y)/x) print(&amp;quot;len=&amp;quot;,length) print(&amp;quot;max_err=&amp;quot;,max_err) print(&amp;quot;max_err_rate=&amp;quot;,max_err_rate*100,&amp;quot;%&amp;quot;) print(&amp;quot;ave_err=&amp;quot;,ave_err/length) 需要提供两个文件，并且两个文件的数据格式相同。</description></item><item><title>intel tbb 学习笔记</title><link>https://111qqz.com/2018/07/intel-tbb-notes/</link><pubDate>Wed, 18 Jul 2018 06:57:38 +0000</pubDate><guid>https://111qqz.com/2018/07/intel-tbb-notes/</guid><description>
tbb是**Threading Building Blocks library的缩写,**是一个为开发者提供并行解决方案的库.
先放个文档https://www.threadingbuildingblocks.org/intel-tbb-tutorial
再放一个代码示例:
/* *********************************************** Author :111qqz mail: renkuanze@sensetime.com Created Time :2018年07月18日 星期三 14时20分54秒 File Name :parallel_for.cpp ************************************************ */ #include &amp;lt;iostream&amp;gt; #include &amp;quot;tbb/tbb.h&amp;quot; #include &amp;lt;chrono&amp;gt; using namespace std; using namespace tbb; const int N=1E9+7; float a[N+5]; void Foo(float &amp;amp;x) { x -= 100; } void SerialApplyFoo( float a[], size_t n ) { for( size_t i=0; i!=n; ++i ) Foo(a[i]); } class ApplyFoo { float *const my_a; public: void operator()(const blocked_range&amp;lt;size_t&amp;gt; &amp;amp;r) const { float *a = my_a; for (size_t i = r.</description></item><item><title>Kafka 学习笔记</title><link>https://111qqz.com/2018/07/kafka-notes/</link><pubDate>Mon, 02 Jul 2018 08:56:52 +0000</pubDate><guid>https://111qqz.com/2018/07/kafka-notes/</guid><description>
先放资料．
kafka简明教程</description></item><item><title>linux 下C++ 连接mysql 数据库</title><link>https://111qqz.com/2018/07/connect-mysql-with-cpp-under-linux/</link><pubDate>Mon, 02 Jul 2018 07:02:28 +0000</pubDate><guid>https://111qqz.com/2018/07/connect-mysql-with-cpp-under-linux/</guid><description>
资料推荐这个:MySQL C API programming tutorial
环境为ubuntu 14.04 lts
需要安装mysql 和mysql 开发包
sudo apt-get install libmysqlclient15-dev mysql-server mysql-client
先在mysql 中建立test数据库和test表格
　mysql&amp;gt;create database test; mysql&amp;gt;use test; //切换到test数据库中 mysql&amp;gt; create table test(name varchar(255),num int(10) ); //创建一个叫test的表 mysql&amp;gt;show create table test; //显示刚才创建的表信息 mysql&amp;gt; select * from test; //查询test表中数据 mysql&amp;gt;quit 然后用如下cpp代码连接
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;mysql.h&amp;gt; #include &amp;lt;cstring&amp;gt; int main(int argc,char *argv[]) { MYSQL conn; int res; mysql_init(&amp;amp;conn); if (mysql_real_connect(&amp;amp;conn,&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;2254965&amp;quot;,&amp;quot;test&amp;quot;,0,NULL,CLIENT_FOUND_ROWS)) { puts(&amp;quot;connect success&amp;quot;); res = mysql_query(&amp;amp;conn,&amp;quot;insert into test values('sensetime','23333')&amp;quot;); if (res) puts(&amp;quot;error&amp;quot;); else puts(&amp;quot;success&amp;quot;); printf(&amp;quot;res=%d\n&amp;quot;,res); } return 0; } 编译:</description></item><item><title>使用haproxy中转酸酸流量</title><link>https://111qqz.com/2018/05/shadowsocks-with-haproxy/</link><pubDate>Tue, 15 May 2018 06:27:35 +0000</pubDate><guid>https://111qqz.com/2018/05/shadowsocks-with-haproxy/</guid><description>
一个国内vps，一个国外vps.
前提是国外vps已经配置好。
接下来，我们在国内vps上安装haproxy
yum -y install haproxy 或者 apt-get install haproxy
然后修改配置文件,位置在/etc/haproxy/haproxy.cfg
global defaults log global mode tcp option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend ss-in bind *:[port] default_backend ss-out backend ss-out server server1 [ip]:[port] maxconn 20480 把其中的[ip]和[port]替换成国外vps的ip和相应服务的port
然后在客户端，ip填写国内vps的ip,密码还是酸酸的密码，其他保持一致。</description></item><item><title>wordpress 开启全站https</title><link>https://111qqz.com/2018/05/enable-https-for-wordpress/</link><pubDate>Mon, 14 May 2018 13:08:30 +0000</pubDate><guid>https://111qqz.com/2018/05/enable-https-for-wordpress/</guid><description>
20190511更新:
证书到期了,写一下更换证书的流程.
重新申请好证书之后,直接把Apache里面对应的123放到/data/cert文件夹.
其中1对应server-ca.crt,2对应server.crt,3对应server.key
由于从套路云转移到良心云，迫于国内某些蛋疼的政策，以及一些其他原因，决定全站上https.
首先是申请SSL证书，这个良心云就可以申请，也有其他地方。
这里要注意的是，有些证书是只能对应一个域名，腾讯云貌似就是这样，不过好像www.111qqz.com的证书也可以用于111qqz.com
得到证书中有Apache,Nginx,Tomcat和IIS四个文件夹，由于我们使用的是Apache，所以其他三个不用管。
1. 将证书上传到服务器证书目录：/data/cert（没有cert目录可以自己新建） 2. 在/etc/httpd/conf.d目录下新建一个https配置文件，假设命名为mydomain-ssl.conf。 3. 拷贝下面的https配置文件模板到mydomain-ssl.conf文件中，并保存 &amp;lt;VirtualHost *:443&amp;gt; ServerName www.111qqz.com ServerAlias 111qqz.com DocumentRoot &amp;quot;/data/wwwroot/default/wordpress&amp;quot; #ErrorLog &amp;quot;logs/www.mydomain.com-error_log&amp;quot; #CustomLog &amp;quot;logs/www.mydomain.com-access_log&amp;quot; common &amp;lt;Directory &amp;quot;/data/wwwroot/default/wordpress&amp;quot;&amp;gt; Options Indexes FollowSymlinks AllowOverride All Require all granted &amp;lt;/Directory&amp;gt; SSLEngine on SSLCertificateFile /data/cert/server.crt SSLCertificateKeyFile /data/cert/server.key SSLCertificateChainFile /data/cert/server-ca.crt &amp;lt;/VirtualHost&amp;gt; 需要注意的是，servername那里要写带www的域名，不带www的写在serveralias 4. 修改配置文件中相关项，并保存 ServerName #主域名，务必修改 ServerAlias #副域名，可选项 DocumentRoot #网站路径，务必填写网站实际路径，例如:/data/wwwroot/default/wordpress Directory #同上 SSLCertificateFile #证书，务必填写网站实际路径 SSLCertificateKeyFile #证书私钥，务必填写网站实际路径 SSLCertificateChainFile #证书链（CA文件），务必填写网站实际路径
然后由于我是迁移了服务器，很大可能是主页可以访问，但任何一个其他页面都会因报错500 internal error 之类，查看日志，位置在/var/log/httpd 里面，发现报错AH00124: Request exceeded the limit of 10 internal redirects due to probable configuration error.</description></item><item><title>vim 插件 NERDTree 学习笔记</title><link>https://111qqz.com/2018/04/vim-NERDTree-plugin/</link><pubDate>Mon, 30 Apr 2018 05:54:33 +0000</pubDate><guid>https://111qqz.com/2018/04/vim-NERDTree-plugin/</guid><description>
迫于要在服务器上写cpp代码，又由于各种原因，没办法把同步到本地。因此要在服务器上配置一个cpp的环境orz.
我是用vim-plug来管理插件的，只需要添加
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } 就好了。 下面记录一些会用到的快捷键:
ctrl+w类似tmux里面的功能键。
crtl+w+w: 光标自动在左右侧窗口切换
cril+w+r:调换左右侧窗口的布局位置
t 在新 Tab 中打开选中文件/书签，并跳到新 Tab T 在新 Tab 中打开选中文件/书签，但不跳到新 Tab gT 前一个 tab gt 后一个 tab</description></item><item><title>gRPC学习笔记</title><link>https://111qqz.com/2018/04/grpc-notes/</link><pubDate>Sun, 29 Apr 2018 16:18:47 +0000</pubDate><guid>https://111qqz.com/2018/04/grpc-notes/</guid><description>
gRPC 是 google 最新发布的开源 RPC 框架, 声称是&amp;quot;一个高性能，开源，将移动和HTTP/2放在首位的通用的RPC框架.&amp;quot;. 技术栈非常的新, 基于HTTP/2, netty4.1, proto3, 拥有非常丰富而实用的特性, 堪称新一代RPC框架的典范.
//上面这段话是我抄的，其实我之前连RPC是什么都不知道，
关于RPC，如果你和我一样根本不知道是什么，请参考这里 
我对RPC的理解就是，一层封装，使得不在同一个机器上的程序A可以一个调用另一个程序B，而不需要考虑这两台机器，以及这两个程序使用的语言的不同。
而gRPC是诸多RPC框架中比较新，也比较好用的一个。
学习gRPC需要会使用protobuf3,关于protobuf，可以参考protobuf学习笔记
官方文档 还是要给出的，虽然我没怎么看就是了orz
gRPC的安装 参考这个，从源码编译安装
$ [sudo] apt-get install build-essential autoconf libtool pkg-config $ [sudo] apt-get install libgflags-dev libgtest-dev $ [sudo] apt-get install clang libc++-dev $ git clone -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc $ cd grpc $ git submodule update --init $ make $ [sudo] make install 如果出现
configure: error: cannot find install-sh, install.</description></item><item><title>8102年了，来更新一波vim配置</title><link>https://111qqz.com/2018/04/vim-config-in-2018/</link><pubDate>Wed, 25 Apr 2018 16:46:51 +0000</pubDate><guid>https://111qqz.com/2018/04/vim-config-in-2018/</guid><description>
现在用的vim配置还是2015年7月的时候写的。
三年过去了，vim到了8.0,很多功能也有了更多选择。因此打算来更新一波vim配置。目前还在更新过程中。。。等差不多折腾完再来记录一些信息。
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; for vim &amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; set ru set nu set clipboard+=unnamed &amp;quot; 映射全选+复制 ctrl+a map &amp;lt;C-A&amp;gt; ggvG&amp;quot;+Y &amp;quot;去空行 nnoremap &amp;lt;F2&amp;gt; :g/^\s*$/d&amp;lt;CR&amp;gt; &amp;quot; 自动缩进 set autoindent set tabstop=4 set softtabstop=4 set shiftwidth=4 filetype on &amp;quot; 载入文件类型插件 filetype plugin on &amp;quot; 为特定文件类型载入相关缩进文件 filetype indent on &amp;quot; 高亮显示匹配的括号 set showmatch &amp;quot; 高亮当前行 set cursorline hi CursorLine cterm=bold ctermbg=blue ctermfg=yellow &amp;quot;C，C++ 按F5编译运行 map &amp;lt;F5&amp;gt; :call CompileRunGcc()&amp;lt;CR&amp;gt; func! CompileRunGcc() exec &amp;quot;w&amp;quot; if &amp;amp;filetype == 'c' exec &amp;quot;!</description></item><item><title>protobuf学习笔记</title><link>https://111qqz.com/2018/04/protobuf-notes/</link><pubDate>Tue, 24 Apr 2018 03:05:09 +0000</pubDate><guid>https://111qqz.com/2018/04/protobuf-notes/</guid><description>
Protobuff 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。
之前由于要用levelDB存feature,而levelDB的key只能是string(?,反正不能是一个数组)， 使用了protobuf. protobuf本身还比较easy,不过目前似乎protobuf2仍然是主流，但是由于最近在看gRPC的缘故，要使用protobuf3.　如果protobuf2没有卸载干净，绝对欲仙欲死...记录一些坑．详细一点的笔记之后补．
// protobuf3坑好多啊...语法全靠猜，也是有毒 
行吧，怪我没找到orz,生成的cpp语法部分在 这里。
先放参考资料好了。一开始找到一个pdf文档，说是官方文档的翻译版...但实际上感觉，讲得很烂。直接看官方文档比较好。
其中Language Guide (proto3) 讲了protobuf3的proto文件的语法相关。
Protocol Buffer Basics: C++ 讲了怎么从编写proto文件到在cpp中使用的一般步骤（注意此处貌似是按照protobuf2讲的）
C++ Generated Code 讲了生成的cpp代码的接口，并且强调了protobuf2和protobuf3的区别。
syntax = &amp;quot;proto3&amp;quot;; package test; message Feature { int32 ver = 1; int32 idx = 2; int32 len = 3; repeated float feat = 4; } 生成相应代码的语法为: protoc --cpp_out=. test.proto
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;quot;test.pb.h&amp;quot; using namespace std; using namespace test; int main() { float arr[10]={4,5,6,7,8,9}; Feature feature; puts(&amp;quot;def feature&amp;quot;); float ft; for ( int i = 0 ; i &amp;lt; 4 ; i++) { feature.</description></item><item><title>Eigen: C++开源矩阵学习笔记</title><link>https://111qqz.com/2018/04/eigen-notes/</link><pubDate>Thu, 05 Apr 2018 07:14:54 +0000</pubDate><guid>https://111qqz.com/2018/04/eigen-notes/</guid><description>
接触Eigen的原因是最近在看caffe/caffe2源码,caffe2中使用了Eigen库. Eigen 是一个基于C++模板的线性代数库，直接将库下载后放在项目目录下，然后包含头文件就能使用，非常方便。对于Linux用户,只需要把头文件放到/usr/include 下即可此外，Eigen的接口清晰，稳定高效。
之后会更新一些,Eigen中我使用过的函数.
ubuntu14.04LTS 下使用方式: sudo apt-get install libeigen3-dev cd /usr/include/eigen3 sudo cp -R Eigen /usr/include 然后尝试运行如下代码,直接编译即可.如果可以正常运行,表明安装完毕.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;Eigen/Dense&amp;gt; //using Eigen::MatrixXd; using namespace Eigen; using namespace Eigen::internal; using namespace Eigen::Architecture; using namespace std; int main() { cout&amp;lt;&amp;lt;&amp;quot;*******************1D-object****************&amp;quot;&amp;lt;&amp;lt;endl; Vector4d v1; v1&amp;lt;&amp;lt; 1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v1=\n&amp;quot;&amp;lt;&amp;lt;v1&amp;lt;&amp;lt;endl; VectorXd v2(3); v2&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v2=\n&amp;quot;&amp;lt;&amp;lt;v2&amp;lt;&amp;lt;endl; Array4i v3; v3&amp;lt;&amp;lt;1,2,3,4; cout&amp;lt;&amp;lt;&amp;quot;v3=\n&amp;quot;&amp;lt;&amp;lt;v3&amp;lt;&amp;lt;endl; ArrayXf v4(3); v4&amp;lt;&amp;lt;1,2,3; cout&amp;lt;&amp;lt;&amp;quot;v4=\n&amp;quot;&amp;lt;&amp;lt;v4&amp;lt;&amp;lt;endl; } map的使用办法: double arr[9]={1,2,3,4,5,6,7,8,9}; Map A(arr,3,3); 得到 1 4 7 2 5 8 3 6 9</description></item><item><title>linux/win双系统 更新win后 grub 出现 Error: unknown filesystem 的解决办法</title><link>https://111qqz.com/2018/04/the-way-to-fix-unkown-filesystem-error-in-grub/</link><pubDate>Sun, 01 Apr 2018 06:28:30 +0000</pubDate><guid>https://111qqz.com/2018/04/the-way-to-fix-unkown-filesystem-error-in-grub/</guid><description>
windows自己更新把grub更新挂了....
更新的时候要重启几次,重启一次挂一次...
讲真,windows(或者说win10?) 是我见过的最辣鸡的OS了... 自己把自己弄挂这事不是一两次了.
下面说修复办法:
先ls,得到一堆诸如(hd0,gpt7) 这种
然后选设X=第一个(x,y)形式的输出
之后
&amp;lt;code&amp;gt;set root=X set prefix=X/boot/grub insmod normal normal &amp;lt;/code&amp;gt; 然后记得要进入linux分区..... 执行: sudo update-grub sudo grub-install /dev/sda
总结:珍爱生命,远离辣鸡windows!!!!! 珍爱生命,远离辣鸡windows!!!!! 珍爱生命,远离辣鸡windows!!!!!</description></item><item><title>mysql 出现　innoDB: Cannot allocate memory for the buffer pool　的解决办法</title><link>https://111qqz.com/2018/03/the-way-to-fix-mysql-innodb-cannot-allocate-memory/</link><pubDate>Thu, 15 Mar 2018 04:56:58 +0000</pubDate><guid>https://111qqz.com/2018/03/the-way-to-fix-mysql-innodb-cannot-allocate-memory/</guid><description>
emmm,博客的数据库又挂了。
看了下log，发现innoDB: Cannot allocate memory for the buffer pool　的error
查了下，貌似是内存不够了？　orz
用free 命令看了下，阿里云ecs貌似是默认没有swap分区的。
于是参考云服务器 ECS Linux SWAP 配置概要说明 
设置了swap分区。看下还会不会挂orz</description></item><item><title>unicode 汉字表示不唯一的问题 (cjk字符集)</title><link>https://111qqz.com/2017/12/unicode-char-not-unique/</link><pubDate>Tue, 05 Dec 2017 02:44:46 +0000</pubDate><guid>https://111qqz.com/2017/12/unicode-char-not-unique/</guid><description>
update:
遇到的汉字：
丹：63838
李：63969
昨天写的正则发现死活识别不了 &amp;quot;年&amp;quot;字...
放到unicode编码转化公式 查了下发现竟然是不同的字orz..
其实猜想到也许是日文的&amp;quot;年&amp;quot;...结果查询了下发现是韩文的锅?
具体参考为何Unicode中有字形完全相同的CJK字符？
以及兼容汉字的参考表:UF900</description></item><item><title>正则匹配中文及常用正则表达式 (转载)</title><link>https://111qqz.com/2017/12/Common-regular-expression/</link><pubDate>Mon, 04 Dec 2017 11:34:06 +0000</pubDate><guid>https://111qqz.com/2017/12/Common-regular-expression/</guid><description>
先放一个同事安利给我的网站:regex101
查询匹配的中文字符unicode编码
正则表达式用于字符串处理、表单验证、日志数据分析等场合，实用高效。现将自己走网上搜索并总结的常用方法收集了一下：
匹配中文字符的正则表达式： [\u4e00-\u9fa5] 注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^\x00-\xff] 注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：\n\s*\r 注：可以用来删除空白行
匹配HTML标记的正则表达式：&amp;lt;(\S_?)[^&amp;gt;]&amp;gt;.?&amp;lt;/&amp;gt;|&amp;lt;._? /&amp;gt; 注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^\s_|\s_$ 注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)* 注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^\s]* 注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]$ 注：表单验证时很实用
匹配国内电话号码：\d-\d|\d-\d 注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9] 注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]\d(?!\d) 注：中国邮政编码为6位数字
匹配身份证：\d|\d 注：中国的身份证为15位或18位
匹配ip地址：\d+.\d+.\d+.\d+ 注：提取ip地址时有用
匹配特定数字： ^[1-9]\d_$　//匹配正整数 ^-[1-9]\d_$ //匹配负整数 ^-?[1-9]\d_$　//匹配整数 ^[1-9]\d_|0$　//匹配非负整数（正整数 + 0） ^-[1-9]\d_|0$　//匹配非正整数（负整数 + 0） ^[1-9]\d_.\d_|0.\d_[1-9]\d_$　//匹配正浮点数 ^-([1-9]\d_.\d_|0.\d_[1-9]\d_)$　//匹配负浮点数 ^-?([1-9]\d_.\d_|0.\d_[1-9]\d_|0?.0+|0)$　//匹配浮点数 ^[1-9]\d_.\d_|0.\d_[1-9]\d_|0?.0+|0$　//匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d_.\d_|0.\d_[1-9]\d*))|0?.0+|0$　//匹配非正浮点数（负浮点数 + 0） 注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串： ^[A-Za-z]+$　//匹配由26个英文字母组成的字符串 ^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串 ^[a-z]+$　//匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$　//匹配由数字和26个英文字母组成的字符串 ^\w+$　//匹配由数字、26个英文字母或者下划线组成的字符串 注：最基本也是最常用的一些表达式</description></item><item><title>基础 Haskell 学习笔记</title><link>https://111qqz.com/2017/11/haskell-notes/</link><pubDate>Fri, 24 Nov 2017 03:18:01 +0000</pubDate><guid>https://111qqz.com/2017/11/haskell-notes/</guid><description>
出于对函数式编程语言这一技能点的缺失...以及退役之后闲得蛋疼
打算浅尝辄止地学一下haskell
这篇笔记不会写成文档那样的详尽..毕竟函数式编程语言也是编程语言...有很多和其他编程语言(命令式？)相似的地方...
所以只会写一些简单的语法+让我感到惊讶的地方orz
总体的感觉...在里面看到了些python和pascal的影子orz...比如子界...已经好久没见到了
变量 * 命令式语言中，变量用来跟踪状态（keeping track of state）。 * Haskell中，变量保存了一个值，**然后再也不可以修改它了。** * 变量不仅可以保存像3.14这样的数值，还可以保存任何Haskell表达式 函数 * 函数中的函数 Prelude&amp;gt; let areaRect l w = l * w Prelude&amp;gt; let areaSquare s = areaRect s s Prelude&amp;gt; areaSquare 5 25 列表 * 创建列表/添加元素 Prelude&amp;gt; let numbers = [1,2,3,4] Prelude&amp;gt; numbers [1,2,3,4] Prelude&amp;gt; 0:numbers [0,1,2,3,4] Prelude&amp;gt; 1:0:numbers [1,0,1,2,3,4] Prelude&amp;gt; 2:1:0:numbers [2,1,0,1,2,3,4] Prelude&amp;gt; 5:4:3:2:1:0:numbers [5,4,3,2,1,0,1,2,3,4] * 事实上所有的列表都是在一个空的列表（`[]`）的基础上通过附加数据创建的。逗号与方括号的记法实际上是一种**语法糖**般的令人愉快的形式。 换句话说，`[1,2,3,4,5]`精确地等同于`1:2:3:4:5:[]` * 列表中的元素必须有相同的类型 * 列表的嵌套(二维以及高维度) * 列表大概可以类比数组或者python 中的list * 将两个List合并是很常见的操作，这可以通过++运算符实现。运算时会遍历左边的list,**因此用:运算符往一个List前端插入元素会是更好的选择。** * 若是要按照索引取得List中的元素，可以使用!</description></item><item><title>在wordpress 中输入数学公式</title><link>https://111qqz.com/2017/10/input-formula-on-wordpress/</link><pubDate>Tue, 31 Oct 2017 15:26:25 +0000</pubDate><guid>https://111qqz.com/2017/10/input-formula-on-wordpress/</guid><description>
查了一些资料。。发现不是要装各种插件（还不一定能用，比如和crayon冲突。。就是讲得很不清楚orz。。
又下一个win下的公式编辑器之类的软件是什么鬼啊？
干脆记录一下必要步骤。只有一步。
1. 配置mathjax. 加入下面代码到该主题的header.php中 &amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间（要放在**&amp;lt;?php wp_head(); ?&amp;gt;**） &amp;lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'&amp;gt;&amp;lt;/script&amp;gt; * **换行显示（displayed mathematics）**，它的分隔符是 $$...$$和 \[...\] ， * **行内显示（in-line mathematics）**，它的分割符号是 \\(...\\) (只有一个\) 不记得公式语法去latex online 查看即可</description></item><item><title>archlinux/manjaro fcitx 与 chrome 不兼容 中文掉字 解决办法</title><link>https://111qqz.com/2017/10/manjaro-fcitx-drop-chinese-words-randomly/</link><pubDate>Wed, 11 Oct 2017 16:24:11 +0000</pubDate><guid>https://111qqz.com/2017/10/manjaro-fcitx-drop-chinese-words-randomly/</guid><description>
[已解决]最近两个版本的 chrome（aura界面）有两个问题
https://github.com/fcitx/fcitx/issues/197
解决办法： 安装fcitx-im 包即可</description></item><item><title>20170929</title><link>https://111qqz.com/2017/09/20170929/</link><pubDate>Fri, 29 Sep 2017 17:10:29 +0000</pubDate><guid>https://111qqz.com/2017/09/20170929/</guid><description>
刚刚看了TBBT season 11 episode 1
Sheldon 和Amy 订婚了，Bernadette又怀孕了。
想想上一季结束的时候，大概半年前。
我好像还是只单身狗，手头没啥能看的offer，还有巨大的学业压力在前方。
感觉这半年收获了好多，多了一份担当，多了几个offer，可能是16年的运气真的太差了吧。
就沈阳打铁这事。。。就真的令人窒息。
这半年真的不知道是怎么过来的，虽然也知道“成年人的事情没有容易二字”，
也不是很愿意太过矫情...
而且日常警惕那种“毫无意义的自我感动”
不过还是真的想说
感谢菊苣@sxg的陪伴
感谢身边那些，在我最低沉最痛苦最萎靡的时候，一直给我加油打气，给我信心的小伙伴。
还要感谢自己....在最艰难的时候，也未曾想过放弃。
这几年真的是...过得太痛苦了...
真的好想大哭一场啊....</description></item><item><title>MPI 学习笔记</title><link>https://111qqz.com/2017/08/mpi-notes/</link><pubDate>Thu, 31 Aug 2017 03:04:27 +0000</pubDate><guid>https://111qqz.com/2017/08/mpi-notes/</guid><description>
参考资料：
消息传递接口（MPI）维基百科
MPI_TUTORIAL
MPI 在大规模机器学习领域的前景如何？
因为要和平台组对接工作以及写我们自己的BN同步...所以来了解一下MPI相关...感谢平台组@gyz 菊苣提供指导。
下面写一些自己的理解 ^_^
OVERVIEW MPI是一个跨语言的通讯协议，用于并行相关
MPI不是一种具体的语言实现，而是一种标准或者说接口，类比sql在关系型数据库中的地位，具体用的时候我们是用某个特定的实现，例如openmpi或者mpich2
对于机器学习问题，MPI很适合用在超算上...
下面随便补一些我认为需要了解的：
** **_communicator _是一个进程的group,该group里的所有进程可以相互通信。
在这组进程中，每个进程有一个唯一的rank,通信按照rank进行（做身份标识的作用？
MPI支持的通信方式有point-to-point 和 collective 两种，也就是点对点和广播
下面分别介绍这两种方式。
Blocking point-to-point communication Blocking communication 就是阻塞通信
**阻塞通信**是指消息发送方的send调用需要接受方的recv调用的配合才可完成 对于非阻塞通信，不必等到通信操作完全完成便可以返回，该通信操作可以交给特定的通信硬件去完成，在该通信硬件完成该通信操作的同时，处理机可以同时进行计算操作，这样便实现了计算与通信的重叠。通过计算与通信的重叠，可以大大提高程序执行的效率。这一方法和通过异步I/O实现I/O与计算的重叠思路是完全一样的。
MPI Send and Receive</description></item><item><title>python只获取当前目录下的文件夹及文件名</title><link>https://111qqz.com/2017/08/python-get-dir-name-in-current-path/</link><pubDate>Wed, 16 Aug 2017 08:21:41 +0000</pubDate><guid>https://111qqz.com/2017/08/python-get-dir-name-in-current-path/</guid><description>
list = os.listdir(rootdir)#列出目录下的所有文件和目录 for line in list: filepath = os.path.join(rootdir,line) if os.path.isdir(filepath):#如果filepath是目录 print &amp;quot;dir:&amp;quot; + filepath else: print &amp;quot;file:&amp;quot; + filepath
如果需要遍历文件夹下的所以文件，可以使用os.walk()方法。
os.walk()返回一个三元素的tuple：当前路径、子文件夹名称、文件列表。 import os for root, dirs, files in os.walk(path): for filename in files: print filename for dirname in dirs: print dirname 举个列处当前目录所有文件夹的例子：
from os import listdir from os.path import isfile, join import os dir =os.listdir() for line in dir: if os.path.isdir(line): print (line) 参考资料</description></item><item><title>峰度（Kurtosis）和偏度（Skewness）</title><link>https://111qqz.com/2017/08/kurtosisskewness/</link><pubDate>Wed, 02 Aug 2017 01:34:58 +0000</pubDate><guid>https://111qqz.com/2017/08/kurtosisskewness/</guid><description>
昨天pinduoduo笔试遇到了，看心情蒙的2333，来学习一下
** 峰度（Kurtosis）和偏度（Skewness）**
重点：正太分布的峰度和偏度都是0
峰度是描述总体中所有取值分布形态陡缓程度的统计量。这个统计量需要与正态分布相比较，峰度为0表示该总体数据分布与正态分布的陡缓程度相同；峰度大于0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰；峰度小于0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。峰度的绝对值数值越大表示其分布形态的陡缓程度与正态分布的差异程度越大。
峰度的具体计算公式为：
[![](http://images.51cto.com/files/uploadimg/20100408/161046770.jpg) ](http://images.51cto.com/files/uploadimg/20100408/161046770.jpg) 偏度与峰度类似，它也是描述数据分布形态的统计量，其描述的是某总体取值分布的对称性。这个统计量同样需要与正态分布相比较，**偏度为0表示其数据分布形态与正态分布的偏斜程度相同**；偏度大于0表示其数据分布形态与正态分布相比为正偏或右偏，即有一条长尾巴拖在右边，数据右端有较多的极端值；偏度小于0表示其数据分布形态与正态分布相比为负偏或左偏，即有一条长尾拖在左边，数据左端有较多的极端值。偏度的绝对值数值越大表示其分布形态的偏斜程度越大。 偏度的具体计算公式为：
[![](http://images.51cto.com/files/uploadimg/20100408/161111811.jpg) ](http://images.51cto.com/files/uploadimg/20100408/161111811.jpg)</description></item><item><title>manjaro(archlinux) 安装 YouCompleteMe</title><link>https://111qqz.com/2017/07/install-YouCompleteMe-on-manjaro/</link><pubDate>Fri, 28 Jul 2017 09:13:34 +0000</pubDate><guid>https://111qqz.com/2017/07/install-YouCompleteMe-on-manjaro/</guid><description>
来来回回折腾了好多次，aur直接安装或者手动编译，安装后都无法补全
ycm的log文件是在/tmp目录下的。
发现问题是缺少libtinfo.so.5
2017-07-28 17:02:12,667 - ERROR - Error occurred while loading global extra conf /home/coder/.ycm_extra_conf.py Traceback (most recent call last): File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/extra_conf_store.py&amp;quot;, line 94, in _CallGlobalExtraConfMethod module = Load( global_ycm_extra_conf, force = True ) File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/extra_conf_store.py&amp;quot;, line 173, in Load module = LoadPythonSource( _RandomName(), module_file ) File &amp;quot;/home/coder/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/../ycmd/utils.py&amp;quot;, line 400, in LoadPythonSource return imp.load_source( name, pathname ) File &amp;quot;/home/coder/.ycm_extra_conf.py&amp;quot;, line 32, in &amp;lt;module&amp;gt; import ycm_core ImportError: libtinfo.so.5: cannot open shared object file: No such file or directory 2017-07-28 17:02:12,667 - ERROR - libtinfo.</description></item><item><title>python numpy 用法 简明手册</title><link>https://111qqz.com/2017/07/python-numpy-notes/</link><pubDate>Mon, 24 Jul 2017 03:08:35 +0000</pubDate><guid>https://111qqz.com/2017/07/python-numpy-notes/</guid><description>
原文链接
感谢stanford,感谢原作者的翻译，我调整了一下代码格式，可以当做手册来用了，毕竟之前没怎么写过py 23333
**译者注**：本文[智能单元](https://zhuanlan.zhihu.com/intelligentunit)首发，翻译自斯坦福CS231n课程笔记[Python Numpy Tutorial](http://link.zhihu.com/?target=http//cs231n.github.io/python-numpy-tutorial/)，由课程教师[Andrej Karpathy](http://link.zhihu.com/?target=http//cs.stanford.edu/people/karpathy/)授权进行翻译。本篇教程由[杜客](https://www.zhihu.com/people/du-ke)翻译完成，[Flood Sung](https://www.zhihu.com/people/flood-sung)、[SunisDown](https://www.zhihu.com/people/sunisdown)、[巩子嘉](https://www.zhihu.com/people/gong-zi-jia-57)和一位不愿透露ID的知友对本翻译亦有贡献。 原文如下 这篇教程由Justin Johnson创作。
我们将使用Python编程语言来完成本课程的所有作业。Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。
我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。
一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 numpy for Matlab users页面。
你们还可以查看本教程的IPython notebook版。该教程是由Volodymyr Kuleshov和Isaac Caswell为课程CS 228创建的。
内容列表：
* Python * 基本数据类型 * 容器 * 列表 * 字典 * 集合 * 元组 * 函数 * 类 * Numpy * 数组 * 访问数组 * 数据类型 * 数组计算 * 广播 * SciPy * 图像操作 * MATLAB文件 * 点之间的距离 * Matplotlib * 绘制图形 * 绘制多个图形 * 图像 Python Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：</description></item><item><title>archlinux/manjaro 下 安装 qq/tim</title><link>https://111qqz.com/2017/06/install-qq-on-manjaro/</link><pubDate>Mon, 26 Jun 2017 16:09:19 +0000</pubDate><guid>https://111qqz.com/2017/06/install-qq-on-manjaro/</guid><description>
参考资料：install qq/tim on linux with wine
wine运行qq不能输入账号
This tutorial introduces how to install QQ/TIM in Linux with Wine, which had been tested on ArchLinux with Wine 2.4.
Prerequisites Before start, you need to get the latest Wine. I'm not sure whether QQ/TIM can run on lower version of Wine. In ArchLinux, you can easily get the latest Wine using following command:
?
pacman -S wine However, in Debian, you need to install Wine with some more steps.</description></item><item><title>libgfortran.so.4 missing under archlinux</title><link>https://111qqz.com/2017/06/libgfortran-so-4-missing-under-archlinux/</link><pubDate>Fri, 09 Jun 2017 20:12:41 +0000</pubDate><guid>https://111qqz.com/2017/06/libgfortran-so-4-missing-under-archlinux/</guid><description>
。。。哭了哦。。终于解决了这个bug
参考资料：
libgfortran broken?
libgfortran=3.0 should not be install with numpy &amp;lt;= 1.9
[SOLVED] libgfortran.so.3:cannot open shared object file: No such file
[Replacing gcc-libs-libs with gcc-multilib arch
conflict with gcc-libs and gcc-libs-multilib on latest update
一开始以为是anaconda相关。。。搞了半天。。。
然后又按照第一个资料里。。。试图把libgfortran用libgcc替代。。
发现删掉libgfortran会同时删掉scripy...
然后又觉得。。或许是scripy有什么问题？
查了一会也没发现什么。。。
后来又想也许是dlib的问题？
看了下dlib的github,说是pip 的安装方式可能存在问题，我又用源码安装了一边，问题依旧....
然后本来打算睡觉了。。。
突然梦到。。。也许是arch的问题呢。。。
一搜果然是。。。MGJ。。。这bug出现的时间。。。貌似是2017年5月30号以后。。。（具体参照最后一个资料的日期。。。
而且这。。。谁能想到是arch的锅啊。。。更别说是这么新鲜的bug...
所以说arch是不是不适合跑深度学习，做科学计算之类的啊orz....
最后说下解决办法：
:: gcc-libs 与 gcc-libs-multilib 有冲突。删除 gcc-libs-multilib 吗？ [y/N] y 错误：无法准备事务处理 (无法满足依赖关系) :: gcc-multilib：移除 gcc-libs-multilib 将破坏依赖关系 'gcc-libs-multilib=6.3.1-2' (tensorflow) [coder@111qqz-pc github]$ sudo pacman -S gcc-libs --force 正在解决依赖关系.</description></item><item><title>manjaro installation guide</title><link>https://111qqz.com/2017/06/manjaro-installation-guide/</link><pubDate>Thu, 08 Jun 2017 18:26:14 +0000</pubDate><guid>https://111qqz.com/2017/06/manjaro-installation-guide/</guid><description>
20180214 update:
第一个版本已经比较久了，于是更新一下，顺便写了个脚本orz
1 2 pacman-mirrors -c China 3 echo &amp;#34; [archlinuxcn] &amp;#34; &amp;gt;&amp;gt; /etc/pacman.conf 4 echo &amp;#34; SigLevel = Optional TrustedOnly &amp;#34; &amp;gt;&amp;gt; /etc/pacman.conf 5 echo &amp;#34; Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&amp;#34; &amp;gt;&amp;gt; /etc/pacman.conf 6 7 8 echo &amp;#34;[arch4edu]&amp;#34; &amp;gt;&amp;gt; /etc/pacman.conf 9 echo &amp;#34;SigLevel = Never&amp;#34; &amp;gt;&amp;gt; /etc/pacman.conf 10 echo &amp;#34;Server = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/\$arch &amp;#34; &amp;gt;&amp;gt; /etc/pacman.conf 11 pacman -Syyu 12 pacman -S archlinuxcn-keyring 13 14 pacman -S yakuake fish gvim 15 pacman -S google-chrome chromium 16 pacman -S wget aria2 remarkable netease-cloud-music 17 pacman -S fcitx fcitx-configtool fcitx-sogoupinyin fcitx-im kcm-fcitx 18 pacman -S shadowsocks-qt5 19 pacman -S wqy-microhei wqy-microhei-lite wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming adobe-source-han-sans-cn-fonts 20 21 cat &amp;gt;&amp;gt; ~/.</description></item><item><title>conda升级anaconda　ValueError的解决办法</title><link>https://111qqz.com/2017/06/how-to-fix-conda-upgrade-valueerror/</link><pubDate>Thu, 08 Jun 2017 13:03:51 +0000</pubDate><guid>https://111qqz.com/2017/06/how-to-fix-conda-upgrade-valueerror/</guid><description>
conda update anaconda　后提示
ValueError: unsupported format character ')' (0x29) at index 49 查到了这个：anaconda update issue
I have narrowed this down to the following packages: package build psutil-1.2.1 py27_0 hard-link pycparser-2.10 py27_0 hard-link pykit-0.1.0 np18py27_2 hard-link pyparsing-2.0.1 py27_0 hard-link by calling "</description></item><item><title>数字图像处理大作业(初步）</title><link>https://111qqz.com/2017/06/digital-image-processing-course-final-project/</link><pubDate>Wed, 07 Jun 2017 06:53:36 +0000</pubDate><guid>https://111qqz.com/2017/06/digital-image-processing-course-final-project/</guid><description>
...先随便记录一下好了。。。
* 神经网络识别数字或者字母？ * 识别车牌号？ * not hot dog? 安装python pandas pandas
发现之前装caffe的时候...装了这个东西。。。
但是就是检测不到？于是卸载重装。。。。
需要注意的是，如果是python2,要用pip2 install pandas,如果是python3,要用pip3 install pandas.
安装tensorflow...直接sudo pacman -Syu python-tensorflow 即可。。。
然后装好之后检测不到orz...感觉还是pip的安装方式比较靠谱。。。
pip2 install tensorflow
tensorflow_pip安装
我的环境是python2.7
# Ubuntu/Linux 64-bit, CPU only, Python 2.7 $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.10.0-cp27-none-linux_x86_64.whl sudo pip install --upgrade $TF_BINARY_URL 安装成功。。然后发现。。numpy挂了（？？？？？
SO上给出的建议 感觉之后还会各种遇到不同python版本导致的问题。。。。那就上anaconda好了。。。
试了anaconda...想法挺好。。但是貌似还不成熟.。。比如用anaconda安装numpy会报错orz..
最后解决办法是。。。卸载了python-numpy以及所有依赖python-numpy的a包；卸载了python2-numpy以及所有a依赖python２-numpy的包
然后重新安装了python2-numpy
以及发现。。。还有些坑是shellaa相关的.。。y所以暂时不要用fish了。。。
然后提示Missing required dependencies ['dateutil']
解决办法是安装python2-datautil
以及各种pip安装。。都记得要pip2而不是pip
中间缺少一堆库。。。大部分直接安装就好了。。。记得要安装python2对应的版本。。。
然后对于ImportError: No module named tensorboard.plugins
解决办法　是将tensorflow升级到1.</description></item><item><title>vim下python 的配置</title><link>https://111qqz.com/2017/06/vimrc-for-python/</link><pubDate>Wed, 07 Jun 2017 06:21:12 +0000</pubDate><guid>https://111qqz.com/2017/06/vimrc-for-python/</guid><description>
由于最近要做数字图像处理的大作业，以及之后一段时间，估计写python多一些，所以打算花些时间配置下vim. 1. 一键执行 其实之前一直有的。。不过没有效果，就没有管。发现问题是，python对应的filetype为&amp;quot;python&amp;quot;，而不是&amp;quot;py&amp;quot; func! CompileRunGcc() exec &amp;quot;w&amp;quot; if &amp;amp;filetype == 'c' exec &amp;quot;!g++ % -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'cpp' exec &amp;quot;!g++ % -std=gnu++11 -Wall -o %&amp;lt;&amp;quot; exec &amp;quot;! ./%&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'java' exec &amp;quot;!javac %&amp;quot; exec &amp;quot;!java %&amp;lt;&amp;quot; elseif &amp;amp;filetype == 'sh' :!./% elseif &amp;amp;filetype == 'python' &amp;quot; exec &amp;quot;!python %&amp;quot; &amp;quot; exec &amp;quot;!python %&amp;lt;&amp;quot; exec &amp;quot;!python2.7 %&amp;quot; endif endfunc 2.代码补全 不想折腾了。。既然ycm也支持python,就先用用看好了。。不行再换别的。 放一段ycm　for python的配置文件 &amp;quot;默认配置文件路径&amp;quot; let g:ycm_global_ycm_extra_conf = '~/.</description></item><item><title>vundle error detected while processing function</title><link>https://111qqz.com/2017/06/vundle-error-detected-while-processing-function/</link><pubDate>Wed, 07 Jun 2017 05:50:27 +0000</pubDate><guid>https://111qqz.com/2017/06/vundle-error-detected-while-processing-function/</guid><description>
好久没装新插件了，最新要配下python,发现安装时候满屏的错误。。。 最后发现是shell的锅，因为我用的是fish,在.vimrc文件中添加 set shell=/bin/bash 即可。 以及说下可能的其他原因，虽然我没遇到 * 对于arch系，可能从aur中安装的版本out ot data * 可能没有把.vimrc中vundle的配置从set rtp+=~/.vim/bundle/vundle更新成set rtp+=~/.vim/bundle/vundle.vim * 可能项目名称用了&amp;quot; 而不是' 以及顺手查了下bundle和Plugin的区别。。。 简单来说。。Plugin是新写法，bundle是正在被淘汰的写法，不过由于兼容性的原因，仍然在使用。。。 以后使用plugin的写法就好。 参考资料</description></item><item><title>边界的链码，归一化链码，差分玛，形状数</title><link>https://111qqz.com/2017/06/digital-image-processing-course-review/</link><pubDate>Tue, 06 Jun 2017 11:42:37 +0000</pubDate><guid>https://111qqz.com/2017/06/digital-image-processing-course-review/</guid><description>
复习一下数字图像处理。 按照我自己的理解简单来说： 原链码：按照任意起点走边界一周，方向按照上图对应的表示，得到的数字序列就是原链码。 归一化链码：为了解决原链码中起点不唯一而产生的序列不唯一的问题，规定，对于所有起点得到的原链码中，字典序最小的即为归一化链码（由于序列都是自然数，因此字典序最小也可以理解成，把该序列看成有前导０的自然数之后的数值之后的数值最小。 差分码：为了解决图形旋转之后，原链码和归一化链码都会发生变化，引入差分码。n位原链码（或归一化链码，由于归一化链码只是一种特殊的原链码，之后不再单独强调）可以得到n-1位差分码。具体来说，对于原链码ai，可以得到差分码b[i],_b[i] = ((a[i+1] - a[i])+mod)%mod(i属于1..n-1)，_mod根据实际有几个方向决定，通常为４或者８。 形状数：需要强调的是，形状数也是一个序列，而不是一个数。其实形状数就是把差分码按照字典序排序之后，最小的序列。形状数的阶数是该序列的长度。 Freeman链码（弗雷曼链码）是指用曲线起始点的坐标和边界点方向代码来描述曲线或边界的方法，常被用来在图像处理、计算机图形学、模式识别等领域中表示曲线和区域边界。它是一种边界的编码表示法，用边界方向作为编码依据，为简化边界的描述，一般描述的是边界点集。
常用的链码按照中心像素点邻接方向个数的不同，分为4连通链码和8连通链码。4连通链码的邻接点有4个，分别在中心点的上、下、左和右。8连通链码比4连通链码增加了4个斜方向，因为任意一个像素周围均有8个邻接点，而8连通链码正好与像素点的实际情况相符，能够准确地描述中心像素点与其邻接点的信息。因此，8连通链码的使用相对较多。
(a)四方向链码的方向符； （b）八方向链码的方向符。
八链码如下：
链码的定义 按照水平、垂直和两条对角线方向，可以为相邻的两个像素点定义4个方向符：0、1、2、3，分别表示0°、90°、180°和270°四个方向。同样，也可以定义8个方向符：0、1、2、3、4、5、6、7。链码就是用线段的起点加上由这几个方向符所构成的一组数列，通常称之为Freeman链码。用Freeman链码表示曲线时需要曲线的起点，对8链码而言，奇数码和偶数码的对应线段长度不等，规定偶数码单位长度为1，奇数码的单位长度为1.414。
2. 曲线的链码表示
（1）原链码 从边界（曲线）起点S开始，按顺时针方向观察每一线段走向，并用相应的指向符表示，结果就形成表示该边界（曲线）的数码序列，称为原链码，表示为
其中，S表示边界（曲线）的起点坐标，N=4或8时分别表示四链码和八链码。当边界（曲线）闭合时，会回到起点，S可省略。
（2）归一化链码
原链码具有平移不变性（平移时不改变指向符），但当改变起点S时，会得到不同的链码表示，即不具备唯一性。为此可引入归一化链码，其方法是：
对于闭合边界，任选一起点S得到原链码，将链码看作由各方向数构成的n位自然数，将该码按一个方向循环，使其构成的n位自然数最小，此时就形成起点唯一的链码，称为归一化链码，也称为规格化链码。我们将这样转换后所对应的链码起点作为这个边界的归—化链码的起点。
（3）链码的旋转归一化
用链码表示给定目标的边界时，如果目标平移，链码不会发生变化。
但是，如果目标旋转则链码会发生变化。为了得到具有旋转不变性的链码，我们可定义所谓的差分码。链码对应的差分码定义为：
对差分码进行（起点）归一化，就可得到归一化（唯一）的差分码，它具有平移和旋转不变性，也具有唯一性。
3. 边界的形状数表示
由于归一化的差分码既具有唯一性，也具有目标物平移和旋转不变性，因此可用来表示边界，称为形状数。形状数序列的长度(位数)称为形状数的阶,它可作为闭合边界的周长。
如上图所示的目标边界，其
原链码为：42120606454 ，
差分码为 ： 6716626617 ，
形状数: 1662661767 ，
形状数的阶为10 。
参考资料：
图像形状特征（三）--链码及形状数
中南大学_第7章 目标表达和描述技术</description></item><item><title>qt 5.x　初探　(5)　</title><link>https://111qqz.com/2017/06/qt-5-notes-5/</link><pubDate>Sun, 04 Jun 2017 17:14:39 +0000</pubDate><guid>https://111qqz.com/2017/06/qt-5-notes-5/</guid><description>
qt_5.9_ui_doc
还是比直接写代码方便点。。。所以不妨学习一个！
以及。。。qt在2017年6月１号发布了5.9。。。所以之前是5.8。。。现在变成5.9了。。。
遇到了修改了ui文件却没有生效的问题。。。
解决办法：
到项目目录下去执行：uic mainwindow.ui &amp;gt; ui_mainwindow.h 时间测试的qt方法。。。
头文件#include &amp;lt;QTime&amp;gt; QTime time; time.start(); // do something qDebug()&amp;lt;&amp;lt;time.elapsed()&amp;lt;&amp;lt;&amp;quot;ms&amp;quot;; （注意单位。。。</description></item><item><title>qt 5.x初探　（４）　qt 在win下打包成exe</title><link>https://111qqz.com/2017/06/qt-5-notes-4/</link><pubDate>Sun, 04 Jun 2017 12:54:51 +0000</pubDate><guid>https://111qqz.com/2017/06/qt-5-notes-4/</guid><description>
des的基本搞定了。。。打包。。。
在linux下打包成exe。。。。实在是。。没什么好办法的样子。。。
嘛。转念一想。老师说是打包成可执行文件。。。没说一定是exe啊。。。
然后也许我就零分了呢2333
des1.0
好了。。我又跑到windows下装了个qt...安装包2.3G,记得要安装编译器...
装好以后。。。开始打包。。。
注意区分：
Qt Widgets Application 和 Qt Quick Application
我的是后者。。。打包方式略有不同。。。
下面引用了详细步骤。。我来说下简略步骤好了。。。
* 将creator选到release的部署模式。。然后编译。。。 * 将exe文件单独拷贝出来，放到一个文件夹。。。 * **运行qt的命令行（不是系统的命令行！)** * **在qt的命令行中运行windeployqt helloqml.exe --qmldir C:\Qt\Qt5.4.0\5.4\mingw491_32\qml（其中qmldir后面换为qml的真实路径）** 顺便吐槽这工具有点智障。。。文件夹选项不显示后缀名就找不到helloqml　也是有毒。。。
Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll， 如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。 因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe。 以官方 Qt 5.4.0+MinGW 开发环境为例， 从开始菜单--》Qt 5.4.0--》5.4--》MinGW 4.9 (32-bit)--》Qt 5.4 for Desktop (MinGW 4.9 32 bit)，可以打开 Qt 命令行，从这里就可以执行 windeployqt 工具。 集成开发环境 QtCreator 目前生成图形界面程序 exe 大致可以分为两类： Qt Widgets Application 和 Qt Quick Application。 下面分别介绍这两类exe 的发布方式。</description></item><item><title>关于恋爱模式的一点思考</title><link>https://111qqz.com/2017/05/think-about-Love-relationship/</link><pubDate>Tue, 30 May 2017 06:03:09 +0000</pubDate><guid>https://111qqz.com/2017/05/think-about-Love-relationship/</guid><description>
最近和妹子闹了一点小矛盾，不过已经problem solved.
大概是因为，我聊到了妹子很不喜欢的话题，导致妹子情绪变得负面而我还没意识到...
我是感觉...就像写代码一样，代码没有bug(初始时）是不太现实的，关键是要debug?
所以人际关系，更具体的说是和妹子相处....也不可能没有矛盾吧...
尤其是两个人成长环境如果相差得比较多的情况下...接触的时间越长，暴露的矛盾应该就越多...
一个好的coder会惧怕代码中有bug吗？当然不会...
所以矛盾似乎也没什么可怕的...
不过一个熟练的coder大概可能写出的bug会越来越少吧。
所以我觉得，找到一种合适的机制，去解决矛盾是非常必要的....
这种机制不是说解决矛盾的方法本身，而是更通用的为解决矛盾提供的环境？
另外，其实有矛盾也不是什么坏事....如果矛盾是客观存在的，大概越早暴露越好...
越早暴露应该越好解决吧orz
所以大概....下次遇到，至少是这一类的问题，我们应该能解决的更好了吧...
用coding的思维考虑恋爱关系想想其实也没有那么奇怪啊...
我一直觉得，每一对情侣之间都有他们自己相处的模式吧....
所以其实使用这一类方法（不过不代表全部套用...就好像觉得某种语言的某个特性好不代表以后就只使用这种语言一样2333）
对于我们来说应该是种挺高效的模式吧。。。
其实这也可以归结成“见什么人说什么话”？
就想起那次和室友们打《优势物种》...解释规则的时候，“资源的实例”的说法软院的学生都会明白而又不会显得冗杂..
就好像某次和妹子去光谷浪，看到很多家烤串店纠结去哪一家的时候....“遍历一下”也比能想到的其他说法更加准确高效....</description></item><item><title>安装win10后导致grub 引导缺失的解决办法</title><link>https://111qqz.com/2017/05/missing-grub-after-install-windows10/</link><pubDate>Sun, 28 May 2017 04:10:35 +0000</pubDate><guid>https://111qqz.com/2017/05/missing-grub-after-install-windows10/</guid><description>
我之前是单系统manjaro，装了win10以后，grub menu直接消失不见...
ubuntu 的live cd进去，用神器boot-repair也没作用...
最后的解决办法是：
用随便一个什么linux的live cd,进入live模式
使用某种方法（fdisk?gparted?自己记得？）确认linux安装在哪个分区（如果有安装了多个，应该以最后一个为准）我的linux安装在了sda5
挂载linux分区:
sudo mount /dev/sda5 /mnt #Replace sda5 with your partition number
4.挂载其他必要的文件夹
for i in /sys /proc /run /dev; do sudo mount --bind &amp;quot;$i&amp;quot; &amp;quot;/mnt$i&amp;quot;; done 5:chroot进你的系统
sudo chroot /mnt 6.重装并更新grub引导
grub-install /dev/sda update-grub exit sudo reboot 完美解决！</description></item><item><title>archlinux安装记</title><link>https://111qqz.com/2017/05/install-archlinux-notes/</link><pubDate>Sun, 21 May 2017 18:41:27 +0000</pubDate><guid>https://111qqz.com/2017/05/install-archlinux-notes/</guid><description>
实在不忍心x1c吃灰。。。
打算装个arch玩。。。
第一次失败了，原因是忘记配置引导相关...
第二次就成功了...
教程满大街都是就不再写了....
似乎装好以后，和manjaro区别不大？
有空来更新下配置吧。。。
（越来越觉得折腾linux的时间还不如用来陪妹子...
所以不一定什么时候会更了2333</description></item><item><title>qt 5.x初探 （3）</title><link>https://111qqz.com/2017/05/qt-5-notes-3/</link><pubDate>Thu, 18 May 2017 12:47:20 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-3/</guid><description>
update3：
终于知道了正确的学习姿势...
用百度把要用的东西大概描述出来，然后总能找到一个是你要的。。。
然后再去搜关键词。。。
嗯。。百度还是很有用的啊2333
qt5.8_doc_Line Edits Example
所以现在要把之前写成dialog的几个改回Line edit
update2:
老师说要把输入框中的东西随时选中复制出来check...
QLabel默认好像不具有这种属性啊？
稍微查了下。。。
查到了一个叫setTextInteractionFlags的属性
以及连根拔出了。。
qt5.8 QGraphicsTextItem Class
找到了解决办法。。。
openFileNameLabel = new QLabel; openFileNameLabel-&amp;gt;setFrameStyle(frameStyle); openFileNameLabel-&amp;gt;setTextInteractionFlags(Qt::TextSelectableByMouse); //添加可选中可复制的交互属性。。。 记得要
#include &amp;lt;QGraphicsTextItem&amp;gt; update1:
扶起。。。QFile读中文路径文件毫无问题。。。
换成了cpp的 ifstream就一直报错。。。
由于我还改了其他部分。。。所以。。。
查了好久才发现是ifstream的锅。。。。
把des放了进去。。。
本来加密和解密想就用一个函数用参数调节的。。。
不过看了半天也没太懂。。。这种connnet怎么写。。。
不过对connect的理解更深了一些。。。
信号和槽果然是qt的精髓。。。看起来还算不那么无聊。。。
放一些关于信号和槽的资料好了。。。
信号与槽机制
ibm_qt的信号与槽机制
qt的信号槽
然后目前的进度是。。。
des放了进去。。。加密基本没啥问题。。。
但是有个小问题。。。
对于加密过程。。。我是用了一个全局的QString QTextSt来传递信息。。。
对于打开文件。。。过程是file-&amp;gt;QString
加密后得到密文文件。。过程是QString -&amp;gt; file
但是解密过程。。。。完全反过来了啊。。。？
在思考怎么写在一起能够不违和。。。。。</description></item><item><title>C++中头文件（.h）和源文件（.cpp）都应该写些什么（转载）</title><link>https://111qqz.com/2017/05/cpp-header-file-and-source-file/</link><pubDate>Tue, 16 May 2017 07:07:06 +0000</pubDate><guid>https://111qqz.com/2017/05/cpp-header-file-and-source-file/</guid><description>
感觉其实。。。更像是一种规范。。。？而不是一种具体要求吧。。。
转自 头文件(.h)： 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。
在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：
#ifndef CIRCLE_H #define CIRCLE_H //你的代码写在这里 #endif
这样做是为了防止重复编译，不这样做就有可能出错。
至于CIRCLE_H这个名字实际上是无所谓的，你叫什么都行，只要符合规范都行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。
源文件（.cpp）：
**源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。**那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。
下面举个最简单的例子来描述一下，咱就求个圆面积。
第1步，建立一个空工程（以在VS2003环境下为例）。
第2步，在头文件的文件夹里新建一个名为Circle.h的头文件，它的内容如下：
#ifndef CIRCLE_H #define CIRCLE_H class Circle { private: double r;//半径 public: Circle();//构造函数 Circle(double R);//构造函数 double Area();//求面积函数 }; #endif
注意到开头结尾的预编译语句。在头文件里，并不写出函数的具体实现。
第3步，要给出Circle类的具体实现，因此，在源文件夹里新建一个Circle.cpp的文件，它的内容如下：
#include &amp;quot;Circle.h&amp;quot; Circle::Circle() { this-&amp;gt;r=5.0; } Circle::Circle(double R) { this-&amp;gt;r=R; } double Circle:: Area() { return 3.</description></item><item><title>g++ 编译多个源文件（转载）</title><link>https://111qqz.com/2017/05/g++-compile-multi-file/</link><pubDate>Tue, 16 May 2017 06:40:03 +0000</pubDate><guid>https://111qqz.com/2017/05/g++-compile-multi-file/</guid><description>
参考资料
一. 常用编译命令选项 假设源程序文件名为test.c。
无选项编译链接 用法：#gcc test.c 作用：将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。
选项 -o 用法：#gcc test.c -o test 作用：将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。
选项 -E 用法：#gcc -E test.c -o test.i 作用：将test.c预处理输出test.i文件。
选项 -S 用法：#gcc -S test.i 作用：将预处理输出文件test.i汇编成test.s文件。
选项 -c 用法：#gcc -c test.s 作用：将汇编输出文件test.s编译输出test.o文件。
无选项链接 用法：#gcc test.o -o test 作用：将编译输出文件test.o链接成最终可执行文件test。
选项-O 用法：#gcc -O1 test.c -o test 作用：使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。
二. 多源文件的编译方法
如果有多个源文件，基本上有两种编译方法： [假设有两个源文件为test.c和testfun.c]
多个文件一起编译 **用法：#gcc testfun.</description></item><item><title>qt 5.x 学习笔记　(2)</title><link>https://111qqz.com/2017/05/qt-5-notes-2/</link><pubDate>Tue, 16 May 2017 03:14:19 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-2/</guid><description>
先来放一波过程中用到的资料和官方文档好了。
basic layout_qt5.8
QBoxLayout Class_qt5.8
QString Class 5.8
QChar Class qt 5.8
Standard Dialogs Example qt 5.8
更新的部分还是放在最前面好了。。。
convert from QString to char *的时候有个坑。。。
In order to convert a QString to a char*, then you first need to get a latin1 representation of the string by calling toLatin1() on it which will return a QByteArray. Then call data() on the QByteArray to get a pointer to the data stored in the byte array.</description></item><item><title>qt 5.x　初探(1)</title><link>https://111qqz.com/2017/05/qt-5-notes-1/</link><pubDate>Sun, 14 May 2017 12:21:56 +0000</pubDate><guid>https://111qqz.com/2017/05/qt-5-notes-1/</guid><description>
嘛。。为了系统安全课来学一波qt...
现在算是写出了一个可以打开文件，保存文件的记事本。。。
接下来要搞定的事情是。。。如何写一个自定义的事件。。。比如计算个开方之类的。。。
放一波代码好了。。。
#include &amp;lt;QAction&amp;gt; #include &amp;lt;QMenuBar&amp;gt; #include &amp;lt;QMessageBox&amp;gt; #include &amp;lt;QStatusBar&amp;gt; #include &amp;lt;QToolBar&amp;gt; #include &amp;lt;QDebug&amp;gt; #include &amp;lt;QTextEdit&amp;gt; #include &amp;lt;QFileDialog&amp;gt; #include &amp;quot;mainwindow.h&amp;quot; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { openAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Open...&amp;quot;), this); openAction-&amp;gt;setShortcuts(QKeySequence::Open); openAction-&amp;gt;setStatusTip(tr(&amp;quot;Open an existing file&amp;quot;)); saveAction = new QAction(QIcon(&amp;quot;:/images/file-open&amp;quot;), tr(&amp;quot;&amp;amp;Save...&amp;quot;), this); saveAction-&amp;gt;setShortcuts(QKeySequence::Save); saveAction-&amp;gt;setStatusTip(tr(&amp;quot;Save a new file&amp;quot;)); QMenu *file = menuBar()-&amp;gt;addMenu(tr(&amp;quot;&amp;amp;File&amp;quot;)); file-&amp;gt;addAction(openAction); file-&amp;gt;addAction(saveAction); QToolBar *toolBar = addToolBar(tr(&amp;quot;&amp;amp;File&amp;quot;)); toolBar-&amp;gt;addAction(openAction); toolBar-&amp;gt;addAction(saveAction); textEdit = new QTextEdit(this); setCentralWidget(textEdit); connect(openAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::openFile); connect(saveAction, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::saveFile); } MainWindow::~MainWindow() { } void MainWindow::openFile() { QString path = QFileDialog::getOpenFileName(this, tr(&amp;quot;Open File&amp;quot;), &amp;quot;.</description></item><item><title>20170504近况</title><link>https://111qqz.com/2017/05/20170504/</link><pubDate>Thu, 04 May 2017 12:58:06 +0000</pubDate><guid>https://111qqz.com/2017/05/20170504/</guid><description>
啊。。在准备考试QAQ
明天约了鹅厂面试。。。然而从四月就开始一直考试考试考试....感觉药丸啊？
MS的结果貌似明天也要出了orz...
之前没收到positive以为是跪了，结果听说有人没收到positive也拿到了offer啊？
以及，被之前拿到的某厂追加了类似sp之类的东西....
虽然说实习工资什么的的确不是很重要，不过比初始的offer 多了60%的工资还是美滋滋的啊？
而且貌似是我们组的boss帮我争取到的T T
好感动啊。。。。
哦还有。。后半学期有门叫大数据与云计算的课。。。
大概是做一些，和hadoop,spark,caffe有关的实验orz
我本以为我虽然菜了一点。。。但是毕竟一直在linux环境下。。。
这些东西还是能应付的。。。
结果关键步骤几乎全靠妹子carry啊orz....我好菜.jpg
所以虽然我们因为课程太多没办法像其他情侣一样出去玩。。。
一起在写代码，一起debug也算是另一种浪漫吧（强行自我安慰）
增强了专业水平又促进了感情orz
哦还有校赛。。。
虽然是菜鸡。。。不过校赛帮忙出题我觉得是老年选手的义务吧。。。。
但是听说dp和数学题已经够多了。。。马丹这两个最好出了吧orz...
尤其我半年没写过题。。。。我当时的idea...早就过时了吧orz...
而且还是校赛...武汉高校都会来吧。。。
万一因为我出的题太差影响了hust的形象那可就。。。。太糟糕了啊。。。</description></item><item><title>ubuntu 包管理(apt-get)损坏的解决办法</title><link>https://111qqz.com/2017/04/fix-ubuntu-package-manager-broken-problem/</link><pubDate>Sun, 30 Apr 2017 06:58:27 +0000</pubDate><guid>https://111qqz.com/2017/04/fix-ubuntu-package-manager-broken-problem/</guid><description>
症状是不管安装什么，都会说有一大堆依赖无法安装。。。
大概是: a depends b[i],but b[i] is not be installed. (b==0..n)
最后会提示Unable to correct problems, you have held broken packages
解决办法：用synaptic工具，把可能存在问题的包都清除掉。
参考资料
顺便想吐槽。。。ubuntu的包管理工具好辣鸡啊。。
随便装点东西竟然就损坏了？
我刚才装chrome,然后出了错误，提示我apt-get -f install 解决问题。。。
然后包管理就挂了？
想起当年虽然装的第一个发行版是ubuntu,但是并不好用啊？
好好使用的第一个还是mint
所以其实ubuntu不是很适合新手吧。。。只不过知名度高。。。。资料多。。。
要我说 manjaro 或者 linux mint 都要比ubuntu新手友好的多啊orz</description></item><item><title>install galliumOS on chromebook with chrx</title><link>https://111qqz.com/2017/04/install-galliumos-with-chrx-on-chromebook/</link><pubDate>Sat, 29 Apr 2017 15:09:51 +0000</pubDate><guid>https://111qqz.com/2017/04/install-galliumos-with-chrx-on-chromebook/</guid><description>
我的chromebook 是　samsung 3
查阅Hardware Compatibility 可以知道我的cb支持　gallium,对应的cpu 是Intel Braswell
然后去galliumos　官网　下载相应版本。  (发现这种做法并不需要自己下载。。。)
安装　galliumOS大体有两种方法，一种是完全去掉chromeOS,这种方法需要需要拆机去除写保护。。。我嫌麻烦。。。于是打算另一种，使用chrx　
步骤如下：
1. Enable [Developer Mode](http://www.chromium.org/chromium-os/developer-information-for-chrome-os-devices) (process is model-specific; for Acer C720, press `ESC+F3(Refresh)+Power`), then reboot 2. Load ChromeOS by pressing `CTRL+D` at the white &amp;quot;OS verification is OFF&amp;quot; screen 3. Configure your Wi-Fi network if necessary, then log in (Guest account is fine) 4. Open the ChromeOS Terminal by pressing `CTRL+ALT+T`, and enter `shell` at the prompt 5.</description></item><item><title>为什么。。。为什么会变成这样呢。。。</title><link>https://111qqz.com/2017/04/why-is-it-like-this/</link><pubDate>Thu, 27 Apr 2017 07:53:22 +0000</pubDate><guid>https://111qqz.com/2017/04/why-is-it-like-this/</guid><description>
连着考试。。。
取消考试周这做法就是蠢。。。
白天上课晚上考试。。。
说得好像没有考试周大家就不会复习了一样。。。
结果就只能是在白天的课上复习。。。
又影响听新的课，又影响复习。。。。
然后昨天还推了鹅厂的面试。。。不知道会不会留下什么不好的印象T T
连着考试真心要死啊。。。
身体完全受不了。。。
这还只是期中。。。
想想我们前半学期学完了 文档+专业英语+信号+测试+uml+游戏+计网，7门课。。。。
那就意味着期末还有12门。。。。。。。。
感觉真的。。。。。。。为什么。。。要这么多课呢。。。。。。。</description></item><item><title>20140419</title><link>https://111qqz.com/2017/04/20140419/</link><pubDate>Wed, 19 Apr 2017 12:56:13 +0000</pubDate><guid>https://111qqz.com/2017/04/20140419/</guid><description>
最让你恶心痛苦的那些人，你必要从他们身上学到最重要和有用的东西。 所有的痛苦都不能白受，克我者必生我。 在知乎看到这句话，不禁在想
人无疑是zhangk，可是学到了什么呢？
好像什么都没学到T T
那我好亏啊~~~~(&amp;gt;_&amp;lt;)~~~~</description></item><item><title>2017年3月更新archlinux后没有声音问题的解决办法</title><link>https://111qqz.com/2017/03/20173archlinux/</link><pubDate>Thu, 16 Mar 2017 06:37:25 +0000</pubDate><guid>https://111qqz.com/2017/03/20173archlinux/</guid><description>
系统信息：
表现为不管外放还是耳机。。都没有声音。。。
解决办法：
pacmd set-card-profile alsa_card.pci-0000_00_1b.0 output:analog-stereo+input:analog-stereo 参考资料</description></item><item><title>缓存淘汰算法之LRU（转载）</title><link>https://111qqz.com/2017/03/lru/</link><pubDate>Wed, 15 Mar 2017 00:34:50 +0000</pubDate><guid>https://111qqz.com/2017/03/lru/</guid><description>
参考博客
计组块忘光了呜呜呜。。。来复习一波。。
1. LRU 1.1. 原理
LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。
1.2. 实现 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：
1. 新数据插入到链表头部；
2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3. 当链表满的时候，将链表尾部的数据丢弃。
1.3. 分析 【命中率】
当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。
【复杂度】
实现简单。
【代价】
命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。
2. LRU-K 2.1. 原理 LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。
2.2. 实现 相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：
1. 数据第一次被访问，加入到访问历史列表；
2. 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；
3. 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；
4. 缓存数据队列中被再次访问后，重新排序；
5. 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。
LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。
2.3. 分析 【命中率】
LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。
【复杂度】
LRU-K队列是一个优先级队列，算法复杂度和代价比较高。
【代价】
由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。
LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。
3. Two queues（2Q） 3.1. 原理 Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。
3.2. 实现 当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：
1. 新访问的数据插入到FIFO队列；
2. 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</description></item><item><title>大数据top K 问题总结（转载）</title><link>https://111qqz.com/2017/03/top-k-problems/</link><pubDate>Tue, 14 Mar 2017 06:21:24 +0000</pubDate><guid>https://111qqz.com/2017/03/top-k-problems/</guid><description>
转自：http://blog.csdn.net/v_july_v/article/details/6279498
第一部分、十道海量数据处理面试题
1、海量日志数据，提取出某日访问百度次数最多的那个IP。
首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。
或者如下阐述（雪域之鹰）： 算法思想：分而治之+Hash
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)24值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；
**2、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。 ** 假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。
典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。
文中，给出的最终算法是： 第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）； 第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。
或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
方案：顺序读文件中，对于每个词x，取hash(x)00，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。
如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。 4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。
还是典型的TOP K算法，解决方案如下： 方案1： 顺序读取10个文件，按照hash(query)的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。
对这10个文件进行归并排序（内排序与外排序相结合）。
方案2： 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。
方案3： 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
遍历文件a，对每个url求取hash(url)00，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。
遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。
方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。
Bloom filter日后会在本BLOG内详细阐述。 6、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。
方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。
方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。 7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法： **方案1：**oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。
dizengrong： **方案2：**这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。
然后将这40亿个数分成两类: 1.</description></item><item><title>局部敏感哈希算法(Locality Sensitive Hashing)初探</title><link>https://111qqz.com/2017/03/locality-sensitive-hashing/</link><pubDate>Sat, 11 Mar 2017 07:59:00 +0000</pubDate><guid>https://111qqz.com/2017/03/locality-sensitive-hashing/</guid><description>
前言： 其实有了前文simhash算法的基础，局部敏感hash算法已经不存在理解上的问题了吧。。。毕竟simhash算法应该是局部敏感哈希算法的一种。。所以我就直接转载几篇我认为比较好的文档结合一下好了。。。会把比较重要的概念或者定义标记重点。
局部敏感哈希(Locality Sensitive Hashing，LSH)算法是我在前一段时间找工作时接触到的一种衡量文本相似度的算法。局部敏感哈希是近似最近邻搜索算法中最流行的一种，它有坚实的理论依据并且在高维数据空间中表现优异。它的主要作用就是从海量的数据中挖掘出相似的数据，可以具体应用到文本相似度检测、网页搜索等领域。 1. 基本思想 局部敏感哈希的基本思想类似于一种空间域转换思想，LSH算法基于一个假设，如果两个文本在原有的数据空间是相似的，那么分别经过哈希函数转换以后的****它们也具有很高的相似度；相反，如果它们本身是不相似的，那么经过转换后它们应仍不具有相似性。
哈希函数，大家一定都很熟悉，那么什么样的哈希函数可以具有上述的功能呢，可以保持数据转化前后的相似性？当然，答案就是局部敏感哈希。
回到顶部
2. 局部敏感哈希LSH 局部敏感哈希的最大特点就在于保持数据的相似性，我们通过一个反例来具体介绍一下。
假设一个哈希函数为Hash(x) = x%8，那么我们现在有三个数据分别为255、257和1023，我们知道255和257本身在数值上具有很小的差距，也就是说它们在三者中比较相似。我们将上述的三个数据通过Hash函数转换：
Hash(255) = 255%8 = 7;
Hash(257) = 257%8 = 1;
Hash(1023) = 1023%8 = 7;
我们通过上述的转换结果可以看出，本身很相似的255和257在转换以后变得差距很大，而在数值上差很多的255和1023却对应相同的转换结果。从这个例子我们可以看出，上述的Hash函数从数值相似度角度来看，它不是一个局部敏感哈希，因为经过它转换后的数据的相似性丧失了。
我们说局部敏感哈希要求能够保持数据的相似性，那么很多人怀疑这样的哈希函数是否真的存在。我们这样去思考这样一个极端的条件，假设一个局部敏感哈希函数具有10个不同的输出值，而现在我们具有11个完全没有相似度的数据，那么它们经过这个哈希函数必然至少存在两个不相似的数据变为了相似数据。从这个假设中，我们应该意识到局部敏感哈希是相对的，而且我们所说的保持数据的相似度不是说保持100%的相似度，而是保持最大可能的相似度。
对于局部敏感哈希“保持最大可能的相似度”的这一点，我们也可以从数据降维的角度去考虑。数据对应的维度越高，信息量也就越大，相反，如果数据进行了降维，那么毫无疑问数据所反映的信息必然会有损失。哈希函数从本质上来看就是一直在扮演数据降维的角色。
回到顶部
3. 文档相似度计算 我们通过利用LSH来实现文档的相似度计算这个实例来介绍一下LSH的具体用法。
3.1 Shingling 假设现在有4个网页，我们将它们分别进行Shingling（将待查询的字符串集进行映射，映射到一个集合里，如字符串“abcdeeee&amp;quot;, 映射到集合”(a,b,c,d,e)&amp;quot;, 注意集合中元素是无重复的，这一步骤就叫做Shingling, 意即构建文档中的短字符串集合，即shingle集合。），得到如下的特征矩阵：
其中“1”代表对应位置的Shingles在文档中出现过，“0”则代表没有出现过。
在衡量文档的相似度中，我们有很多的方法去完成，比如利用欧式距离、编辑距离、余弦距离、Jaccard距离等来进行相似度的度量。在这里我们运用Jaccard相似度。接下来我们就要去找一种哈希函数，使得在hash后尽量还能保持这些文档之间的Jaccard相似度，即：
我们的目标就是找到这样一种哈希函数，如果原来文档的Jaccard相似度高，那么它们的hash值相同的概率高，如果原来文档的Jaccard相似度低，那么它们的hash值不相同的概率高，我们称之为Min-hashing(最小哈希)。
3.2 Min-hashing Min-hashing定义为：特征矩阵按行进行一个随机的排列后，第一个列值为1的行的行号。举例说明如下，假设之前的特征矩阵按行进行的一个随机排列如下：
元素 S1 S2 S3 S4 他 0 0 1 0 成功 0 0 1 1 我 1 0 0 0 减肥 1 0 1 1 要 0 1 0 1 最小哈希值：h(S1)=3，h(S2)=5，h(S3)=1，h(S4)=2.</description></item><item><title>文本相似度判断-simhash算法学习笔记</title><link>https://111qqz.com/2017/03/simhash/</link><pubDate>Fri, 10 Mar 2017 03:33:08 +0000</pubDate><guid>https://111qqz.com/2017/03/simhash/</guid><description>
先放原始论文。。。以此表达对这个算法的敬意orz
论文链接
问题引出： 那天百度一面，frog学姐问了我如何判断两篇新闻稿的相似度的问题....我满篇口胡...也只是回答了一些诸如从图片上考虑。。或者去掉stop word之后得到特征向量然后计算余弦值之类得到传统想法。。。
今天看到了google在用的网页去重的算法（？。。。感觉好神奇。。。准备面试到现在，第一个让我感到惊异而不是套路的算法orz
对于处理**大规模文本（500字以上吧）**的时候效果很好。。。但是算法思想却又非常简单。
这才是算法的美丽之处吧。。。。leetcode上的那些纱布技巧也好意思叫算法。。。？
网页去重，其实本质还是网页相似度的计算....首先是两篇，之后还可以推广到海量数据。
算法初探： simhash算法。。。字面上也可以看出。。是一种hash算法。。。那么它和一般的hash有什么不同呢？
最大的问题在于。。。传统hash的设计目的之一是使得映射后的值的分布尽可能均匀...对于同样的key会有同样的value,但是每当key有轻微的变化的时候，value就会千差万别。
举个例子：
“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 通过simhash计算结果为：
1000010010101101111111100000101011010001001111100001001011001011
1000010010101101011111100000101011010001001111100001101010001011
通过 hashcode计算为：
1111111111111111111111111111111110001000001100110100111011011110
1010010001111111110010110011101
也就是说。。。没办法通过hash之后得到的值的差异，去分析key的相似程度。
而simhash就是通过某种方法进行hash，使得hash之后得到的value可以反应key的相似度。
流程 simhash算法分为5个步骤：分词、hash、加权、合并、降维，具体过程如下所述： * 分词 * 给定一段语句，进行分词，得到有效的特征向量，然后为每一个特征向量设置1-5等5个级别的权重（如果是给定一个文本，那么特征向量可以是文本中的词，其权重可以是这个词出现的次数）。例如给定一段语句：“CSDN博客结构之法算法之道的作者July”，分词后为：“CSDN 博客 结构 之 法 算法 之 道 的 作者 July”，然后为每个特征向量赋予权值：CSDN(4) 博客(5) 结构(3) 之(1) 法(2) 算法(3) 之(1) 道(2) 的(1) 作者(5) July(5)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。 * hash * 通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“CSDN”的hash值Hash(CSDN)为100101，“博客”的hash值Hash(博客)为“101011”。就这样，字符串就变成了一系列数字。 * 加权 * 在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“CSDN”的hash值“100101”加权得到：W(CSDN) = 100101 _4 = 4 -4 -4 4 -4 4，给“博客”的hash值“101011”加权得到：W(博客)=101011 _5 = 5 -5 5 -5 5 5，其余特征向量类似此般操作。 * 合并 * 将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“CSDN”的“4 -4 -4 4 -4 4”和“博客”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。 * 降维 * 对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 0 1 0 1 1”，从而形成它们的simhash签名。 每篇文档得到SimHash签名值后，接着计算两个签名的海明距离即可。根据经验值，对64位的 SimHash值，海明距离在3以内的可认为相似度比较高。</description></item><item><title>蓄水池抽样算法概述(Reservoir Sampling Algorithm)[转载]</title><link>https://111qqz.com/2017/03/reservoir-sampling-algorithm/</link><pubDate>Thu, 09 Mar 2017 12:14:11 +0000</pubDate><guid>https://111qqz.com/2017/03/reservoir-sampling-algorithm/</guid><description>
面京东被这个问题卡了QAQ，来补补这方面的课。
转自：链接
蓄水池抽样算法随机算法的一种，用来从 N 个样本中随机选择 K 个样本，其中 N 非常大（以至于 N 个样本不能同时放入内存）或者 N 是一个未知数。其时间复杂度为 O(N),包含下列步骤 (假设有一维数组 S, 长度未知，需要从中随机选择 k 个元素, 数组下标从 1 开始), 伪代码如下:
array R[k]; // result integer i, j; // fill the reservoir array for each i in 1 to k do R[i] := S[i] done; // replace elements with gradually decreasing probability for each i in k+1 to length(S) do j := random(1, i); // important: inclusive range if j &amp;lt;= k then R[j] := S[i] fi done 算法首先创建一个长度为 k 的数组（蓄水池）用来存放结果，初始化为 S 的前 k 个元素。然后从 k+1 个元素开始迭代直到数组结束，在 S 的第 i 个元素，算法生成一个随机数 j∈[1,i]j∈[1,i]， 如果 j &amp;lt;= k， 那么蓄水池的第 j 个元素被替换为 S 的第 i 个元素。</description></item><item><title>软件体系结构复习笔记</title><link>https://111qqz.com/2017/01/Software-Architecture-course-review/</link><pubDate>Tue, 03 Jan 2017 03:26:39 +0000</pubDate><guid>https://111qqz.com/2017/01/Software-Architecture-course-review/</guid><description>
Cha1 软件架构概念： 是系统的一个或多个结构，它们由软件组件，组件的外部可见属性以及组件之间的关系组成。 组件的外部可见属性是指其他组件对该组件所做的假设。 软件架构的多个结构： 静态的角度： 模块结构 分析类结构 类结构 动态的角度： 进程结构 数据流 控制流 使用结构 调用结构 层次结构 部署的角度： 物理结构
架构不止是功能需求的结果 Ch2: 需求包含三要素:功能，质量，限制条件 质量属性：系统在其生命周期过程中所表现出来的各种特征 质量属性的关系： 一个质量属性的获取对其他质量属性可能产生正面或者负面的影响。 任何质量属性都不可能在不考虑其他属性情况下单独获取。 质量属性举例： 运行时可见属性：性能，可用性，安全性 维护时可见属性：可修改，可扩展，可移植 易用性： 可学习性 可记忆性 错误避免 错误处理 满意度 质量场景创建的参与人员： 最终用户 系统管理员 维护人员 客户 开发组织 构架本身的质量属性： 一致性 正确性和完整性 可构建性 生成质量属性场景的目的和意义： 帮助构架师生成有意义的质量属性需求 使质量属性需求的描述规范化 某一场景是一类场景的代表，系统将以完全相同的方式做出反应。 构架的商业属性（限制）： 上市时间 成本和收益 预期系统生命周期长短 目标市场 推出计划 与老系统的集成 第三章： 软件架构样式的种类： 以数据为中心 数据流 虚拟机 调用-返回 独立组件 C/S 构架的异质性： 局部异质 层次异质 并行异质 ISO/OSI七层参考模型： 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 软件框架： 提取特定领域软件的共性部分形成的体系结构。 框架和架构的关系： 框架不是构架。 构架确定了系统整体结构、层次划分、不同部分之间的协作等设计老驴。 框架比构架更具体，更偏重于技术。 一个框架对应一个架构，一个架构可以有多个框架。 第四章： 架构战术：影响质量属性的设计决策。 架构策略：架构中所采用的战术的集合。 可用性的战术： 错误检测的战术： 回声 心跳 异常 错误恢复的战术： 表决 主动冗余 被动冗余 备件 状态再同步 检查点/回滚 错误预防的战术： 进程监视器 从服务中删除 事物 可修改性的战术： 局部化修改的战术： 维持语义一致性 预期期望的变更 泛化模块 限制可能的选择 防止连锁反应的战术： 信息隐藏 维持现有的接口 添加结构 添加适配器 提供一个占位程序 推迟绑定时间的战术： 运行时注册 配置文件 多态 组件更换 遵守已定义的协议 实施性能的战术： 影响响应时间的两个基本因素： 资源消耗 阻塞时间： 资源争用 资源的可用性 对其他计算的依赖性 控制对资源需求的战术： 减少处理一个事件所需要的资源： 提高计算效率 减少计算开销 减少需要同时处理： 管理事件率 控制采样频率 控制系统的使用： 限制执行时间 限制队列的大小 资源管理的战术： 引入并发 维持数据或计算的多个副本 增加可用资源 资源仲裁常见的调度策略： 先进/先出 固定优先级：语义重要性；时限时间单调；速率单调 动态优先级调度：轮转；时限时间最早优先 静态调度 实施安全性的战术： 用于抵抗攻击的战术： 对用户进行身份验证 对用户进行授权 维护数据的机密性 维护完整性 限制暴露的信息 限制访问 检测攻击的战术： 从攻击中恢复的战术： 回复状态 识别攻击者 易用性的战术： 运行时战术： 维持任务的一个模型 维护用户的一个模型 维护系统的一个模型 设计时战术： 软件架构样式与战术的关系： 软件架构样式是从战略层面解决质量问题，战术是从具体部署上给猪解决质量问题的局部策略。 第五章：设计构架 基于构架的开发步骤： 为软件系统创建一个商业案例 弄清系统需求 构建构架 正确表述此构架，并与有关各方进行交流 对此构架进行分析和评价 实现基于构架的系统并保证与构架相一致 系统维护时，构架文档应同步维护 构架驱动的因素： 功能 质量 部分限制条件（限制条件的某个子集） 良好架构的评判原则（判断题常考）： 设计构架过程的建议: 架的设计应该由一门设计师来完成 设计师应该全面掌握对系统的技术需求，以及对各项定性指标的优先级清单。 构架的文档完备，并蚕蛹所有人员认可的文档形式。 构架设计文档应让各风险承担者积极评估。 通过对构架分析，得出明确的定性与定量指标。 构架设计应该有助于具体实现。 允许构架带来一定的资源争用，并给出可行的解决方案。 关于构架的结构的建议： 构架由定义良好的模块组成，各个模块的功能划分应该基于信息隐藏。 模块的划分应体现出相互独立的原则。 把计算机基础结构的特性封装在一定的模块 构架尽量不依赖某个特定版本的商品产品或工具。 产生数据的功能和使用数据的功能应分属于不同的模块。 对并发系统，构架应充分考虑进程与模块结构的不对应。 进程编写要考虑到与特定处理器的关系，并容易改变关系。 构架应尽量采用一些已知的设计模式。 ADD构架设计的步骤： 样本输入 选择要分解的模块 根据下列5个步骤对模块进行求精（重点）： 从具体的质量场景和功能需求集合中选择构架驱动因素。 选择满足构架驱动因素的构架模式。 实例化模块并根据用例分配功能，使用多个视图进行表示 定义子模块的接口 验证用例和质量场景并对其进行求精，使它们称为子模块的限制。 对需求进一步分解的每个模块重复上述步骤。 创建骨架系统： 思想：提供一种基本能力，以一种对项目有利的顺序实现系统的功能。 好处： 提高开发效率，鼓舞士气。 能更早发现复杂的依赖关系。 使开发人员更多关注最难实现的部分。 能够缩短系统集成时间，降低其成本，并使集成成本更明确。 便于评审和测试。 步骤： 实现处理构架组件交互的软件部分 选择组件逐步添加到系统中。 逐步进行测试。 架构师的职责： 了解所在组织的业务目标，使架构更好地支持业务目标。 规划产品的开发与严禁 规划和建设架构级的重用etc 分析软件构架的原因(重要): 它是风险承担者之间的交流平台，是早期设计决策的体现，是可传递的模型。 软件质量不可能在软件开发的最后阶段追加上去，必须在设计之初就考虑到。 第七章： 构架评审： 成本： 人员时间成本 构架评审部门的组织开销 构架评审部分要求高级设计人员参与的代价（不就是人员时间成本吗。。。 收益： 及早发现构架中存在的问题 构架的改进 财务收益 强制位评审做准备 捕获构架设计的基本思想 验证需求的有效性 评审实施： 按问题的重要性进行分类 强调那些与偶家相符或相悖的重要问题 必须记载评审中所提的每个问题 构架评审的主要指导原则： 把由独立部门实施的正规的构架评审作为项目开发周期规划的一部分。 选择评审的最佳时间，尽早预审一次。 选择恰当的评审技巧 签署评审合同 限制所要品神的质量属性的个数 要保证评审小组中有构架方面的专家，领域专家，资料员，后勤员。 一定要有系统设计师。 收集各种场景数据，并在此基础上形成评审清单。 第八章： 架构权衡分析法（ATAM)： 特点：不仅可以揭示出构架满足特定质量目标的情况，而且可以让我们更清楚地认识质量目标之间的联系。 输入：用场景集合捕获的质量要求。 输出： 简介的框架表述 表述清楚的业务目标 构架决策到质量需求的映射 所确定的敏感点和权衡点集合 有风险决策和无风险决策 风险主题的集合 阶段： 评估小组和项目决策者共同决定评估细节 评估小组收集信息和分析 风险承担着参与评估 评估小组自我检查和改进，提交书面报告 步骤（重点）： ATAM方法的表述 商业动机的表述 构架的表述 对构架方法进行分类 生成质量属性效用树 分析构架方法 集体讨论并确定场景优先级 再次分析构架方法 结果的表述 第九章： 文档： 目的与作用：让不同的风险承担者都能快速找到和理解他们需要的信息。 基本原则：从读者的角度出发。</description></item><item><title>manjaro安(zhe)装(teng)记</title><link>https://111qqz.com/2016/12/manjarozheteng/</link><pubDate>Tue, 27 Dec 2016 04:40:53 +0000</pubDate><guid>https://111qqz.com/2016/12/manjarozheteng/</guid><description>
噫。。之前x200上装的是win7+fedora25 gnome。。。
虽然感觉gnome对于09年的老电脑来说有点吃力...不过也懒得换..
结果硬盘挂了2333 于是换了块硬盘
以及被人安利了manjaro，一个基于arch的linux发行版
还有就是因为平安夜又没有代码可以写又没有妹子可以陪觉得人生寂寞如雪
官网下好镜像以后，一开始用dd命令做u盘，发现启动不了。
无奈到win下用了poweriso制作，成功。
安装很顺利...基本就是傻瓜操作...
装好以后...装了vim...shadowsocks...chrome...fish...搜狗输入法。。。
添加了archcn的源
发现不能切换输入法。。。
解决办法：
在~/.xprofile 文件中添加如下内容 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot; 其他都挺顺利的。。
结果今天用着用着发现renkz2011这账户无法登录了。。。提示密码错误。。。
root账户是可以登录的。。。
于是我跑到root下登录。。。是可以的。。。
于是改了下renkz2011的密码。。。发现依然提示错误。。。
但是呢。。。我在root下做需要renkz2011权限的事情。。。输入密码就是没有问题的。。
我新建了一个账户。。。发现登录也没有问题。。。
奇怪啊。。。回想一下。。。我改了什么。。。
添加了archcn的源。。。
应该没关系。。。
还有就是。。。remove了zsh..?
于是我尝试着重新装回zsh...
再登录。。发现可以了。。。
回想一下。。。我在renkz2011账户下曾经设置默认shell为zsh...
卸载以后好像忘记更改了orz
但是。。。为什么和shell有关呢。。。</description></item><item><title>discourse邮件服务无法使用的解决方案</title><link>https://111qqz.com/2016/12/discourse/</link><pubDate>Sun, 25 Dec 2016 07:27:48 +0000</pubDate><guid>https://111qqz.com/2016/12/discourse/</guid><description>
解决办法:https://blog.discourse.org/2016/03/switching-your-discourse-from-mandrill-to-mailgun/</description></item><item><title>编译原理实验：词法分析器</title><link>https://111qqz.com/2016/12/</link><pubDate>Mon, 12 Dec 2016 09:02:12 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
实验一　设计实现简单语言的词法分析器 1、实验目的
通过该实验,熟练应用编译原理关于词法分析的基本理论和方法；学会用C/C++高级程序设计语言设计一个词法分析器；加深对编译原理理论的分析理解，提高实际操作和解决具体问题的能力。
2、实验条件
计算机上安装C/C++编译处理软件。
3、实验内容及要求
对下述单词表定义的语言设计编制一个词法分析器。单词符号及种别表和词法分析器功能及基本要求如下：
（1）单词符号及种别表
单词符号 种别编码 单词值 main 1 int 2 float 3 double 4 char 5 if 6 else 7 do 8 while 9 l(l|d)* 10 内部字符串 ( +|-|ε ) dd*(.</description></item><item><title>一些计划。。。</title><link>https://111qqz.com/2016/12/</link><pubDate>Fri, 09 Dec 2016 09:51:40 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
感觉owncloud的确很赞的样子。。。
小电影什么的。。我倒是需求不大。。。
不过作为同步盘感觉蛮赞的。。。
然而现在手头的服务器。。。除了论坛的vultr...都不是辣么有名的公司貌似。。。（国内的阿里云就算了。。。
所以现在的计划是。。。
等明年８月班瓦工到期。。。以及。。。不知道什么时候说不定就会tj的论坛。。。
打算买一个好一点的服务器orz，ss,owncloud，博客也搬过去吧...</description></item><item><title>fedora/centos　服务器搭建shadowsocks超时的解决办法</title><link>https://111qqz.com/2016/12/fedoracentosshadowsocks/</link><pubDate>Thu, 08 Dec 2016 07:42:54 +0000</pubDate><guid>https://111qqz.com/2016/12/fedoracentosshadowsocks/</guid><description>
操作肯定没有错，就是连接不上，显示超时
发现是防火墙的锅
具体请看：github_shadowsocks_issues_477</description></item><item><title>搭建论坛历程</title><link>https://111qqz.com/2016/12/</link><pubDate>Mon, 05 Dec 2016 08:32:38 +0000</pubDate><guid>https://111qqz.com/2016/12/</guid><description>
。。。由于一些不可描述的原因。。。
和某个华师计科的妹子一拍即合。。。打算搞一个论坛出来。。。
算是做一些微小的贡献2333
一开始打算尝试dz...毕竟社区比较丰富...服务器的话。。先拿个免费的搭起来再说https://www.hostinger.com.hk/
不过安装失败了...还是数据库的问题...
加上被gyz安利了discourse...稍微看了下，感觉还是挺不错的。。。
不过考虑到，社交登陆方面,discourse貌似对fb,google+,twitter之类的支持良好..但是对于国内的....
至少对于我来讲，我是不愿意再多注册一个账号的..
而且日后可能要加一些功能。。。要自己写的那种。。。discourse的技术链。。。我真是一点也不懂2333（虽然php我懂的也不多。。。。
基于以上原因。。我还是先打算继续搞dz...
20161207update:搭好了。。。免费的服务器太不稳定。。。于是买了日本某公司的服务器2333.一个月１０刀。。。暂时我们三个人平摊吧。。。
然后选择了discourese...其实还是不错的2333
接下来的问题。。就是如何吸引第一批成员加入。。。
这个就交给她们两个了。。。</description></item><item><title>关于代码插件　crayon　无法高亮的解决方案</title><link>https://111qqz.com/2016/11/crayon/</link><pubDate>Wed, 30 Nov 2016 08:37:57 +0000</pubDate><guid>https://111qqz.com/2016/11/crayon/</guid><description>
在最后一个标签　加上两个
（空格的字符表示　＆　＋　nbsp） 就好了。。。。</description></item><item><title>database connection error 的解决方案</title><link>https://111qqz.com/2016/10/database-connection-error-/</link><pubDate>Mon, 10 Oct 2016 10:37:14 +0000</pubDate><guid>https://111qqz.com/2016/10/database-connection-error-/</guid><description>
其实 东西之前出现过...不过好像重启一下服务器就可以了？
这次比较麻烦。
一开始我是直接google 了这条错误信息，结果答案五花八门，或者说...可能的原因非常多。
排查了几个。。。还是没有搞定。。。
突然想到。。。。为何不直接看log....我好傻啊。
2016-10-10 10:36:54 3755 [Note] IPv6 is not available. 2016-10-10 10:36:54 3755 [Note] - '0.0.0.0' resolves to '0.0.0.0'; 2016-10-10 10:36:54 3755 [Note] Server socket created on IP: '0.0.0.0'. 2016-10-10 10:36:54 3755 [ERROR] /alidata/server/mysql/bin/mysqld: Table './mysql/user' is marked as crashed and last (automatic?) repair failed 2016-10-10 10:36:54 3755 [ERROR] Fatal error: Can't open and lock privilege tables: Table './mysql/user' is marked as crashed and last (automatic?</description></item><item><title>[solved ]fedora 24 "Tap to click" not working</title><link>https://111qqz.com/2016/09/solved-fedora-24-tap-to-click-not-working/</link><pubDate>Thu, 01 Sep 2016 08:16:07 +0000</pubDate><guid>https://111qqz.com/2016/09/solved-fedora-24-tap-to-click-not-working/</guid><description>
链接</description></item><item><title>using your computer without mouse</title><link>https://111qqz.com/2016/09/using-your-computer-without-mouse/</link><pubDate>Thu, 01 Sep 2016 07:44:31 +0000</pubDate><guid>https://111qqz.com/2016/09/using-your-computer-without-mouse/</guid><description>
键盘足够爽了以后。。。
鼠标明显降低效率。。。
学会逐步脱离鼠标吧orz.
首先是chrome插件vimium
vimium教程
Vimium 常用的按键功能解释： * **j：向下细微滚动窗口 k：向上细微滚动窗口** * J：(**Shift+j的意思，以下大写全部表示加Shift)** 下一个标签页 K：上一个标签页 * d：向下滚动半个屏幕 u：向上移动半个屏幕 * **g+g（连续按两下g）：回到顶部** * **G：到达页面底部** * H：后退 L： 前进 * f：将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框。如果按的是F，那么将在新窗口中打开页面（见上图） * g+i：将光标 定位到输入框，如果有多个可以按Tab键切换 * x：关闭当前页面 X：恢复刚刚关闭的页面 * o：相当于Chrome中的地址栏，可以匹配历史记录、收藏夹并在当前窗口打开，或者直接打开一个网址或者搜索一个关键字（Chrome在全屏的时候地址栏死都出不来，有了它就解决这个一直困扰我的问题了！～），如果按的是O，则可以在新窗口中打开，非常非常方便！ * g+s：查看网页的源代码 * r：重新载入当前网页（顺便提一句，这点上新浪微博和它是一样的，光标没有定位在发送框时，即便没有安装这个插件你也可以用j/k来控制页面上下滚动，用r在刷新，用f或者p来定位到发送框。而Gmail的快捷键如j,k上下移动光标也是类似，有兴趣大家可以再自己去了解一下一些常用web应用的快捷键）</description></item><item><title>fedora 24 cannot modify keyboard delay and rate</title><link>https://111qqz.com/2016/08/fedora-24-cannot-modify-keyboard-delay-and-rate/</link><pubDate>Thu, 25 Aug 2016 08:58:50 +0000</pubDate><guid>https://111qqz.com/2016/08/fedora-24-cannot-modify-keyboard-delay-and-rate/</guid><description>
最近入手了x1 c
然后发现没办法支持 f22.....
没办法，只好上f24了。。。虽然明知道一堆bug...
最近发现。。之前在系统设置-&amp;gt;键盘-&amp;gt;打字 中的调整键盘延迟和速率的选项。。。不见了。。。
找了好久终于找到了解决办法：
/××××××××××××××××××××××××××××××××××××××××××××××××/ xset r rate 250 30
链接：参考</description></item><item><title>实训相关。。。。</title><link>https://111qqz.com/2016/07/</link><pubDate>Sat, 02 Jul 2016 07:44:27 +0000</pubDate><guid>https://111qqz.com/2016/07/</guid><description>
列个技能表。。。。。
java.... mysql... tomcat apache jsp..... idea...?
tomcat是apache的进化。。。。？？？
hibernate...持久层的设计模式。。？？ http://docs.jboss.org/hibernate/orm/</description></item><item><title>geekos project 1 （ELF文件相关）</title><link>https://111qqz.com/2016/06/geekos-project-1-elf/</link><pubDate>Sat, 18 Jun 2016 19:43:34 +0000</pubDate><guid>https://111qqz.com/2016/06/geekos-project-1-elf/</guid><description>
一、目的 熟悉ELF文件格式，了解GeekOS系统如何将ELF格式的可执行程序装入到内存，建立内核进程并运行的实现技术。 二、流程 1、修改/geekos/elf.c文件：在函数Parse_ELF_Executable( )中添加代码，分析ELF格式的可执行文件（包括分析得出ELF文件头、程序头，获取可执行文件长度，代码段、数据段等信息），并填充Exe_Format数据结构中的域值。 2、在Linux环境下编译系统得到GeekOS镜像文件。 3、编写一个相应的bochs配置文件。 4、在bochs中运行GeekOS系统显示结果。
编译以及启动bochs同project0... project0遇到的那些错误还是都会遇到一遍233.
然后在project1/src/geekos/ 目录下的elf.c中添加函数：int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength, struct Exe_Format *exeFormat)
原理部分不过多阐释，具体可见我参考的博客。
最后实现为：
int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength, struct Exe_Format *exeFormat) { elfHeader* header = exeFileData; programHeader* pHeader = (exeFileData+header-&amp;gt;phoff); exeFormat-&amp;gt;numSegments = header-&amp;gt;phnum; exeFormat-&amp;gt;entryAddr = header-&amp;gt;entry; int i = 0; for (; i&amp;lt; header-&amp;gt;phnum; i++) { exeFormat-&amp;gt;segmentList[i].offsetInFile = pHeader-&amp;gt;offset; exeFormat-&amp;gt;segmentList[i].lengthInFile = pHeader-&amp;gt;fileSize; exeFormat-&amp;gt;segmentList[i].startAddress = pHeader-&amp;gt;vaddr; exeFormat-&amp;gt;segmentList[i].sizeInMemory = pHeader-&amp;gt;memSize; exeFormat-&amp;gt;segmentList[i].protFlags = pHeader-&amp;gt;flags; pHeader++; } return 0; //!</description></item><item><title>geek OS project 0 （下）</title><link>https://111qqz.com/2016/06/geek-os-project-0-/</link><pubDate>Sat, 18 Jun 2016 09:48:06 +0000</pubDate><guid>https://111qqz.com/2016/06/geek-os-project-0-/</guid><description>
现在我们环境已经搭好了，参考 geekos实验环境的搭建
在main.c中新加个函数，命名为projecto,函数的代码如下：
/* * GeekOS C code entry point * Copyright (c) 2001,2003,2004 David H. Hovemeyer &amp;lt;daveho@cs.umd.edu&amp;gt; * Copyright (c) 2003, Jeffrey K. Hollingsworth &amp;lt;hollings@cs.umd.edu&amp;gt; * Copyright (c) 2004, Iulian Neamtiu &amp;lt;neamtiu@cs.umd.edu&amp;gt; * $Revision: 1.51 $ * * This is free software. You are permitted to use, * redistribute, and modify it as specified in the file &amp;quot;COPYING&amp;quot;. */ #include &amp;lt;geekos/bootinfo.h&amp;gt; #include &amp;lt;geekos/string.h&amp;gt; #include &amp;lt;geekos/screen.h&amp;gt; #include &amp;lt;geekos/mem.h&amp;gt; #include &amp;lt;geekos/crc32.h&amp;gt; #include &amp;lt;geekos/tss.</description></item><item><title>geekok project0（上）（实验环境的搭建）</title><link>https://111qqz.com/2016/06/geekok-project0/</link><pubDate>Sat, 18 Jun 2016 08:35:49 +0000</pubDate><guid>https://111qqz.com/2016/06/geekok-project0/</guid><description>
apt-get install build-essential apt-get install bochs bochs-x nasm
此处下载的bochs应该是比较新的...如果之后遇到
failed assertion in init_idt :g_handlersizenoterr == g_handlersizeerr 这个错误，建议安装比较老的nasm版本，比如2.08.02链接
下载geekos-0.3软件包，地址为： geekOS下载地址
然后解压到~/work目录。
然后进入到 /work/geekos-0.3.0/src/project0/build 目录下
之后的操作都是在这个目录下进行的。
rkz2013@111qqz-ThinkPad-X200 ~/work/geekos-0.3.0/src/project0/build $ make depend Makefile:249: depend.mak: 没有那个文件或目录 touch depend.mak gcc -M -O -Wall -Werror -g -DGEEKOS -I../include \ ../src/geekos/idt.c ../src/geekos/int.c ../src/geekos/trap.c ../src/geekos/irq.c ../src/geekos/io.c ../src/geekos/keyboard.c ../src/geekos/screen.c ../src/geekos/timer.c ../src/geekos/mem.c ../src/geekos/crc32.c ../src/geekos/gdt.c ../src/geekos/tss.c ../src/geekos/segment.c ../src/geekos/bget.c ../src/geekos/malloc.c ../src/geekos/synch.c ../src/geekos/kthread.c ../src/geekos/main.c \ | perl -n -e 's,^(\S),geekos/$1,;print' \ &amp;gt; depend.mak gcc -M -O -Wall -Werror -I.</description></item><item><title>OS课设之geek os 非最终版</title><link>https://111qqz.com/2016/06/osgeek-os-/</link><pubDate>Fri, 17 Jun 2016 04:09:37 +0000</pubDate><guid>https://111qqz.com/2016/06/osgeek-os-/</guid><description>
参考了这篇博客
流程部分不再具体描述，可以参考上面的博客。
只详细给出我遇到的问题。
我的pc环境是：Linux 111qqz-ThinkPad-X200 3.16.0-38-generic #52~14.04.1-Ubuntu SMP Fri May 8 09:43:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
linux mint 17.2 cinnamon
apt-get install build-essential apt-get install bochs bochs-x nasm http://sourceforge.net/projects/geekos/files/ 下载geekos软件包并且解压
$ cd ~/geekos-0.3.0/src/project0/build$ $ make depend $ make 报错。。
解法办法：修改/home/rkz2013/geekos-0.3.0/src/project0/build
目录下的Makefile文件。
CC_GENERAL_OPTS := $(GENERAL_OPTS) -Werror 改为 CC_GENERAL_OPTS := $(GENERAL_OPTS) make后再次出现错误：
fmtout.c:(.text+0xa16)：对‘__stack_chk_fail’未定义的引用 解决办法：
在project0/build 目录下的makefile文件的148行 添加编译选项 -fno-stack-protector 然后又报错
i386 architecture of input file `geekos/lowlevel.o' is incompatible with i386:x86-64 output 解决办法：</description></item><item><title>linux下的对拍写法</title><link>https://111qqz.com/2016/05/linux/</link><pubDate>Mon, 16 May 2016 13:44:16 +0000</pubDate><guid>https://111qqz.com/2016/05/linux/</guid><description>
首先先生成三个程序： $ g++ a+b.cpp -o a+b $ g++ a+b2.cpp -o a+b2 $ g++ make.cpp -o make 然后生成数据 $ ./make &amp;gt; in.txt 然后运行两个程序 $ ./a+b &amp;lt; in.txt &amp;gt; out.txt $ ./a+b2 &amp;lt; in.txt &amp;gt; ans.txt 最后对拍 $ diff out.txt ans.txt 输出的结果可以man diff查阅一下相关文档中关于输出含义的内容 注：上面的$都是命令提示符，复制粘贴时不需要</description></item><item><title>tmp</title><link>https://111qqz.com/2016/04/tmp/</link><pubDate>Wed, 13 Apr 2016 12:10:55 +0000</pubDate><guid>https://111qqz.com/2016/04/tmp/</guid><description>
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int N=1E4+7; int n,k,Q; int siz; int pos[N]; int sum[N]; int dis[N]; bool vis[N]; vector &amp;lt; pair&amp;lt;int,int&amp;gt; &amp;gt; edge[N]; struct node { int l,r; int id; bool operator &amp;lt; (node b)const { if (pos[l]==pos[b.l]) return r&amp;lt;b.r; return pos[l]&amp;lt;pos[b.l]; } }q[N]; void dfs( int u,int val) { vis[u] = true; dis[u+1] = val; int Siz = edge[u].</description></item><item><title>NYOJ 505 因子和阶乘</title><link>https://111qqz.com/2016/01/nyoj-505-/</link><pubDate>Wed, 20 Jan 2016 07:08:01 +0000</pubDate><guid>https://111qqz.com/2016/01/nyoj-505-/</guid><description>
http://acm.nyist.net/JudgeOnline/problem.php?pid=509 题意：中文题目。。。 思路：快速筛即可。。。妈蛋。。。这个oj不能用宏编译==。。。然后一直TLE...去掉了就好了。。sad
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 13时53分54秒 File Name :code/nyoj/509.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=10500; int n; int pri[N]={0}; int npri[N]={1,1}; int num[N]; int cnt; void pre() { cnt = 0 ; for ( int i = 2 ; i &amp;lt; N ; i++) { if (!</description></item><item><title>poj 1350 Cabric Number Problem</title><link>https://111qqz.com/2016/01/poj1350/</link><pubDate>Wed, 20 Jan 2016 05:29:46 +0000</pubDate><guid>https://111qqz.com/2016/01/poj1350/</guid><description>
http://poj.org/problem?id=1350
题意：6174问题。。。一个四位数。。四个数字重排。。。最大的减去最小的得到新的数字。最后一定能得到6174或者0.除非这个四位数的四个数字都一样。写出变化的过程。
思路：。。。可能不是不四位数。。略坑。然后写了下字符串和数字相互转化的两个函数。嗯。
/* *********************************************** Author :111qqz Created Time :2016年01月20日 星期三 12时51分41秒 File Name :code/poj/1350.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; int cnt; int get_next( int x) { int a,b,len; char st[10]; sprintf(st,&amp;quot;%d&amp;quot;,x); len = strlen(st); // if (len&amp;lt;4) return -1; if (st[0]==st[1]&amp;amp;&amp;amp;st[1]==st[2]&amp;amp;&amp;amp;st[2]==st[3]&amp;amp;&amp;amp;st[3]==st[0]) return -1; for ( int i = 0 ; i &amp;lt; len ; i++) for ( int j = i+1 ; j &amp;lt; len ; j++) if (st[i]&amp;lt;st[j]) swap(st[i],st[j]); sscanf(st,&amp;quot;%d&amp;quot;,&amp;amp;a); // cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; for ( int i = 0 ;i &amp;lt; len/2 ; i++) swap(st[i],st[len-1-i]); // cout&amp;lt;&amp;lt;st&amp;lt;&amp;lt;endl; sscanf(st,&amp;quot;%d&amp;quot;,&amp;amp;b); printf(&amp;quot;%d-%d=%d\n&amp;quot;,a,b,a-b); return a-b; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>linux mint gedit 中文乱码</title><link>https://111qqz.com/2015/12/linux-mint-gedit-/</link><pubDate>Mon, 28 Dec 2015 12:46:05 +0000</pubDate><guid>https://111qqz.com/2015/12/linux-mint-gedit-/</guid><description>
gconftool-2 --set --type=list --list-type=string /apps/gedit-2/preferences/encodings/auto_detected &amp;quot;[UTF-8,CURRENT,GB18030,ISO-8859-15,UTF-16]&amp;quot;</description></item><item><title>在linux mint 上安装 Oracle JDK 的方法</title><link>https://111qqz.com/2015/12/linux-mint--oracle-jdk-/</link><pubDate>Mon, 28 Dec 2015 08:17:03 +0000</pubDate><guid>https://111qqz.com/2015/12/linux-mint--oracle-jdk-/</guid><description>
Open up the Terminal (Alt + F2 &amp;gt; Terminal).
Remove OpenJDK installation.
sudo apt-get update &amp;amp;&amp;amp; apt-get remove openjdk*
Download Oracle JDK from here. You are looking for a linux version with tar.gz extension. Also choose the right version from 32-bit (x86) and 64bit (x64) one.
Change directory into one with downloaded tarball. In my case $HOME/Downloads.
cd ~/Downloads
Extract tarball.</description></item><item><title>codeforces 519 C. A and B and Team Training</title><link>https://111qqz.com/2015/12/cf519c/</link><pubDate>Mon, 14 Dec 2015 10:53:21 +0000</pubDate><guid>https://111qqz.com/2015/12/cf519c/</guid><description>
http://codeforces.com/problemset/problem/519/C 题意：两种组队方式，3人一组，1个大牛+2个蒟蒻或者1个蒟蒻+2个大牛。给定大牛和蒟蒻的个数。问最多能组多少队。 思路：线性规划。设两种队分别有x,y个即可。 突然发现这题以前做过。。。比当时的代码简单了一些。还不错。
/* *********************************************** Author :111qqz Created Time :2015年12月14日 星期一 18时31分10秒 File Name :code/cf/problem/519C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n,m; int main() { #ifndef ONLINE_JUDGE // freopen(&amp;quot;code/in.</description></item><item><title>codeforces #334 div 2 C. Alternative Thinking</title><link>https://111qqz.com/2015/12/codeforces-334-div-2-c-alternative-thinking/</link><pubDate>Wed, 02 Dec 2015 08:54:38 +0000</pubDate><guid>https://111qqz.com/2015/12/codeforces-334-div-2-c-alternative-thinking/</guid><description>
题意：给定一个01串。要进行一次变换：选一段连续的非空的字串，将这段串的0和1反转（0变成1,1变成0） 然后问能得到的最长的0,1交替的序列的长度是多少（不一定连续）
比赛的时候想出来两种会将答案增加的可能情况。一种是10000001 中间有大于等于3个的连续字符，这样可以把中间反转一下，答案会+2 另外一种是 1001001 这样。。有至少两段的连续两个以上的相同字符被另一个字符隔开的情况。只要将1001001变成1010101。答案还是会+2。。。然后发现这两种情况实际上可以统一起来。即：有至少两段的连续相同字符。 注意000 也算有两段。 如果有两段或者以上，那么答案+2.
/* *********************************************** Author :111qqz Created Time :2015年12月02日 星期三 00时36分47秒 File Name :code/cf/#334/C.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=1E5+7; char a[N]; int n; char tow(char ch) { if (ch=='0') return '1'; if (ch=='1') return '0'; } int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>test</title><link>https://111qqz.com/2015/12/test/</link><pubDate>Tue, 01 Dec 2015 07:04:19 +0000</pubDate><guid>https://111qqz.com/2015/12/test/</guid><description>
应大家的要求，写一篇博客来介绍下vim在ACM中的简单使用。
写本文的目的，只是为了给广大acmer一个入门vim的指导。不喜勿喷！ 不想看到的请远离！
vim大法好，远离sublime、cb保平安！
从13年开始，平时写程序和比赛都是用的vim，也一直在推荐大家使用vim，至于为何要用vim，原因很多。
为何要使用vim？1) 可以装逼，vim显得高端大气上档次，现场赛你打开的是丑陋的CB，别人打开的是VIM，高下立判。 2) 用vim可以明显提高写代码的感觉，加快代码速度。3) vim大法好。
当然，前面纯粹个人胡扯，要用啥都是个人偏好而已。
下面简单介绍VIM的使用。
比赛篇 首先介绍vim在比赛使用的使用。
先大致介绍现场赛vim的配置方法。
现场赛比赛系统是ubuntu， 都是安装好了vim的。
ubuntu系统下打开终端（终端一般在左侧有了，没有就按Ctrl+Alt+T启动，然后可以锁定在左侧），打开终端输入vim就进入vim了。
配置方法是输入 vim ~/.vimrc (这样是用vim编辑配置文件，或者用 gedit ~/.vimrc 就是用gedit编辑了)
配置的话，按照自己习惯加几句配置文件就可以使用了。
我一般配置下面几个：
C++
syntax on set nu set tabstop=4 set shiftwidth=4 colo evening set mouse=a set cin
&amp;lt;table class=&amp;quot;crayon-table&amp;quot; &amp;gt; &amp;lt;tr class=&amp;quot;crayon-row&amp;quot; &amp;gt; 1
2
3
4
5
6
7
syntax on
set nu
set tabstop=4
set shiftwidth=4
colo evening
set mouse=a</description></item><item><title>atom在linux下安装插件失败的解决方案</title><link>https://111qqz.com/2015/12/atomlinux/</link><pubDate>Mon, 30 Nov 2015 17:27:17 +0000</pubDate><guid>https://111qqz.com/2015/12/atomlinux/</guid><description>
gyp info it worked if it ends with ok gyp info using node-gyp@2.0.2 gyp info using node@0.10.40 | linux | x64 gyp http GET https://atom.io/download/atom-shell/v0.34.0/node-v0.34.0.tar.gz gyp WARN install got an error, rolling back install gyp ERR! install error gyp ERR! stack Error: This is most likely not a problem with node-gyp or the package itself and gyp ERR! stack is related to network connectivity. In most cases you are behind a proxy or have bad gyp ERR!</description></item><item><title>wordpress无法创建目录/没有写权限的解决方案</title><link>https://111qqz.com/2015/11/wordpress/</link><pubDate>Mon, 30 Nov 2015 02:44:19 +0000</pubDate><guid>https://111qqz.com/2015/11/wordpress/</guid><description>
终于解决了。
的确是权限问题。
但是由于初始化的时候，我错误的设置了数据库目录。应该为/alidata/www/serve/mysql ，而我设置成了/home/mysql
之前一直是在改alidata下的权限...现在可以了QAQ</description></item><item><title>博客算是搭好了？</title><link>https://111qqz.com/2015/11/</link><pubDate>Sun, 29 Nov 2015 11:18:01 +0000</pubDate><guid>https://111qqz.com/2015/11/</guid><description>
然而不能上传...
插件也是。在线安装也不可以。
google遍了只看到说是权限问题。
然而wp-content整个目录都已经chmod 777了...依然不可以。
日了狗了。</description></item><item><title>世界，您好！</title><link>https://111qqz.com/2015/11/hello-world/</link><pubDate>Sun, 29 Nov 2015 08:13:34 +0000</pubDate><guid>https://111qqz.com/2015/11/hello-world/</guid><description>
欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</description></item></channel></rss>