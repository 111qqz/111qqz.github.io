<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on Clarity</title><link>https://111qqz.com/categories/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on Clarity</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Fri, 18 Aug 2017 19:18:25 +0000</lastBuildDate><atom:link href="https://111qqz.com/categories/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>leetcode 146. LRU Cache(list+unordered_map)</title><link>https://111qqz.com/2017/08/leetcode-146-lru-cache/</link><pubDate>Fri, 18 Aug 2017 19:18:25 +0000</pubDate><guid>https://111qqz.com/2017/08/leetcode-146-lru-cache/</guid><description>
请实现最近最少使用缓存(Least Recently Used (LRU) cache)类,需要支持 get, set,操作。 get 操作,给出 key,获取到相应的 value (value 为非负数),如果不存在返回-1, 如果存在此 key 算作被访问过。 set 操作,设置 key,如果 key 存在则覆盖之前的 value (此时相当于访问过一次)。 如果 key 不存在,需要进行插入操作,如果此时已经 key 的数量已经到达 capacity, 这样需要淘汰掉最近最少使用(也就是上次被使用的时间距离现在最久的)的那 一项。
要求get和set的时间复杂度都是O(1)
/* *********************************************** Author :111qqz Created Time :2017年08月18日 星期五 00时00分22秒 File Name :LRU.cpp ************************************************ */ class LRUCache{ private: //map:&amp;lt;key,Value&amp;gt; //Value:pair&amp;lt;value,time&amp;gt; //time:vector? list? typedef unordered_map&amp;lt;int, pair&amp;lt;int , list&amp;lt;int&amp;gt;::iterator &amp;gt; &amp;gt;Cache; Cache cache; list&amp;lt;int&amp;gt;hit_seq; //头部最新元素，尾部最旧元素 int siz; #define fst first #define sec second #define MP make_pair void hit(Cache::iterator it) //access once { int key = it-&amp;gt;fst; hit_seq.</description></item><item><title>面试相关</title><link>https://111qqz.com/2017/08/interview-record/</link><pubDate>Sat, 12 Aug 2017 04:03:44 +0000</pubDate><guid>https://111qqz.com/2017/08/interview-record/</guid><description>
随便记录一下面试中遇到的问题：
梯度下降和牛顿迭代的区别？为什么常用梯度下降？ **牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快**。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。 根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。
常用梯度下降的原因是牛顿迭代的计算时间复杂度太大了...
如果一个优化问题是n 维的，那么单轮梯度下降的复杂度是O(n) ，Quasi-Newton是O(n^2)
收敛速度和计算的时间复杂度是两回事，切记不要混淆。
拟牛顿法：拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。
[Math] 常见的几种最优化方法
优化函数有哪些方法？非凸函数怎么办？在ml中如何求全局最优值？ 梯度下降，牛顿法等数值计算方法（要求有二阶导数？
模拟退火，遗传算法等近似算法。
由于凸函数有一个很好的性质，即局部最优就是全局最优，所以求凸函数的最优解比较容易，梯度下降，贪心（比如爬山法）等局部算法都ok.
对于非凸函数的最优化比较困难，比较常见的有蒙特卡洛方法投点法，大概思想就是，投n次点，每次在该点附近用凸函数的优化方法求最值，最后取所有局部最值的max(min)
模拟退火应该也可以求解非凸函数？ 毕竟喝醉的人可能走错路，陷入局部最优的时候有几率跳出。
什么是过拟合?如何防止过拟合？ 我的理解，过拟合就是由于参数过多等原因导致训练出来的模型不够一般化，可能对当前训练用的数据集拟合得很好，但是换一个数据集就不能很好的拟合。
防止过拟合主要有几种方法：L1,L2,dropout,Early stopping，数据集扩增。
L1,L2都是正则化方法，通过在代价函数上添加一个关于features的惩罚项，使得每一个features尽可能小，从而降低每个features对cost的贡献程度。
dropout是指在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。
dropout有效的原因没有统一结论（？
Early stopping便是一种迭代次数截断的方法来防止过拟合的方法，即在模型对训练数据集迭代收敛之前(**如果可以认为loss不会再减少了)**停止迭代来防止过拟合。
通俗得讲，数据机扩增即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法：
* 从数据源头采集更多数据 * 复制原有数据并加上随机噪声 * 重采样 * 根据当前数据集估计数据分布参数，使用该分布产生更多数据等 L1,L2规范化有什么区别？ 核心：L2对大数，对异常值更敏感！
L1：计算绝对值之和，用以产生稀疏性，因为它是L0范式的一个最优凸近似，容易优化求解 L2：计算平方和再开根号，L2范数更多是防止过拟合，并且让优化求解变得稳定很快速（这是因为加入了L2范式之后，满足了强凸）。
L1 nrom几乎没有比L2 norm表现好的时候，优先使用L2 norm是比较好的选择。
特征值和奇异值的关系？ ...?
有哪些旋转不变性（计算机视觉） ...?
逻辑回归和svm的关系？ 内核通信（那是啥 如何改变一个常量的值（不能去除常量属性 #define定义的常量是真正的常量(保存在常量区)，而const却是由编译器判断实现的常量，是一个假常量。const常量本质上还是一个变量，只不过C++中提出的const机制在编译层面上对const常量提供了写保护，是为了防止意外修改。
答案：volatile 关键字
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：
#include &amp;lt;stdio.h&amp;gt; int main() { const volatile int i = 10; int* pi = (int*)(&amp;amp;i); *pi = 100; printf(&amp;quot;*pi: %d\n&amp;quot;,*pi); printf(&amp;quot;i: %d\n&amp;quot;,i); printf(&amp;quot;pi: %p\n&amp;quot;,pi); printf(&amp;quot;&amp;amp;i: %p\n&amp;quot;, &amp;amp;i); return 0; } 智能指针？ 智能指针的出现实际上就是为了可以方便的控制对象的生命期，在智能指针中，一个对象什么时候和在什么条件下要被析构或者是删除是受智能指针本身决定的，用户并不需要管理。</description></item><item><title>leetcode162. Find Peak Element (O(lgn)复杂度寻找峰值)</title><link>https://111qqz.com/2017/04/leetcode-162/</link><pubDate>Fri, 14 Apr 2017 12:25:16 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-162/</guid><description>
A peak element is an element that is greater than its neighbors.
Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[-1] = num[n] = -∞.
For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</description></item><item><title>leetcode 152. Maximum Product Subarray (最大连续子序列乘积，dp)</title><link>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray/</link><pubDate>Fri, 14 Apr 2017 11:33:30 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray/</guid><description>
Find the contiguous subarray within an array (containing at least one number) which has the largest product.
For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.
思路：由于有正，有负，还有0.。。所以比最大子串之和要复杂一些。。。
dp[i].max表示到当前位置的最大乘积。
dp[i].min表示到当前位置的最小乘积。
dp[i].max = max{dp[i-1].maxa[i],dp[i-1].mina[i],a[i]};
dp[i].min同理
边界dp[i].max = dp[i].min = a[0]
/* *********************************************** Author :111qqz Created Time :2017年04月14日 星期五 18时57分13秒 File Name :152.cpp ************************************************ */ class Solution { public: //dp //dp[i]表示当前的最大乘积。 //用了滚动数组优化空间/ int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetcode 228. Summary Ranges</title><link>https://111qqz.com/2017/04/leetcode-228/</link><pubDate>Fri, 14 Apr 2017 10:51:39 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-228/</guid><description>
Given a sorted integer array without duplicates, return the summary of its ranges.
For example, given [0,1,2,4,5,7], return [&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;].
题意：把连续的数连续表示
思路：模拟。注意有负数，注意有-2147483648这种数据。
本来还想着，可能是leetcode加数据的审核机制太松，导致被人加了奇怪的数据。。。
结果发现出题人和加数据的人是一个人啊？
不给数据范围，加这种奇怪的数据很有意思？ 分分钟卡掉你的标程啊？
感觉像吃了苍蝇一样恶心。。一句话，出题人傻逼
/* *********************************************** Author :111qqz Created Time :2017年04月14日 星期五 16时26分01秒 File Name :228.cpp ************************************************ */ class Solution { public: string int2st(long long x) { if (x==0) return &amp;quot;0&amp;quot;; string ret = &amp;quot;&amp;quot;; int val; //md还有负数 long long sign = 1; if (x&amp;lt;0) sign = -1; x*=sign; while (x) { val = x % 10; ret = ret + char(val+'0'); x/=10; } if (sign==-1) ret +=&amp;quot;-&amp;quot;; reverse(ret.</description></item><item><title>leetcode 209. Minimum Size Subarray Sum (尺取法)</title><link>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum/</link><pubDate>Thu, 13 Apr 2017 13:50:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum/</guid><description>
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.
For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint
思路：尺取即可。。好久没写，竟然调了半天。。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 20时48分00秒 File Name :209.cpp ************************************************ */ class Solution { public: int ruler(vector&amp;lt;int&amp;gt;nums,int tar,int n) { int head = 0; int tail = 0; int sum = 0 ; int res = 0x3f3f3f3f; while (tail&amp;lt;n&amp;amp;&amp;amp;head&amp;lt;=tail) { sum = sum + nums[tail]; if (sum&amp;gt;=tar) { res = min(res,tail-head+1); while (sum&amp;gt;=tar&amp;amp;&amp;amp;head&amp;lt;tail) { sum-=nums[head]; head++; } if (sum&amp;gt;=tar) { res = min(res,tail-head+1); } else { head--; sum+=nums[head]; res = min(res,tail-head+1); } } tail++; } return res==0x3f3f3f3f?</description></item><item><title>leetcode 229. Majority Element II （O(1)空间找出现次数大于n/3的元素）</title><link>https://111qqz.com/2017/04/leetcode-229-majority-element-ii/</link><pubDate>Thu, 13 Apr 2017 12:41:33 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-229-majority-element-ii/</guid><description>
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.
题意：给你n个数，要求找出出现此处大于n/3的。。。
思路：之前做过一个找出n个数出现此处大于n/2的题目，思想是“非吾族类，其心必异”。。
这道题类似。。。容易知道题目要求的数最多有2个，最少有0个。。。
由于最多两个“族类”，在更新的时候，要判断是不是友军的人...毕竟朋友妻不可欺嘛（什么鬼
最后记得扫一遍，check一下，检查出现此处是否满足题意。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 20时05分53秒 File Name :229.cpp ************************************************ */ class Solution { public: //出现次数大于int(n/3)的元素，最少有0个，最多有两个 vector&amp;lt;int&amp;gt; majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt;res; int n = nums.size(); if (n==0) return res; int cnt1,cnt2,v1,v2; cnt1 = cnt2 = 0; v1 = v2 = -1; for ( int i = 0 ; i &amp;lt; n ; i++) { int x = nums[i]; // printf(&amp;quot;i:%d nums[i]:%d v1:%d cnt1:%d v2:%d cnt2:%d\n&amp;quot;,i,nums[i],v1,cnt1,v2,cnt2); if (cnt1==0&amp;amp;&amp;amp;v2!</description></item><item><title>leetcode 75. Sort Colors</title><link>https://111qqz.com/2017/04/leetcode-75-sort-colors/</link><pubDate>Thu, 13 Apr 2017 12:02:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-75-sort-colors/</guid><description>
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
题意：一个数组，由0,1,2组成，现在要求升序排列
思路：无脑做法就是计数排序，扫两遍，时间复杂度O(n)，空间复杂度O(1)
如果只扫一遍呢？
一个容易想到的思路是两个指针：
需要注意 的是，交换2后要再次遍历到当前位置，或者说，只有当不交换2的时候，才执行cur++
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 18时24分25秒 File Name :75.cpp ************************************************ */ class Solution { public: //思路：把0往前仍，把2往后仍 void pr(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetcode 11. Container With Most Water (two pointer)</title><link>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</link><pubDate>Thu, 13 Apr 2017 10:13:01 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</guid><description>
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.
题意：n条竖直的线段 (i,0)-&amp;gt;(i,a[i]),从中选2条，和x轴共同组成一个开口的容器，问容器的最大面积。</description></item><item><title>leetcode 16. 3Sum Closest (k-sum问题，two pointer)</title><link>https://111qqz.com/2017/04/leetcode-16-3sum-closest/</link><pubDate>Thu, 13 Apr 2017 09:45:45 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-16-3sum-closest/</guid><description>
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
思路： 排序，然后two pointer,复杂度 O(n^2)
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 16时24分28秒 File Name :16.cpp ************************************************ */ class Solution { public: int n; int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { n = nums.</description></item><item><title>leetcode 18. 4Sum (k-sum问题，two pointer)</title><link>https://111qqz.com/2017/04/leetcode-18-4sum/</link><pubDate>Thu, 13 Apr 2017 09:34:15 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-18-4sum/</guid><description>
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
思路： O(n^2)枚举两个元素，变成2-sum问题，总体复杂度O(n^3)
hash的解法以后补
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 17时24分54秒 File Name :18.cpp ************************************************ */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; int n; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { n = nums.</description></item><item><title>leetcode 15. 3Sum (k-sum问题，two pointer)</title><link>https://111qqz.com/2017/04/leetcode-15-3sum/</link><pubDate>Thu, 13 Apr 2017 08:21:52 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-15-3sum/</guid><description>
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note: The solution set must not contain duplicate triplets.
思路：排序O(nlgn)，然后枚举一个元素O(n),对于每个元素，在剩下的区间中 two pointer O(n)
整体复杂度 O(n^2)。
hash的解法以后补。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 16时07分00秒 File Name :15.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.</description></item><item><title>leetcode 216. Combination Sum III Add to List (枚举子集，限定集合大小，和为定值）</title><link>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list/</link><pubDate>Thu, 13 Apr 2017 07:55:09 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list/</guid><description>
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
题意：1..9个数，从中选择k个，和为n，要求输出所有满足题意的集合。
思路：枚举子集，根据sum和集合元素个数剪枝即可。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时44分56秒 File Name :216.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; int B[1005]; void get_subset(int n,int *B,int cur,int cnt,int k,int sum,int tar) { if (cur==n) { if (cnt!</description></item><item><title>leetcode 77. Combinations (枚举子集，限定集合大小)</title><link>https://111qqz.com/2017/04/leetcode-77-combinations/</link><pubDate>Thu, 13 Apr 2017 07:43:43 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-77-combinations/</guid><description>
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
思路：就是枚举子集，根据集合的大小剪枝。。。最后只要集合大小为k的集合
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时25分37秒 File Name :77.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; int B[1005]; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; void get_subset(int n,int *B,int cur,int cnt,int k) { if (cur==n) { vector&amp;lt;int&amp;gt;tmp; for ( int i = 0 ; i &amp;lt; n ; i++) if (B[i]) tmp.push_back(i+1); if (tmp.</description></item><item><title>leetcode 60. Permutation Sequence (求第k个排列)</title><link>https://111qqz.com/2017/04/leetcode-60-permutation-sequence/</link><pubDate>Thu, 13 Apr 2017 07:24:41 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-60-permutation-sequence/</guid><description>
The set [1,2,3,…,_n_] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):
1. `&amp;quot;123&amp;quot;` 2. `&amp;quot;132&amp;quot;` 3. `&amp;quot;213&amp;quot;` 4. `&amp;quot;231&amp;quot;` 5. `&amp;quot;312&amp;quot;` 6. `&amp;quot;321&amp;quot;` Given n and k, return the _k_th permutation sequence.
Note: Given n will be between 1 and 9 inclusive.
思路：还是根据leetcode 31 解题报告 中的算法搞一下就好了。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时17分19秒 File Name :60.</description></item><item><title>leetcode 47. Permutations II (生成全排列，有重复元素)</title><link>https://111qqz.com/2017/04/leetcode-47-permutations-ii/</link><pubDate>Thu, 13 Apr 2017 07:14:03 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-47-permutations-ii/</guid><description>
Given a collection of numbers that might contain duplicates, return all possible unique permutations.__
思路：和leet code 46 类似，最后用set去个重即可。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时00分48秒 File Name :47.cpp ************************************************ */ class Solution { public: void solve( vector&amp;lt;int&amp;gt;&amp;amp;nums) { int n = nums.size(); if (n==0) return; int k = -1; for ( int i = n-2 ; i &amp;gt;= 0 ; i--) { if (nums[i]&amp;lt;nums[i+1]) { k = i; break; } } if (k==-1) { reverse(nums.</description></item><item><title>leetcode 46. Permutations (生成全排列，无重复元素)</title><link>https://111qqz.com/2017/04/leetcode-46-permutations/</link><pubDate>Thu, 13 Apr 2017 06:59:43 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-46-permutations/</guid><description>
Given a collection of distinct numbers, return all possible permutations.
思路：调用n-1次 leetcode 31 解题报告 中提到的算法即可。。。
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 14时49分34秒 File Name :46.cpp ************************************************ */ class Solution { public: void solve(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int n = nums.size(); if (n==0) return; int k = -1; for ( int i = n-2 ; i &amp;gt;= 0 ; i--) { if (nums[i]&amp;lt;nums[i+1]) { k = i ; break; } } if (k==-1) { reverse(nums.</description></item><item><title>leetcode 31. Next Permutation (in-place 生成下一个全排列)</title><link>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place/</link><pubDate>Thu, 13 Apr 2017 06:47:55 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place/</guid><description>
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
The replacement must be in-place, do not allocate extra memory.
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1</description></item><item><title>leetcode 33. Search in Rotated Sorted Array (无重复数的旋转数组找定值)</title><link>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array/</link><pubDate>Thu, 13 Apr 2017 06:29:37 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array/</guid><description>
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
思路：找规律。。。二分。。。
0 1 2 3 4 5 6 1 2 3 4 5 6 0 2 3 4 5 6 0 1 3 4 5 6 0 1 2 4 5 6 0 1 2 3 5 6 0 1 2 3 4 6 0 1 2 3 4 5 观察发现。。。a[mid]&amp;lt;a[r]的时候，后半段有序;</description></item><item><title>leetcode 34. Search for a Range (二分，找到一段值为tar的区间)</title><link>https://111qqz.com/2017/04/leetcode-34-search-for-a-range/</link><pubDate>Thu, 13 Apr 2017 05:34:45 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-34-search-for-a-range/</guid><description>
Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm's runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4].
思路：二分。。。
我好像根本不会二分啊？？？
二分查找
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 10时49分02秒 File Name :34.</description></item><item><title>leetcode 39. Combination Sum (dfs，求所有的组合，和为定值，每个数可以重复用)</title><link>https://111qqz.com/2017/04/leetcode-39-combination-sum/</link><pubDate>Thu, 13 Apr 2017 02:47:49 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-39-combination-sum/</guid><description>
Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
The same repeated number may be chosen from C unlimited number of times.
Note:
* All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations. 题意：给n个数，求所有的组合，和为定值，每个数可以重复用)
思路：。。。。一开始用顺着枚举子集的思路。。。发现。。并不好搞。。。？还不如直接dfs...
/* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 00时06分12秒 File Name :39.</description></item><item><title>leetcode 40. Combination Sum II (枚举子集，和为定值)</title><link>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii/</link><pubDate>Wed, 12 Apr 2017 16:23:29 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii/</guid><description>
* Total Accepted: **106670** * Total Submissions: **329718** * Difficulty: **Medium** * Contributor: **LeetCode** Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
Each number in C may only be used once in the combination.
Note:
* All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations.</description></item><item><title>leetcode 495. Teemo Attacking</title><link>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</link><pubDate>Wed, 12 Apr 2017 16:00:57 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</guid><description>
In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.
You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</description></item><item><title>leetcode 442. Find All Duplicates in an Array（找出出现两次的元素）</title><link>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</link><pubDate>Wed, 12 Apr 2017 15:21:23 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</guid><description>
Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements that appear twice in this array.
Could you do it without extra space and in O(n) runtime?
思路：还是一个映射，如果某个位置要映射的时候已经为负了，就说明之前映射过该位置，那么该位置对应的元素就是出现了两个的元素。
和leetcode 448是一对题目。
/* *********************************************** Author :111qqz Created Time :2017年04月12日 星期三 21时49分11秒 File Name :442.cpp ************************************************ */ class Solution { public: vector&amp;lt;int&amp;gt; findDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt;res; int n = nums.</description></item><item><title>leetcode 48. Rotate Image (旋转方阵(in place))</title><link>https://111qqz.com/2017/04/leetcode-48-rotate-image/</link><pubDate>Wed, 12 Apr 2017 13:22:33 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-48-rotate-image/</guid><description>
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Follow up: Could you do this in-place?
题意：给一个n*n的方阵，要求顺时针旋转90度。
思路：(x,y)-&amp;gt;(y,n-1-x);
要求in-place的做法的话，其实是若干长度为4的环，保护一个节点，然后顺次做就好了。
然后对于那些标记已经做过选旋转的问题，实际上没有必要进行标记。
对于偶数，只需要处理 左上角hf * hf个,奇数只需要处理左上角hf*(hf-1)个。
其中hf = (n+1)/2
1A
1 2 3 (0,0) -&amp;gt;(0,2) 4 5 6 7 8 9 7 4 1 8 5 2 9 6 3 0 1 2 3 0 1 2 3 4 (0,0)-&amp;gt;(0,3) (0,1)-&amp;gt;(1,3) (0,2)-&amp;gt;(2,3) (0,3)-&amp;gt;(3,3) 1 5 6 7 8 (1,1)-&amp;gt;(1,2) (1,2)-&amp;gt;(2,2) (2,2)-&amp;gt;(2,1) 2 9 A B C (1,0)-&amp;gt;(0,2) (2,0)-&amp;gt;(0,1) 3 D E F G //只搞四分之一角落 0 1 2 3 0 D 9 5 1 1 E A 6 2 2 F B 7 3 3 G C 8 4 1 2 3 4 3 1 4 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* *********************************************** Author :111qqz Created Time :2017年04月12日 星期三 19时56分40秒 File Name :48.</description></item><item><title>leetcode 54. Spiral Matrix (矩阵蛇形取数)</title><link>https://111qqz.com/2017/04/leetcode-54-spiral-matrix/</link><pubDate>Tue, 11 Apr 2017 12:07:54 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-54-spiral-matrix/</guid><description>
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
思路：。。。再次让我回想起高一的暑假。。。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时42分05秒 File Name :54.cpp ************************************************ */ class Solution { public: int n,m; //0右，1下，2左，3上 int cal( int &amp;amp;x,int &amp;amp;y,int dir,vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; &amp;amp; vis) { if (dir==0) { if (y&amp;lt;=n-2&amp;amp;&amp;amp;!vis[x][y+1]) y++; else { dir++; x++; } return dir; } if (dir==1) { if (x&amp;lt;=m-2&amp;amp;&amp;amp;!</description></item><item><title>leetcode 55. Jump Game (dp)</title><link>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</link><pubDate>Tue, 11 Apr 2017 11:39:15 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</guid><description>
Given a collection of intervals, merge all overlapping intervals.
For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].
思路:dp[i]表示能否到达位置i...无脑dp即可。。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时33分51秒 File Name :55.cpp ************************************************ */ class Solution { public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if (n==0) return false; vector&amp;lt;int&amp;gt;dp(n,false); dp[0] = true; for ( int i = 0 ; i &amp;lt; n ; i++) { if (dp[i]) { int r = min(i+nums[i],n-1); for ( int j = i+1 ; j &amp;lt;=r ; j++) dp[j] = true; } } return dp[n-1]; } };</description></item><item><title>leetcode 56. Merge Intervals (模拟，求相交区间)</title><link>https://111qqz.com/2017/04/leetcode-56-merge-intervals/</link><pubDate>Tue, 11 Apr 2017 11:30:32 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-56-merge-intervals/</guid><description>
Given a collection of intervals, merge all overlapping intervals.
For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].
思路：扫一遍即可。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时15分30秒 File Name :56.cpp ************************************************ */ /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public: int n; static bool cmp(Interval A,Interval B) { return A.</description></item><item><title>leetocde 59. Spiral Matrix II (模拟)</title><link>https://111qqz.com/2017/04/59-spiral-matrix-ii/</link><pubDate>Tue, 11 Apr 2017 11:07:52 +0000</pubDate><guid>https://111qqz.com/2017/04/59-spiral-matrix-ii/</guid><description>
Given an integer n, generate a square matrix filled with elements from 1 to _n_2 in spiral order.
思路：仿佛回到高一的那个暑假。。。
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时52分15秒 File Name :59.cpp ************************************************ */ class Solution { public: int ok (int dir, int &amp;amp;x,int &amp;amp;y,int n,vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp;res) // 0右，1下，2左，3上 { if (dir==0) { if (y&amp;lt;=n-2&amp;amp;&amp;amp;res[x][y+1]==0) y++; else { dir++; x++; } return dir; } if (dir==1) { if (x&amp;lt;=n-2&amp;amp;&amp;amp;res[x+1][y]==0) x++; else { dir++; y--; } return dir; } if (dir==2) { if (y&amp;gt;=1&amp;amp;&amp;amp;res[x][y-1]==0) y--; else { dir++; x--; } return dir; } if (dir==3) { if (x&amp;gt;=1&amp;amp;&amp;amp;res[x-1][y]==0) x--; else { dir = 0 ; y++; } return dir; } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n) { vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res(n,vector&amp;lt;int&amp;gt;(n,0)); int dir = 0; int x,y; x = y = 0 ; for ( int i = 0 ; i &amp;lt; n*n ; i++) { res[x][y] = i+1; // printf(&amp;quot; x:%d y: %d\n&amp;quot;,x,y); dir = ok (dir,x,y,n,res); } return res; } };</description></item><item><title>leetocde 63. Unique Paths II</title><link>https://111qqz.com/2017/04/63-unique-paths-ii/</link><pubDate>Tue, 11 Apr 2017 10:50:57 +0000</pubDate><guid>https://111qqz.com/2017/04/63-unique-paths-ii/</guid><description>
Follow up for &amp;quot;Unique Paths&amp;quot;:
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.
[ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2.
题意：从左上到右下的方案数，有些点不能走。
思路：简单dp...1A
/* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时37分47秒 File Name :63.</description></item><item><title>leetcode 64. Minimum Path Sum (二维dp)</title><link>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum/</link><pubDate>Mon, 10 Apr 2017 02:35:20 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum/</guid><description>
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
数字三角形。。。。从坐上到右下问最短路径。。每次只能向下或者向右。。。
wa了一次。。。是因为边界值赋值成了0.。。求最短路径显然因为赋值成inf才对orz..果然傻了。。
简单的dp我们简单的A.
顺便吐槽一下。。(100,100)的答案会溢出int...然而答案就是负的。。。就没人check一下吗，，，
/* *********************************************** Author :111qqz Created Time :2017年04月10日 星期一 10时11分26秒 File Name :64.cpp ************************************************ */ class Solution { public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int n = grid.</description></item><item><title>leetcode 73. Set Matrix Zeroes (矩阵置0，乱搞)</title><link>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes/</link><pubDate>Mon, 10 Apr 2017 01:16:43 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes/</guid><description>
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.
click to show follow up.
**Follow up:**Did you use extra space? A straight forward solution using O(m__n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?
直接放常数空间的做法。
这道题面hypereal的时候遇到过，基本思路就是用已经确定是0的位置来存储其他行和列的信息。
三点注意：</description></item><item><title>leetcode 238. Product of Array Except Self (乱搞)</title><link>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self/</link><pubDate>Sun, 09 Apr 2017 11:50:05 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self/</guid><description>
Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
Solve it without division and in O(n).
For example, given [1,2,3,4], return [24,12,8,6].
Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.</description></item><item><title>leetcode 79. Word Search (dfs)</title><link>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</link><pubDate>Fri, 07 Apr 2017 06:59:26 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</guid><description>
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;quot;adjacent&amp;quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
思路：dfs即可。记得要回溯一下...
/* *********************************************** Author :111qqz Created Time :2017年04月07日 星期五 14时32分54秒 File Name :79.cpp ************************************************ */ class Solution { public: int n,m; const int dx4[4]={1,-1,0,0}; const int dy4[4]={0,0,-1,1}; bool vis[1005][1005]; int len; bool yes( int x,int y) { if (x&amp;gt;=0&amp;amp;&amp;amp;x&amp;lt;=n-1&amp;amp;&amp;amp;y&amp;gt;=0&amp;amp;&amp;amp;y&amp;lt;=m-1) return true; return false; } bool dfs( int x,int y,int cur,vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt; &amp;amp; maze,string &amp;amp; st) { // printf(&amp;quot;x:%d y:%d cur : %d\n&amp;quot;,x,y,cur); if (cur&amp;gt;=len) return true; for ( int i = 0 ; i &amp;lt; 4 ; i++) { int nx = x + dx4[i]; int ny = y + dy4[i]; if (!</description></item><item><title>leetcode 80 Remove Duplicates from Sorted Array II （有序数组去除重复元素）</title><link>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</link><pubDate>Wed, 05 Apr 2017 13:36:44 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</guid><description>
Follow up for &amp;quot;Remove Duplicates&amp;quot;: What if duplicates are allowed at most twice?
For example, Given sorted array nums = [1,1,1,2,2,3],
Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.
Subscribe to see which companies asked this question.
题意：一个有序数组，每个元素最多出现两次，如果大于两次，把多的去掉，返回去掉后的数组长度len，以及要求数组前len是去掉那些元素之后的元素。//语死早。。看原题好了。。
思路：排序了还不是随便搞？ 没要求空间再开一个标记空间。。。O(1)空间的话。。就乱搞一下？
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 21时25分48秒 File Name :80.</description></item><item><title>leetcode 81. Search in Rotated Sorted Array II (有重复元素的旋转数组找给定值)</title><link>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii/</link><pubDate>Wed, 05 Apr 2017 13:17:51 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii/</guid><description>
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Write a function to determine if a given target is in the array.
The array may contain duplicates.
好像阿里一面的时候问过。。。
思路：肯定是二分。。。不过由于有重复元素。。。所以很恶心。。。
总的思路是。。。当发现重复元素。。并且该重复元素不是target的时候。。。缩小范围。。。
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 20时26分25秒 File Name :81.cpp ************************************************ */ class Solution { public: bool search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int siz = nums.</description></item><item><title>leetcode 289. Game of Life (模拟)</title><link>https://111qqz.com/2017/04/leetcode-289-game-of-life/</link><pubDate>Wed, 05 Apr 2017 12:03:28 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-289-game-of-life/</guid><description>
According to the Wikipedia's article: &amp;quot;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;quot;
Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.</description></item><item><title>leetcode 90. Subsets II (枚举子集)</title><link>https://111qqz.com/2017/04/leetcode-90-subsets-ii/</link><pubDate>Wed, 05 Apr 2017 10:45:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-90-subsets-ii/</guid><description>
Given a collection of integers that might contain duplicates, nums, return all possible subsets.
Note: The solution set must not contain duplicate subsets.
For example, If nums = [1,2,2], a solution is:
[ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路：
复习（？）一下 枚举子集的三种写法
（还有种更飘逸的...先不写了orz
这道题我用位向量法A的。。
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 17时15分34秒 File Name :90.cpp ************************************************ */ class Solution { public: set&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;se; int B[1005]; vector &amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res; void get_subset(int n,int *B,int cur,vector&amp;lt;int&amp;gt;&amp;amp; nums) { // cout&amp;lt;&amp;lt;&amp;quot;cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; if (cur==n) //from 0 { vector&amp;lt;int&amp;gt;tmp; for ( int i = 0 ; i &amp;lt; n ; i++) if (B[i]) tmp.</description></item><item><title>106. Construct Binary Tree from Inorder and Postorder Traversal(根据中序和后序遍历构建二叉树)</title><link>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Wed, 05 Apr 2017 08:59:41 +0000</pubDate><guid>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>
/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 16时49分57秒 File Name :106.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTree(vector&amp;amp; inorder, vector&amp;amp; postorder) { int siz = inorder.size(); if (siz==0) return NULL; int rt = postorder[siz-1]; int pos = -1; for ( int i = 0 ; i &amp;lt; siz; i++) { if (inorder[i]==rt) { pos = i ; break; } } TreeNode *head = new TreeNode(rt); vectorin,post; for ( int i = 0 ; i &amp;lt; pos ; i++) { in.</description></item><item><title>leetcode 287. Find the Duplicate Number (floyd判圈算法找重复元素)</title><link>https://111qqz.com/2017/04/leetcode-287-find-the-duplicate-number-floyd/</link><pubDate>Wed, 05 Apr 2017 07:31:49 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-287-find-the-duplicate-number-floyd/</guid><description>
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Note:
1. You **must not** modify the array (assume the array is read only). 2. You must use only constant, _O_(1) extra space. 3. Your runtime complexity should be less than `O(n2)`.</description></item><item><title>leetcode 532. K-diff Pairs in an Array （找差为k的数对）</title><link>https://111qqz.com/2017/04/leetcode-532-k-diff-pairs-in-an-array/</link><pubDate>Wed, 05 Apr 2017 06:53:02 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-532-k-diff-pairs-in-an-array/</guid><description>
Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
Example 1:
Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description></item><item><title>leetcode 448. Find All Numbers Disappeared in an Array(寻找所有消失的元素）</title><link>https://111qqz.com/2017/04/leetcode-448-find-all-numbers-disappeared-in-an-array/</link><pubDate>Wed, 05 Apr 2017 06:19:06 +0000</pubDate><guid>https://111qqz.com/2017/04/leetcode-448-find-all-numbers-disappeared-in-an-array/</guid><description>
Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1] Output: [5,6] 思路：由于元素大小有限制，是在1..n之间。
这个信息有两个作用。一个是元素都是正数，一个是元素大小（绝对值意义上的）有限。</description></item><item><title>今日头条2017秋招笔试_1</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-04/</link><pubDate>Thu, 30 Mar 2017 05:53:33 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-04/</guid><description>
头条校招（今日头条2017秋招真题）
题目描述 头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队。每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来。在选题之前，我们对题目进行了盲审，并定出了每道题的难度系数。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a, b, c，我们希望这3道题能满足下列条件：
a＜= b＜= c b - a＜= 10 c - b＜= 10
所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求。然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？
输入输入的第一行包含一个整数n，表示目前已经出好的题目数量。
第二行给出每道题目的难度系数 d1, d2, …, dn。
样例输入4
20 35 23 40
输出输出只包括一行，即所求的答案。
样例输出2
时间限制C/C++语言：1000MS其它语言：3000MS
内存限制C/C++语言：65536KB其它语言：589824K
div2 A的难度...直接贪就好,不给数据范围的都是耍流氓...
/* *********************************************** Author :111qqz Created Time :2017年03月30日 星期四 12时55分21秒 File Name :code/toutiao/1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; int n; vector&amp;lt;int&amp;gt;vec; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>今日头条笔试题-木棒拼图(数学)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-02/</link><pubDate>Wed, 29 Mar 2017 13:27:24 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-02/</guid><description>
有一个由很多木棒构成的集合，每个木棒有对应的长度，请问能否用集合中的这些木棒以某个顺序首尾相连构成一个面积大于 0 的简单多边形且所有木棒都要用上，简单多边形即不会自交的多边形。
初始集合是空的，有两种操作，要么给集合添加一个长度为 L 的木棒，要么删去集合中已经有的某个木棒。每次操作结束后你都需要告知是否能用集合中的这些木棒构成一个简单多边形。
输入描述: 每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n 表示操作的数量(1 ≤ n ≤ 50000) ， 接下来有n行，每行第一个整数为操作类型 i (i ∈ {1,2})，第二个整数为一个长度 L(1 ≤ L ≤ 1,000,000,000)。如果 i=1 代表在集合内插入一个长度为 L 的木棒，如果 i=2 代表删去在集合内的一根长度为 L 的木棒。输入数据保证删除时集合中必定存在长度为 L 的木棒，且任意操作后集合都是非空的。
输出描述: 对于每一次操作结束有一次输出，如果集合内的木棒可以构成简单多边形，输出 &amp;quot;Yes&amp;quot; ，否则输出 &amp;quot;No&amp;quot;。
输入例子: 5 1 1 1 1 1 1 2 1 1 2 输出例子: No No Yes No No 能组成n边形的条件可以由三角形推广而来..(虽然只是猜想... 也就是n-1条较小边的和大于最大边...事实证明这结论是对的orz.. 然后就是multiset就好...
/* *********************************************** Author :111qqz Created Time :2017年03月29日 星期三 21时17分02秒 File Name :code/toutiao2.</description></item><item><title>今日头条笔试题-最大映射(贪心)</title><link>https://111qqz.com/2017/03/bytedance-2017-interview-01/</link><pubDate>Wed, 29 Mar 2017 12:47:29 +0000</pubDate><guid>https://111qqz.com/2017/03/bytedance-2017-interview-01/</guid><description>
有 n 个字符串，每个字符串都是由 A-J 的大写字符构成。现在你将每个字符映射为一个 0-9 的数字，不同字符映射为不同的数字。这样每个字符串就可以看做一个整数，唯一的要求是这些整数必须是正整数且它们的字符串不能有前导零。现在问你怎样映射字符才能使得这些字符串表示的整数之和最大？ 输入描述:每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n ， 接下来有 n 行，每行一个长度不超过 12 且仅包含大写字母 A-J 的字符串。 n 不大于 50，且至少存在一个字符不是任何字符串的首字母。 输出描述:输出一个数，表示最大和是多少。 输入例子: 2 ABC BCA 输出例子: 1875 一开始看漏了首位不能映射到0的条件...直接贪了..结果发现不太对...
哦贪心的方法就是算每个字母的权值和...用pair 搞一下...
处理的办法是如果10个字母都出现,那么先把没有在首位出现过的字母中权重最小的那个映射到0,再搞剩下的...
一个trick是...map映射到0..和某个key没有被映射过..产生了二义性....
窝的做法就是整体+1,最后再减回来..
然后因为某处手残卡了1个小时...???.
哎我果然是个废k了.....傻逼贪心都写不对QAQ
/* *********************************************** Author :111qqz Created Time :2017年03月29日 星期三 16时28分18秒 File Name :toutiao1.cpp ************************************************ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;ctime&amp;gt; #define fst first #define sec second #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 #define ms(a,x) memset(a,x,sizeof(a)) typedef long long LL; #define pi pair &amp;lt; int ,int &amp;gt; #define MP make_pair using namespace std; const double eps = 1E-8; const int dx4[4]={1,0,0,-1}; const int dy4[4]={0,-1,1,0}; const int inf = 0x3f3f3f3f; const int N=55; int n; string st[N]; pair &amp;lt;long long ,int &amp;gt; cnt[20]; LL ten[25]; map&amp;lt;char,int&amp;gt;mp; set&amp;lt;char&amp;gt;Nhead; bool head[25]; set&amp;lt;char&amp;gt;all; set&amp;lt;char&amp;gt;used; set&amp;lt; pair &amp;lt;long long ,char&amp;gt; &amp;gt; se; int main() { #ifndef ONLINE_JUDGE freopen(&amp;quot;code/in.</description></item><item><title>京东实习面试总结</title><link>https://111qqz.com/2017/03/jd-intern-interview/</link><pubDate>Sat, 18 Mar 2017 08:01:49 +0000</pubDate><guid>https://111qqz.com/2017/03/jd-intern-interview/</guid><description>
印象中是并没有看到jd，只是要求熟悉算法和数据结构+C艹...于是当时扔了份简历过去。
然后立刻就接到了一个电话，大概问了下一些基本情况。。以及。。你为什么不考研。。。
然后说之后会安排面试。。就杳无音信了。。然后突然有一天周末晚上11点接到短信说要安排面试orz...
【一面】 一面先是手写代码...都是面试套路题，就不说了...
哦其中一道题给出了优于面试官手中正解复杂度(nlgn）的复杂度的做法...
因为我说完我的做法给出了一点正确性的证明以后听他说了句“哦这题原来可以O(n)啊”
然后问了一点cpp基础。。。不记得问什么了。。反正也都很简单？
之后问了两个智力题吧。。。其中一个是7g+9g砝码称140g中的50g的问题...当时的确想了一下。。
再之后。。。开始问机器学习。。。。
这个时候我才意识到。。。这大概是算法岗啊。。。orz
然后我就全程装死。。。直言说不会orz...
然后面试官说，那我问问你微积分和概率论吧。。。。
我继续装死...
然后就结束了...结束的时候问了面试官有什么建议
他说。。建议我。。去读研。。。。。。去读研。。。。
心想一定gg了。。。于是就忘了这事。。。
【二面】 然后10天以后。。竟然接到电话。。自称是二面面试官。。。
还说看到一面面试官对我评价很高。。。
我：喵喵喵喵喵？
然后我当时直接就问了一句：但是我机器学习基本不会，怎么会评价高呢。。。。
面试官说：放心我不会问你这些。。。
之后约了面试，还是手写代码...
先是考了个尺取。。忘记题目了。。反正是那种被考烂的题。。。
然后第二个问题是手写快排。。。问了下快排相关的问题。。。
第三个问题是让我设计一个高效算法。。查询区间最大值。。。。。
我问查询次数多吗。。他说很多。。。我说可以用st表的rmq来做。。。
他说对，然后让我手写一下rmq的初始化函数...
再之后，问了一个top k问题...还好之前看群里的人讨论过orz...
最后一个问题问了蓄水池抽样...orz...
之前没看过这个算法，没有回答出来。。
第二天有一个貌似是部门负责人的人告诉我二面通过了。。。评价很高（我：？？？？？）
说是可能还会有个HR面。。。让我保持联系。。。
【HR面】 不知道能不能称之为HR面。。。感觉就是HR姐姐确认一些问题？
先是问我。。你一个武汉的学生。。。怎么想到北京来了呢。。。
之后问了。。。以后的打算啊。。。有没有拿到其他offer啊。。。
然后确认了下薪资问题。。。。
说是offer流程要一周左右。。。让我耐心等待。。
然后果然等了快一周2333
【总结】 其实接到二面通知的时候，jd是我当时面过的几家里面的最差的一家了（害怕。。。这里最差显然是说我很多没答上来的意思好么2333。。。京东很强啊orz...不要误会啊QAQ）....能接到二面也是很神奇...想了想也只可能那个复杂度O(n)的解法起了作用吧2333</description></item><item><title>阿里面试算法题（转载）</title><link>https://111qqz.com/2017/03/</link><pubDate>Tue, 14 Mar 2017 06:28:42 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
I want to match those five numbers 3, 7, 8, 9, 87 through regular express.
Here is my thought: - match those four numbers `3 7 8 9` var `^[3|7|8|9]$` - match number `87` var `^87$` Then combine them together, `(^[3|7|8|9]$|^87$)`. With some test, it seems correct. Is there any way to do that more efficiently? ------------------------------- Q: 已知三个升序整数数组a[l], b[m]和c[n]。请在三个数组中各找一个元素，是的组成的三元组距离最小。 三元组的距离定义是：假设a[i]、b[j]和c[k]是一个三元组，那么距离为: Distance = max(|a[i] – b[j]|, |a[i] – c[k]|, |b[j] – c[k]|) 请设计一个求最小三元组距离的最优算法，并分析时间复杂度。 用三个指针分别指向a,b,c中最小的数，计算一次他们最大距离的Distance ，然后在移动三个数中较小的数组指针， 再计算一次，每次移动一个，直到其中一个数组结束为止，最慢(l+ m + n)次，复杂度为O(l+ m + n) --------------------------------------------------------------------------------------------------------------------- Q:设计一个最优算法来查找一n个元素数组中的最大值和最小值。 已知一种需要比较2n次的方法，请给一个更优的算法。情特别注意优化时间复杂度的常数。 把数组两两一对分组，如果数组元素个数为奇数，就最后单独分一个，然后分别对每一组的两个数比较， 把小的放在左边，大的放在右边，这样遍历下来，总共比较的次数是 N/2 次；在前面分组的基础上，那么可以得到结论， 最小值一定在每一组的左边部分找，最大值一定在数组的右边部分找，最大值和最小值的查找分别需要比较N/2 次和N/2 次； 这样就可以找到最大值和最小值了，比较的次数为 N/2 * 3 = (3N)/2 次 --------------------------------------------------------------------------------------------------------------------- Q:有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。 从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？ 用一个栈 从左向右处理数据 1)遇到向右的鱼，压栈； 2)遇到向左的鱼，若栈空，结果+1；否则，将该鱼和栈顶比较，若栈顶鱼较大，则该鱼被吃掉，栈不变，处理下一个数据； 若栈顶鱼小，则弹出栈顶，继续与下一个比较，直到遇到较大的鱼，该鱼被吃掉；或者栈里鱼都比该鱼小，栈清空，结果+1 3)加上最终栈中鱼的数目 -------------------------------------------------------------------------------------------------------------------- Q: Taxicab numbers.</description></item><item><title>O(1)得到最小值的栈</title><link>https://111qqz.com/2017/03/o1/</link><pubDate>Sun, 12 Mar 2017 14:12:08 +0000</pubDate><guid>https://111qqz.com/2017/03/o1/</guid><description>
题意：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数，要求时间复杂度为O(1)
思路：标题党去死一死好么。。。真是无趣。。。就是用两个栈封装成一个。。。一个栈s1正常搞。。。一个是辅助栈s2。。每次去存min(value,s2.top());
。。。我还以为什么黑科技。。。
class Solution { public: stack&amp;lt;int&amp;gt;s1,s2; void push(int value) { s1.push(value); if (s2.empty()||value&amp;lt;s2.top()) s2.push(value); else s2.push(s2.top()); } void pop() { s1.pop(); s2.pop(); } int top() { return s1.top(); } int min() { return s2.top(); } };</description></item><item><title>求旋转数组最小值（二分）</title><link>https://111qqz.com/2017/03/</link><pubDate>Sun, 12 Mar 2017 13:19:16 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
题意：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
思路：二分。。。注意有重复元素。。。
class Solution { public: int minNumberInRotateArray(vector&amp;lt;int&amp;gt; a) { int siz = a.size(); int l = 0 ; int r = siz-1; while (r-l&amp;gt;1) { int mid = (l+r)&amp;gt;&amp;gt;1; if (a[mid]&amp;gt;a[r]) l = mid; else r = mid; } return min(a[l],a[r]); } };</description></item><item><title>用两个栈实现队列</title><link>https://111qqz.com/2017/03/</link><pubDate>Sat, 11 Mar 2017 12:52:58 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
思路：
一个元素入队的时候直接插入到stack1中。。。
一个元素出队的时候。。。如果stack2不为空。。stack2顶的元素就是要出队的。。
如果stakc2为空。。。就将stack1清空，按照元素出栈的顺序依次入栈到stack2
class Solution { public: void push(int node) { stack1.push(node); } int pop() { if (stack2.size()!=0) { int ret = stack2.top(); stack2.pop(); return ret; } while (!stack1.empty()) { int val = stack1.top(); stack1.pop(); stack2.push(val); } if (stack2.size()!=0) { int ret = stack2.top(); stack2.pop(); return ret; } return -1; } private: stack&amp;lt;int&amp;gt; stack1; stack&amp;lt;int&amp;gt; stack2; };</description></item><item><title>leetcode 105 根据前序遍历和中序遍历重构二叉树</title><link>https://111qqz.com/2017/03/</link><pubDate>Sat, 11 Mar 2017 11:34:40 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
思路：
分治搞之。
实际上两个vector就够了。。。4个会MLE(在leetcode上。。。
/** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* res; TreeNode* reConstructBinaryTree(vector&amp;lt;int&amp;gt; pre,vector&amp;lt;int&amp;gt; vin) { int siz = pre.size(); if (siz==0) return NULL; int rt = pre[0]; int pos=-1; for ( int i = 0 ; i &amp;lt; siz; i++) if (vin[i]==rt) { pos = i; break; } vector&amp;lt;int&amp;gt;preL,preR,vinL,vinR; for ( int i = 0 ; i &amp;lt; pos ; i++) { preL.</description></item><item><title>leetcode 74. Search a 2D Matrix</title><link>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</link><pubDate>Thu, 09 Mar 2017 11:14:05 +0000</pubDate><guid>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</guid><description>
题目链接
题意：给一个二维数组。。。每一行每一列都分别递增。。问某个value是否出现过。。。
思路：单调。。显然二分。。。唯一的技巧是从右上角开始搜。
/* *********************************************** Author :111qqz Created Time :2017年03月09日 星期四 19时03分07秒 File Name :74.cpp ************************************************ */ class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int n = matrix.size(); if (n==0) return false; int m = matrix[0].size(); if (m==0) return false; int row = 0 ; int col = m-1; while (col&amp;gt;=0&amp;amp;&amp;amp;row&amp;lt;n) { if (matrix[row][col]==target) return true; else if (matrix[row][col]&amp;gt;target) col--; else row++; } return false; } };</description></item><item><title>阿里一面.</title><link>https://111qqz.com/2017/03/</link><pubDate>Sun, 05 Mar 2017 12:51:42 +0000</pubDate><guid>https://111qqz.com/2017/03/</guid><description>
一开始是晚上七点半，直接一个电话过来就开始面试》。。
窝说不方便，又约了周末下午或者晚上，然后周六上午来了电话....。。。。于是又约了周天下午。。。
然后窝从两点开始等。。。等到六点半。。。决定去教室写报告。。。然后刚到教室电话就来了orz...
先是常规的简单自我介绍。。
然后先是问了一些cpp的问题。。
问了一些cpp的问题：
先是问了c和cppneicu内存的区别。。。我：？？？？？ 内存区别什么鬼。。
然后就回答了malloc,free,delete,new的区别。。。好像就是这个问题。。。
第二个问题是什么时候会内存泄露。。
我说申请了内存没释放blablabla...
第三个问题是cpp哪些函数不能为虚函数：
我说构造函数。。。面试官姐姐问还有呢。。。。窝说不知道了orz...
第四个问题问了指针和引用的区别。。。
我回答了三方面。。。初始化。。。赋值。。还有类型转化上。。。
面试官姐姐问还有呢。。。。我：喵喵喵喵喵？。。。不知道了。。。给点提示可？
面试官姐姐说在作为参数传递的时候。。。
我说传数组只能用指针。。不能用引用。。。
第五个问题问了栈和堆在xx方面的区别。。。（xx我不记得原词是什么了。。大概是说使用场合？）
我说一个是系统用。。一个是程序员用。。。（？？？
第六个问题是问我面向对象的特性。。。
我说是继承。。封装。。多态。。个人认为最核心的是多态blablabla...
然后面试官姐姐就问cpp多态的体现。。。
我说分动多态和静多态。。。。。。然后把模板，，，函数重载。。。虚函数什么的说了一下。。。
这大概是第一部分。。。第二部分问了我数据结构。。。
先问了我堆排。。。
给我一串无序数。。让我构造一个大根堆。。。。
我。。竟然。。。一脸智障。。。。。。
真的不记得了。。。。虽然记得这题数据结构考试还考过吧。。。
最后在面试官姐姐的提示下。。蒙出来了。。。人生污点啊。。。orz
然后问我复杂度。。。稳定性。。。
又问了快排。。让我给他讲一下快排。。。
我就说了取pivot的几种策略。。。然后复杂度的平均和最坏情况。。。以及避免最坏情况的方法。。。
然后面试官姐姐问我最坏情况的数据是怎么样的。。。
这个经典问题我竟然也。。。。（人生污点*2
答案是基本单调的。。。
然后问我一个有序的数组。。找index=value的值。。数组没有重复元素。。。
其实一开始没说单调。。。我问了一句她才说漏了个条件2333.
单调。。那就二分呗。然而我口头描述了下二分的代码。。。
就是l和r的值什么要注意一下吧。。。
然后问我有单调有重复怎么办。。。
一开始没过脑子。。。说了个两次二分出一个区间。。事实证明是错误的。。。
然而实际上只要稍微修改下二分代码就好了。。。。
之后问我一棵二叉树。。如何in-place 按照前序遍历转化成单项链表。。。想了一会。。。还是不会orz。。。
这大概是leetcode的套路题吧。。。由于觉得leetcode太恶心。。。刷了80+就没再刷了。。。QAQ
然后第三部分。。。问我我OS的东西。。。
问我了内核态和用户态的区别。。。
然后问我linux的blablabla....我说我不会QAQ 面试官姐姐就没再问这方面了。。。
后来面试官姐姐说这方面她也不太懂。。。
第四部分。。。问了我数据库。。？
就问了一个 事务的特性。。。
我就回答了acid...每个解释了一下。。。
然后就没了吧。。。</description></item><item><title>百度实习生面试总结</title><link>https://111qqz.com/2017/02/baidu-intern-interview/</link><pubDate>Tue, 28 Feb 2017 13:36:11 +0000</pubDate><guid>https://111qqz.com/2017/02/baidu-intern-interview/</guid><description>
啊。。。虽然结果还没出来。。。不过回想发现有些细节已经有些记不清了。。。
所以打算先记录一下？ 就算过不了。。。也算是积累一些经验。
一面： 先是简单自我介绍。。。
然后问了2-sum...?(。。。我之前真不知道这是套路题。。。花了较长时间。。。被面试官姐姐（or适牛？）吐槽不够smartQAQ
姐姐表示没听过。。我说就是two-pointer...之后要求我实现一下尺取做法的代码。。。
有点久没写尺取竟然写残了。。。？面试官姐姐看了之后说。。。你的two pointer 怎么head和tail都在一端啊。。。不应该在两端吗。。。我表示喵喵喵喵喵？ 我写了好多尺取都是在一端。。。不过这倒是提醒了我。。。改对了代码。。。一头一尾。。。难道说这不叫two pointer? 还是说。。。尺取和two pointer根本不是一个东西。。。
之后好像问了道有很多人买5元一瓶的饮料。。。但是有一半人手里是有5元钱的，有一半人手里只有10元。初始饮料店老板手里没钱。。问合法的方案数？
听懂题目以后直觉和母函数有关系。。。就试探性问了句面试官姐姐。。。
发现果然是对的。。。然后面试官姐姐直接就说出了关键字catalan数....说是本打算让我自己推倒一遍的。。。
嗯。。虽然当时啃《组合数学》的时候母函数这部分我看得很细。。catalan数也是ACM题目的常客。。。。以及16年以前网上能找到的普通型母函数和指数型母函数的题目我基本A光了。。。但是感觉真让我推一遍。。。在面试的紧张气氛里。。。说不定就gg了。。。。。
好像算法题就这两个？
之后好像问了一个。。。大概是说同一个新闻可能会被不同站点报道。。。怎么去判断两个新闻稿件的相似度。。。
我说新闻稿件一般都会有图片。。。一张图片某些关键信息可以作为该图片的特征值。。。一般会有多张图片。。。然后算个n维向量的余弦值。。。。
然后文字部分。。。首先stop word什么的肯定要去掉。。。然后同一个新闻的不同稿件。。。时间地点人物什么的都应该一样。。。没有意义。。。
不同稿件应该是观点不同？ 所以我觉得应该重点关注那些表示观点的词。。。由于中文表示观点的词应该还算相对有限？ 可以打个表把不同类别的词赋值成不同的值。。。然后hash一下。。。？
（感觉自己全程口胡。。。。
其实一面应该还问了其他问题。。。？ 我实在不记得了。。。这几个问题是印象比较深刻的。。。
然后挂了一面电话没几分钟。。。就接了二面电话。。。。上来就面试问问题。。。被效率吓到。。。以至于我以为是哪里搞错了。。。还问了句。。。请问这是什么面试2333.
二面： 一开始好像问了个。。将一个数组的奇数放在前半部分。。。偶数放在后半部分。。。要求 原地完成。。。
这个还好。。。就是两个指针一前一后搞一搞。。。
然后问了。。。搜索中的敏感词问题。。。
问怎么把正文中的敏感词全部替换成星号。。。
我问敏感词多吗?好像是说1000个？反正不多。。。
我就说AC自动机就好。。。敏感词建一个AC自动机。。。然后正文扔进去跑。。。
面试官问我复杂度。。。。啊。。我。。。真的不记得。。。想了下说应该是O((n+m)*L)吧。。。L是字符表的大小。。。。
面试官说这效率不够好。。。让我再想想。。。。
我想到了hash....说把敏感词hash一下。。。？ 面试官问我正文怎么办。。。要把每个词也都hash吗。。。
我当时绝逼脑子短路了。。。以为两个字的词是把n个字两两组合。。。。。我怎么这么傻。。。然后觉得这复杂度显然炸了啊。。。不行。。。
实际上就是O(n)好么。。。再加上敏感词一般都不长。。。
于是我就放弃hash的思路了。。。。
黔驴技穷。。。最后给出了个口胡的统计上的思路。。。
就说统计敏感词的那些字的出现概率。。。以及每个敏感词的字的前后都是那些字（因为这些字出现在一起才敏感）。。。
根据马尔科夫假设。。。每个字出现的概率只和其前面一个字有关blablabla....
然后面试官说。。可以。。但是做不到精确。。。有没有精确的做法。。。
我又想了下。。说除了AC自动机我想不出别的做法了。。。
然后就问下一道题了。。。
说是一个随机数发生器。。。得到0的概率是p，得到1的概率是1-p，问如何等概率生成0和1.。
我想了下说好像和之前遇到的一个问题有点像。。。那道题是给你rand5()的随机数发生器让你生成rand7()的随机数发生器。。。
然后面试官说那就先说说你这道题吧。。。
内心：呜呜呜让你多嘴。。。
然后。。。不知道是紧张还是什么原因。。。明明面hypereal完美回答的问题竟然突然忘记该怎么生成了。。。？
关键就是那个等概率函数怎么构造。。。。
完全不记得当时怎么构造的了。。情急之下。。。竟然又想出另一种？
大概是把每个生成的rand5()看成五进制数某一位数字。。。这样就是等概率的了。。。结果%7就好。。。
不过这个思路貌似对于等概率生成0,1的原始题目也有用？
我可以直接生成二进制数啊。。。00,01,10,11...然后扔掉00和11.。。岂不是美滋滋？
之后又给了我一段代码。。。问我有没有什么问题。。。当时没有看出来。。。。最后知道。。。是在考vector的底层实现。。。
于是最近打算稍微看下STL那些东西的原理。。。
然后。。。大概就是这些。。。每次面试都能暴露自己蛮多问题。。。蛮不错的。。。</description></item><item><title>leetcode 437. Path Sum III</title><link>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</link><pubDate>Fri, 24 Feb 2017 03:45:38 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</guid><description>
题目链接
题意：求一棵二叉树中，所有一段连续路径之和等于给定值的路径数目。
思路：想了半天就只能想到暴力。。。复杂度大概O(n^2)。。。也不是不可以接受。。。但是感觉这也太暴力了。。就去看了题解。。。发现题解就还真是暴力orz。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { //思路：枚举每个起点？？？好暴力啊。。。卧槽。。正解就是这样。。。 public: int dfs(TreeNode* root,int sum) { int res = 0 ; if (root==NULL) return res; if (root-&amp;gt;val==sum) res++; res += dfs(root-&amp;gt;left,sum-root-&amp;gt;val)+dfs(root-&amp;gt;right,sum-root-&amp;gt;val); return res; } int pathSum(TreeNode* root, int sum) { if (root==NULL) return 0; return dfs(root,sum)+pathSum(root-&amp;gt;left,sum)+pathSum(root-&amp;gt;right,sum); } };</description></item><item><title>leetcode 101. Symmetric Tree Add to List（二叉树，判断镜像）</title><link>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</link><pubDate>Fri, 24 Feb 2017 02:57:19 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</guid><description>
题目链接
题意：判断一棵二叉树是否是自己的镜像。做法是做个copy，相当于两棵树做比较。注意逻辑不要漏掉就好
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } bool mirror(TreeNode* rt1,TreeNode* rt2) { if (rt1==NULL&amp;amp;&amp;amp;rt2==NULL) return true; if (rt1==NULL||rt2==NULL) return false; printf(&amp;quot;%d %d\n&amp;quot;,rt1-&amp;gt;val,rt2-&amp;gt;val); if (leaf(rt1)&amp;amp;&amp;amp;leaf(rt2)&amp;amp;&amp;amp;rt1-&amp;gt;val==rt2-&amp;gt;val) return true; if (leaf(rt1)||leaf(rt2)) return false; //包含了其中一个是叶子，或者两个都是叶子但是值不相等的情况。 if (rt1-&amp;gt;val!</description></item><item><title>leetcode 110. Balanced Binary Tree</title><link>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</link><pubDate>Fri, 24 Feb 2017 00:20:19 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</guid><description>
题目链接
题意：判断一颗二叉树是否平衡....
思路：直接搞就好了。。。神TM又忘记dfs的时候忘记返回子调用的值。。。。我这是药丸啊。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { //错误原因：左右子树都平衡的树未必平衡！！！！ public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } int dep(TreeNode* root) { if (root==NULL) return 0; return max(dep(root-&amp;gt;left),dep(root-&amp;gt;right))+1; } bool dfs(TreeNode* root) { bool res = true; if (abs(dep(root-&amp;gt;left)-dep(root-&amp;gt;right))&amp;gt;1) return false; if (root-&amp;gt;left!</description></item><item><title>leetcode 235. Lowest Common Ancestor of a Binary Search Tree（求一个BST中某两个节点LCA）</title><link>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</link><pubDate>Wed, 22 Feb 2017 13:22:08 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</guid><description>
题目链接
题意：求一个BST中某两个节点LCA....
思路：卧槽。。。竟然求LCA...直接想到的显然是Tarjan的方法或者。。。RMQ+DFS。。。但是感觉。。。leetcode怎么可能考算法。。。。于是想到。。。可以从BST下手。。。
两个节点的LCA的值一定在这两个节点之间。
可以根据这个条件做二分。。。
这道题的收获是。。。不要被已知的东西限制住思路。。。tarjan或者RMQ+DFS显然也能做。。。但是那样的相当于没有用到BST的条件。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode * Find(TreeNode* root,TreeNode* p,TreeNode *q) { if (root==NULL) return NULL; //实际上这应该不可能发生》。。。 int rt = root-&amp;gt;val; int a = p-&amp;gt;val; int b = q-&amp;gt;val; if (a&amp;lt;=rt&amp;amp;&amp;amp;rt&amp;lt;=b) return root; if (b&amp;lt;=rt&amp;amp;&amp;amp;rt&amp;lt;=a) return root; if (a&amp;lt;rt&amp;amp;&amp;amp;b&amp;lt;rt) return Find(root-&amp;gt;left,p,q); if (a&amp;gt;rt&amp;amp;&amp;amp;b&amp;gt;rt) return Find(root-&amp;gt;right,p,q); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root==NULL) return NULL; TreeNode* res = Find(root,p,q); return res; } };</description></item><item><title>leetcode 226. Invert Binary Tree（反转二叉树）</title><link>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</link><pubDate>Wed, 22 Feb 2017 12:14:36 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</guid><description>
题目链接
题意：反转一棵二叉树。。。字面意思理解即可。。就是把每一棵子树的左右孩子交换。。。
思路：直接照着题意做就好了。。。没有坑。。记录的原因是听说这题比较经典（虽然毫无难度...
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } void dfs(TreeNode* root) { if (leaf(root)) return; TreeNode* tmp = root-&amp;gt;left; root-&amp;gt;left = root-&amp;gt;right; root-&amp;gt;right = tmp; if (root-&amp;gt;left!=NULL) dfs(root-&amp;gt;left); if (root-&amp;gt;right!</description></item><item><title>112. Path Sum</title><link>https://111qqz.com/2017/02/112-path-sum/</link><pubDate>Wed, 22 Feb 2017 11:40:23 +0000</pubDate><guid>https://111qqz.com/2017/02/112-path-sum/</guid><description>
题目链接
题意：给一棵树。。问是否存在一条从树根到叶子的路径，使得路径上每个点的val之和等于给定的sum。
思路：。。。直接搞就好。。。由于是比较经典的题目所以记录一下。。。注意递归的时候每一部分都要返回值orz..(我是多久没写代码了。。。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool leaf(TreeNode* root) { if (root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL) return true; return false; } int SUM; bool dfs(TreeNode* root,int cur) { // cout&amp;lt;&amp;lt;&amp;quot;val:&amp;quot;&amp;lt;&amp;lt;root-&amp;gt;val&amp;lt;&amp;lt;&amp;quot; cur:&amp;quot;&amp;lt;&amp;lt;cur&amp;lt;&amp;lt;endl; bool ret=false; if (cur+root-&amp;gt;val==SUM&amp;amp;&amp;amp;leaf(root)) return true; if (root-&amp;gt;left!=NULL) ret = dfs(root-&amp;gt;left,cur+root-&amp;gt;val); if (ret) return true; if (root-&amp;gt;right!</description></item><item><title>leetcode 108. Convert Sorted Array to Binary Search Tree（有序数组转化成bst）</title><link>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</link><pubDate>Tue, 21 Feb 2017 11:14:48 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</guid><description>
leetcode108
题意：把有一个有序的数组转化成一课高度尽量小的bst(二叉搜索树)
思路：我竟然忘记了什么是bst........我好傻啊...不过想想可能是因为...最朴素的二叉搜索树几乎用不到...所以很容易忘记吧2333
bst是 binary search tree的缩写..
具体见 维基百科_二叉搜索树
想起来概念就好搞了...直接递归建树即可...类似线段树的build的过程
/* *********************************************** Author :111qqz Created Time :2017年02月21日 星期二 13时08分04秒 File Name :108.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* dfs( int l,int r,vector&amp;lt;int&amp;gt;&amp;amp;nums) { int n = r-l+1; if (n&amp;lt;=0) return NULL; int m = n/2; cout&amp;lt;&amp;lt;&amp;quot;l:&amp;quot;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&amp;quot; r:&amp;quot;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; TreeNode* rt = new TreeNode(nums[l+m]); rt-&amp;gt;left = dfs(l,l+m-1,nums); rt-&amp;gt;right = dfs(l+m+1,r,nums); return rt; } TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int siz = nums.</description></item><item><title>leetcode 107 Binary Tree Level Order Traversal II(最底层往上依次输出二叉树每一个node的val)</title><link>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</link><pubDate>Mon, 20 Feb 2017 12:36:21 +0000</pubDate><guid>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</guid><description>
最近要准备面试...虽然leetcode的题目难度比较水..不过白板写代码还是要练下的。。。我所理解的白板写代码。。。大概就是。。。用记事本。。一遍写对代码的能力吧。。。所以我来记录一下。。思路想错的或者没有秒的题目。
（因为题目描述傻逼/数据范围故意坑人/leetcode抽风 / 我自己犯傻逼 等原因 没有一次通过的题目不在记录之列）
leetcode107
题意：给一棵二叉树，从最底层往上依次输出每一个node的val..
思路：一开始以为同一层的一定会在相邻时间内访问。。。后来发现的确是蠢了。。。
因此dfs的时候加了一个level域。。。每次dfs的时候先左后右就好了。。。
注意记得判断root为空的情况。。。
/* *********************************************** Author :111qqz Created Time :2017年02月20日 星期一 19时21分51秒 File Name :107.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;res; vector&amp;lt;int&amp;gt;tmp[1500]; int mx_level = 0 ; void dfs( TreeNode* root,int level) { // cout&amp;lt;&amp;lt;&amp;quot;level:&amp;quot;&amp;lt;&amp;lt;level&amp;lt;&amp;lt;endl; mx_level = max(mx_level,level); if (root-&amp;gt;left!</description></item></channel></rss>