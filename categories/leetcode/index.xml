<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 111qqz的小窝</title>
    <link>https://111qqz.com/categories/leetcode/</link>
    <description>Recent content in leetcode on 111qqz的小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Aug 2017 19:18:25 +0000</lastBuildDate>
    
	<atom:link href="https://111qqz.com/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode 146. LRU Cache(list&#43;unordered_map)</title>
      <link>https://111qqz.com/2017/08/leetcode-146-lru-cachelistunordered_map/</link>
      <pubDate>Fri, 18 Aug 2017 19:18:25 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/08/leetcode-146-lru-cachelistunordered_map/</guid>
      <description>请实现最近最少使用缓存(Least Recently Used (LRU) cache)类,需要支持 get, set,操作。 get 操作,给出 key,获取到相应的 value (value 为非负数),如果不存在返</description>
    </item>
    
    <item>
      <title>leetcode 146. LRU Cache(list&#43;unordered_map)</title>
      <link>https://111qqz.com/2017/08/leetcode-146-lru-cachelistunordered_map/</link>
      <pubDate>Fri, 18 Aug 2017 19:18:25 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/08/leetcode-146-lru-cachelistunordered_map/</guid>
      <description>请实现最近最少使用缓存(Least Recently Used (LRU) cache)类,需要支持 get, set,操作。 get 操作,给出 key,获取到相应的 value (value 为非负数),如果不存在返</description>
    </item>
    
    <item>
      <title>leetcode162. Find Peak Element (O(lgn)复杂度寻找峰值)</title>
      <link>https://111qqz.com/2017/04/leetcode162-find-peak-element-olgn%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%af%bb%e6%89%be%e5%b3%b0%e5%80%bc/</link>
      <pubDate>Fri, 14 Apr 2017 12:25:16 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode162-find-peak-element-olgn%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%af%bb%e6%89%be%e5%b3%b0%e5%80%bc/</guid>
      <description>A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2, 3, 1], 3 is a</description>
    </item>
    
    <item>
      <title>leetcode162. Find Peak Element (O(lgn)复杂度寻找峰值)</title>
      <link>https://111qqz.com/2017/04/leetcode162-find-peak-element-olgn%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%af%bb%e6%89%be%e5%b3%b0%e5%80%bc/</link>
      <pubDate>Fri, 14 Apr 2017 12:25:16 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode162-find-peak-element-olgn%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%af%bb%e6%89%be%e5%b3%b0%e5%80%bc/</guid>
      <description>A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2, 3, 1], 3 is a</description>
    </item>
    
    <item>
      <title>leetcode 152. Maximum Product Subarray (最大连续子序列乘积，dp)</title>
      <link>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray-%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad%e5%ad%90%e5%ba%8f%e5%88%97%e4%b9%98%e7%a7%af%ef%bc%8cdp/</link>
      <pubDate>Fri, 14 Apr 2017 11:33:30 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray-%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad%e5%ad%90%e5%ba%8f%e5%88%97%e4%b9%98%e7%a7%af%ef%bc%8cdp/</guid>
      <description>Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. 思路：由于有正，有负，还有0.。。所以比最大子串之和要复杂一些。。。 dp[</description>
    </item>
    
    <item>
      <title>leetcode 152. Maximum Product Subarray (最大连续子序列乘积，dp)</title>
      <link>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray-%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad%e5%ad%90%e5%ba%8f%e5%88%97%e4%b9%98%e7%a7%af%ef%bc%8cdp/</link>
      <pubDate>Fri, 14 Apr 2017 11:33:30 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-152-maximum-product-subarray-%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad%e5%ad%90%e5%ba%8f%e5%88%97%e4%b9%98%e7%a7%af%ef%bc%8cdp/</guid>
      <description>Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. 思路：由于有正，有负，还有0.。。所以比最大子串之和要复杂一些。。。 dp[</description>
    </item>
    
    <item>
      <title>leetcode 228. Summary Ranges</title>
      <link>https://111qqz.com/2017/04/leetcode-228-summary-ranges/</link>
      <pubDate>Fri, 14 Apr 2017 10:51:39 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-228-summary-ranges/</guid>
      <description>Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;]. 题意：把连续的数连续表示 思路：模拟。注意有负数，注意有-2147483648这种数据。 本来还想着，可能</description>
    </item>
    
    <item>
      <title>leetcode 228. Summary Ranges</title>
      <link>https://111qqz.com/2017/04/leetcode-228-summary-ranges/</link>
      <pubDate>Fri, 14 Apr 2017 10:51:39 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-228-summary-ranges/</guid>
      <description>Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;]. 题意：把连续的数连续表示 思路：模拟。注意有负数，注意有-2147483648这种数据。 本来还想着，可能</description>
    </item>
    
    <item>
      <title>leetcode 209. Minimum Size Subarray Sum (尺取法)</title>
      <link>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum-%e5%b0%ba%e5%8f%96%e6%b3%95/</link>
      <pubDate>Thu, 13 Apr 2017 13:50:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum-%e5%b0%ba%e5%8f%96%e6%b3%95/</guid>
      <description>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;rsquo;t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint 思路：尺取即可。。好久没写，竟然</description>
    </item>
    
    <item>
      <title>leetcode 209. Minimum Size Subarray Sum (尺取法)</title>
      <link>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum-%e5%b0%ba%e5%8f%96%e6%b3%95/</link>
      <pubDate>Thu, 13 Apr 2017 13:50:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-209-minimum-size-subarray-sum-%e5%b0%ba%e5%8f%96%e6%b3%95/</guid>
      <description>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;rsquo;t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint 思路：尺取即可。。好久没写，竟然</description>
    </item>
    
    <item>
      <title>leetcode 229. Majority Element II （O(1)空间找出现次数大于n/3的元素）</title>
      <link>https://111qqz.com/2017/04/leetcode-229-majority-element-ii-%ef%bc%88o1%e7%a9%ba%e9%97%b4%e6%89%be%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0%e5%a4%a7%e4%ba%8en3%e7%9a%84%e5%85%83%e7%b4%a0%ef%bc%89/</link>
      <pubDate>Thu, 13 Apr 2017 12:41:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-229-majority-element-ii-%ef%bc%88o1%e7%a9%ba%e9%97%b4%e6%89%be%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0%e5%a4%a7%e4%ba%8en3%e7%9a%84%e5%85%83%e7%b4%a0%ef%bc%89/</guid>
      <description>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. 题意：给你n个数，要求找出出现此处大于n/3的。。。 思路：之前做过一个找出n个数出</description>
    </item>
    
    <item>
      <title>leetcode 229. Majority Element II （O(1)空间找出现次数大于n/3的元素）</title>
      <link>https://111qqz.com/2017/04/leetcode-229-majority-element-ii-%ef%bc%88o1%e7%a9%ba%e9%97%b4%e6%89%be%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0%e5%a4%a7%e4%ba%8en3%e7%9a%84%e5%85%83%e7%b4%a0%ef%bc%89/</link>
      <pubDate>Thu, 13 Apr 2017 12:41:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-229-majority-element-ii-%ef%bc%88o1%e7%a9%ba%e9%97%b4%e6%89%be%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0%e5%a4%a7%e4%ba%8en3%e7%9a%84%e5%85%83%e7%b4%a0%ef%bc%89/</guid>
      <description>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. 题意：给你n个数，要求找出出现此处大于n/3的。。。 思路：之前做过一个找出n个数出</description>
    </item>
    
    <item>
      <title>leetcode 75. Sort Colors</title>
      <link>https://111qqz.com/2017/04/leetcode-75-sort-colors/</link>
      <pubDate>Thu, 13 Apr 2017 12:02:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-75-sort-colors/</guid>
      <description>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. 题意：一个数组，由0,1,2组成，现在</description>
    </item>
    
    <item>
      <title>leetcode 75. Sort Colors</title>
      <link>https://111qqz.com/2017/04/leetcode-75-sort-colors/</link>
      <pubDate>Thu, 13 Apr 2017 12:02:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-75-sort-colors/</guid>
      <description>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. 题意：一个数组，由0,1,2组成，现在</description>
    </item>
    
    <item>
      <title>leetcode 11. Container With Most Water (two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 10:13:01 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</guid>
      <description>Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 题意</description>
    </item>
    
    <item>
      <title>leetcode 11. Container With Most Water (two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 10:13:01 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-11-container-with-most-water-two-pointer/</guid>
      <description>Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 题意</description>
    </item>
    
    <item>
      <title>leetcode 16. 3Sum Closest (k-sum问题，two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-16-3sum-closest-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 09:45:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-16-3sum-closest-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</guid>
      <description>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 思路： 排序，然后two pointer,复杂度 O(n^2) /* *********************************************** Author :111qqz Created Time</description>
    </item>
    
    <item>
      <title>leetcode 16. 3Sum Closest (k-sum问题，two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-16-3sum-closest-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 09:45:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-16-3sum-closest-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</guid>
      <description>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 思路： 排序，然后two pointer,复杂度 O(n^2) /* *********************************************** Author :111qqz Created Time</description>
    </item>
    
    <item>
      <title>leetcode 18. 4Sum (k-sum问题，two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-18-4sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 09:34:15 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-18-4sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</guid>
      <description>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 思路： O(n^2)枚举两个元素，变成2-</description>
    </item>
    
    <item>
      <title>leetcode 18. 4Sum (k-sum问题，two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-18-4sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 09:34:15 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-18-4sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</guid>
      <description>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 思路： O(n^2)枚举两个元素，变成2-</description>
    </item>
    
    <item>
      <title>leetcode 15. 3Sum (k-sum问题，two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-15-3sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 08:21:52 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-15-3sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</guid>
      <description>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 思路：排序O(nlgn)，然后枚举一个元素O(n</description>
    </item>
    
    <item>
      <title>leetcode 15. 3Sum (k-sum问题，two pointer)</title>
      <link>https://111qqz.com/2017/04/leetcode-15-3sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</link>
      <pubDate>Thu, 13 Apr 2017 08:21:52 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-15-3sum-k-sum%e9%97%ae%e9%a2%98%ef%bc%8ctwo-pointer/</guid>
      <description>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 思路：排序O(nlgn)，然后枚举一个元素O(n</description>
    </item>
    
    <item>
      <title>leetcode 216. Combination Sum III Add to List (枚举子集，限定集合大小，和为定值）</title>
      <link>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%89/</link>
      <pubDate>Thu, 13 Apr 2017 07:55:09 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%89/</guid>
      <description>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. 题意：1..9个数，从中选择k个，和为n，要求输出所有满足题意的集合。</description>
    </item>
    
    <item>
      <title>leetcode 216. Combination Sum III Add to List (枚举子集，限定集合大小，和为定值）</title>
      <link>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%89/</link>
      <pubDate>Thu, 13 Apr 2017 07:55:09 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-216-combination-sum-iii-add-to-list-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%89/</guid>
      <description>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. 题意：1..9个数，从中选择k个，和为n，要求输出所有满足题意的集合。</description>
    </item>
    
    <item>
      <title>leetcode 77. Combinations (枚举子集，限定集合大小)</title>
      <link>https://111qqz.com/2017/04/leetcode-77-combinations-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f/</link>
      <pubDate>Thu, 13 Apr 2017 07:43:43 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-77-combinations-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f/</guid>
      <description>Given two integers n and k, return all possible combinations of k numbers out of 1 &amp;hellip; n. 思路：就是枚举子集，根据集合的大小剪枝。。。最后只要集合大小为k的集合 /* *********************************************** Author :111qqz Created Time :2017年04月13</description>
    </item>
    
    <item>
      <title>leetcode 77. Combinations (枚举子集，限定集合大小)</title>
      <link>https://111qqz.com/2017/04/leetcode-77-combinations-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f/</link>
      <pubDate>Thu, 13 Apr 2017 07:43:43 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-77-combinations-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e9%99%90%e5%ae%9a%e9%9b%86%e5%90%88%e5%a4%a7%e5%b0%8f/</guid>
      <description>Given two integers n and k, return all possible combinations of k numbers out of 1 &amp;hellip; n. 思路：就是枚举子集，根据集合的大小剪枝。。。最后只要集合大小为k的集合 /* *********************************************** Author :111qqz Created Time :2017年04月13</description>
    </item>
    
    <item>
      <title>leetcode 60. Permutation Sequence (求第k个排列)</title>
      <link>https://111qqz.com/2017/04/leetcode-60-permutation-sequence-%e6%b1%82%e7%ac%ack%e4%b8%aa%e6%8e%92%e5%88%97/</link>
      <pubDate>Thu, 13 Apr 2017 07:24:41 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-60-permutation-sequence-%e6%b1%82%e7%ac%ack%e4%b8%aa%e6%8e%92%e5%88%97/</guid>
      <description>The set [1,2,3,…,_n_] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3): 1. `&amp;quot;123&amp;quot;` 2. `&amp;quot;132&amp;quot;` 3. `&amp;quot;213&amp;quot;` 4. `&amp;quot;231&amp;quot;` 5. `&amp;quot;312&amp;quot;` 6. `&amp;quot;321&amp;quot;` Given n and k, return the _k_th permutation sequence. Note: Given n will be between 1</description>
    </item>
    
    <item>
      <title>leetcode 60. Permutation Sequence (求第k个排列)</title>
      <link>https://111qqz.com/2017/04/leetcode-60-permutation-sequence-%e6%b1%82%e7%ac%ack%e4%b8%aa%e6%8e%92%e5%88%97/</link>
      <pubDate>Thu, 13 Apr 2017 07:24:41 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-60-permutation-sequence-%e6%b1%82%e7%ac%ack%e4%b8%aa%e6%8e%92%e5%88%97/</guid>
      <description>The set [1,2,3,…,_n_] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3): 1. `&amp;quot;123&amp;quot;` 2. `&amp;quot;132&amp;quot;` 3. `&amp;quot;213&amp;quot;` 4. `&amp;quot;231&amp;quot;` 5. `&amp;quot;312&amp;quot;` 6. `&amp;quot;321&amp;quot;` Given n and k, return the _k_th permutation sequence. Note: Given n will be between 1</description>
    </item>
    
    <item>
      <title>leetcode 47. Permutations II (生成全排列，有重复元素)</title>
      <link>https://111qqz.com/2017/04/leetcode-47-permutations-ii-%e7%94%9f%e6%88%90%e5%85%a8%e6%8e%92%e5%88%97%ef%bc%8c%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0/</link>
      <pubDate>Thu, 13 Apr 2017 07:14:03 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-47-permutations-ii-%e7%94%9f%e6%88%90%e5%85%a8%e6%8e%92%e5%88%97%ef%bc%8c%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0/</guid>
      <description>Given a collection of numbers that might contain duplicates, return all possible unique permutations.__ 思路：和leet code 46 类似，最后用set去个重即可。。 /* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时00分48秒</description>
    </item>
    
    <item>
      <title>leetcode 47. Permutations II (生成全排列，有重复元素)</title>
      <link>https://111qqz.com/2017/04/leetcode-47-permutations-ii-%e7%94%9f%e6%88%90%e5%85%a8%e6%8e%92%e5%88%97%ef%bc%8c%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0/</link>
      <pubDate>Thu, 13 Apr 2017 07:14:03 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-47-permutations-ii-%e7%94%9f%e6%88%90%e5%85%a8%e6%8e%92%e5%88%97%ef%bc%8c%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0/</guid>
      <description>Given a collection of numbers that might contain duplicates, return all possible unique permutations.__ 思路：和leet code 46 类似，最后用set去个重即可。。 /* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 15时00分48秒</description>
    </item>
    
    <item>
      <title>leetcode 46. Permutations (生成全排列，无重复元素)</title>
      <link>https://111qqz.com/2017/04/leetcode-46-permutations-%e7%94%9f%e6%88%90%e6%89%80%e6%9c%89%e5%85%a8%e6%8e%92%e5%88%97/</link>
      <pubDate>Thu, 13 Apr 2017 06:59:43 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-46-permutations-%e7%94%9f%e6%88%90%e6%89%80%e6%9c%89%e5%85%a8%e6%8e%92%e5%88%97/</guid>
      <description>Given a collection of distinct numbers, return all possible permutations. 思路：调用n-1次 leetcode 31 解题报告 中提到的算法即可。。。 /* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 14时49分34秒 File Name :46.cpp ************************************************</description>
    </item>
    
    <item>
      <title>leetcode 46. Permutations (生成全排列，无重复元素)</title>
      <link>https://111qqz.com/2017/04/leetcode-46-permutations-%e7%94%9f%e6%88%90%e6%89%80%e6%9c%89%e5%85%a8%e6%8e%92%e5%88%97/</link>
      <pubDate>Thu, 13 Apr 2017 06:59:43 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-46-permutations-%e7%94%9f%e6%88%90%e6%89%80%e6%9c%89%e5%85%a8%e6%8e%92%e5%88%97/</guid>
      <description>Given a collection of distinct numbers, return all possible permutations. 思路：调用n-1次 leetcode 31 解题报告 中提到的算法即可。。。 /* *********************************************** Author :111qqz Created Time :2017年04月13日 星期四 14时49分34秒 File Name :46.cpp ************************************************</description>
    </item>
    
    <item>
      <title>leetcode 31. Next Permutation (in-place 生成下一个全排列)</title>
      <link>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place-%e7%94%9f%e6%88%90%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%85%a8%e6%8e%92%e5%88%97/</link>
      <pubDate>Thu, 13 Apr 2017 06:47:55 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place-%e7%94%9f%e6%88%90%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%85%a8%e6%8e%92%e5%88%97/</guid>
      <description>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5</description>
    </item>
    
    <item>
      <title>leetcode 31. Next Permutation (in-place 生成下一个全排列)</title>
      <link>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place-%e7%94%9f%e6%88%90%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%85%a8%e6%8e%92%e5%88%97/</link>
      <pubDate>Thu, 13 Apr 2017 06:47:55 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-31-next-permutation-in-place-%e7%94%9f%e6%88%90%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%85%a8%e6%8e%92%e5%88%97/</guid>
      <description>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5</description>
    </item>
    
    <item>
      <title>leetcode 33. Search in Rotated Sorted Array (无重复数的旋转数组找定值)</title>
      <link>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array-%e6%97%a0%e9%87%8d%e5%a4%8d%e6%95%b0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e5%ae%9a%e5%80%bc/</link>
      <pubDate>Thu, 13 Apr 2017 06:29:37 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array-%e6%97%a0%e9%87%8d%e5%a4%8d%e6%95%b0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e5%ae%9a%e5%80%bc/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 思路：找规律。。。</description>
    </item>
    
    <item>
      <title>leetcode 33. Search in Rotated Sorted Array (无重复数的旋转数组找定值)</title>
      <link>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array-%e6%97%a0%e9%87%8d%e5%a4%8d%e6%95%b0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e5%ae%9a%e5%80%bc/</link>
      <pubDate>Thu, 13 Apr 2017 06:29:37 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-33-search-in-rotated-sorted-array-%e6%97%a0%e9%87%8d%e5%a4%8d%e6%95%b0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e5%ae%9a%e5%80%bc/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 思路：找规律。。。</description>
    </item>
    
    <item>
      <title>leetcode 34. Search for a Range (二分，找到一段值为tar的区间)</title>
      <link>https://111qqz.com/2017/04/leetcode-34-search-for-a-range-%e4%ba%8c%e5%88%86%ef%bc%8c%e6%89%be%e5%88%b0%e4%b8%80%e6%ae%b5%e5%80%bc%e4%b8%batar%e7%9a%84%e5%8c%ba%e9%97%b4/</link>
      <pubDate>Thu, 13 Apr 2017 05:34:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-34-search-for-a-range-%e4%ba%8c%e5%88%86%ef%bc%8c%e6%89%be%e5%88%b0%e4%b8%80%e6%ae%b5%e5%80%bc%e4%b8%batar%e7%9a%84%e5%8c%ba%e9%97%b4/</guid>
      <description>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4]. 思路：二分。。。 我好</description>
    </item>
    
    <item>
      <title>leetcode 34. Search for a Range (二分，找到一段值为tar的区间)</title>
      <link>https://111qqz.com/2017/04/leetcode-34-search-for-a-range-%e4%ba%8c%e5%88%86%ef%bc%8c%e6%89%be%e5%88%b0%e4%b8%80%e6%ae%b5%e5%80%bc%e4%b8%batar%e7%9a%84%e5%8c%ba%e9%97%b4/</link>
      <pubDate>Thu, 13 Apr 2017 05:34:45 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-34-search-for-a-range-%e4%ba%8c%e5%88%86%ef%bc%8c%e6%89%be%e5%88%b0%e4%b8%80%e6%ae%b5%e5%80%bc%e4%b8%batar%e7%9a%84%e5%8c%ba%e9%97%b4/</guid>
      <description>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4]. 思路：二分。。。 我好</description>
    </item>
    
    <item>
      <title>leetcode 39. Combination Sum (dfs，求所有的组合，和为定值，每个数可以重复用)</title>
      <link>https://111qqz.com/2017/04/leetcode-39-combination-sum-dfs%ef%bc%8c%e6%b1%82%e6%89%80%e6%9c%89%e7%9a%84%e7%bb%84%e5%90%88%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%8c%e6%af%8f%e4%b8%aa%e6%95%b0%e5%8f%af%e4%bb%a5/</link>
      <pubDate>Thu, 13 Apr 2017 02:47:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-39-combination-sum-dfs%ef%bc%8c%e6%b1%82%e6%89%80%e6%9c%89%e7%9a%84%e7%bb%84%e5%90%88%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%8c%e6%af%8f%e4%b8%aa%e6%95%b0%e5%8f%af%e4%bb%a5/</guid>
      <description>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: * All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations. 题意：给n个数，求所有</description>
    </item>
    
    <item>
      <title>leetcode 39. Combination Sum (dfs，求所有的组合，和为定值，每个数可以重复用)</title>
      <link>https://111qqz.com/2017/04/leetcode-39-combination-sum-dfs%ef%bc%8c%e6%b1%82%e6%89%80%e6%9c%89%e7%9a%84%e7%bb%84%e5%90%88%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%8c%e6%af%8f%e4%b8%aa%e6%95%b0%e5%8f%af%e4%bb%a5/</link>
      <pubDate>Thu, 13 Apr 2017 02:47:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-39-combination-sum-dfs%ef%bc%8c%e6%b1%82%e6%89%80%e6%9c%89%e7%9a%84%e7%bb%84%e5%90%88%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc%ef%bc%8c%e6%af%8f%e4%b8%aa%e6%95%b0%e5%8f%af%e4%bb%a5/</guid>
      <description>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: * All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations. 题意：给n个数，求所有</description>
    </item>
    
    <item>
      <title>leetcode 40. Combination Sum II (枚举子集，和为定值)</title>
      <link>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc/</link>
      <pubDate>Wed, 12 Apr 2017 16:23:29 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc/</guid>
      <description>* Total Accepted: **106670** * Total Submissions: **329718** * Difficulty: **Medium** * Contributor: **LeetCode** Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: * All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations.</description>
    </item>
    
    <item>
      <title>leetcode 40. Combination Sum II (枚举子集，和为定值)</title>
      <link>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc/</link>
      <pubDate>Wed, 12 Apr 2017 16:23:29 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-40-combination-sum-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86%ef%bc%8c%e5%92%8c%e4%b8%ba%e5%ae%9a%e5%80%bc/</guid>
      <description>* Total Accepted: **106670** * Total Submissions: **329718** * Difficulty: **Medium** * Contributor: **LeetCode** Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: * All numbers (including target) will be positive integers. * The solution set must not contain duplicate combinations.</description>
    </item>
    
    <item>
      <title>leetcode 495. Teemo Attacking</title>
      <link>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</link>
      <pubDate>Wed, 12 Apr 2017 16:00:57 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</guid>
      <description>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo&amp;rsquo;s attacking ascending time series towards Ashe and the poisoning time duration per Teemo&amp;rsquo;s attacking, you need to output the total time that Ashe is in poisoned condition. You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe</description>
    </item>
    
    <item>
      <title>leetcode 495. Teemo Attacking</title>
      <link>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</link>
      <pubDate>Wed, 12 Apr 2017 16:00:57 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-495-teemo-attacking/</guid>
      <description>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo&amp;rsquo;s attacking ascending time series towards Ashe and the poisoning time duration per Teemo&amp;rsquo;s attacking, you need to output the total time that Ashe is in poisoned condition. You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe</description>
    </item>
    
    <item>
      <title>leetcode 442. Find All Duplicates in an Array（找出出现两次的元素）</title>
      <link>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</link>
      <pubDate>Wed, 12 Apr 2017 15:21:23 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</guid>
      <description>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? 思路：还是一个映射，如果某个位置要映射的时候已经为负</description>
    </item>
    
    <item>
      <title>leetcode 442. Find All Duplicates in an Array（找出出现两次的元素）</title>
      <link>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</link>
      <pubDate>Wed, 12 Apr 2017 15:21:23 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-442-find-all-duplicates-in-an-array/</guid>
      <description>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? 思路：还是一个映射，如果某个位置要映射的时候已经为负</description>
    </item>
    
    <item>
      <title>leetcode 48. Rotate Image (旋转方阵(in place))</title>
      <link>https://111qqz.com/2017/04/leetcode-48-rotate-image-%e6%97%8b%e8%bd%ac%e6%96%b9%e9%98%b5inplace/</link>
      <pubDate>Wed, 12 Apr 2017 13:22:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-48-rotate-image-%e6%97%8b%e8%bd%ac%e6%96%b9%e9%98%b5inplace/</guid>
      <description>You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 题意：给一个n*n的方阵，要求顺时针旋转90度。 思路：(x,y)-&amp;gt;(y,n-1-</description>
    </item>
    
    <item>
      <title>leetcode 48. Rotate Image (旋转方阵(in place))</title>
      <link>https://111qqz.com/2017/04/leetcode-48-rotate-image-%e6%97%8b%e8%bd%ac%e6%96%b9%e9%98%b5inplace/</link>
      <pubDate>Wed, 12 Apr 2017 13:22:33 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-48-rotate-image-%e6%97%8b%e8%bd%ac%e6%96%b9%e9%98%b5inplace/</guid>
      <description>You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 题意：给一个n*n的方阵，要求顺时针旋转90度。 思路：(x,y)-&amp;gt;(y,n-1-</description>
    </item>
    
    <item>
      <title>leetcode 54. Spiral Matrix (矩阵蛇形取数)</title>
      <link>https://111qqz.com/2017/04/leetcode-54-spiral-matrix-%e7%9f%a9%e9%98%b5%e8%9b%87%e5%bd%a2%e5%8f%96%e6%95%b0/</link>
      <pubDate>Tue, 11 Apr 2017 12:07:54 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-54-spiral-matrix-%e7%9f%a9%e9%98%b5%e8%9b%87%e5%bd%a2%e5%8f%96%e6%95%b0/</guid>
      <description>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 思路：。。。再次让我回想起高一的暑假。。。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时42分</description>
    </item>
    
    <item>
      <title>leetcode 54. Spiral Matrix (矩阵蛇形取数)</title>
      <link>https://111qqz.com/2017/04/leetcode-54-spiral-matrix-%e7%9f%a9%e9%98%b5%e8%9b%87%e5%bd%a2%e5%8f%96%e6%95%b0/</link>
      <pubDate>Tue, 11 Apr 2017 12:07:54 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-54-spiral-matrix-%e7%9f%a9%e9%98%b5%e8%9b%87%e5%bd%a2%e5%8f%96%e6%95%b0/</guid>
      <description>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 思路：。。。再次让我回想起高一的暑假。。。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时42分</description>
    </item>
    
    <item>
      <title>leetcode  55. Jump Game (dp)</title>
      <link>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</link>
      <pubDate>Tue, 11 Apr 2017 11:39:15 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 思路:dp[i]表示能否到达位置i&amp;hellip;无脑dp即可。。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二</description>
    </item>
    
    <item>
      <title>leetcode  55. Jump Game (dp)</title>
      <link>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</link>
      <pubDate>Tue, 11 Apr 2017 11:39:15 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-55-jump-game-dp/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 思路:dp[i]表示能否到达位置i&amp;hellip;无脑dp即可。。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二</description>
    </item>
    
    <item>
      <title>leetcode 56. Merge Intervals (模拟，求相交区间)</title>
      <link>https://111qqz.com/2017/04/leetcode-56-merge-intervals-%e6%a8%a1%e6%8b%9f%ef%bc%8c%e6%b1%82%e7%9b%b8%e4%ba%a4%e5%8c%ba%e9%97%b4/</link>
      <pubDate>Tue, 11 Apr 2017 11:30:32 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-56-merge-intervals-%e6%a8%a1%e6%8b%9f%ef%bc%8c%e6%b1%82%e7%9b%b8%e4%ba%a4%e5%8c%ba%e9%97%b4/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 思路：扫一遍即可。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时15分30秒 File Name :56.cpp ************************************************ */ /** * Definition for an interval. * struct Interval {</description>
    </item>
    
    <item>
      <title>leetcode 56. Merge Intervals (模拟，求相交区间)</title>
      <link>https://111qqz.com/2017/04/leetcode-56-merge-intervals-%e6%a8%a1%e6%8b%9f%ef%bc%8c%e6%b1%82%e7%9b%b8%e4%ba%a4%e5%8c%ba%e9%97%b4/</link>
      <pubDate>Tue, 11 Apr 2017 11:30:32 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-56-merge-intervals-%e6%a8%a1%e6%8b%9f%ef%bc%8c%e6%b1%82%e7%9b%b8%e4%ba%a4%e5%8c%ba%e9%97%b4/</guid>
      <description>Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 思路：扫一遍即可。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 19时15分30秒 File Name :56.cpp ************************************************ */ /** * Definition for an interval. * struct Interval {</description>
    </item>
    
    <item>
      <title>leetocde 59. Spiral Matrix II (模拟)</title>
      <link>https://111qqz.com/2017/04/59-spiral-matrix-ii-%e6%a8%a1%e6%8b%9f/</link>
      <pubDate>Tue, 11 Apr 2017 11:07:52 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/59-spiral-matrix-ii-%e6%a8%a1%e6%8b%9f/</guid>
      <description>Given an integer n, generate a square matrix filled with elements from 1 to _n_2 in spiral order. 思路：仿佛回到高一的那个暑假。。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时52分15秒 File Name :59.cpp ************************************************ */</description>
    </item>
    
    <item>
      <title>leetocde 59. Spiral Matrix II (模拟)</title>
      <link>https://111qqz.com/2017/04/59-spiral-matrix-ii-%e6%a8%a1%e6%8b%9f/</link>
      <pubDate>Tue, 11 Apr 2017 11:07:52 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/59-spiral-matrix-ii-%e6%a8%a1%e6%8b%9f/</guid>
      <description>Given an integer n, generate a square matrix filled with elements from 1 to _n_2 in spiral order. 思路：仿佛回到高一的那个暑假。。。 /* *********************************************** Author :111qqz Created Time :2017年04月11日 星期二 18时52分15秒 File Name :59.cpp ************************************************ */</description>
    </item>
    
    <item>
      <title>leetocde 63. Unique Paths II</title>
      <link>https://111qqz.com/2017/04/63-unique-paths-ii/</link>
      <pubDate>Tue, 11 Apr 2017 10:50:57 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/63-unique-paths-ii/</guid>
      <description>Follow up for &amp;ldquo;Unique Paths&amp;rdquo;: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. [ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2. 题意：从</description>
    </item>
    
    <item>
      <title>leetocde 63. Unique Paths II</title>
      <link>https://111qqz.com/2017/04/63-unique-paths-ii/</link>
      <pubDate>Tue, 11 Apr 2017 10:50:57 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/63-unique-paths-ii/</guid>
      <description>Follow up for &amp;ldquo;Unique Paths&amp;rdquo;: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. [ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2. 题意：从</description>
    </item>
    
    <item>
      <title>leetcode 64. Minimum Path Sum (二维dp)</title>
      <link>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum-%e4%ba%8c%e7%bb%b4dp/</link>
      <pubDate>Mon, 10 Apr 2017 02:35:20 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum-%e4%ba%8c%e7%bb%b4dp/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 数字三角形。。。。从坐上到右下问最短路径。。每次只能向</description>
    </item>
    
    <item>
      <title>leetcode 64. Minimum Path Sum (二维dp)</title>
      <link>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum-%e4%ba%8c%e7%bb%b4dp/</link>
      <pubDate>Mon, 10 Apr 2017 02:35:20 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-64-minimum-path-sum-%e4%ba%8c%e7%bb%b4dp/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 数字三角形。。。。从坐上到右下问最短路径。。每次只能向</description>
    </item>
    
    <item>
      <title>leetcode  73. Set Matrix Zeroes (矩阵置0，乱搞)</title>
      <link>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes-%e7%9f%a9%e9%98%b5%e7%bd%ae0%ef%bc%8c%e4%b9%b1%e6%90%9e/</link>
      <pubDate>Mon, 10 Apr 2017 01:16:43 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes-%e7%9f%a9%e9%98%b5%e7%bd%ae0%ef%bc%8c%e4%b9%b1%e6%90%9e/</guid>
      <description>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. click to show follow up. Follow up:Did you use extra space? A straight forward solution using O(_m_n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 直接放</description>
    </item>
    
    <item>
      <title>leetcode  73. Set Matrix Zeroes (矩阵置0，乱搞)</title>
      <link>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes-%e7%9f%a9%e9%98%b5%e7%bd%ae0%ef%bc%8c%e4%b9%b1%e6%90%9e/</link>
      <pubDate>Mon, 10 Apr 2017 01:16:43 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-73-set-matrix-zeroes-%e7%9f%a9%e9%98%b5%e7%bd%ae0%ef%bc%8c%e4%b9%b1%e6%90%9e/</guid>
      <description>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. click to show follow up. Follow up:Did you use extra space? A straight forward solution using O(_m_n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 直接放</description>
    </item>
    
    <item>
      <title>leetcode 238. Product of Array Except Self (乱搞)</title>
      <link>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self-%e4%b9%b1%e6%90%9e/</link>
      <pubDate>Sun, 09 Apr 2017 11:50:05 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self-%e4%b9%b1%e6%90%9e/</guid>
      <description>Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity</description>
    </item>
    
    <item>
      <title>leetcode 238. Product of Array Except Self (乱搞)</title>
      <link>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self-%e4%b9%b1%e6%90%9e/</link>
      <pubDate>Sun, 09 Apr 2017 11:50:05 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-238-product-of-array-except-self-%e4%b9%b1%e6%90%9e/</guid>
      <description>Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity</description>
    </item>
    
    <item>
      <title>leetcode 79. Word Search (dfs)</title>
      <link>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</link>
      <pubDate>Fri, 07 Apr 2017 06:59:26 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</guid>
      <description>Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 思路：dfs即可。记得要回溯一下&amp;hellip;</description>
    </item>
    
    <item>
      <title>leetcode 79. Word Search (dfs)</title>
      <link>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</link>
      <pubDate>Fri, 07 Apr 2017 06:59:26 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-79-word-search-dfs/</guid>
      <description>Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 思路：dfs即可。记得要回溯一下&amp;hellip;</description>
    </item>
    
    <item>
      <title>leetcode 80 Remove Duplicates from Sorted Array II  （有序数组去除重复元素）</title>
      <link>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Wed, 05 Apr 2017 13:36:44 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</guid>
      <description>Follow up for &amp;ldquo;Remove Duplicates&amp;rdquo;: What if duplicates are allowed at most twice? For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&amp;rsquo;t matter what you leave beyond the new length. Subscribe to see which companies asked this question. 题意：一个有序数组，</description>
    </item>
    
    <item>
      <title>leetcode 80 Remove Duplicates from Sorted Array II  （有序数组去除重复元素）</title>
      <link>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Wed, 05 Apr 2017 13:36:44 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-80-remove-duplicates-from-sorted-array-ii/</guid>
      <description>Follow up for &amp;ldquo;Remove Duplicates&amp;rdquo;: What if duplicates are allowed at most twice? For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&amp;rsquo;t matter what you leave beyond the new length. Subscribe to see which companies asked this question. 题意：一个有序数组，</description>
    </item>
    
    <item>
      <title>leetcode  81. Search in Rotated Sorted Array II (有重复元素的旋转数组找给定值)</title>
      <link>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii-%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e7%bb%99%e5%ae%9a%e5%80%bc/</link>
      <pubDate>Wed, 05 Apr 2017 13:17:51 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii-%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e7%bb%99%e5%ae%9a%e5%80%bc/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 好像阿里一面的时候问过。。。 思路：肯定</description>
    </item>
    
    <item>
      <title>leetcode  81. Search in Rotated Sorted Array II (有重复元素的旋转数组找给定值)</title>
      <link>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii-%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e7%bb%99%e5%ae%9a%e5%80%bc/</link>
      <pubDate>Wed, 05 Apr 2017 13:17:51 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-81-search-in-rotated-sorted-array-ii-%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0%e7%9a%84%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e6%89%be%e7%bb%99%e5%ae%9a%e5%80%bc/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 好像阿里一面的时候问过。。。 思路：肯定</description>
    </item>
    
    <item>
      <title>leetcode  289. Game of Life (模拟)</title>
      <link>https://111qqz.com/2017/04/leetcode-289-game-of-life-%e6%a8%a1%e6%8b%9f/</link>
      <pubDate>Wed, 05 Apr 2017 12:03:28 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-289-game-of-life-%e6%a8%a1%e6%8b%9f/</guid>
      <description>According to the Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo; Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): 1. Any</description>
    </item>
    
    <item>
      <title>leetcode  289. Game of Life (模拟)</title>
      <link>https://111qqz.com/2017/04/leetcode-289-game-of-life-%e6%a8%a1%e6%8b%9f/</link>
      <pubDate>Wed, 05 Apr 2017 12:03:28 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/leetcode-289-game-of-life-%e6%a8%a1%e6%8b%9f/</guid>
      <description>According to the Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo; Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): 1. Any</description>
    </item>
    
    <item>
      <title>90. Subsets II (枚举子集)</title>
      <link>https://111qqz.com/2017/04/90-subsets-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86/</link>
      <pubDate>Wed, 05 Apr 2017 10:45:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/90-subsets-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86/</guid>
      <description>Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example, If nums = [1,2,2], a solution is: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路： 复习（？）一下 枚举子集的三种写法 （还有种更飘逸的&amp;he</description>
    </item>
    
    <item>
      <title>90. Subsets II (枚举子集)</title>
      <link>https://111qqz.com/2017/04/90-subsets-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86/</link>
      <pubDate>Wed, 05 Apr 2017 10:45:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/90-subsets-ii-%e6%9e%9a%e4%b8%be%e5%ad%90%e9%9b%86/</guid>
      <description>Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example, If nums = [1,2,2], a solution is: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路： 复习（？）一下 枚举子集的三种写法 （还有种更飘逸的&amp;he</description>
    </item>
    
    <item>
      <title>106. Construct Binary Tree from Inorder and Postorder Traversal(根据中序和后序遍历构建二叉树)</title>
      <link>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal%e6%a0%b9%e6%8d%ae%e4%b8%ad%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91/</link>
      <pubDate>Wed, 05 Apr 2017 08:59:41 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal%e6%a0%b9%e6%8d%ae%e4%b8%ad%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91/</guid>
      <description>/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 16时49分57秒 File Name :106.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; / class Solution {</description>
    </item>
    
    <item>
      <title>106. Construct Binary Tree from Inorder and Postorder Traversal(根据中序和后序遍历构建二叉树)</title>
      <link>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal%e6%a0%b9%e6%8d%ae%e4%b8%ad%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91/</link>
      <pubDate>Wed, 05 Apr 2017 08:59:41 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/106-construct-binary-tree-from-inorder-and-postorder-traversal%e6%a0%b9%e6%8d%ae%e4%b8%ad%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91/</guid>
      <description>/* *********************************************** Author :111qqz Created Time :2017年04月05日 星期三 16时49分57秒 File Name :106.cpp ************************************************ */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; / class Solution {</description>
    </item>
    
    <item>
      <title>287. Find the Duplicate Number (floyd判圈算法找重复元素)</title>
      <link>https://111qqz.com/2017/04/287-find-the-duplicate-number-floyd%e5%88%a4%e5%9c%88%e7%ae%97%e6%b3%95/</link>
      <pubDate>Wed, 05 Apr 2017 07:31:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/287-find-the-duplicate-number-floyd%e5%88%a4%e5%9c%88%e7%ae%97%e6%b3%95/</guid>
      <description>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: 1. You **must not** modify the array (assume the array is read only). 2. You must use only constant, _O_(1) extra space. 3. Your runtime complexity should be less than</description>
    </item>
    
    <item>
      <title>287. Find the Duplicate Number (floyd判圈算法找重复元素)</title>
      <link>https://111qqz.com/2017/04/287-find-the-duplicate-number-floyd%e5%88%a4%e5%9c%88%e7%ae%97%e6%b3%95/</link>
      <pubDate>Wed, 05 Apr 2017 07:31:49 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/287-find-the-duplicate-number-floyd%e5%88%a4%e5%9c%88%e7%ae%97%e6%b3%95/</guid>
      <description>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: 1. You **must not** modify the array (assume the array is read only). 2. You must use only constant, _O_(1) extra space. 3. Your runtime complexity should be less than</description>
    </item>
    
    <item>
      <title>532. K-diff Pairs in an Array （找差为k的数对）</title>
      <link>https://111qqz.com/2017/04/532-k-diff-pairs-in-an-array/</link>
      <pubDate>Wed, 05 Apr 2017 06:53:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/532-k-diff-pairs-in-an-array/</guid>
      <description>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in</description>
    </item>
    
    <item>
      <title>532. K-diff Pairs in an Array （找差为k的数对）</title>
      <link>https://111qqz.com/2017/04/532-k-diff-pairs-in-an-array/</link>
      <pubDate>Wed, 05 Apr 2017 06:53:02 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/532-k-diff-pairs-in-an-array/</guid>
      <description>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in</description>
    </item>
    
    <item>
      <title>448. Find All Numbers Disappeared in an Array(寻找所有消失的元素）</title>
      <link>https://111qqz.com/2017/04/448-find-all-numbers-disappeared-in-an-arraygiven-an-array-of-integers-where-1-%e2%89%a4-ai-%e2%89%a4-n-n-size-of-array-some-elements-appear-twice-and-others-appear-once-find-all-the-element/</link>
      <pubDate>Wed, 05 Apr 2017 06:19:06 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/448-find-all-numbers-disappeared-in-an-arraygiven-an-array-of-integers-where-1-%e2%89%a4-ai-%e2%89%a4-n-n-size-of-array-some-elements-appear-twice-and-others-appear-once-find-all-the-element/</guid>
      <description>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6] 思路：</description>
    </item>
    
    <item>
      <title>448. Find All Numbers Disappeared in an Array(寻找所有消失的元素）</title>
      <link>https://111qqz.com/2017/04/448-find-all-numbers-disappeared-in-an-arraygiven-an-array-of-integers-where-1-%e2%89%a4-ai-%e2%89%a4-n-n-size-of-array-some-elements-appear-twice-and-others-appear-once-find-all-the-element/</link>
      <pubDate>Wed, 05 Apr 2017 06:19:06 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/04/448-find-all-numbers-disappeared-in-an-arraygiven-an-array-of-integers-where-1-%e2%89%a4-ai-%e2%89%a4-n-n-size-of-array-some-elements-appear-twice-and-others-appear-once-find-all-the-element/</guid>
      <description>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6] 思路：</description>
    </item>
    
    <item>
      <title>O(1)得到最小值的栈</title>
      <link>https://111qqz.com/2017/03/o1%e5%be%97%e5%88%b0%e6%9c%80%e5%b0%8f%e5%80%bc%e7%9a%84%e6%a0%88/</link>
      <pubDate>Sun, 12 Mar 2017 14:12:08 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/o1%e5%be%97%e5%88%b0%e6%9c%80%e5%b0%8f%e5%80%bc%e7%9a%84%e6%a0%88/</guid>
      <description>题意：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数，要求时间复杂度为O(1) 思路：标题党去死一死好么。。。真是无趣。</description>
    </item>
    
    <item>
      <title>O(1)得到最小值的栈</title>
      <link>https://111qqz.com/2017/03/o1%e5%be%97%e5%88%b0%e6%9c%80%e5%b0%8f%e5%80%bc%e7%9a%84%e6%a0%88/</link>
      <pubDate>Sun, 12 Mar 2017 14:12:08 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/o1%e5%be%97%e5%88%b0%e6%9c%80%e5%b0%8f%e5%80%bc%e7%9a%84%e6%a0%88/</guid>
      <description>题意：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数，要求时间复杂度为O(1) 思路：标题党去死一死好么。。。真是无趣。</description>
    </item>
    
    <item>
      <title>求旋转数组最小值（二分）</title>
      <link>https://111qqz.com/2017/03/%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%89/</link>
      <pubDate>Sun, 12 Mar 2017 13:19:16 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%89/</guid>
      <description>题意：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组</description>
    </item>
    
    <item>
      <title>求旋转数组最小值（二分）</title>
      <link>https://111qqz.com/2017/03/%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%89/</link>
      <pubDate>Sun, 12 Mar 2017 13:19:16 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%89/</guid>
      <description>题意：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组</description>
    </item>
    
    <item>
      <title>用两个栈实现队列</title>
      <link>https://111qqz.com/2017/03/%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97/</link>
      <pubDate>Sat, 11 Mar 2017 12:52:58 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97/</guid>
      <description>思路： 一个元素入队的时候直接插入到stack1中。。。 一个元素出队的时候。。。如果stack2不为空。。stack2顶的元素就是要出队的。。</description>
    </item>
    
    <item>
      <title>用两个栈实现队列</title>
      <link>https://111qqz.com/2017/03/%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97/</link>
      <pubDate>Sat, 11 Mar 2017 12:52:58 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97/</guid>
      <description>思路： 一个元素入队的时候直接插入到stack1中。。。 一个元素出队的时候。。。如果stack2不为空。。stack2顶的元素就是要出队的。。</description>
    </item>
    
    <item>
      <title>leetcode 105 根据前序遍历和中序遍历重构二叉树</title>
      <link>https://111qqz.com/2017/03/%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e5%92%8c%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e9%87%8d%e6%9e%84%e4%ba%8c%e5%8f%89%e6%a0%91/</link>
      <pubDate>Sat, 11 Mar 2017 11:34:40 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e5%92%8c%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e9%87%8d%e6%9e%84%e4%ba%8c%e5%8f%89%e6%a0%91/</guid>
      <description>思路： 分治搞之。 实际上两个vector就够了。。。4个会MLE(在leetcode上。。。 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL),</description>
    </item>
    
    <item>
      <title>leetcode 105 根据前序遍历和中序遍历重构二叉树</title>
      <link>https://111qqz.com/2017/03/%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e5%92%8c%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e9%87%8d%e6%9e%84%e4%ba%8c%e5%8f%89%e6%a0%91/</link>
      <pubDate>Sat, 11 Mar 2017 11:34:40 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86%e5%92%8c%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e9%87%8d%e6%9e%84%e4%ba%8c%e5%8f%89%e6%a0%91/</guid>
      <description>思路： 分治搞之。 实际上两个vector就够了。。。4个会MLE(在leetcode上。。。 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL),</description>
    </item>
    
    <item>
      <title>leetcode 74. Search a 2D Matrix</title>
      <link>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</link>
      <pubDate>Thu, 09 Mar 2017 11:14:05 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</guid>
      <description>题目链接 题意：给一个二维数组。。。每一行每一列都分别递增。。问某个value是否出现过。。。 思路：单调。。显然二分。。。唯一的技巧是从右上角</description>
    </item>
    
    <item>
      <title>leetcode 74. Search a 2D Matrix</title>
      <link>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</link>
      <pubDate>Thu, 09 Mar 2017 11:14:05 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/03/leetcode-74-search-a-2d-matrix/</guid>
      <description>题目链接 题意：给一个二维数组。。。每一行每一列都分别递增。。问某个value是否出现过。。。 思路：单调。。显然二分。。。唯一的技巧是从右上角</description>
    </item>
    
    <item>
      <title>leetcode 437. Path Sum III</title>
      <link>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</link>
      <pubDate>Fri, 24 Feb 2017 03:45:38 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</guid>
      <description>题目链接 题意：求一棵二叉树中，所有一段连续路径之和等于给定值的路径数目。 思路：想了半天就只能想到暴力。。。复杂度大概O(n^2)。。。也不是</description>
    </item>
    
    <item>
      <title>leetcode 437. Path Sum III</title>
      <link>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</link>
      <pubDate>Fri, 24 Feb 2017 03:45:38 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-437-path-sum-iii/</guid>
      <description>题目链接 题意：求一棵二叉树中，所有一段连续路径之和等于给定值的路径数目。 思路：想了半天就只能想到暴力。。。复杂度大概O(n^2)。。。也不是</description>
    </item>
    
    <item>
      <title>leetcode 101. Symmetric Tree Add to List（二叉树，判断镜像）</title>
      <link>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</link>
      <pubDate>Fri, 24 Feb 2017 02:57:19 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</guid>
      <description>题目链接 题意：判断一棵二叉树是否是自己的镜像。做法是做个copy，相当于两棵树做比较。注意逻辑不要漏掉就好 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>leetcode 101. Symmetric Tree Add to List（二叉树，判断镜像）</title>
      <link>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</link>
      <pubDate>Fri, 24 Feb 2017 02:57:19 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-101-symmetric-tree-add-to-list/</guid>
      <description>题目链接 题意：判断一棵二叉树是否是自己的镜像。做法是做个copy，相当于两棵树做比较。注意逻辑不要漏掉就好 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>leetcode 110. Balanced Binary Tree</title>
      <link>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</link>
      <pubDate>Fri, 24 Feb 2017 00:20:19 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</guid>
      <description>题目链接 题意：判断一颗二叉树是否平衡&amp;hellip;. 思路：直接搞就好了。。。神TM又忘记dfs的时候忘记返回子调用的值。。。。我这是药丸啊</description>
    </item>
    
    <item>
      <title>leetcode 110. Balanced Binary Tree</title>
      <link>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</link>
      <pubDate>Fri, 24 Feb 2017 00:20:19 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-110-balanced-binary-tree/</guid>
      <description>题目链接 题意：判断一颗二叉树是否平衡&amp;hellip;. 思路：直接搞就好了。。。神TM又忘记dfs的时候忘记返回子调用的值。。。。我这是药丸啊</description>
    </item>
    
    <item>
      <title>leetcode 235. Lowest Common Ancestor of a Binary Search Tree（求一个BST中某两个节点LCA）</title>
      <link>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Wed, 22 Feb 2017 13:22:08 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>题目链接 题意：求一个BST中某两个节点LCA&amp;hellip;. 思路：卧槽。。。竟然求LCA&amp;hellip;直接想到的显然是Tarjan的方法</description>
    </item>
    
    <item>
      <title>leetcode 235. Lowest Common Ancestor of a Binary Search Tree（求一个BST中某两个节点LCA）</title>
      <link>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Wed, 22 Feb 2017 13:22:08 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>题目链接 题意：求一个BST中某两个节点LCA&amp;hellip;. 思路：卧槽。。。竟然求LCA&amp;hellip;直接想到的显然是Tarjan的方法</description>
    </item>
    
    <item>
      <title>leetcode 104. Maximum Depth of Binary Tree（求一棵树的深度）</title>
      <link>https://111qqz.com/2017/02/leetcode-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 22 Feb 2017 12:41:34 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-104-maximum-depth-of-binary-tree/</guid>
      <description>题目链接 题意：求一棵树的深度。。。。 思路：。。。定义搞即可。。按照左右子树中大的算。。。因为据说是经典题（虽然并不觉得2333。。。所以记录</description>
    </item>
    
    <item>
      <title>leetcode 104. Maximum Depth of Binary Tree（求一棵树的深度）</title>
      <link>https://111qqz.com/2017/02/leetcode-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 22 Feb 2017 12:41:34 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-104-maximum-depth-of-binary-tree/</guid>
      <description>题目链接 题意：求一棵树的深度。。。。 思路：。。。定义搞即可。。按照左右子树中大的算。。。因为据说是经典题（虽然并不觉得2333。。。所以记录</description>
    </item>
    
    <item>
      <title>leetcode 226. Invert Binary Tree（反转二叉树）</title>
      <link>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</link>
      <pubDate>Wed, 22 Feb 2017 12:14:36 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</guid>
      <description>题目链接 题意：反转一棵二叉树。。。字面意思理解即可。。就是把每一棵子树的左右孩子交换。。。 思路：直接照着题意做就好了。。。没有坑。。记录的原</description>
    </item>
    
    <item>
      <title>leetcode 226. Invert Binary Tree（反转二叉树）</title>
      <link>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</link>
      <pubDate>Wed, 22 Feb 2017 12:14:36 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-226-invert-binary-tree/</guid>
      <description>题目链接 题意：反转一棵二叉树。。。字面意思理解即可。。就是把每一棵子树的左右孩子交换。。。 思路：直接照着题意做就好了。。。没有坑。。记录的原</description>
    </item>
    
    <item>
      <title>112. Path Sum</title>
      <link>https://111qqz.com/2017/02/112-path-sum/</link>
      <pubDate>Wed, 22 Feb 2017 11:40:23 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/112-path-sum/</guid>
      <description>题目链接 题意：给一棵树。。问是否存在一条从树根到叶子的路径，使得路径上每个点的val之和等于给定的sum。 思路：。。。直接搞就好。。。由于是</description>
    </item>
    
    <item>
      <title>112. Path Sum</title>
      <link>https://111qqz.com/2017/02/112-path-sum/</link>
      <pubDate>Wed, 22 Feb 2017 11:40:23 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/112-path-sum/</guid>
      <description>题目链接 题意：给一棵树。。问是否存在一条从树根到叶子的路径，使得路径上每个点的val之和等于给定的sum。 思路：。。。直接搞就好。。。由于是</description>
    </item>
    
    <item>
      <title>leetcode 108. Convert Sorted Array to Binary Search Tree（有序数组转化成bst）</title>
      <link>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Tue, 21 Feb 2017 11:14:48 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</guid>
      <description>leetcode108 题意：把有一个有序的数组转化成一课高度尽量小的bst(二叉搜索树) 思路：我竟然忘记了什么是bst&amp;hellip;&amp;hellip;..我好傻</description>
    </item>
    
    <item>
      <title>leetcode 108. Convert Sorted Array to Binary Search Tree（有序数组转化成bst）</title>
      <link>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Tue, 21 Feb 2017 11:14:48 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-108-convert-sorted-array-to-binary-search-tree/</guid>
      <description>leetcode108 题意：把有一个有序的数组转化成一课高度尽量小的bst(二叉搜索树) 思路：我竟然忘记了什么是bst&amp;hellip;&amp;hellip;..我好傻</description>
    </item>
    
    <item>
      <title>leetcode 107 Binary Tree Level Order Traversal II(最底层往上依次输出二叉树每一个node的val)</title>
      <link>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Mon, 20 Feb 2017 12:36:21 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</guid>
      <description>最近要准备面试&amp;hellip;虽然leetcode的题目难度比较水..不过白板写代码还是要练下的。。。我所理解的白板写代码。。。大概就是。。</description>
    </item>
    
    <item>
      <title>leetcode 107 Binary Tree Level Order Traversal II(最底层往上依次输出二叉树每一个node的val)</title>
      <link>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Mon, 20 Feb 2017 12:36:21 +0000</pubDate>
      
      <guid>https://111qqz.com/2017/02/leetcode-107-binary-tree-level-order-traversal-ii/</guid>
      <description>最近要准备面试&amp;hellip;虽然leetcode的题目难度比较水..不过白板写代码还是要练下的。。。我所理解的白板写代码。。。大概就是。。</description>
    </item>
    
  </channel>
</rss>